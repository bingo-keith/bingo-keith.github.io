<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科瑞兹曼的博客</title>
  <icon>https://www.gravatar.com/avatar/affa8020d9d54afc774924f7f7fe256a</icon>
  <subtitle>专注于前端开发技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.icrazyman.cn/"/>
  <updated>2020-08-10T10:39:44.176Z</updated>
  <id>http://www.icrazyman.cn/</id>
  
  <author>
    <name>科瑞兹曼</name>
    <email>hg.wb.zheng@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端性能优化原理与实践</title>
    <link href="http://www.icrazyman.cn/2020/08/10/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.icrazyman.cn/2020/08/10/前端性能优化原理与实践/</id>
    <published>2020-08-10T10:34:29.000Z</published>
    <updated>2020-08-10T10:39:44.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>提起性能优化，大家现在脑海里第一时间会映射出什么内容呢？</p><p>可能是类似<a href="https://developer.yahoo.com/performance/rules.html?guccounter=1" target="_blank" rel="noopener">“雅虎军规”</a>和<a href="https://book.douban.com/subject/5362856/" target="_blank" rel="noopener">《高性能 JavaScript》</a>这样历久弥香的经典之作，也可能是搜索引擎聚合给你的一篇又一篇以性能优化为主题的个人或团队实践而来的“私货”。至少当我确定自己的研发方向、并接到第一个性能优化任务时，我做的第一件事是向搜索引擎求助，第二件事是买书，然后开始了摸着石头过河，前后花费了大量的时间和精力。我深感性能优化实在是前端知识树中特别的一环——当你需要学习前端框架时，文档和源码几乎可以告诉你所有问题的答案，当你需要学习 Git 时，你也可以找到放之四海皆准的实践方案。但性能优化却不一样，它好像只能是一个摸索的过程。</p><p>这个摸索的过程是痛苦的、漫长的，也是紧要的。因为在如今的互联网环境下，一个前端团队如果只把性能优化这个任务写在纸上，而不投入实践，它将缺失最基本的竞争力。</p><p>笔者写这本小册，是希望通过短短十数个章节的讲解，尽可能降低一些大家学习性能优化的成本。</p><p>一方面，这本小册为没有接触过性能优化的新同学建立起一个正确的前端性能优化的“世界观”，知道性能优化是什么、为什么、怎么做，从而使性能优化这件事情有迹可循，有路可走。这样在面试现场被问到性能优化层面的问题时，能够做到滔滔不绝、言之有物，而非像背书一样罗列干巴巴的知识点，最终淹没在茫茫的求职大军中。另一方面，小册可以为在职的工程师们提供一线团队已经实践过的“方法论”，知道什么场景下该做什么事情，最终在脑海中留下一张涵盖核心原理和实践的、可随时查阅并且高度可扩展的性能优化思路索引表。然后在今后的开发生活中可以去践行它，更进一步去挖掘它。把性能优化变作你前端工程师生涯的一门必修课，进而演化为自己研发方面的核心竞争力。</p><p>同时，相信大家可以明确这样一个学习观念：任何技术的掌握，都离不开一定比例的理论基础和实际操作的支撑。</p><p>具体到前端性能优化这件事情上，我认为它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。所以希望大家阅读本小册时，能够读到一些“书本之外的东西”——最好是一边读一边回忆自己既有的开发经历，尝试去留意哪些知识是已知的，哪些是未知的。</p><p>这样读完之后，就可以有的放矢地把这些知识转换为自己的项目实践——前端技术日新月异，性能方案永远都在更迭，所以一定要形成自己的学习思路。</p><p>建议每一位读者都带着“学了就要用”的心态去读这本小册。如果阅读结束，能够为你带来哪怕一个小小的开发习惯或者优化观念上的改变，这数小时的阅读时间就算没有白费。</p><h2 id="知识体系：-从一道面试题说起"><a href="#知识体系：-从一道面试题说起" class="headerlink" title="知识体系： 从一道面试题说起"></a>知识体系： 从一道面试题说起</h2><p>在展开性能优化的话题之前，我想先抛出一个老生常谈的面试问题：</p><blockquote><p>从输入 URL 到页面加载完成，发生了什么？</p></blockquote><p>这个问题非常重要，因为我们后续的内容都将以这个问题的答案为骨架展开。我希望正在阅读这本小册的各位可以在心里琢磨一下这个问题——无须你调动太多计算机的专业知识，只需要你用最快的速度在脑海中架构起这个抽象的过程——我们接下来所有的工作，就是围绕这个过程来做文章。</p><p>我们现在站在性能优化的角度，一起简单地复习一遍这个经典的过程：首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作（如下图所示）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/r5r.jW0JZFmFKdRYe5qoxrqlAr5fqrbSutHA74Xhp1FZfirxX*8bqKGna7wWrmsnjwUNNSw5GIfHBbg*hBhaQ.edeB*B5hVveVyVwNSv9C8!/b&amp;bo=6QFJAekBSQEDCSw!&amp;rf=viewer_4" alt="img"></p><p>我们将这个过程切分为如下的过程片段：</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><p>大家谨记，我们任何一个用户端的产品，都需要把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</p><h2 id="从原理到实践：各个击破"><a href="#从原理到实践：各个击破" class="headerlink" title="从原理到实践：各个击破"></a>从原理到实践：各个击破</h2><p>我们接下来要做的事情，就是针对这五个过程进行分解，各个提问，各个击破。</p><p>具体来说，DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？能——浏览器 DNS 缓存和 DNS prefetch。TCP 每次的三次握手都急死人，有没有解决方案？有——长连接、预连接、接入 SPDY 协议。如果说这两个过程的优化往往需要我们和团队的服务端工程师协作完成，前端单方面可以做的努力有限，那么 HTTP 请求呢？——在减少请求次数和减小请求体积方面，我们应该是专家！再者，服务器越远，一次请求就越慢，那部署时就把静态资源放在离我们更近的 CDN 上是不是就能更快一些？</p><p>以上提到的都是网络层面的性能优化。再往下走就是浏览器端的性能优化——这部分涉及资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等——这正是前端工程师可以真正一展拳脚的地方。学习这些知识，不仅可以帮助我们从根本上提升页面性能，更能够大大加深个人对浏览器底层原理、运行机制的理解，一举两得！</p><p>我们整个的知识图谱，用思维导图展示如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntvj32oyDYngqL0SrLOARhYCoJCwDbV9GXy*2FcmGEa4h9VoqcGw4LuDXSLK22d9MPShTHuCxFn8bALQswKYwWUU!/b&amp;bo=rgniBa4J4gUDORw!&amp;rf=viewer_4" alt="img"></p><h2 id="小册格局"><a href="#小册格局" class="headerlink" title="小册格局"></a>小册格局</h2><p>总的来说，我们将从<strong>网络层面</strong>和<strong>渲染层面</strong>两个大的维度来逐个点亮前端性能优化的技能树。</p><p>这两个维度的知识面貌各有千秋：在网络层面，我们需要学习一些必需的理论基础作为前置知识。这部分的学习或许不需要大家写特别多的代码，但需要大家对每一个知识点理解透彻，进而应用到自己日常优化的决策中去。网络层面结束后，由本地存储开始，我们会渐渐过渡到浏览器这一端的优化，大家喜闻乐见的“真代码”就会相应地多起来。</p><p>为了使同学们耐心学习一些理论性稍强的知识，我也会尽自己所能去讲述得有趣、易读、可用，同时希望大家可以真的沉下心去理解这些知识，它们与大家喜闻乐见的框架和工具无异，一样是实实在在的生产力。</p><p>“经验丰富的人读书用两只眼睛，一只眼睛看到纸面上的话，另一只眼睛看到纸的背面”。在这本小册，代码片段固然有用，它们是“纸面上的话”，我自然希望大家可以记下来、用起来。而代码之外那些反复讲解的原理，则是“纸的背面”，同样是我希望引起大家重视的内容。</p><p>现在相信大家已经对我们的优化观念、知识结构、小册格局都有了基本认知，那么我们就赶快趁热打铁，进入实战技能的学习吧~</p><a id="more"></a><h1 id="网络篇-1：webpack-性能调优与-Gzip-原理"><a href="#网络篇-1：webpack-性能调优与-Gzip-原理" class="headerlink" title="网络篇 1：webpack 性能调优与 Gzip 原理"></a>网络篇 1：webpack 性能调优与 Gzip 原理</h1><p>从本节开始，我们进入网络层面的性能优化世界。</p><p>大家可以从第一节的示意图中看出，我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求/响应</li></ul><p>对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。因此我们开门见山，抓主要矛盾，直接从 HTTP 开始讲起。</p><p>HTTP 优化有两个大的方向：</p><ul><li>减少请求次数</li><li>减少单次请求所花费的时间</li></ul><p>这两个优化点直直地指向了我们日常开发中非常常见的操作——资源的压缩与合并。没错，这就是我们每天用构建工具在做的事情。而时下最主流的构建工具无疑是 webpack，所以我们这节的主要任务就是围绕业界霸主 webpack 来做文章。</p><h2 id="webpack-的性能瓶颈"><a href="#webpack-的性能瓶颈" class="headerlink" title="webpack 的性能瓶颈"></a>webpack 的性能瓶颈</h2><p>相信每个用过 webpack 的同学都对“打包”和“压缩”这样的事情烂熟于心。这些老生常谈的特性，我更推荐大家去阅读文档。而关于 webpack 的详细操作，则推荐大家读读这本 <a href="https://juejin.im/book/5a6abad5518825733c144469/section/5a6abad5518825732e2f8546#heading-2" target="_blank" rel="noopener">关于 webpack 的掘金小册</a>，这里我们把注意力放在 webpack 的性能优化上。</p><p>webpack 的优化瓶颈，主要是两个方面：</p><ul><li>webpack 的构建过程太花时间</li><li>webpack 打包的结果体积太大</li></ul><h2 id="webpack-优化方案"><a href="#webpack-优化方案" class="headerlink" title="webpack 优化方案"></a>webpack 优化方案</h2><h3 id="构建过程提速策略"><a href="#构建过程提速策略" class="headerlink" title="构建过程提速策略"></a>构建过程提速策略</h3><h4 id="不要让-loader-做太多事情——以-babel-loader-为例"><a href="#不要让-loader-做太多事情——以-babel-loader-为例" class="headerlink" title="不要让 loader 做太多事情——以 babel-loader 为例"></a>不要让 loader 做太多事情——以 babel-loader 为例</h4><p>babel-loader 无疑是强大的，但它也是慢的。</p><p>最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：</p><pre><code class="js">module: {  rules: [    {      test: /\.js$/,      exclude: /(node_modules|bower_components)/,      use: {        loader: &#39;babel-loader&#39;,        options: {          presets: [&#39;@babel/preset-env&#39;]        }      }    }  ]}</code></pre><p>这段代码帮我们规避了对庞大的 node_modules 文件夹或者 bower_components 文件夹的处理。但通过限定文件范围带来的性能提升是有限的。除此之外，如果我们选择开启缓存将转译结果缓存至文件系统，则至少可以将 babel-loader 的工作效率提升两倍。要做到这点，我们只需要为 loader 增加相应的参数设定：</p><pre><code class="js">loader: &#39;babel-loader?cacheDirectory=true&#39;</code></pre><p>以上都是在讨论针对 loader 的配置，但我们的优化范围不止是 loader 们。</p><p>举个🌰，尽管我们可以在 loader 配置时通过写入 exclude 去避免 babel-loader 对不必要的文件的处理，但是考虑到这个规则仅作用于这个 loader，像一些类似 UglifyJsPlugin 的 webpack 插件在工作时依然会被这些庞大的第三方库拖累，webpack 构建速度依然会因此大打折扣。所以针对这些庞大的第三方库，我们还需要做一些额外的努力。</p><h4 id="不要放过第三方库"><a href="#不要放过第三方库" class="headerlink" title="不要放过第三方库"></a>不要放过第三方库</h4><p>第三方库以 node_modules 为代表，它们庞大得可怕，却又不可或缺。</p><p>处理第三方库的姿势有很多，其中，Externals 不够聪明，一些情况下会引发重复打包的问题；而 CommonsChunkPlugin 每次构建时都会重新构建一次 vendor；出于对效率的考虑，我们这里为大家推荐 DllPlugin。</p><p>DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。<strong>这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包</strong>。</p><p>用 DllPlugin 处理文件，要分两步走：</p><ul><li>基于 dll 专属的配置文件，打包 dll 库</li><li>基于 webpack.config.js 文件，打包业务代码</li></ul><p>以一个基于 React 的简单项目为例，我们的 dll 的配置文件可以编写如下：</p><pre><code class="js">const path = require(&#39;path&#39;)const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {      // 依赖的库数组      vendor: [        &#39;prop-types&#39;,        &#39;babel-polyfill&#39;,        &#39;react&#39;,        &#39;react-dom&#39;,        &#39;react-router-dom&#39;,      ]    },    output: {      path: path.join(__dirname, &#39;dist&#39;),      filename: &#39;[name].js&#39;,      library: &#39;[name]_[hash]&#39;,    },    plugins: [      new webpack.DllPlugin({        // DllPlugin的name属性需要和libary保持一致        name: &#39;[name]_[hash]&#39;,        path: path.join(__dirname, &#39;dist&#39;, &#39;[name]-manifest.json&#39;),        // context需要和webpack.config.js保持一致        context: __dirname,      }),    ],}</code></pre><p>编写完成之后，运行这个配置文件，我们的 dist 文件夹里会出现这样两个文件：</p><pre><code class="js">vendor-manifest.jsonvendor.js</code></pre><p>vendor.js 不必解释，是我们第三方库打包的结果。这个多出来的 vendor-manifest.json，则用于描述每个第三方库对应的具体路径，我这里截取一部分给大家看下：</p><pre><code class="js">{  &quot;name&quot;: &quot;vendor_397f9e25e49947b8675d&quot;,  &quot;content&quot;: {    &quot;./node_modules/core-js/modules/_export.js&quot;: {      &quot;id&quot;: 0,        &quot;buildMeta&quot;: {        &quot;providedExports&quot;: true      }    },    &quot;./node_modules/prop-types/index.js&quot;: {      &quot;id&quot;: 1,        &quot;buildMeta&quot;: {        &quot;providedExports&quot;: true      }    },    ...  }}  </code></pre><p>随后，我们只需在 webpack.config.js 里针对 dll 稍作配置：</p><pre><code class="js">const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;)module.exports = {  mode: &#39;production&#39;,  // 编译入口  entry: {    main: &#39;./src/index.js&#39;  },  // 目标文件  output: {    path: path.join(__dirname, &#39;dist/&#39;),    filename: &#39;[name].js&#39;  },  // dll相关配置  plugins: [    new webpack.DllReferencePlugin({      context: __dirname,      // manifest就是我们第一步中打包出来的json文件      manifest: require(&#39;./dist/vendor-manifest.json&#39;),    })  ]}</code></pre><p>一次基于 dll 的 webpack 构建过程优化，便大功告成了！</p><h4 id="Happypack——将-loader-由单进程转为多进程"><a href="#Happypack——将-loader-由单进程转为多进程" class="headerlink" title="Happypack——将 loader 由单进程转为多进程"></a>Happypack——将 loader 由单进程转为多进程</h4><p>大家知道，webpack 是单线程的，就算此刻存在多个任务，你也只能排队一个接一个地等待处理。这是 webpack 的缺点，好在我们的 CPU 是多核的，Happypack 会充分释放 CPU 在多核并发方面的优势，帮我们把任务分解给多个子进程去并发执行，大大提升打包效率。</p><p>HappyPack 的使用方法也非常简单，只需要我们把对 loader 的配置转移到 HappyPack 中去就好，我们可以手动告诉 HappyPack 我们需要多少个并发的进程：</p><pre><code class="js">const HappyPack = require(&#39;happypack&#39;)// 手动创建进程池const happyThreadPool =  HappyPack.ThreadPool({ size: os.cpus().length })module.exports = {  module: {    rules: [      ...      {        test: /\.js$/,        // 问号后面的查询参数指定了处理这类文件的HappyPack实例的名字        loader: &#39;happypack/loader?id=happyBabel&#39;,        ...      },    ],  },  plugins: [    ...    new HappyPack({      // 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应      id: &#39;happyBabel&#39;,      // 指定进程池      threadPool: happyThreadPool,      loaders: [&#39;babel-loader?cacheDirectory&#39;]    })  ],}</code></pre><h3 id="构建结果体积压缩"><a href="#构建结果体积压缩" class="headerlink" title="构建结果体积压缩"></a>构建结果体积压缩</h3><h4 id="文件结构可视化，找出导致体积过大的原因"><a href="#文件结构可视化，找出导致体积过大的原因" class="headerlink" title="文件结构可视化，找出导致体积过大的原因"></a>文件结构可视化，找出导致体积过大的原因</h4><p>这里为大家介绍一个非常好用的包组成可视化工具——<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>，配置方法和普通的 plugin 无异，它会以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来，格局如官方所提供这张图所示：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntg8J*I*s2M8YJQVy2N397bbF*6gcxHhQGlrvrSvMEzm4yyXURcGSQ13hu87LXQevyHrxyfYduiU29aHbVa0hwGM!/b&amp;bo=jAMjAowDIwICia0!&amp;rf=viewer_4" alt="img"></p><p>在使用时，我们只需要将其以插件的形式引入：</p><pre><code class="js">const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;module.exports = {  plugins: [    new BundleAnalyzerPlugin()  ]}</code></pre><h4 id="拆分资源"><a href="#拆分资源" class="headerlink" title="拆分资源"></a>拆分资源</h4><p>这点仍然围绕 DllPlugin 展开，可参考上文。</p><h4 id="删除冗余代码"><a href="#删除冗余代码" class="headerlink" title="删除冗余代码"></a>删除冗余代码</h4><p>一个比较典型的应用，就是 <code>Tree-Shaking</code>。</p><p>从 webpack2 开始，webpack 原生支持了 ES6 的模块系统，并基于此推出了 Tree-Shaking。webpack 官方是这样介绍它的：</p><blockquote><p>Tree shaking is a term commonly used in the JavaScript context for dead-code elimination, or more precisely, live-code import. It relies on ES2015 module import/export for the static structure of its module system.</p></blockquote><p>意思是基于 import/export 语法，Tree-Shaking 可以在编译的过程中获悉哪些模块并没有真正被使用，这些没用的代码，在最后打包的时候会被去除。</p><p>举个🌰，假设我的主干文件（入口文件）是这么写的：</p><pre><code class="js">import { page1, page2 } from &#39;./pages&#39;// show是事先定义好的函数，大家理解它的功能是展示页面即可show(page1)</code></pre><p>pages 文件里，我虽然导出了两个页面：</p><pre><code class="js">export const page1 = xxxexport const page2 = xxx</code></pre><p>但因为 page2 事实上并没有被用到（这个没有被用到的情况在静态分析的过程中是可以被感知出来的），所以打包的结果里会把这部分：</p><pre><code class="js">export const page2 = xxx;</code></pre><p>直接删掉，这就是 Tree-Shaking 帮我们做的事情。</p><p>相信大家不难看出，Tree-Shaking 的针对性很强，它更适合用来处理模块级别的冗余代码。至于<strong>粒度更细</strong>的冗余代码的去除，往往会被整合进 JS 或 CSS 的压缩或分离过程中。</p><p>这里我们以当下接受度较高的 UglifyJsPlugin 为例，看一下如何在压缩过程中对碎片化的冗余代码（如 console 语句、注释等）进行自动化删除：</p><pre><code class="js">const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;);module.exports = { plugins: [   new UglifyJsPlugin({     // 允许并发     parallel: true,     // 开启缓存     cache: true,     compress: {       // 删除所有的console语句           drop_console: true,       // 把使用多次的静态值自动定义为变量       reduce_vars: true,     },     output: {       // 不保留注释       comment: false,       // 使输出的代码尽可能紧凑       beautify: false     }   }) ]}</code></pre><p>有心的同学会注意到，这段手动引入 UglifyJsPlugin 的代码其实是 webpack3 的用法，webpack4 现在已经默认使用 uglifyjs-webpack-plugin 对代码做压缩了——在 webpack4 中，我们是通过配置 optimization.minimize 与 optimization.minimizer 来自定义压缩相关的操作的。</p><p>这里也引出了我们学习性能优化的一个核心的理念——用什么工具，怎么用，并不是我们这本小册的重点，因为所有的工具都存在用法迭代的问题。但现在大家知道了在打包的过程中做一些如上文所述的“手脚”可以实现打包结果的最优化，那下次大家再去执行打包操作，会不会对这个操作更加留心，从而自己去寻找彼时操作的具体实现方案呢？我最希望大家掌握的技能就是，先在脑海中留下“这个xx操作是对的，是有用的”，在日后的实践中，可以基于这个认知去寻找把正确的操作落地的具体方案。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>大家想象这样一个场景。我现在用 React 构建一个单页应用，用 React-Router 来控制路由，十个路由对应了十个页面，这十个页面都不简单。如果我把这整个项目打一个包，用户打开我的网站时，会发生什么？有很大机率会卡死，对不对？更好的做法肯定是先给用户展示主页，其它页面等请求到了再加载。当然这个情况也比较极端，但却能很好地引出按需加载的思想：</p><ul><li>一次不加载完所有的文件内容，只加载此刻需要用到的那部分（会提前做拆分）</li><li>当需要更多内容时，再对用到的内容进行即时加载</li></ul><p>好，既然说到这十个 Router 了，我们就拿其中一个开刀，假设我这个 Router 对应的组件叫做 BugComponent，来看看我们如何利用 webpack 做到该组件的按需加载。</p><p>当我们不需要按需加载的时候，我们的代码是这样的：</p><pre><code class="js">import BugComponent from &#39;../pages/BugComponent&#39;...&lt;Route path=&quot;/bug&quot; component={BugComponent}&gt;</code></pre><p>为了开启按需加载，我们要稍作改动。</p><p>首先 webpack 的配置文件要走起来：</p><pre><code class="js">output: {    path: path.join(__dirname, &#39;/../dist&#39;),    filename: &#39;app.js&#39;,    publicPath: defaultSettings.publicPath,    // 指定 chunkFilename    chunkFilename: &#39;[name].[chunkhash:5].chunk.js&#39;,},</code></pre><p>路由处的代码也要做一下配合：</p><pre><code class="js">const getComponent =&gt; (location, cb) {  require.ensure([], (require) =&gt; {    cb(null, require(&#39;../pages/BugComponent&#39;).default)  }, &#39;bug&#39;)},...&lt;Route path=&quot;/bug&quot; getComponent={getComponent}&gt;</code></pre><p>对，核心就是这个方法：</p><pre><code class="js">require.ensure(dependencies, callback, chunkName)</code></pre><p>这是一个异步的方法，webpack 在打包时，BugComponent 会被单独打成一个文件，只有在我们跳转 bug 这个路由的时候，这个异步方法的回调才会生效，才会真正地去获取 BugComponent 的内容。这就是按需加载。</p><p>按需加载的粒度，还可以继续细化，细化到更小的组件、细化到某个功能点，都是 ok 的。</p><p>等等，这和说好的不一样啊？不是说 Code-Splitting 才是 React-Router 的按需加载实践吗？</p><p>没错，在 React-Router4 中，我们确实是用 Code-Splitting 替换掉了楼上这个操作。而且如果有使用过 React-Router4 实现过路由级别的按需加载的同学，可能会对 React-Router4 里用到的一个叫“Bundle-Loader”的东西印象深刻。我想很多同学读到按需加载这里，心里的预期或许都是时下大热的 Code-Splitting，而非我呈现出来的这段看似“陈旧”的代码。</p><p>但是，如果大家稍微留个心眼，去看一下 Bundle Loader 并不长的源代码的话，你会发现它竟然还是使用 require.ensure 来实现的——这也是我要把 require.ensure 单独拎出来的重要原因。所谓按需加载，根本上就是在正确的时机去触发相应的回调。理解了这个 require.ensure 的玩法，大家甚至可以结合业务自己去修改一个按需加载模块来用。</p><p>这也应了我之前跟大家强调那段话，工具永远在迭代，唯有掌握核心思想，才可以真正做到举一反三——唯“心”不破！</p><h2 id="彩蛋：Gzip-压缩原理"><a href="#彩蛋：Gzip-压缩原理" class="headerlink" title="彩蛋：Gzip 压缩原理"></a>彩蛋：Gzip 压缩原理</h2><p>恭喜大家迎来了本小册的第一个彩蛋。彩蛋为选学内容，以原理性知识为主。意在拓宽大家的技术视野，加深大家对优化相关知识的理解。</p><p>前面说了不少 webpack 的故事，目的还是帮大家更好地实现压缩和合并。说到压缩，可不只是构建工具的专利。我们日常开发中，其实还有一个便宜又好用的压缩操作：开启 Gzip。</p><p>具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：</p><pre><code class="js">accept-encoding:gzip</code></pre><p>相信很多同学对 Gzip 也是了解到这里。之所以为大家开这个彩蛋性的小节，绝不是出于炫技要来给大家展示一下 Gzip 的压缩算法，而是想和大家聊一个和我们前端关系更密切的话题：HTTP 压缩。</p><blockquote><p>HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。</p></blockquote><p>以上是摘自百科的解释，事实上，大家可以这么理解：</p><p><strong>HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程</strong></p><p>Gzip 的内核就是 Deflate，目前我们压缩文件用得最多的就是 Gzip。可以说，Gzip 就是 HTTP 压缩的经典例题。</p><h3 id="该不该用-Gzip"><a href="#该不该用-Gzip" class="headerlink" title="该不该用 Gzip"></a>该不该用 Gzip</h3><p>如果你的项目不是极端迷你的超小型文件，我都建议你试试 Gzip。</p><p>有的同学或许存在这样的疑问：压缩 Gzip，服务端要花时间；解压 Gzip，浏览器要花时间。中间节省出来的传输时间，真的那么可观吗？</p><p>答案是肯定的。如果你手上的项目是 1k、2k 的小文件，那确实有点高射炮打蚊子的意思，不值当。但更多的时候，我们处理的都是具备一定规模的项目文件。实践证明，这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说，可以说是微不足道的。</p><h3 id="Gzip-是万能的吗"><a href="#Gzip-是万能的吗" class="headerlink" title="Gzip 是万能的吗"></a>Gzip 是万能的吗</h3><p>首先要承认 Gzip 是高效的，压缩后<strong>通常</strong>能帮我们减少响应 70% 左右的大小。</p><p>但它并非万能。Gzip 并不保证针对每一个文件的压缩都会使其变小。</p><p>Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大。反之亦然。</p><h3 id="webpack-的-Gzip-和服务端的-Gzip"><a href="#webpack-的-Gzip-和服务端的-Gzip" class="headerlink" title="webpack 的 Gzip 和服务端的 Gzip"></a>webpack 的 Gzip 和服务端的 Gzip</h3><p>一般来说，Gzip 压缩是服务器的活儿：服务器了解到我们这边有一个 Gzip 压缩的需求，它会启动自己的 CPU 去为我们完成这个任务。而压缩文件这个过程本身是需要耗费时间的，大家可以理解为我们以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销。</p><p>既然存在着这样的交换，那么就要求我们学会权衡。服务器的 CPU 性能不是无限的，如果存在大量的压缩需求，服务器也扛不住的。服务器一旦因此慢下来了，用户还是要等。Webpack 中 Gzip 压缩操作的存在，事实上就是为了在构建过程中去做一部分服务器的工作，为服务器分压。</p><p>因此，这两个地方的 Gzip 压缩，谁也不能替代谁。它们必须和平共处，好好合作。作为开发者，我们也应该结合业务压力的实际强度情况，去做好这其中的权衡。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，我们都在讨论文件——准确地说，是文本文件及其构建过程的优化。</p><p>但一个完整的现代前端应用，除了要包含 HTML、CSS 和 JS，往往还需要借助图片来提高用户的视觉体验。而图片优化的思路、场景与措施，又是另外一个说来话长的故事了。下面，我们就一起进入图片的小天地，一窥究竟。</p><h1 id="网络篇-2：图片优化——质量与性能的博弈"><a href="#网络篇-2：图片优化——质量与性能的博弈" class="headerlink" title="网络篇 2：图片优化——质量与性能的博弈"></a>网络篇 2：图片优化——质量与性能的博弈</h1><p>《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 <a href="http://www.stevesouders.com/blog/2013/04/26/i/" target="_blank" rel="noopener">博客</a> 中提到：</p><blockquote><p>我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。</p><p>几个月后，我意识到这是错误的。图片才是页面上最重要的部分。</p><p>我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。</p></blockquote><p>这段话可谓字字珠玑。此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。</p><p>就图片这块来说，与其说我们是在做“优化”，不如说我们是在做“权衡”。因为我们要做的事情，就是去压缩图片的体积（或者一开始就选取体积较小的图片格式）。但这个优化操作，是以牺牲一部分成像质量为代价的。因此我们的主要任务，是尽可能地去寻求一个质量与性能之间的平衡点。</p><h2 id="2018-年，图片依然很大"><a href="#2018-年，图片依然很大" class="headerlink" title="2018 年，图片依然很大"></a>2018 年，图片依然很大</h2><p>这里先给大家介绍 <a href="https://httparchive.org/reports/page-weight#bytesTotal" target="_blank" rel="noopener">HTTP-Archive</a> 这个网站，它会定期抓取 Web 上的站点，并记录资源的加载情况、Web API 的使用情况等页面的详细信息，并会对这些数据进行处理和分析以确定趋势。通过它我们可以实时地看到世界范围内的 Web 资源的统计结果。</p><p>截止到 2018 年 8 月，过去一年<strong>总的 web 资源</strong>的平均请求体积是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntmsX6Kodc89Nb8HJT869bPVby5*TLlGSfLUfBua5OFZ2SpTeIt.0ORf.JtDIwCl8bBV6NfrlvymBbqpHMwz8rC4!/b&amp;bo=bgmAAtgJnAIDKaY!&amp;rf=viewer_4" alt="img"></p><p>而具体到<strong>图片</strong>这一类的资源，平均请求体积是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntjuMwosslFcTknvpGXbRrOalq0VmQhDG2VYFGPYniZ4VOAZkzCaIorxfbiB3X0cdEvCgQ5gECSyuRWhJN5bbDjs!/b&amp;bo=Tgl.Ak4JfgIDKQw!&amp;rf=viewer_4" alt="img"></p><p>当然，随着我们工程师在性能方面所做的努力越来越有成效，平均来说，不管是资源总量还是图片体积，都在往越来越轻量的方向演化。这是一种值得肯定的进步。</p><p>但同时我们不得不承认，如图所示的这个图片体积，依然是太大了。图片在所有资源中所占的比重，也足够“触目惊心”了。为了改变这个现状，我们必须把图片优化提上日程。</p><h2 id="不同业务场景下的图片方案选型"><a href="#不同业务场景下的图片方案选型" class="headerlink" title="不同业务场景下的图片方案选型"></a>不同业务场景下的图片方案选型</h2><p>时下应用较为广泛的 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等，这些格式都是很有故事的，值得我们好好研究一把。此外，老生常谈的雪碧图（CSS Sprites）至今也仍在一线的前端应用中发光发热，我们也会有所提及。</p><p>不谈业务场景的选型都是耍流氓。下面我们就结合具体的业务场景，一起来解开图片选型的神秘面纱！</p><h3 id="前置知识：二进制位数与色彩的关系"><a href="#前置知识：二进制位数与色彩的关系" class="headerlink" title="前置知识：二进制位数与色彩的关系"></a>前置知识：二进制位数与色彩的关系</h3><p>在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。</p><p>一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</p><h3 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG/JPG"></a>JPEG/JPG</h3><p>关键字：<strong>有损压缩、体积小、加载快、不支持透明</strong></p><h4 id="JPG-的优点"><a href="#JPG-的优点" class="headerlink" title="JPG 的优点"></a>JPG 的优点</h4><p>JPG 最大的特点是<strong>有损压缩</strong>。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p><p>两大电商网站对大图的处理，是 JPG 图片应用场景的最佳写照：</p><p>打开淘宝首页，我们可以发现页面中最醒目、最庞大的图片，一定是以 .jpg 为后缀的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnttrLIlxcfjs6dhGnW97SASH09qtDdW9Ve93U22*ioKkfLo1LEWJzOINbUQfwp3n*oTIyBojO0Uce92X1U*7CpkY!/b&amp;bo=8QeAAs4JFgMDaeo!&amp;rf=viewer_4" alt="img"></p><p>京东首页也不例外：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrnIGRytiFDs7FD9iWydc2drxCTmnY7rt6DwmxXEioE43enY5BfZ.8AlwtwzcQfaQpVwzMEcZJKjz4IVceZ6Xn8!/b&amp;bo=TgWAApoJhgQDWaQ!&amp;rf=viewer_4" alt="img"></p><p>使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。</p><h4 id="JPG-的缺陷"><a href="#JPG-的缺陷" class="headerlink" title="JPG 的缺陷"></a>JPG 的缺陷</h4><p>有损压缩在上文所展示的轮播图上确实很难露出马脚，但当它处理<strong>矢量图形</strong>和 <strong>Logo</strong> 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。</p><p>此外，JPEG 图像<strong>不支持透明度处理</strong>，透明图片需要召唤 PNG 来呈现。</p><h3 id="PNG-8-与-PNG-24"><a href="#PNG-8-与-PNG-24" class="headerlink" title="PNG-8 与 PNG-24"></a>PNG-8 与 PNG-24</h3><p>关键字：<strong>无损压缩、质量高、体积大、支持透明</strong></p><h4 id="PNG-的优点"><a href="#PNG-的优点" class="headerlink" title="PNG 的优点"></a>PNG 的优点</h4><p>PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。</p><p>PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是<strong>体积太大</strong>。</p><h4 id="PNG-8-与-PNG-24-的选择题"><a href="#PNG-8-与-PNG-24-的选择题" class="headerlink" title="PNG-8 与 PNG-24 的选择题"></a>PNG-8 与 PNG-24 的选择题</h4><p>什么时候用 PNG-8，什么时候用 PNG-24，这是一个问题。</p><p>理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。</p><p>但实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。</p><p>如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，基于对比的结果去做判断。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面我们提到，复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储。</p><p>考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</p><p>此时我们再次把目光转向性能方面堪称业界楷模的淘宝首页，我们会发现它页面上的 Logo，无论大小，还真的都是 PNG 格式：</p><p>主 Logo：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthnNv19DPjcDHYMj4qX4k2fN7RTxnBJxDEZZ*C2OFYplDTlD0XBfSaUg.GVyIxs73iMF4mvuNZQbZbkeWfIugAk!/b&amp;bo=EgduAhIHbgIDORw!&amp;rf=viewer_4" alt="img"></p><p>较小的 Logo：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntuLkWnAzgIGhdKO.iVbjjtbegvrRgSlx8b3qqg.qLxOzfiYffSgNdUrrulHLgHqqObIMg*e8Qv9SqZgn7N3*QkA!/b&amp;bo=kgViAZIFYgEDGTw!&amp;rf=viewer_4" alt="img"></p><p>颜色简单、对比度较强的透明小图也在 PNG 格式下有着良好的表现：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knth1PqxyVs0GLHyD6zQ4DJtHnPj0zgYgCulCKNJWxOW4u.VIs9uj3eWegzomx4eu3WSrfYYuCocRIkLzgQVHya.w!/b&amp;bo=mgV2AZoFdgEDKQw!&amp;rf=viewer_4" alt="img"></p><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>关键字：<strong>文本文件、体积小、不失真、兼容性好</strong></p><p>SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。</p><h4 id="SVG-的特性"><a href="#SVG-的特性" class="headerlink" title="SVG 的特性"></a>SVG 的特性</h4><p>和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，<strong>文件体积更小，可压缩性更强</strong>。</p><p>当然，作为矢量图，它最显著的优势还是在于<strong>图片可无限放大而不失真</strong>这一点上。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。</p><p>此外，<strong>SVG 是文本文件</strong>。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的<strong>灵活性</strong>。</p><p>SVG 的局限性主要有两个方面，一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。</p><h4 id="SVG-的使用方式与应用场景"><a href="#SVG-的使用方式与应用场景" class="headerlink" title="SVG 的使用方式与应用场景"></a>SVG 的使用方式与应用场景</h4><p>SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。</p><ul><li><p>将 SVG 写入 HTML：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;   width=&quot;200&quot; height=&quot;200&quot;&gt;        &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; /&gt;    &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>将 SVG 写入独立文件后引入 HTML:</p><pre><code class="html">&lt;img src=&quot;文件名.svg&quot; alt=&quot;&quot;&gt;</code></pre></li></ul><p>在实际开发中，我们更多用到的是后者。很多情况下设计师会给到我们 SVG 文件，就算没有设计师，我们还有非常好用的 <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">在线矢量图形库</a>。对于矢量图，我们无须深究过多，只需要对其核心特性有所掌握、日后在应用时做到有迹可循即可。</p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>关键字：<strong>文本文件、依赖编码、小图标解决方案</strong></p><p>Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。在了解 Base64 之前，我们先来了解一下雪碧图。</p><h4 id="前置知识：最经典的小图标解决方案——雪碧图（CSS-Sprites）"><a href="#前置知识：最经典的小图标解决方案——雪碧图（CSS-Sprites）" class="headerlink" title="前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）"></a>前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）</h4><p>雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西——一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。</p><p>MDN 对雪碧图的解释已经非常到位：</p><blockquote><p>图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。</p></blockquote><p>我们几乎可以在每一个有小图标出现的网站里找到雪碧图的影子（下图截取自京东首页）：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrFnj6sU1Vwj0ORlR3BCgHw9oRHu1qoh9dYbNdwlfXPGYRzcd.QvdTr.ugaGHGP3l2*ytytCG.2BPj7Cach2RGI!/b&amp;bo=vAS8AbwEvAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。<strong>Base64 是作为雪碧图的补充而存在的。</strong></p><h4 id="理解-Base64"><a href="#理解-Base64" class="headerlink" title="理解 Base64"></a>理解 Base64</h4><p>通过我们上文的演示，大家不难看出，每次加载图片，都是需要单独向服务器请求这个图片对应的资源的——这也就意味着一次 HTTP 请求的开销。</p><p><strong>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</strong></p><p>我们来一起看一个实例，现在我有这么一个小小的放大镜 Logo：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680" alt="img"></p><p>它对应的链接如下：</p><pre><code class="html">https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680</code></pre><p>按照一贯的思路，我们加载图片需要把图片链接写入 img 标签：</p><pre><code class="html">&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680&quot;&gt;</code></pre><p>浏览器就会针对我们的图片链接去发起一个资源请求。</p><p>但是如果我们对这个图片进行 Base64 编码，我们会得到一个这样的字符串：</p><pre><code>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAMJGlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU8kagOeWJCQktEAEpITeBCnSpdfQpQo2QhJIKDEkBBU7uqjgWlARwYquitjWAshiw14Wwd4fiKgo62LBhsqbFNDV89477z9n7v3yzz9/mcydMwOAehxbJMpFNQDIExaI48MCmeNT05ikR4AECIAKRgEamyMRBcTFRQEoQ+9/yrubAJG9r9nLfP3c/19Fk8uTcABA4iBncCWcPMiHAMDdOCJxAQCEXqg3m1YggkyEWQJtMUwQsrmMsxTsIeMMBUfJbRLjgyCnA6BCZbPFWQCoyfJiFnKyoB+1pZAdhVyBEHIzZF8On82F/BnyqLy8qZDVrSFbZ3znJ+sfPjOGfbLZWcOsqEUuKsECiSiXPeP/nI7/LXm50qEYZrBR+eLweFnNsnnLmRopYyrk88KMmFjIWpCvC7hyexk/4UvDk5T2HziSIDhngAEASuWygyMhG0A2FebGRCn1vpmCUBZkOPdooqCAlagYi3LFU+OV/tHpPElIwhCzxfJYMptSaU5SgNLnRj6PNeSzqYifmKLIE20rFCTHQFaDfF+SkxCptHlexA+KGbIRS+NlOcP/HAOZ4tB4hQ1mnicZqgvz4gtYMUqO4rDl+ehCnlzATwxX+MEKeZLxUUN5cnnBIYq6sGKeMEmZP1YuKgiMV47dJsqNU9pjzbzcMJneFHKrpDBhaGxfAVxsinpxICqIS1TkhmtnsyPiFHFxWxAFgkAwYAIpbBlgKsgGgtbehl74S9ETCthADLIAD9grNUMjUuQ9QvhMAEXgL0g8IBkeFyjv5YFCqP8yrFU87UGmvLdQPiIHPIGcByJBLvwtlY8SDkdLBo+hRvBTdA7MNRc2Wd9POqb6kI4YQgwmhhNDiTa4Pu6Le+NR8OkPmzPugXsO5fXNnvCE0E54RLhB6CDcmSIoFv+QORNEgw6YY6iyuozvq8MtoVdXPBD3gf6hb5yB6wN7fAyMFID7wdiuUPt9rtLhir/NpdIX2ZGMkkeQ/cnWP2Ugm53v61fq1WzVXJV5ZQzPVtCw1Y9egr6bPy58R/5oiS3GDmLnsJPYBawZawBM7DjWiF3Gjsp4eG08lq+NoWjx8txyoB/BT/HYypiyWZM41jn2OH5W9oEC3vQC2ccSNFU0QyzI4hcwA+BuzWOyhByHUUxnRye4i8r2fsXW8oYh39MRxsVvuvwTAHiWQmXWNx0b7kFHngBAf/dNZ/YaLvsVABxt40jFhQodLnsQAAWowy9FDxjBvcsaVuQM3IA38AchIALEgkSQCibDOefDdSoG08AsMB+UgDKwAqwBVWAT2Ap2gj3gAGgAzeAkOAsugTZwA9yDa6UbvAB94B0YQBCEhNAQOqKHGCMWiB3ijHggvkgIEoXEI6lIOpKFCBEpMgtZgJQh5UgVsgWpRX5HjiAnkQtIO3IH6UR6kNfIJxRDqag2aohaoqNRDzQAjUQT0UloFpqPFqEL0WVoJVqD7kbr0ZPoJfQG2oG+QPsxgKliDMwEs8c8sCAsFkvDMjExNgcrxSqwGmwv1gT/6WtYB9aLfcSJOB1n4vZwvYbjSTgHz8fn4EvxKnwnXo+fxq/hnXgf/pVAIxgQ7AheBBZhPCGLMI1QQqggbCccJpyB30434R2RSGQQrYju8NtLJWYTZxKXEjcQ9xFPENuJXcR+EomkR7Ij+ZBiSWxSAamEtI60m3ScdJXUTfqgoqpirOKsEqqSpiJUKVapUNmlckzlqspTlQGyBtmC7EWOJXPJM8jLydvITeQr5G7yAEWTYkXxoSRSsinzKZWUvZQzlPuUN6qqqqaqnqrjVAWq81QrVfernlftVP1I1aLaUoOoE6lS6jLqDuoJ6h3qGxqNZknzp6XRCmjLaLW0U7SHtA9qdDUHNZYaV22uWrVavdpVtZfqZHUL9QD1yepF6hXqB9WvqPdqkDUsNYI02BpzNKo1jmjc0ujXpGs6acZq5mku1dyleUHzmRZJy1IrRIurtVBrq9YprS46RjejB9E59AX0bfQz9G5toraVNks7W7tMe492q3afjpbOGJ1knek61TpHdToYGMOSwWLkMpYzDjBuMj6NMBwRMII3YsmIvSOujnivO1LXX5enW6q7T/eG7ic9pl6IXo7eSr0GvQf6uL6t/jj9afob9c/o947UHuk9kjOydOSBkXcNUANbg3iDmQZbDS4b9BsaGYYZigzXGZ4y7DViGPkbZRutNjpm1GNMN/Y1FhivNj5u/Jypwwxg5jIrmaeZfSYGJuEmUpMtJq0mA6ZWpkmmxab7TB+YUcw8zDLNVpu1mPWZG5tHm88yrzO/a0G28LDgW6y1OGfx3tLKMsVykWWD5TMrXSuWVZFVndV9a5q1n3W+dY31dRuijYdNjs0GmzZb1NbVlm9bbXvFDrVzsxPYbbBrH0UY5TlKOKpm1C17qn2AfaF9nX2nA8MhyqHYocHh5Wjz0WmjV44+N/qro6tjruM2x3tOWk4RTsVOTU6vnW2dOc7VztddaC6hLnNdGl1ejbEbwxuzccxtV7prtOsi1xbXL27ubmK3vW497ubu6e7r3W95aHvEeSz1OO9J8Az0nOvZ7PnRy82rwOuA19/e9t453ru8n421Gssbu21sl4+pD9tni0+HL9M33Xezb4efiR/br8bvkb+ZP9d/u//TAJuA7IDdAS8DHQPFgYcD3wd5Bc0OOhGMBYcFlwa3hmiFJIVUhTwMNQ3NCq0L7QtzDZsZdiKcEB4ZvjL8FsuQxWHVsvoi3CNmR5yOpEYmRFZFPoqyjRJHNUWj0RHRq6Lvx1jECGMaYkEsK3ZV7IM4q7j8uD/GEcfFjase9yTeKX5W/LkEesKUhF0J7xIDE5cn3kuyTpImtSSrJ09Mrk1+nxKcUp7SMX70+NnjL6XqpwpSG9NIaclp29P6J4RMWDOhe6LrxJKJNydZTZo+6cJk/cm5k49OUZ/CnnIwnZCekr4r/TM7ll3D7s9gZazP6OMEcdZyXnD9uau5PTwfXjnvaaZPZnnmsyyfrFVZPXw/fgW/VxAkqBK8yg7P3pT9Pic2Z0fOYG5K7r48lbz0vCNCLWGO8PRUo6nTp7aL7EQloo58r/w1+X3iSPF2CSKZJGks0IaH7MtSa+kv0s5C38Lqwg/TkqcdnK45XTj98gzbGUtmPC0KLfptJj6TM7Nllsms+bM6ZwfM3jIHmZMxp2Wu2dyFc7vnhc3bOZ8yP2f+n8WOxeXFbxekLGhaaLhw3sKuX8J+qStRKxGX3FrkvWjTYnyxYHHrEpcl65Z8LeWWXixzLKso+7yUs/Tir06/Vv46uCxzWetyt+UbVxBXCFfcXOm3cme5ZnlRedeq6FX1q5mrS1e/XTNlzYWKMRWb1lLWStd2VEZVNq4zX7di3ecqftWN6sDqfesN1i9Z/34Dd8PVjf4b924y3FS26dNmwebbW8K21NdY1lRsJW4t3PpkW/K2c795/Fa7XX972fYvO4Q7OnbG7zxd615bu8tg1/I6tE5a17N74u62PcF7Gvfa792yj7GvbD/YL93//Pf0328eiDzQctDj4N5DFofWH6YfLq1H6mfU9zXwGzoaUxvbj0QcaWnybjr8h8MfO5pNmquP6hxdfoxybOGxweNFx/tPiE70nsw62dUypeXeqfGnrp8ed7r1TOSZ82dDz546F3Du+Hmf880XvC4cuehxseGS26X6y66XD//p+ufhVrfW+ivuVxrbPNua2se2H7vqd/XkteBrZ6+zrl+6EXOj/WbSzdu3Jt7quM29/exO7p1XdwvvDtybd59wv/SBxoOKhwYPa/5l8699HW4dRzuDOy8/Snh0r4vT9eKx5PHn7oVPaE8qnho/rX3m/Ky5J7Sn7fmE590vRC8Gekv+0vxr/Uvrl4f+9v/7ct/4vu5X4leDr5e+0Xuz4+2Yty39cf0P3+W9G3hf+kHvw86PHh/PfUr59HRg2mfS58ovNl+avkZ+vT+YNzgoYovZ8qMABhuamQnA6x0A0FLh2aENAMoExd1MLojiPikn8J9YcX+TixsAO/wBSJoHQBQ8o2yEzQIyFb5lR/BEf4C6uAw3pUgyXZwVvqjwxkL4MDj4xhAAUhMAX8SDgwMbBge/bIPJ3gHgRL7iTigT2R10s4OM2rpfgh/l34RUcT2MnhaNAAAB90lEQVQ4Ee1Tv0tbURQ+5yVqFVHs4pBioSAp1mAxUdq05sfoKrh072QXN6HdnMTVyboLShH8D+xLg8UkhjY/tJlERIQilCpKfbmn3w08eOTdl83Nu5x7z/m+737vnHeJHtZ9d4CDLhARK1esfSChWWF6TSQnRLwnSq2mp2OnQTw3bxS2D349I77bAijuAt0oJNfEtJiKj392c6ZotSfhFJfdfUE+jn1eWZwe6HL6Q0yjqHyE6zALr+eK9bl2rvfsc2wXKwskvAZQbibxYsYL1nu7UJ1H2BKiq+bfsaFslp12jD4bHHPLCdwumQi4bBuiP+Gov3vwaMqEMQqz6EER9fHjwyASMGVdU6KeB2F8jjH9cw2+sS5Hg0jodUTXRNFlEMYvzPyjBVa0YCLZpcoE2pBBTYmokgmjcz5hZl7RJEz/vV2oLDcajR6XvHdYT0qTdzQPfd7s9D/7/gotYhdqn/Chy3ovQrfMVMUwh3HpE51rLaGqw+FMNhH97aa80SisAblC9R1EN/AYej0EpGgXpARyEbzKY4i/NYkHCmux/f3GgBP6l8EjiVp40nD8/c3k2Mm3Uu2pUvIVkBEt3vVIpV/FYhea466Owi7IFPPl40jTcfKojaBNB6mp8Wkvzjc8b7HTPvkyehYKh5NwXGbiP52wD7X76cB/EiWtaCMHwyUAAAAASUVORK5CYII=</code></pre><p>字符串比较长，我们可以直接用这个字符串替换掉上文中的链接地址。你会发现浏览器原来是可以理解这个字符串的，它自动就将这个字符串解码为了一个图片，而不需再去发送 HTTP 请求。</p><h4 id="Base64-的应用场景"><a href="#Base64-的应用场景" class="headerlink" title="Base64 的应用场景"></a>Base64 的应用场景</h4><p>上面这个实例，其实源自我们 <a href="https://juejin.im/books" target="_blank" rel="noopener">掘金</a> 网站 Header 部分的搜索栏 Logo：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthVjSfFVMATat3x.9N6BXPqnGke9JL*RH6V30J1KwomqtC0QHsRtLW4*56.a3WvASCsZNwmZRMlgjK15SbrO3og!/b&amp;bo=HgJ8AB4CfAADGTw!&amp;rf=viewer_4" alt="img"></p><p>大家不妨打开小册首页，然后打开开发者工具，在源码中搜索“base64”关键字，你会发现 Base64 码出现的地方真的不少。而且它对应的图片往往是<strong>非常小的 Logo</strong>。</p><p>既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？</p><p>这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。<br>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。</p><p>因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：</p><ul><li>图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）</li><li>图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）</li><li>图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）</li></ul><h4 id="Base64-编码工具推荐"><a href="#Base64-编码工具推荐" class="headerlink" title="Base64 编码工具推荐"></a>Base64 编码工具推荐</h4><p>这里最推荐的是利用 webpack 来进行 Base64 的编码——webpack 的 <a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="noopener">url-loader</a> 非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。</p><p>除此之外，市面上免费的 Base64 编解码工具种类是非常多样化的，有很多网站都提供在线编解码的服务，大家选取自己认为顺手的工具就好。</p><h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>关键字：<strong>年轻的全能型选手</strong></p><p>WebP 是今天在座各类图片格式中最年轻的一位，它于 2010 年被提出， 是 Google 专为 Web 开发的一种<strong>旨在加快图片加载速度</strong>的图片格式，它支持有损压缩和无损压缩。</p><h4 id="WebP-的优点"><a href="#WebP-的优点" class="headerlink" title="WebP 的优点"></a>WebP 的优点</h4><p>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。<br>WebP 的官方介绍对这一点有着更权威的阐述：</p><blockquote><p>与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。</p></blockquote><p>我们开篇提到，图片优化是质量与性能的博弈，从这个角度看，WebP 无疑是真正的赢家。</p><h4 id="WebP-的局限性"><a href="#WebP-的局限性" class="headerlink" title="WebP 的局限性"></a>WebP 的局限性</h4><p>WebP 纵有千般好，但它毕竟<strong>太年轻</strong>。我们知道，任何新生事物，都逃不开兼容性的大坑。现在是 2018 年 9 月，WebP 的支持情况是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntmd8qsc6IUzzkMdkOuCU8nfSP9VfWTjOiyHwPoo8DDzYpE3xqH5MYKqmZZ9lzRBBdbwLLHEfX.a4sHakdTun1Ek!/b&amp;bo=XAaAAuoJ5gMDGeI!&amp;rf=viewer_4" alt="img"></p><p>坦白地说，虽然没有特别惨（毕竟还有亲爹 Chrome 在撑腰），但也足够让人望而却步了。</p><p>此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。</p><h4 id="WebP-的应用场景"><a href="#WebP-的应用场景" class="headerlink" title="WebP 的应用场景"></a>WebP 的应用场景</h4><p>现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，也就是说我们需要准备 PlanB，准备降级方案。</p><p>目前真正把 WebP 格式落地到网页中的网站并不是很多，这其中淘宝首页对 WebP 兼容性问题的处理方式就非常有趣。我们可以打开 Chrome 的开发者工具搜索其源码里的 WebP 关键字：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntvy84ksYDxmo4po*KV4LxlxY0wRNizzvEvNudY9IsFFBQRfkboWIvZsnhBBDMjlmlr3EcOy*Vk3Wc2qzN8NC85U!/b&amp;bo=2ASkAdgEpAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>我们会发现检索结果还是挺多的（单就图示的加载结果来看，足足有 200 多条），下面大家注意一下这些 WebP 图片的链接地址（以其中一个为例）：</p><pre><code class="html">&lt;img src=&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp&quot; alt=&quot;手机app - 聚划算&quot; class=&quot;app-icon&quot;&gt;</code></pre><p>.webp 前面，还跟了一个 .jpg 后缀！</p><p>我们现在先大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。带着这个预判，我们打开并不支持 WebP 格式的 Safari 来进入同样的页面，再次搜索 WebP 关键字：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthgqRlogXqhP3j4b8XgvMmzvjdlPSyMS.JVtSXnmZbC8sN7nwf856ZkZTX3o7EFClzMQSZcQx0OK1q0QxZ.gABw!/b&amp;bo=aAN.AGgDfgADGTw!&amp;rf=viewer_4" alt="img"></p><p>Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接：</p><pre><code class="html">&lt;img src=&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg&quot; alt=&quot;手机app - 聚划算&quot; class=&quot;app-icon&quot;&gt;</code></pre><p>我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。</p><p>此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。</p><p>由此也可以看出，我们 WebP 格式的局限性确实比较明显，如果决定使用 WebP，兼容性处理是必不可少的。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>不知道大家有没有注意到这一点：在图片这一节，我用到的许多案例图示，都是源于一线的电商网站。</p><p>为什么这么做？因为图片是电商平台的重要资源，甚至有人说“做电商就是做图片”。淘宝和京东，都是流量巨大、技术成熟的站点，它们在性能优化方面起步早、成效好，很多方面说是教科书般的案例也不为过。</p><p>这也是非常重要的一个学习方法。在小册开篇我提到，性能优化不那么好学，有很大原因是因为这块的知识不成体系、难以切入，同时技术方案又迭代得飞快。当我们不知道怎么切入的时候，或者说当我们面对一个具体的问题无从下手的时候，除了翻阅手中的书本（很可能是已经过时的）和网络上收藏的文章（也许没那么权威），现在是不是又多了“打开那些优秀的网站看一看”这条路可以走了呢？</p><p>好了，至此，我们终于结束了图片优化的征程。下面，我们以存储篇为过渡，进入 JS 和 CSS 的世界！</p><h1 id="存储篇-1：浏览器缓存机制介绍与缓存策略剖析"><a href="#存储篇-1：浏览器缓存机制介绍与缓存策略剖析" class="headerlink" title="存储篇 1：浏览器缓存机制介绍与缓存策略剖析"></a>存储篇 1：浏览器缓存机制介绍与缓存策略剖析</h1><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些：</p><blockquote><p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p></blockquote><p>很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p><ol><li>Memory Cache</li><li>Service Worker Cache</li><li>HTTP Cache</li><li>Push Cache</li></ol><p>大家对 HTTP Cache（即 Cache-Control、expires 等字段控制的缓存）应该比较熟悉，如果对其它几种缓存可能还没什么概念，我们可以先来看一张线上网站的 Network 面板截图：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrB7su.SNggt5.BgHqRyBxS7VCcq7nWxWPj0owWcY9BQ9Logxx6mW8tMzgLVEw3QztGO2AuWvpXSASHUhDso5e0!/b&amp;bo=QgqAAtYKpAIDSdw!&amp;rf=viewer_4" alt="img"></p><p>我们给 size 这一栏一个特写：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntjdzg5jaGQSmZhV*vtTiEXWsDrMiainR7g7FksCdElQMrRuMO5SqQBg.2rslc6w7AxoNhagEgW82h9G.HoeFPaQ!/b&amp;bo=ugC4AboAuAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>大家注意一下非数字——即形如“（from xxx）”这样的描述——对应的资源，这些资源就是我们通过缓存获取到的。其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。</p><p>本节将会针对这四个方面各个击破。考虑到 HTTP 缓存是最主要、最具有代表性的缓存策略，也是每一位前端工程师都应该深刻理解掌握的性能优化知识点，我们下面优先针对 HTTP 缓存机制进行剖析。</p><h2 id="HTTP-缓存机制探秘"><a href="#HTTP-缓存机制探秘" class="headerlink" title="HTTP 缓存机制探秘"></a>HTTP 缓存机制探秘</h2><p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为<strong>强缓存</strong>和<strong>协商缓存</strong>。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p><h3 id="强缓存的特征"><a href="#强缓存的特征" class="headerlink" title="强缓存的特征"></a>强缓存的特征</h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信。</strong></p><p>命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntjviXCe*cPk5JkNy5msPbLsmlAKibUV*Ck.n37f32L06.X5m8Ia80.emi.dyMx9OLql4lh4ofBZSIFh8UaONae0!/b&amp;bo=lAJkAJQCZAADGTw!&amp;rf=viewer_4" alt="img"></p><h3 id="强缓存的实现：从-expires-到-cache-control"><a href="#强缓存的实现：从-expires-到-cache-control" class="headerlink" title="强缓存的实现：从 expires 到 cache-control"></a>强缓存的实现：从 expires 到 cache-control</h3><p>实现强缓存，过去我们一直用 <code>expires</code>。<br>当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntq1sjZSRWZJkX*NzZ9536QFivP6fpLUB2J91RDoHclpWaNgQuaASFKbLYvvVB6uvG0YyUflFKxpluVEqwmhGD84!/b&amp;bo=xgKEAcYChAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>我们给 expires 一个特写：</p><pre><code class="html">expires: Wed, 11 Sep 2019 16:12:18 GMT</code></pre><p>可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</p><p>从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。</p><p>考虑到 expires 的局限性，HTTP1.1 新增了 <code>Cache-Control</code> 字段来完成 expires 的任务。<br>expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的<strong>完全替代方案</strong>。在当下的前端实践里，我们继续使用 expires 的唯一目的就是<strong>向下兼容</strong>。</p><p>现在我们给 Cache-Control 字段一个特写：</p><pre><code class="html">cache-control: max-age=31536000</code></pre><p>如大家所见，在 Cache-Control 中，我们通过 <code>max-age</code> 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。</p><p><strong>Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。</strong></p><h3 id="Cache-Control-应用分析"><a href="#Cache-Control-应用分析" class="headerlink" title="Cache-Control 应用分析"></a>Cache-Control 应用分析</h3><p>Cache-Control 的神通，可不止于这一个小小的 max-age。如下的用法也非常常见：</p><pre><code class="html">cache-control: max-age=3600, s-maxage=31536000</code></pre><p><strong>s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。</strong></p><p>这个 s-maxage 不像 max-age 一样为大家所熟知。的确，在项目不是特别大的场景下，max-age 足够用了。但在依赖各种<strong>代理</strong>的大型架构中，我们不得不考虑<strong>代理服务器</strong>的缓存问题。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。</p><p>(此处应注意这样一个细节：s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。)</p><p>那么什么是 public 缓存呢？说到这里，Cache-Control 中有一些适合放在一起理解的知识点，我们集中梳理一下：</p><h4 id="public-与-private"><a href="#public-与-private" class="headerlink" title="public 与 private"></a>public 与 private</h4><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。</p><p>如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为<strong>默认值</strong>。但多数情况下，public 并不需要我们手动设置，比如有很多线上网站的 cache-control 是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnttQxZNJsjhHdKzVuzhIUpPPU8*sernrHeYCE*d0*KZQUOczGNHB89Gg74uxApNjftgOkeasPLjojRumpdqbd2Rs!/b&amp;bo=9AIAAfQCAAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>设置了 s-maxage，没设置 public，那么 CDN 还可以缓存这个资源吗？答案是肯定的。因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。</p><h4 id="no-store与no-cache"><a href="#no-store与no-cache" class="headerlink" title="no-store与no-cache"></a>no-store与no-cache</h4><p>no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。</p><p>no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</p><h3 id="协商缓存：浏览器与服务器合作之下的缓存策略"><a href="#协商缓存：浏览器与服务器合作之下的缓存策略" class="headerlink" title="协商缓存：浏览器与服务器合作之下的缓存策略"></a>协商缓存：浏览器与服务器合作之下的缓存策略</h3><p>协商缓存依赖于服务端与浏览器之间的通信。</p><p>协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</p><p>如果服务端提示缓存资源未改动（Not Modified），资源会被<strong>重定向</strong>到浏览器缓存，<strong>这种情况下网络请求对应的状态码是 304</strong>（如下图）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntlxXGziO1rQBtRsv8xob.0.Ll..8iDDQIbip.pG6PNksqUr3NLyyoIJa8*077uN9AI1BaHw0gmHHPJcvyxAqqwA!/b&amp;bo=xgJkAMYCZAADGTw!&amp;rf=viewer_4" alt="img"></p><h3 id="协商缓存的实现：从-Last-Modified-到-Etag"><a href="#协商缓存的实现：从-Last-Modified-到-Etag" class="headerlink" title="协商缓存的实现：从 Last-Modified 到 Etag"></a>协商缓存的实现：从 Last-Modified 到 Etag</h3><p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p><pre><code class="html">Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT</code></pre><p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p><pre><code class="html">If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT</code></pre><p>服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。</p><p>使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：</p><ul><li>我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li><li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li></ul><p>这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。</p><p>Etag 是由服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</p><p>Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的：</p><pre><code class="html">ETag: W/&quot;2a3b-1602480f459&quot;</code></pre><p>那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：</p><pre><code class="html">If-None-Match: W/&quot;2a3b-1602480f459&quot;</code></pre><p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 <strong>Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</strong></p><h2 id="HTTP-缓存决策指南"><a href="#HTTP-缓存决策指南" class="headerlink" title="HTTP 缓存决策指南"></a>HTTP 缓存决策指南</h2><p>行文至此，当代 HTTP 缓存技术用到的知识点，我们已经从头到尾挖掘了一遍了。那么在面对一个具体的缓存需求时，我们到底该怎么决策呢？</p><p>走到决策建议这一步，我本来想给大家重新画一个流程图。但是画来画去终究不如 Chrome 官方给出的这张清晰、权威：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntn6ACQMdpbNshiFHP7Ejo9bnVYsxlGxbI*0kx1DVLDaPKBUYUJ*5Otgmr7Sg*InB3M4SW14NI67OKT0QXzmvGDc!/b&amp;bo=UwJYAlMCWAIDGTw!&amp;rf=viewer_4" alt="img"></p><p>我们现在一起解读一下这张流程图：</p><p>当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p><p>我个人非常推崇这张流程图给出的决策建议，也强烈推荐大家在理解以上知识点的基础上，将这张图保存下来、在日常开发中用用看，它的可行度非常高。</p><p>OK，走到这里，本节最大的一座山已经被大家翻过去了。接下来的内容会相对比较轻松，大家放松心情，我们继续前行！</p><h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</p><p>内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。</p><p>那么哪些文件会被放入内存呢？</p><p>事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。</p><p>虽然划分规则没有定论，但根据日常开发中观察的结果，包括我们开篇给大家展示的 Network 截图，我们至少可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。</p><h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。</p><p>Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。</p><p>下面我们就通过实战的方式，一起见识一下 Service Worker 如何为我们实现离线缓存（注意看注释）： 我们首先在入口文件中插入这样一段 JS 代码，用以判断和引入 Service Worker：</p><pre><code class="js">window.navigator.serviceWorker.register(&#39;/test.js&#39;).then(   function () {      console.log(&#39;注册成功&#39;)    }).catch(err =&gt; {      console.error(&quot;注册失败&quot;)    })</code></pre><p>在 test.js 中，我们进行缓存的处理。假设我们需要缓存的文件分别是 test.html,test.css 和 test.js：</p><pre><code class="js">// Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑  self.addEventListener(&#39;install&#39;, event =&gt; {  event.waitUntil(    // 考虑到缓存也需要更新，open内传入的参数为缓存的版本号    caches.open(&#39;test-v1&#39;).then(cache =&gt; {      return cache.addAll([        // 此处传入指定的需缓存的文件名        &#39;/test.html&#39;,        &#39;/test.css&#39;,        &#39;/test.js&#39;      ])    })  )})// Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的self.addEventListener(&#39;fetch&#39;, event =&gt; {  event.respondWith(    // 尝试匹配该请求对应的缓存值    caches.match(event.request).then(res =&gt; {      // 如果匹配到了，调用Server Worker缓存      if (res) {        return res;      }      // 如果没匹配到，向服务端发起这个资源请求      return fetch(event.request).then(response =&gt; {        if (!response || response.status !== 200) {          return response;        }        // 请求成功的话，将请求缓存起来。        caches.open(&#39;test-v1&#39;).then(function(cache) {          cache.put(event.request, response);        });        return response.clone();      });    })  );});</code></pre><p><strong>PS</strong>：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。</p><h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><blockquote><p>预告：本小节定位为基础科普向，对 Push Cache 有深入挖掘兴趣的同学，强烈推荐拓展阅读 Chrome 工程师 Jake Archibald 的这篇 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a>。</p></blockquote><p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，我找了好几个网站也没找到一个合适的案例来给大家做具体的介绍。但应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：</p><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li><li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li></ul><p>更多的特性和应用，期待大家可以在日后的开发过程中去挖掘和实践。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>小建议！很多同学在学习缓存这块知识的时候可能多少会有这样的感觉：对浏览器缓存，只能描述个大致，却说不上深层原理；好不容易记住了每个字段怎么用，过几天又给忘了。这是因为缓存部分的知识，具有“细碎、迭代快”的特点。对于这样的知识，我们应该尝试先划分出层次和重点，归纳出完整的体系，然后针对每个知识点去各个击破。</p><p>终于结束了对缓存世界的探索，不知道大家有没有一种意犹未尽的感觉。开篇我们谈过，缓存非常重要，它几乎是我们性能优化的首选方案。</p><p>但页面的数据存储方案除了缓存，还有本地存储。在下一节中，我们就将围绕本地存储展开探索。</p><h1 id="存储篇-2：本地存储——从-Cookie-到-Web-Storage、IndexDB"><a href="#存储篇-2：本地存储——从-Cookie-到-Web-Storage、IndexDB" class="headerlink" title="存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB"></a>存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB</h1><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。</p><p>我认为，WebApp 就是我们前端性能优化的产物，是我们前端工程师对体验不懈追求的结果，是 Web 网页在性能上向 Native 应用的一次“宣战”。</p><p>WebApp 优异的性能表现，要归功于浏览器存储技术的广泛应用——这其中除了我们上节提到的缓存，本地存储技术也功不可没。</p><h2 id="故事的开始：从-Cookie-说起"><a href="#故事的开始：从-Cookie-说起" class="headerlink" title="故事的开始：从 Cookie 说起"></a>故事的开始：从 Cookie 说起</h2><p>Cookie 的本职工作并非本地存储，而是“维持状态”。</p><p>在 Web 开发的早期，人们亟需解决的一个问题就是状态管理的问题：HTTP 协议是一个无状态协议，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。那么下次请求的时候，如何让服务器知道“我是我”呢？</p><p>在这样的背景下，Cookie 应运而生。</p><p>Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p><p>关于 Cookie 的详细内容，我们可以在 Chrome 的 Application 面板中查看到：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrnXYNujBPP79P6sa9q7Y96x27avMg4FcxtWnU.HCM7apjq4A5mC.diNLwTOeQ74w.*oH2bIfjMHJUxc7tH3rQY!/b&amp;bo=TAWAAnwHiAMDKTc!&amp;rf=viewer_4" alt="img"></p><p>如大家所见，<strong>Cookie 以键值对的形式存在</strong>。</p><h3 id="Cookie的性能劣势"><a href="#Cookie的性能劣势" class="headerlink" title="Cookie的性能劣势"></a>Cookie的性能劣势</h3><h4 id="Cookie-不够大"><a href="#Cookie-不够大" class="headerlink" title="Cookie 不够大"></a>Cookie 不够大</h4><p>大家知道，Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。</p><h4 id="过量的-Cookie-会带来巨大的性能浪费"><a href="#过量的-Cookie-会带来巨大的性能浪费" class="headerlink" title="过量的 Cookie 会带来巨大的性能浪费"></a>过量的 Cookie 会带来巨大的性能浪费</h4><p><strong>Cookie 是紧跟域名的</strong>。我们通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值：</p><pre><code class="html">Set-Cookie: name=xiuyan; domain=xiuyan.me</code></pre><p><strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p><p>随着前端应用复杂度的提高，Cookie 也渐渐演化为了一个“存储多面手”——它不仅仅被用于维持状态，还被塞入了一些乱七八糟的其它信息，被迫承担起了本地存储的“重任”。在没有更好的本地存储解决方案的年代里，Cookie 小小的身体里承载了 4KB 内存所不能承受的压力。</p><p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p><h2 id="向前一步：Web-Storage"><a href="#向前一步：Web-Storage" class="headerlink" title="向前一步：Web Storage"></a>向前一步：Web Storage</h2><p>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。这两组概念非常相近，我们不妨先理解它们之间的区别，再对它们的共性进行研究。</p><h3 id="Local-Storage-与-Session-Storage-的区别"><a href="#Local-Storage-与-Session-Storage-的区别" class="headerlink" title="Local Storage 与 Session Storage 的区别"></a>Local Storage 与 Session Storage 的区别</h3><p>两者的区别在于<strong>生命周期</strong>与<strong>作用域</strong>的不同。</p><ul><li>生命周期：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</li><li>作用域：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们<strong>不在同一个浏览器窗口中</strong>打开，那么它们的 Session Storage 内容便无法共享。</li></ul><h3 id="Web-Storage-的特性"><a href="#Web-Storage-的特性" class="headerlink" title="Web Storage 的特性"></a>Web Storage 的特性</h3><ul><li>存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。</li><li>仅位于浏览器端，不与服务端发生通信。</li></ul><h3 id="Web-Storage-核心-API-使用示例"><a href="#Web-Storage-核心-API-使用示例" class="headerlink" title="Web Storage 核心 API 使用示例"></a>Web Storage 核心 API 使用示例</h3><p>Web Storage 保存的数据内容和 Cookie 一样，是文本内容，以键值对的形式存在。Local Storage 与 Session Storage 在 API 方面无异，这里我们以 localStorage 为例：</p><ul><li>存储数据：setItem()</li></ul><pre><code class="js">localStorage.setItem(&#39;user_name&#39;, &#39;xiuyan&#39;)</code></pre><ul><li>读取数据： getItem()</li></ul><pre><code class="js">localStorage.getItem(&#39;user_name&#39;)</code></pre><ul><li>删除某一键名对应的数据： removeItem()</li></ul><pre><code class="js">localStorage.removeItem(&#39;user_name&#39;)</code></pre><ul><li>清空数据记录：clear()</li></ul><pre><code class="js">localStorage.clear()</code></pre><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h4><p>Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。</p><p>这里给大家举个例子，考虑到 Local Storage 的特点之一是<strong>持久</strong>，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntn4Vjp3cv2E.wDKHEWOjB7NIMWikDACJEY7J6h1anFdH5T8UUJDhi9gfFJlZJnnakmcyMMkchfhVi5O3reIi0l0!/b&amp;bo=vAcGArwHBgIDORw!&amp;rf=viewer_4" alt="img"></p><p>有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。</p><h4 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h4><p>Session Storage 更适合用来存储生命周期和它同步的<strong>会话级别</strong>的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthBybzOyYbOWbcctuUympeQSnofv9E*K.CRvRXXwg1OoQ8nq6vssFnfc320LgrG3jF4aCwevACr2kdppLjTC894!/b&amp;bo=vQWAAj0GuAIBGYU!&amp;rf=viewer_4" alt="img"></p><p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 Session Storage 来处理再合适不过。</p><p>这样看来，Web Storage 确实也够强大了。那么 Web Storage 是否能 hold 住所有的存储场景呢？</p><p>答案是否定的。大家也看到了，Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p><p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexDB！</p><h2 id="终极形态：IndexDB"><a href="#终极形态：IndexDB" class="headerlink" title="终极形态：IndexDB"></a>终极形态：IndexDB</h2><p>IndexDB 是一个<strong>运行在浏览器上的非关系型数据库</strong>。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p><p>IndexDB 从推出之日起，其优质教程就层出不绝，我们今天不再着重讲解它的详细操作。接下来，我们遵循 MDN 推荐的操作模式，通过一个基本的 IndexDB 使用流程，旨在对 IndexDB 形成一个感性的认知：</p><ol><li>打开/创建一个 IndexDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 xiaoceDB 新数据库）。</li></ol><pre><code class="js">  // 后面的回调中，我们可以通过event.target.result拿到数据库实例  let db  // 参数1位数据库名，参数2为版本号  const request = window.indexedDB.open(&quot;xiaoceDB&quot;, 1)  // 使用IndexDB失败时的监听函数  request.onerror = function(event) {     console.log(&#39;无法使用IndexDB&#39;)   }  // 成功  request.onsuccess  = function(event){    // 此处就可以获取到db实例    db = event.target.result    console.log(&quot;你打开了IndexDB&quot;)  }</code></pre><ol><li>创建一个 object store（object store 对标到数据库中的“表”单位）。</li></ol><pre><code class="js">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object storerequest.onupgradeneeded = function(event){  let objectStore  // 如果同名表未被创建过，则新建test表  if (!db.objectStoreNames.contains(&#39;test&#39;)) {    objectStore = db.createObjectStore(&#39;test&#39;, { keyPath: &#39;id&#39; })  }}  </code></pre><ol><li>构建一个事务来执行一些数据库操作，像增加或提取数据等。</li></ol><pre><code class="js">  // 创建事务，指定表格名称和读写权限  const transaction = db.transaction([&quot;test&quot;],&quot;readwrite&quot;)  // 拿到Object Store对象  const objectStore = transaction.objectStore(&quot;test&quot;)  // 向表格写入数据  objectStore.add({id: 1, name: &#39;xiuyan&#39;})</code></pre><ol><li>通过监听正确类型的事件以等待操作完成。</li></ol><pre><code class="js">  // 操作成功时的监听函数  transaction.oncomplete = function(event) {    console.log(&quot;操作成功&quot;)  }  // 操作失败时的监听函数  transaction.onerror = function(event) {    console.log(&quot;这里有一个Error&quot;)  }</code></pre><h3 id="IndexDB-的应用场景"><a href="#IndexDB-的应用场景" class="headerlink" title="IndexDB 的应用场景"></a>IndexDB 的应用场景</h3><p>通过上面的示例大家可以看出，在 IndexDB 中，我们可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。IndexDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，我们毫无疑问可以请出 IndexDB 来帮忙。</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>浏览器缓存/存储技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于缓存/存储技术的第三方库层出不绝，此外还衍生出了 <a href="https://lavas.baidu.com/pwa" target="_blank" rel="noopener">PWA</a> 这样优秀的 Web 应用模型。可以说，现代前端应用，尤其是移动端应用，之所以可以发展到在体验上叫板 Native 的地步，主要就是仰仗缓存/存储立下的汗马功劳。</p><h1 id="彩蛋篇：CDN-的缓存与回源机制解析"><a href="#彩蛋篇：CDN-的缓存与回源机制解析" class="headerlink" title="彩蛋篇：CDN 的缓存与回源机制解析"></a>彩蛋篇：CDN 的缓存与回源机制解析</h1><h2 id="写在小册的半山腰"><a href="#写在小册的半山腰" class="headerlink" title="写在小册的半山腰"></a>写在小册的半山腰</h2><p>不知不觉，小册内容已经过了小半了。</p><p>回顾一下走过的路：在对知识体系进行一番梳理后，我们操起 webpack 开始优化文件（顺便还学了点 Gzip），随后又马不停蹄进入图片的小天地，最后把缓存和本地存储的味道逐一品尝，终于得以窥见网络层面核心优化技术的全貌。</p><p>古人云：学而不思则罔。</p><p>站在性能优化的半山腰，我希望大家可以缓一缓，停下来思考一个问题：我得到了什么？</p><p>作为作者，我在自己写的每一行字背后都费了思量。在过去的每个章节里我都预先为知识点做了权重划分，力求“详略得当”，而非盲目地求大求全。孰详孰略，只能根据知识点本身的重要性来划分，但读者的知识结构是多样的。“如何使阅读效益最大化”的金钥匙不在我手中，而是在各位自己手中。</p><p>本小册中我有所提及的每一个知识点，<strong>都有大公司在实践</strong>。即便是略写的内容，大家也值得进一步去推敲。可以尝试深挖这本小册的可能性，把它用起来，用到自己的工作中去，去看看它能否给你的业务带来提升，看看是否还有更精进的方案。</p><p>我是一个“啰嗦”的人。尤其是意识到这本书可能会成为一些同学的性能优化启蒙读物时，我更加认为有必要在行文小半时再啰嗦这么一遍：如果读到这里，脑海中无法复现出网络层面的知识体系，无法在回忆每个技术点时记起它的场景和特性，我建议不要急于往下走，而是回过头去再看看学过的这部分的内容——走马观花不是学习，主动理解+动手实践才是。</p><h2 id="彩蛋：CDN的缓存与回源机制解析"><a href="#彩蛋：CDN的缓存与回源机制解析" class="headerlink" title="彩蛋：CDN的缓存与回源机制解析"></a>彩蛋：CDN的缓存与回源机制解析</h2><blockquote><p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p></blockquote><h3 id="为什么要用-CDN"><a href="#为什么要用-CDN" class="headerlink" title="为什么要用 CDN"></a>为什么要用 CDN</h3><p>浏览器存储的相关知识此刻离我们还不太远，大家趁热回忆一下：缓存、本地存储带来的性能提升，是不是只能在“获取到资源并把它们存起来”这件事情发生之后？也就是说，首次请求资源的时候，这些招数都是救不了我们的。要提升首次请求的响应能力，除了我们 2、3、4 节提到的方案之外，我们还需要借助 CDN 的能力。</p><h3 id="CDN-如何工作"><a href="#CDN-如何工作" class="headerlink" title="CDN 如何工作"></a>CDN 如何工作</h3><p>借中国地图一角来给大家举一个简单的🌰：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqI7aizd8NiYRAj2zu1Z0T7KrrpvhR02Axq6W8LGai8XnciRK1paUT*vaPWvoatprI6ZqbTDJ2CzFBvDvP70pAI!/b&amp;bo=oAT8A6AE*AMDWXw!&amp;rf=viewer_4" alt="img"></p><p>假设我的根服务器在杭州，同时在图示的五个城市里都有自己可用的机房。</p><p>此时有一位北京的用户向我请求资源。在网络带宽小、用户访问量大的情况下，杭州的这一台服务器或许不那么给力，不能给用户非常快的响应速度。于是我灵机一动，把这批资源 copy 了一批放在北京的机房里。当用户请求资源时，就近请求北京的服务器，北京这台服务器低头一看，这个资源我存了，离得这么近，响应速度肯定噌噌的！那如果北京这台服务器没有 copy 这批资源呢？它会再向杭州的根服务器去要这个资源。在这个过程中，北京这台服务器就扮演着 CDN 的角色。</p><h3 id="CDN的核心功能特写"><a href="#CDN的核心功能特写" class="headerlink" title="CDN的核心功能特写"></a>CDN的核心功能特写</h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。</p><p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p><h3 id="CDN-与前端性能优化"><a href="#CDN-与前端性能优化" class="headerlink" title="CDN 与前端性能优化"></a>CDN 与前端性能优化</h3><p>一个彩蛋的自我修养——CDN 往往是被前端认为前端不需要了解的东西。</p><p>具体来说，我身边许多同学对其的了解止步于：部署界面上有一个“部署到CDN”按钮，我去点一下，资源就在 CDN 上啦！</p><p>“眼下业务开发用不到的可以暂缓了解”，这是没毛病的。但正如我小册开篇所说的，前端工程师首先是软件工程师。对整个技术架构的理解，将会反哺我们对某一具体环节的理解；知识点的适当拓展，也会对大家技术高度和技术广度的提升大有裨益。</p><p>那么，我们了解一下 CDN 是怎么帮助前端的。</p><p><strong>CDN 往往被用来存放静态资源</strong>。上文中我们举例所提到的“根服务器”本质上是业务服务器，它的核心任务在于<strong>生成动态页面或返回非纯静态页面</strong>，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。</p><p>所谓“静态资源”，就是像 JS、CSS、图片等<strong>不需要业务服务器进行计算即得的资源</strong>。而“动态资源”，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。</p><p>什么是“非纯静态资源”呢？它是指<strong>需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。</p><h3 id="CDN-的实际应用"><a href="#CDN-的实际应用" class="headerlink" title="CDN 的实际应用"></a>CDN 的实际应用</h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段，在许多一线的互联网公司，“静态资源走 CDN”并不是一个建议，而是一个规定。</p><p>比如以淘宝为代表的阿里系产品，就遵循着这个“规定”。<br>打开淘宝首页，我们可以在 Network 面板中看到，“非纯静态”的 HTML 页面，是向业务服务器请求来的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntgZBUeP1qC9iDdXvIzeEpwNy.L.ir4HS4rxx9GTzagO4pN8xaKDWF0mOwnlAUOwnJ5.F9WRroNswFO*D1AyXUYI!/b&amp;bo=XgSmAl4EpgIDKQw!&amp;rf=viewer_4" alt="img"></p><p>我们点击 preview，可以看到业务服务器确实是返回给了我们一个尚未被静态资源加持过的简单 HTML 页面，所有的图片内容都是先以一个 div 占位：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntsPFahGg.nHTKj2vDMIvvmeeviT25WZjwHfpcYjXM2S9QnJp*m2XAcpkayVVRAzB0e4KtCxH42kIT*LuRAR39Uk!/b&amp;bo=Ngh.BDYIfgQDGTw!&amp;rf=viewer_4" alt="img"></p><p>相应地，我们随便点开一个静态资源，可以看到它都是从 CDN 服务器上请求来的。</p><p>比如说图片：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqsAz6NW5fpN3W6uE6fvasm1wuEjn82Iykt.NX4Wfxe19czH2Ifv4C5KwhV72h67UqK4iMJmfB4YBZzwwjtZKP0!/b&amp;bo=ZARqAGQEagADGTw!&amp;rf=viewer_4" alt="img"></p><p>再比如 JS、CSS 文件：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntq.LJn.2UwxJ3lYwCJ*2TfhPfWdWYTJlTZFmWp8*3b.fUtAc72XpD*IFCAD3El1ix.QOxYqHnYFeba90Nbo224M!/b&amp;bo=RgaGAEYGhgADGTw!&amp;rf=viewer_4" alt="img" style="zoom:80%;"></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntjeIz5inkbjcQa60159rVDKy5jvml0e*y1yfK8pFyZDInZAWsQlqhwLhjjFgSVQG86Xy6QBIx*lz9doARvskDRY!/b&amp;bo=rAaWAKwGlgADGTw!&amp;rf=viewer_4" alt="img"></p><h3 id="CDN-优化细节"><a href="#CDN-优化细节" class="headerlink" title="CDN 优化细节"></a>CDN 优化细节</h3><p>如何让 CDN 的效用最大化？这又是需要前后端程序员一起思考的庞大命题。它涉及到 CDN 服务器本身的性能优化、CDN 节点的地址选取等。但我们今天不写高深的论文，只谈离前端最近的这部分细节：CDN 的域名选取。</p><p>大家先回头看一下我刚刚选取的淘宝首页的例子，我们注意到业务服务器的域名是这个：</p><pre><code>www.taobao.com</code></pre><p>而 CDN 服务器的域名是这个：</p><pre><code>g.alicdn.com</code></pre><p>没错，我们不一样！</p><p>再看另一方面，我们讲到 Cookie 的时候，为了凸显 Local Storage 的优越性，曾经提到过：</p><blockquote><p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的……</p></blockquote><p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p><p>看起来是一个不起眼的小细节，但带来的效用却是惊人的。以电商网站静态资源的流量之庞大，如果没把这个多余的 Cookie 拿下来，不仅用户体验会大打折扣，每年因性能浪费带来的经济开销也将是一个非常恐怖的数字。</p><p>如此看来，性能优化还真是要步步为营！</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>结束了对 CDN 的剖析，我们网络层面的优化之旅也终于告一段落了。接下来等待大家的就是另一个庞大的知识板块——渲染层面的挑战。</p><p>与其说是“渲染层面的优化”，不如说是“浏览器端的优化”。这个板块旨在要大家对浏览器及其相关运行机制“知根知底”，进而通过具体的代码片段学习代码层面的应用手段。这部分是实打实的“硬骨头”，需要大家花些精力。</p><p>过去的几个小节里，我们考虑了服务端，考虑了网络，考虑了协议。那么接下来，我们就以“服务端渲染”为引子，承上启下，切入浏览器渲染的世界。</p><h1 id="渲染篇-1：服务端渲染的探索与实践"><a href="#渲染篇-1：服务端渲染的探索与实践" class="headerlink" title="渲染篇 1：服务端渲染的探索与实践"></a>渲染篇 1：服务端渲染的探索与实践</h1><p>服务端渲染（SSR）近两年炒得很火热，相信各位同学对这个名词多少有所耳闻。本节我们将围绕“是什么”（服务端渲染的运行机制）、“为什么”（服务端渲染解决了什么性能问题 ）、“怎么做”（服务端渲染的应用实例与使用场景）这三个点，对服务端渲染进行探索。</p><p>服务端渲染是一个相对的概念，它的对立面是“客户端渲染”。在运行机制解析这部分，我们会借力客户端渲染的概念，来帮大家理解服务端渲染的工作方式。基于对工作方式的了解，再去深挖它的原理与优势。</p><p>任何知识点都不是“一座孤岛”，服务端渲染的实践往往与当下流行的前端技术（譬如 Vue，React，Redux 等）紧密结合。本节下半场将以 React 和 Vue 下的服务端渲染实现为例，为大家呈现一个完整的 SSR 实现过程。</p><h2 id="服务端渲染的运行机制"><a href="#服务端渲染的运行机制" class="headerlink" title="服务端渲染的运行机制"></a>服务端渲染的运行机制</h2><p>相对于服务端渲染，同学们普遍对客户端渲染接受度更高一些，所以我们先从大家喜闻乐见的客户端渲染说起。</p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，往往是这个德行：</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;我是客户端渲染的页面&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&#39;root&#39;&gt;&lt;/div&gt;    &lt;script src=&#39;index.js&#39;&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>根节点下到底是什么内容呢？你不知道，我不知道，只有浏览器把 index.js 跑过一遍后才知道，这就是典型的客户端渲染。</p><p><strong>页面上呈现的内容，你在 html 源文件里里找不到</strong>——这正是它的特点。</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。</p><p>使用服务端渲染的网站，可以说是“所见即所得”，<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。</p><p>比如知乎就是典型的服务端渲染案例：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knti.Vfhawjw5iLZRyZIRCvFircViFWS0CnJrYLIvf.PwRrNelxnX59a5zJUY*UrF9hX0lMc4p33WbjaISpICxpL8!/b&amp;bo=sApGArAKRgIDORw!&amp;rf=viewer_4" alt="img"></p><p><a href="http://zhihu.com/" target="_blank" rel="noopener">zhihu.com</a> 返回的 HTML 文件已经是可以直接进行渲染的内容了。</p><h2 id="服务端渲染解决了什么性能问题"><a href="#服务端渲染解决了什么性能问题" class="headerlink" title="服务端渲染解决了什么性能问题"></a>服务端渲染解决了什么性能问题</h2><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。</p><p>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。</p><p>但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？</p><h2 id="服务端渲染的应用实例"><a href="#服务端渲染的应用实例" class="headerlink" title="服务端渲染的应用实例"></a>服务端渲染的应用实例</h2><p>下面我们先来看一下在一个 React 项目里，服务端渲染是怎么实现的。本例中，我们使用 Express 搭建后端服务。</p><p>项目中有一个叫做 VDom 的 React 组件，它的内容如下。</p><p>VDom.js:</p><pre><code class="js">import React from &#39;react&#39;const VDom = () =&gt; {  return &lt;div&gt;我是一个被渲染为真实DOM的虚拟DOM&lt;/div&gt;}export default VDom</code></pre><p>在服务端的入口文件中，我引入这个组件，对它进行渲染：</p><pre><code class="js">import express from &#39;express&#39;import React from &#39;react&#39;import { renderToString } from &#39;react-dom/server&#39;import VDom from &#39;./VDom&#39;// 创建一个express应用const app = express()// renderToString 是把虚拟DOM转化为真实DOM的关键方法const RDom = renderToString(&lt;VDom /&gt;)// 编写HTML模板，插入转化后的真实DOM内容const Page = `            &lt;html&gt;              &lt;head&gt;                &lt;title&gt;test&lt;/title&gt;              &lt;/head&gt;              &lt;body&gt;                &lt;span&gt;服务端渲染出了真实DOM:  &lt;/span&gt;                ${RDom}              &lt;/body&gt;            &lt;/html&gt;            `// 配置HTML内容对应的路由app.get(&#39;/index&#39;, function(req, res) {  res.send(Page)})// 配置端口号const server = app.listen(8000)</code></pre><p>根据我们的路由配置，当我访问 <a href="http://localhost:8000/index" target="_blank" rel="noopener">http://localhost:8000/index</a> 时，就可以呈现出服务端渲染的结果了：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrFVslHOyc2ni1gJ*Tg3rmlbYdZjHKD51fvLP.ebUhgd9uS.LK8jVriZJIWf9UOWjM1weXXNzupOqTV7e1Gypm8!/b&amp;bo=3gWYAd4FmAEDGTw!&amp;rf=viewer_4" alt="img"></p><p>我们可以看到，VDom 组件已经被 renderToString 转化为了一个内容为<code>&lt;div data-reactroot=&quot;&quot;&gt;我是一个被渲染为真实DOM的虚拟DOM&lt;/div&gt;</code>的字符串，这个字符串被插入 HTML 代码，成为了真实 DOM 树的一部分。</p><p>那么 Vue 是如何实现服务端渲染的呢？</p><p>其实是一个套路，我这里基于 <a href="https://ssr.vuejs.org/zh/#什么是服务器端渲染-ssr-？" target="_blank" rel="noopener">Vue SSR 指南</a> 中官方给出的例子为大家讲解 Vue 中的实现思路（思路见注释）。</p><p>该示例直接将 Vue 实例整合进了服务端的入口文件中：</p><pre><code class="js">const Vue = require(&#39;vue&#39;)// 创建一个express应用const server = require(&#39;express&#39;)()// 提取出renderer实例const renderer = require(&#39;vue-server-renderer&#39;).createRenderer()server.get(&#39;*&#39;, (req, res) =&gt; {  // 编写Vue实例（虚拟DOM节点）  const app = new Vue({    data: {      url: req.url    },    // 编写模板HTML的内容    template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;`  })  // renderToString 是把Vue实例转化为真实DOM的关键方法  renderer.renderToString(app, (err, html) =&gt; {    if (err) {      res.status(500).end(&#39;Internal Server Error&#39;)      return    }    // 把渲染出来的真实DOM字符串插入HTML模板中    res.end(`      &lt;!DOCTYPE html&gt;      &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;        &lt;body&gt;${html}&lt;/body&gt;      &lt;/html&gt;    `)  })})server.listen(8080)</code></pre><p>大家对比一下 React 项目中的注释内容，是不是发现这两段代码从本质上来说区别不大呢？</p><p>以上两个小🌰，为大家演示了基本的服务端渲染实现流程。</p><p>实际项目比这些复杂很多，但万变不离其宗。强调的只有两点：一是这个 renderToString() 方法；二是把转化结果“塞”进模板里的这一步。这两个操作是服务端渲染的灵魂操作。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。</p><h2 id="服务端渲染的应用场景"><a href="#服务端渲染的应用场景" class="headerlink" title="服务端渲染的应用场景"></a>服务端渲染的应用场景</h2><p>打眼一看，这个服务端渲染给浏览器省了这么多事儿，性能肯定是质的飞跃啊！喜闻乐见！但是大家打开自己经常访问的那些网页看一看，会发现仍然有许多网站压根儿不用服务端渲染——看来这个东西也不是万能的。</p><p>根据我们前面的描述，不难看出，服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理：浏览器性能毕竟有限，服务器多牛逼！能者多劳，就该让服务器多干点活！</p><p>但仔细想想，在这个网民遍地的时代，几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。</p><p>这样分析下来，服务端渲染也并非万全之策。在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了~</p><h1 id="渲染篇-2：知己知彼——解锁浏览器背后的运行机制"><a href="#渲染篇-2：知己知彼——解锁浏览器背后的运行机制" class="headerlink" title="渲染篇 2：知己知彼——解锁浏览器背后的运行机制"></a>渲染篇 2：知己知彼——解锁浏览器背后的运行机制</h1><p>从本章开始，我们的性能优化探险也正式进入到了“深水区”——浏览器端的性能优化。</p><p>平时我们几乎每天都在和浏览器打交道，在一些兼容任务比较繁重的团队里，苦逼的前端攻城师们甚至为了兼容各个浏览器而不断地去测试和调试，还要在脑子中记下各种遇到的 BUG 及解决方案。即便如此，我们好像并没有去主动地关注和了解下浏览器的工作原理。我想如果我们对此做一点了解，在项目过程中就可以有效地避免一些问题，并对页面性能做出相应的改进。</p><p>“知己知彼，百战不殆”，今天，我们就一起来揭开浏览器渲染过程的神秘面纱！</p><h2 id="浏览器的“心”"><a href="#浏览器的“心”" class="headerlink" title="浏览器的“心”"></a>浏览器的“心”</h2><p>浏览器的“心”，说的就是浏览器的内核。在研究浏览器微观的运行机制之前，我们首先要对浏览器内核有一个宏观的把握。</p><p>开篇我提到许多工程师因为业务需要，免不了需要去处理不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。<br>浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（<strong>下文我们将沿用这种叫法</strong>）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntg*JGMK3THg5fVetJkdU*EL7JAfs5CMG1TzW0DoOSlckUrwSr*7TcftHIhZASde8nIu2sC1Fr3wJa4uPltBh2hs!/b&amp;bo=EgQaARIEGgEDORw!&amp;rf=viewer_4" alt="img"></p><p>目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p><p>这里面大家最耳熟能详的可能就是 Webkit 内核了。很多同学可能会听说过 Chrome 的内核就是 Webkit，殊不知 Chrome 内核早已迭代为了 Blink。但是换汤不换药，Blink 其实也是基于 Webkit 衍生而来的一个分支，因此，Webkit 内核仍然是当下浏览器世界真正的霸主。</p><p>下面我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。</p><h2 id="开启浏览器渲染“黑盒”"><a href="#开启浏览器渲染“黑盒”" class="headerlink" title="开启浏览器渲染“黑盒”"></a>开启浏览器渲染“黑盒”</h2><p>什么是渲染过程？简单来说，渲染引擎根据 HTML 文件描述构建相应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果，这个过程就是渲染过程（如下图）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnLnj*OPRr7g*WgmZjWfznvpQjqusaXBI.0vFWSPjE5P2rnw8KTNo40IG.akcsyWgjxTpsiSFQ1NVHE3gdaGaug!/b&amp;bo=owJ6AKMCegADGTw!&amp;rf=viewer_4" alt="img"></p><p>从这个流程来看，浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是<strong>HTML 解释器</strong>、<strong>CSS 解释器</strong>、<strong>图层布局计算模块</strong>、<strong>视图绘制模块</strong>与<strong>JavaScript 引擎</strong>这几大模块：</p><ul><li>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</li><li>CSS 解释器：解析 CSS 文档, 生成样式规则。</li><li>图层布局计算模块：布局计算每个对象的精确位置和大小。</li><li>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</li><li>JavaScript 引擎：编译执行 Javascript 代码。</li></ul><h2 id="浏览器渲染过程解析"><a href="#浏览器渲染过程解析" class="headerlink" title="浏览器渲染过程解析"></a>浏览器渲染过程解析</h2><p>有了对零部件的了解打底，我们就可以一起来走一遍浏览器的渲染流程了。在浏览器里，每一个页面的首次渲染都经历了如下阶段（图中箭头不代表串行，有一些操作是并行进行的，下文会说明）：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntvMAI.olEKW1.72Bc*nfey6ehmjg360erN4afBwR8GOJ6rgwNnzUa6HA23w04SKD2soBKvnwsxyEPoSH8Hn*20g!/b&amp;bo=QgfQAUIH0AEDGTw!&amp;rf=viewer_4" alt="img"></p><ul><li><strong>解析 HTML</strong></li></ul><p>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</p><ul><li><strong>计算样式</strong></li></ul><p>浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。</p><ul><li><strong>计算图层布局</strong></li></ul><p>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</p><ul><li><strong>绘制图层</strong></li></ul><p>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</p><ul><li><strong>整合图层，得到页面</strong></li></ul><p>最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</p><h2 id="几棵重要的“树”"><a href="#几棵重要的“树”" class="headerlink" title="几棵重要的“树”"></a>几棵重要的“树”</h2><p>上面的内容没有理解透彻？别着急，我们一起来捋一捋这个过程中的重点——树！</p><p>为了使渲染过程更明晰一些，我们需要给这些”树“们一个特写:</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntuh2cWwBkwfQQKQnjIEHkBuQMRP1SSQL9d7ZWzOGpeSaCEMPhhOhFg1uKZtmfRwHRuL6Brx5uoA0KhoitQi4CqQ!/b&amp;bo=.gN5AfoDeQEDGTw!&amp;rf=viewer_4" alt="img"></p><ul><li>DOM 树：解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</li><li>CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是<strong>并行的</strong>。</li><li>渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</li><li>布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。</li><li>绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。</li></ul><p>基于这些“树”，我们再梳理一番：</p><p>渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</p><p>之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。</p><p>有心的同学可能已经在思考了，查表是个花时间的活，我怎么让浏览器的查询工作又快又好地实现呢？OK，讲了这么多原理，我们终于引出了我们的第一个可转化为代码的优化点——CSS 样式表规则的优化！</p><h2 id="不做无用功：基于渲染流程的-CSS-优化建议"><a href="#不做无用功：基于渲染流程的-CSS-优化建议" class="headerlink" title="不做无用功：基于渲染流程的 CSS 优化建议"></a>不做无用功：基于渲染流程的 CSS 优化建议</h2><p>在给出 CSS 选择器方面的优化建议之前，先告诉大家一个小知识：CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 看如下规则：</p><pre><code class="css">#myList  li {}</code></pre><p>这样的写法其实很常见。大家平时习惯了从左到右阅读的文字阅读方式，会本能地以为浏览器也是从左到右匹配 CSS 选择器的，因此会推测这个选择器并不会费多少力气：#myList 是一个 id 选择器，它对应的元素只有一个，查找起来应该很快。定位到了 myList 元素，等于是缩小了范围后再去查找它后代中的 li 元素，没毛病。</p><p>事实上，<strong>CSS 选择符是从右到左进行匹配的</strong>。我们这个看似“没毛病”的选择器，实际开销相当高：浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList，你说坑不坑！</p><p>说到坑，不知道大家还记不记得这个经典的通配符：</p><pre><code class="css">* {}</code></pre><p>入门 CSS 的时候，不少同学拿通配符清除默认样式（我曾经也是通配符用户的一员）。但这个家伙很恐怖，它会匹配所有元素，所以浏览器必须去遍历每一个元素！大家低头看看自己页面里的元素个数，是不是心凉了——这得计算多少次呀！</p><p>这样一看，一个小小的 CSS 选择器，也有不少的门道！好的 CSS 选择器书写习惯，可以为我们带来非常可观的性能提升。根据上面的分析，我们至少可以总结出如下性能提升的方案：</p><ul><li><p>避免使用通配符，只对需要用到的元素进行选择。</p></li><li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p></li><li><p>少用标签选择器。如果可以，用类选择器替代，举个🌰：</p><p>错误示范：</p><pre><code class="css">#myList li{}</code></pre><p>课代表：</p><pre><code class="css">.myList_li {}</code></pre></li><li><p>不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。举个🌰：</p><p>错误示范</p><pre><code class="css">.myList#title</code></pre><p>课代表</p><pre><code class="css">#title</code></pre></li><li><p>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</p></li></ul><p>搞定了 CSS 选择器，万里长征才刚刚开始的第一步。但现在你已经理解了浏览器的工作过程，接下来的征程对你来说并不再是什么难题~</p><h2 id="告别阻塞：CSS-与-JS-的加载顺序优化"><a href="#告别阻塞：CSS-与-JS-的加载顺序优化" class="headerlink" title="告别阻塞：CSS 与 JS 的加载顺序优化"></a>告别阻塞：CSS 与 JS 的加载顺序优化</h2><p>说完了过程，我们来说一说特性。</p><p>HTML、CSS 和 JS，都具有<strong>阻塞渲染</strong>的特性。</p><p>HTML 阻塞，天经地义——没有 HTML，何来 DOM？没有 DOM，渲染和优化，都是空谈。</p><p>那么 CSS 和 JS 的阻塞又是怎么回事呢？</p><h3 id="CSS-的阻塞"><a href="#CSS-的阻塞" class="headerlink" title="CSS 的阻塞"></a>CSS 的阻塞</h3><p>在刚刚的过程中，我们提到 DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，<strong>不会渲染任何已处理的内容</strong>。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。</p><p>我们知道，只有当我们开始解析 HTML 后、解析到 link 标签或者 style 标签时，CSS 才登场，CSSOM 的构建才开始。很多时候，DOM 不得不等待 CSSOM。因此我们可以这样总结：</p><blockquote><p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p></blockquote><p>事实上，现在很多团队都已经做到了尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）。这个“把 CSS 往前放”的动作，对很多同学来说已经内化为一种编码习惯。那么现在我们还应该知道，这个“习惯”不是空穴来风，它是由 CSS 的特性决定的。</p><h3 id="JS-的阻塞"><a href="#JS-的阻塞" class="headerlink" title="JS 的阻塞"></a>JS 的阻塞</h3><p>不知道大家注意到没有，前面我们说过程的时候，花了很多笔墨去说 HTML、说 CSS。相比之下，JS 的出镜率也太低了点。<br>这当然不是因为 JS 不重要。而是因为，在首次渲染过程中，JS 并不是一个非登场不可的角色——没有 JS，CSSOM 和 DOM 照样可以组成渲染树，页面依然会呈现——即使它死气沉沉、毫无交互。</p><p>JS 的作用在于<strong>修改</strong>，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。因此 JS 的执行会阻止 CSSOM，在我们不作显式声明的情况下，它也会阻塞 DOM。</p><p>我们通过一个🌰来理解一下这个机制：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;JS阻塞测试&lt;/title&gt;  &lt;style&gt;    #container {      background-color: yellow;      width: 100px;      height: 100px;    }  &lt;/style&gt;  &lt;script&gt;    // 尝试获取container元素    var container = document.getElementById(&quot;container&quot;)    console.log(&#39;container&#39;, container)  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 尝试获取container元素    var container = document.getElementById(&quot;container&quot;)    console.log(&#39;container&#39;, container)    // 输出container元素此刻的背景色    console.log(&#39;container bgColor&#39;, getComputedStyle(container).backgroundColor)  &lt;/script&gt;  &lt;style&gt;    #container {      background-color: blue;    }  &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>三个 console 的结果分别为：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntve6VxIMRBXC3PjhrSUvGU2EmgsQEcHn.8DmB82kUzQZkOO1al*flZ*PrKkl63uzo03khVCGF.DMR7fHwfZSxb0!/b&amp;bo=GgT.ABoE*gADGTw!&amp;rf=viewer_4" alt="img"></p><p>注：本例仅使用了内联 JS 做测试。感兴趣的同学可以把这部分 JS 当做外部文件引入看看效果——它们的表现一致。</p><p>第一次尝试获取 id 为 container 的 DOM 失败，这说明 JS 执行时阻塞了 DOM，后续的 DOM 无法构建；第二次才成功，这说明脚本块只能找到在它前面构建好的元素。这两者结合起来，“阻塞 DOM”得到了验证。再看第三个 console，尝试获取 CSS 样式，获取到的是在 JS 代码执行前的背景色（yellow），而非后续设定的新样式（blue），说明 CSSOM 也被阻塞了。那么在阻塞的背后，到底发生了什么呢？</p><p>我们前面说过，<strong>JS 引擎是独立于渲染引擎存在的</strong>。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 因此与其说是 JS 把 CSS 和 HTML 阻塞了，不如说是 JS 引擎抢走了渲染引擎的控制权。</p><p>现在理解了阻塞的表现与原理，我们开始思考一个问题。浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。但是我们是写 JS 的人，我们知道 JS 会做什么改变。假如我们可以确认一个 JS 文件的执行时机并不一定非要是此时此刻，我们就可以通过对它使用 defer 和 async 来避免不必要的阻塞，这里我们就引出了外部 JS 的三种加载方式。</p><h3 id="JS的三种加载方式"><a href="#JS的三种加载方式" class="headerlink" title="JS的三种加载方式"></a>JS的三种加载方式</h3><ul><li><p>正常模式：</p><pre><code class="html">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><p>这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p><ul><li><p>async 模式：</p><pre><code class="html">&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><p>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会<strong>立即执行</strong>。</p><ul><li><p>defer 模式：</p><pre><code class="html">&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><p>defer 模式下，JS 的加载是异步的，执行是<strong>被推迟的</strong>。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</p><p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p><p>通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。</p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>我们知道，当 JS 登场时，往往意味着对 DOM 的操作。DOM 操作所导致的性能开销的“昂贵”，大家可能早就有所耳闻，雅虎军规里很重要的一条就是“尽量减少 DOM 访问”。</p><p>那么 DOM 到底为什么慢，我们如何去规避这种慢呢？这里我们就引出了下一个章节需要重点解释的两个概念：CSS 中的回流（Reflow）与重绘（Repaint）。</p><h1 id="渲染篇-3：对症下药——DOM-优化原理与基本实践"><a href="#渲染篇-3：对症下药——DOM-优化原理与基本实践" class="headerlink" title="渲染篇 3：对症下药——DOM 优化原理与基本实践"></a>渲染篇 3：对症下药——DOM 优化原理与基本实践</h1><p>从本节开始，我们要关心的两大核心问题就是：“DOM 为什么这么慢”以及“如何使 DOM 变快”。</p><p>后者是一个比“生存还是毁灭”更加经典的问题。不仅我们为它“肝肠寸断”，许多优秀前端框架的作者大大们也曾为其绞尽脑汁。这一点可喜可贺——研究的人越多，产出优秀实践的概率就越大。因此在本章的方法论环节，我们不仅会根据 DOM 特性及渲染原理为大家讲解基本的优化思路，还会涉及到一部分生产实践。</p><p>循着这个思路，我们把 DOM 优化这块划分为三个小专题：“DOM 优化思路”、“异步更新策略”及“回流与重绘”。本节对应第一个小专题。三个小专题休戚与共、你侬我侬，在思路上相互依赖、一脉相承，因此此处<strong>严格禁止任何姿势的跳读行为</strong>。</p><p>考虑到本节内容与上一节有着密不可分的关系，因此<strong>强烈不建议没有读完上一节的同学直接跳读本节</strong>。</p><h2 id="望闻问切：DOM-为什么这么慢"><a href="#望闻问切：DOM-为什么这么慢" class="headerlink" title="望闻问切：DOM 为什么这么慢"></a>望闻问切：DOM 为什么这么慢</h2><h3 id="因为收了“过路费”"><a href="#因为收了“过路费”" class="headerlink" title="因为收了“过路费”"></a>因为收了“过路费”</h3><blockquote><p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p></blockquote><p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。</p><p>上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnttQ4pceu761Qur5BoNg1U89piWD1s7hAXkwnq*3qYpF9mU1UmWoMD5Ihoyee43VkzRfsjgg9mZU0uzRJWSNN.To!/b&amp;bo=agLyAGoC8gADGTw!&amp;rf=viewer_4" alt="img"></p><p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p><h3 id="对-DOM-的修改引发样式的更迭"><a href="#对-DOM-的修改引发样式的更迭" class="headerlink" title="对 DOM 的修改引发样式的更迭"></a>对 DOM 的修改引发样式的更迭</h3><p>过桥很慢，到了桥对岸，我们的更改操作带来的结果也很慢。</p><p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发<strong>回流</strong>或<strong>重绘</strong>。</p><p>这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntupP5hYRnxRrP.HpGdzcIt6nZp96XMwMTznzFVD4G*hWW5gv.MJqR2EZDbs.JkhNKnr0eMLG3nOF6q75UmrEXzk!/b&amp;bo=hAJBAYQCQQEDGTw!&amp;rf=viewer_4" alt="img"></p><ul><li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li></ul><p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p><h2 id="药到病除：给你的-DOM-“提提速”"><a href="#药到病除：给你的-DOM-“提提速”" class="headerlink" title="药到病除：给你的 DOM “提提速”"></a>药到病除：给你的 DOM “提提速”</h2><p>知道了 DOM 慢的原因，我们就可以对症下药了。</p><h3 id="减少-DOM-操作：少交“过路费”、避免过度渲染"><a href="#减少-DOM-操作：少交“过路费”、避免过度渲染" class="headerlink" title="减少 DOM 操作：少交“过路费”、避免过度渲染"></a>减少 DOM 操作：少交“过路费”、避免过度渲染</h3><p>我们来看这样一个🌰，HTML 内容如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;DOM操作测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时我有一个假需求——我想往 container 元素里写 10000 句一样的话。如果我这么做：</p><pre><code class="js">for(var count=0;count&lt;10000;count++){   document.getElementById(&#39;container&#39;).innerHTML+=&#39;&lt;span&gt;我是一个小测试&lt;/span&gt;&#39;} </code></pre><p>这段代码有两个明显的可优化点。</p><p>第一点，<strong>过路费交太多了</strong>。我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，相当于每次循环都交了一次过路费。前后交了 10000 次过路费，但其中 9999 次过路费都可以用<strong>缓存变量</strong>的方式节省下来：</p><pre><code class="js">// 只获取一次containerlet container = document.getElementById(&#39;container&#39;)for(let count=0;count&lt;10000;count++){   container.innerHTML += &#39;&lt;span&gt;我是一个小测试&lt;/span&gt;&#39;} </code></pre><p>第二点，<strong>不必要的 DOM 更改太多了</strong>。我们的 10000 次循环里，修改了 10000 次 DOM 树。我们前面说过，对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程，而这个过程的开销是很“贵”的。这么贵的操作，我们竟然重复执行了 N 多次！其实我们可以通过<strong>就事论事</strong>的方式节省下来不必要的渲染：</p><pre><code class="js">let container = document.getElementById(&#39;container&#39;)let content = &#39;&#39;for(let count=0;count&lt;10000;count++){   // 先对内容进行操作  content += &#39;&lt;span&gt;我是一个小测试&lt;/span&gt;&#39;} // 内容处理好了,最后再触发DOM的更改container.innerHTML = content</code></pre><p>所谓“就事论事”，就像大家所看到的：JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告。</p><p>事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是<strong>让 JS 去给 DOM 分压</strong>。</p><p>这个思路，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DOM Fragment</a> 中体现得淋漓尽致。</p><blockquote><p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p></blockquote><p>在我们上面的例子里，字符串变量 content 就扮演着一个 DOM Fragment 的角色。其实无论字符串变量也好，DOM Fragment 也罢，它们本质上都作为脱离了真实 DOM 树的<strong>容器</strong>出现，用于缓存批量化的 DOM 操作。</p><p>前面我们直接用 innerHTML 去拼接目标内容，这样做固然有用，但却不够优雅。相比之下，DOM Fragment 可以帮助我们用更加结构化的方式去达成同样的目的，从而在维持性能的同时，保住我们代码的可拓展和可维护性。我们现在用 DOM Fragment 来改写上面的例子：</p><pre><code class="js">let container = document.getElementById(&#39;container&#39;)// 创建一个DOM Fragment对象作为容器let content = document.createDocumentFragment()for(let count=0;count&lt;10000;count++){  // span此时可以通过DOM API去创建  let oSpan = document.createElement(&quot;span&quot;)  oSpan.innerHTML = &#39;我是一个小测试&#39;  // 像操作真实DOM一样操作DOM Fragment对象  content.appendChild(oSpan)}// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content)</code></pre><p>我们运行这段代码，可以得到与前面两种写法相同的运行结果。<br>可以看出，DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后<strong>全身而退</strong>，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。</p><p>相比 DOM 命题的博大精深，一个简单的循环 Demo 显然不能说明所有问题。不过不用着急，在本节，我只希望大家能牢记原理与宏观思路。“药到病除”到这里才刚刚开了个头，下个小节，我们将深挖事件循环机制，从而深入 JS 层面的生产实践。</p><h1 id="渲染篇-4：千方百计——Event-Loop-与异步更新策略"><a href="#渲染篇-4：千方百计——Event-Loop-与异步更新策略" class="headerlink" title="渲染篇 4：千方百计——Event Loop 与异步更新策略"></a>渲染篇 4：千方百计——Event Loop 与异步更新策略</h1><p>Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。通过研究框架的运行机制，其设计思路将深化我们对 DOM 优化的理解，其实现手法将拓宽我们对 DOM 实践的认知。</p><p>本节我们将基于 Event Loop 机制，对 Vue 的异步更新策略作探讨。</p><h2 id="前置知识：Event-Loop-中的“渲染时机”"><a href="#前置知识：Event-Loop-中的“渲染时机”" class="headerlink" title="前置知识：Event Loop 中的“渲染时机”"></a>前置知识：Event Loop 中的“渲染时机”</h2><p>搞懂 Event Loop，是理解 Vue 对 DOM 操作优化的第一步。</p><h3 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h3><p>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。</p><p>常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。</p><h3 id="Event-Loop-过程解析"><a href="#Event-Loop-过程解析" class="headerlink" title="Event Loop 过程解析"></a>Event Loop 过程解析</h3><p>基于对 micro 和 macro 的认知，我们来走一遍完整的事件循环过程。</p><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p><ul><li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li><li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，<strong>这个过程本质上是队列的 macro-task 的执行和出队的过程</strong>。</li><li>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntiIWMQk1fbt*IxZQMqmBXSqNkzQOf4SbYNvcXETFDZZ.aHkT8cgLRDheZY7NsvmuLxytJpw5HJGIz4tQBK9Aq24!/b&amp;bo=4AGaAeABmgEDGTw!&amp;rf=viewer_4" alt="img"></p><ul><li><strong>执行渲染操作，更新界面</strong>（敲黑板划重点）。</li><li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</li></ul><p>（上述过程循环往复，直到两个队列都清空）</p><p>我们总结一下，每一次循环都是一个这样的过程：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrMC14Mzv3kEzCqGonJhKOXYc72bXMygQTZm2h7qWtqne8jepwxtwjimDtBgJtlhdQbKfWIXa2WM43mMzLRuvho!/b&amp;bo=WQPzAFkD8wADGTw!&amp;rf=viewer_4" alt="img"></p><h3 id="渲染的时机"><a href="#渲染的时机" class="headerlink" title="渲染的时机"></a>渲染的时机</h3><p>大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成 micro 还是 macro 呢？</p><p>我们先假设它是一个 macro 任务，比如我在 script 脚本中用 setTimeout 来处理它：</p><pre><code class="js">// task是一个用于修改DOM的回调setTimeout(task, 0)</code></pre><p>现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render，对不对？</p><p>但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。</p><p>macro 不 ok，我们转向 micro 试试看。我用 Promise 来把 task 包装成是一个 micro 任务：</p><pre><code class="js">Promise.resolve().then(task)</code></pre><p>那么我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。</p><p>因此，我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。<strong>当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择</strong>。</p><h2 id="生产实践：异步更新策略——以-Vue-为例"><a href="#生产实践：异步更新策略——以-Vue-为例" class="headerlink" title="生产实践：异步更新策略——以 Vue 为例"></a>生产实践：异步更新策略——以 Vue 为例</h2><p>什么是异步更新？</p><p>当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被<strong>批量触发</strong>。这就是异步更新。</p><p>异步更新可以帮助我们避免过度渲染，是我们上节提到的“让 JS 为 DOM 分压”的典范之一。</p><h3 id="异步更新的优越性"><a href="#异步更新的优越性" class="headerlink" title="异步更新的优越性"></a>异步更新的优越性</h3><p>异步更新的特性在于它<strong>只看结果</strong>，因此渲染引擎<strong>不需要为过程买单</strong>。</p><p>最典型的例子，比如有时我们会遇到这样的情况：</p><pre><code class="js">// 任务一this.content = &#39;第一次测试&#39;// 任务二this.content = &#39;第二次测试&#39;// 任务三this.content = &#39;第三次测试&#39;</code></pre><p>我们在三个更新任务中对同一个状态修改了三次，如果我们采取传统的同步更新策略，那么就要操作三次 DOM。但本质上需要呈现给用户的目标内容其实只是第三次的结果，也就是说只有第三次的操作是有意义的——我们白白浪费了两次计算。</p><p>但如果我们把这三个任务塞进异步更新队列里，它们会先在 JS 的层面上被<strong>批量执行完毕</strong>。当流程走到渲染这一步时，它仅仅需要针对有意义的计算结果操作一次 DOM——这就是异步更新的妙处。</p><h3 id="Vue状态更新手法：nextTick"><a href="#Vue状态更新手法：nextTick" class="headerlink" title="Vue状态更新手法：nextTick"></a>Vue状态更新手法：nextTick</h3><p>Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。这件事情，在源码中是由一个叫做 nextTick 的函数来完成的：</p><pre><code class="js">export function nextTick (cb?: Function, ctx?: Object) {  let _resolve  callbacks.push(() =&gt; {    if (cb) {      try {        cb.call(ctx)      } catch (e) {        handleError(e, ctx, &#39;nextTick&#39;)      }    } else if (_resolve) {      _resolve(ctx)    }  })  // 检查上一个异步任务队列（即名为callbacks的任务数组）是否派发和执行完毕了。pending此处相当于一个锁  if (!pending) {    // 若上一个异步任务队列已经执行完毕，则将pending设定为true（把锁锁上）    pending = true    // 是否要求一定要派发为macro任务    if (useMacroTask) {      macroTimerFunc()    } else {      // 如果不说明一定要macro 你们就全都是micro      microTimerFunc()    }  }  // $flow-disable-line  if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {    return new Promise(resolve =&gt; {      _resolve = resolve    })  }}</code></pre><p>我们看到，Vue 的异步任务默认情况下都是用 Promise 来包装的，也就是是说它们都是 micro-task。这一点和我们“前置知识”中的渲染时机的分析不谋而合。</p><p>为了带大家熟悉一下常见的 macro 和 micro 派发方式、加深对 Event Loop 的理解，我们继续细化解析一下 macroTimeFunc() 和 microTimeFunc() 两个方法。</p><p>macroTimeFunc() 是这么实现的：</p><pre><code class="js">// macro首选setImmediate 这个兼容性最差if (typeof setImmediate !== &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) {  macroTimerFunc = () =&gt; {    setImmediate(flushCallbacks)  }} else if (typeof MessageChannel !== &#39;undefined&#39; &amp;&amp; (    isNative(MessageChannel) ||    // PhantomJS    MessageChannel.toString() === &#39;[object MessageChannelConstructor]&#39;  )) {  const channel = new MessageChannel()  const port = channel.port2  channel.port1.onmessage = flushCallbacks  macroTimerFunc = () =&gt; {    port.postMessage(1)  }} else {  // 兼容性最好的派发方式是setTimeout  macroTimerFunc = () =&gt; {    setTimeout(flushCallbacks, 0)  }}</code></pre><p>microTimeFunc() 是这么实现的：</p><pre><code class="js">// 简单粗暴 不是ios全都给我去Promise 如果不兼容promise 那么你只能将就一下变成macro了if (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) {  const p = Promise.resolve()  microTimerFunc = () =&gt; {    p.then(flushCallbacks)    // in problematic UIWebViews, Promise.then doesn&#39;t completely break, but    // it can get stuck in a weird state where callbacks are pushed into the    // microtask queue but the queue isn&#39;t being flushed, until the browser    // needs to do some other work, e.g. handle a timer. Therefore we can    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.    if (isIOS) setTimeout(noop)  }} else {  // 如果无法派发micro，就退而求其次派发为macro  microTimerFunc = macroTimerFunc}</code></pre><p>我们注意到，无论是派发 macro 任务还是派发 micro 任务，派发的任务对象都是一个叫做 flushCallbacks 的东西，这个东西做了什么呢？</p><p>flushCallbacks 源码如下：</p><pre><code class="js">function flushCallbacks () {  pending = false  // callbacks在nextick中出现过 它是任务数组（队列）  const copies = callbacks.slice(0)  callbacks.length = 0  // 将callbacks中的任务逐个取出执行  for (let i = 0; i &lt; copies.length; i++) {    copies[i]()  }}</code></pre><p>现在我们理清楚了：Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。</p><p>本小节我们从性能优化的角度出发，通过解析Vue源码，对异步更新这一高效的 DOM 优化手段有了感性的认知。同时帮助大家进一步熟悉了 micro 与 macro 在生产中的应用，加深了对 Event Loop 的理解。事实上，Vue 源码中还有许多值得称道的生产实践，其设计模式与编码细节都值得我们去细细品味。对这个话题感兴趣的同学，课后不妨移步 <a href="https://juejin.im/book/5a36661851882538e2259c0f" target="_blank" rel="noopener">Vue运行机制解析</a> 进行探索。</p><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的 DOM 优化之路才走完了一半。</p><p>以上我们都在讨论“如何减少 DOM 操作”的话题。这个话题比较宏观——DOM 操作也分很多种，它们带来的变化各不相同。有的操作只触发重绘，这时我们的性能损耗就小一些；有的操作会触发回流，这时我们更“肉疼”一些。那么如何理解回流与重绘，如何借助这些理解去提升页面渲染效率呢？</p><p>结束了 JS 的征程，我们下面就走进 CSS 的世界一窥究竟。</p><h1 id="渲染篇-5：最后一击——回流（Reflow）与重绘（Repaint）"><a href="#渲染篇-5：最后一击——回流（Reflow）与重绘（Repaint）" class="headerlink" title="渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）"></a>渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）</h1><p>开篇我们先对上上节介绍的回流与重绘的基础知识做个复习（跳读的同学请自觉回到上上节补齐 →_→）。</p><p><strong>回流</strong>：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p><p><strong>重绘</strong>：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p><p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p><h2 id="哪些实际操作会导致回流与重绘"><a href="#哪些实际操作会导致回流与重绘" class="headerlink" title="哪些实际操作会导致回流与重绘"></a>哪些实际操作会导致回流与重绘</h2><p>要避免回流与重绘的发生，最直接的做法是避免掉可能会引发回流与重绘的 DOM 操作，就好像拆弹专家在解决一颗炸弹时，最重要的是掐灭它的导火索。</p><p>触发重绘的“导火索”比较好识别——只要是不触发回流，但又触发了样式改变的 DOM 操作，都会引起重绘，比如背景色、文字色、可见性(可见性这里特指形如visibility: hidden这样不改变元素位置和存在性的、单纯针对可见性的操作，注意与display:none进行区分)等。为此，我们要着重理解一下那些可能触发回流的操作。</p><h3 id="回流的“导火索”"><a href="#回流的“导火索”" class="headerlink" title="回流的“导火索”"></a>回流的“导火索”</h3><ul><li>最“贵”的操作：改变 DOM 元素的几何属性</li></ul><p>这个改变几乎可以说是“牵一发动全身”——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p><p>常见的几何属性有 width、height、padding、margin、left、top、border 等等。此处不再给大家一一列举。有的文章喜欢罗列属性表格，但我相信我今天列出来大家也不会看、看了也记不住（因为太多了）。我自己也不会去记这些——其实确实没必要记，️一个属性是不是几何属性、会不会导致空间布局发生变化，大家写样式的时候完全可以通过代码效果看出来。多说无益，还希望大家可以多写多试，形成自己的“肌肉记忆”。</p><ul><li>“价格适中”的操作：改变 DOM 树的结构</li></ul><p>这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。</p><ul><li>最容易被忽略的操作：获取一些特定属性的值</li></ul><p>当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！</p><p>“像这样”的属性，到底是像什么样？——这些值有一个共性，就是需要通过<strong>即时计算</strong>得到。因此浏览器为了获取这些值，也会进行回流。</p><p>除此之外，当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。</p><h2 id="如何规避回流与重绘"><a href="#如何规避回流与重绘" class="headerlink" title="如何规避回流与重绘"></a>如何规避回流与重绘</h2><p>了解了回流与重绘的“导火索”，我们就要尽量规避它们。但很多时候，我们不得不使用它们。当避无可避时，我们就要学会更聪明地使用它们。</p><h3 id="将“导火索”缓存起来，避免频繁改动"><a href="#将“导火索”缓存起来，避免频繁改动" class="headerlink" title="将“导火索”缓存起来，避免频繁改动"></a>将“导火索”缓存起来，避免频繁改动</h3><p>有时我们想要通过多次计算得到一个元素的布局位置，我们可能会这样做：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    #el {      width: 100px;      height: 100px;      background-color: yellow;      position: absolute;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;el&quot;&gt;&lt;/div&gt;  &lt;script&gt;  // 获取el元素  const el = document.getElementById(&#39;el&#39;)  // 这里循环判定比较简单，实际中或许会拓展出比较复杂的判定需求  for(let i=0;i&lt;10;i++) {      el.style.top  = el.offsetTop  + 10 + &quot;px&quot;;      el.style.left = el.offsetLeft + 10 + &quot;px&quot;;  }  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样做，每次循环都需要获取多次“敏感属性”，是比较糟糕的。我们可以将其以 JS 变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求：</p><pre><code class="js">// 缓存offsetLeft与offsetTop的值const el = document.getElementById(&#39;el&#39;) let offLeft = el.offsetLeft, offTop = el.offsetTop// 在JS层面进行计算for(let i=0;i&lt;10;i++) {  offLeft += 10  offTop  += 10}// 一次性将计算结果应用到DOM上el.style.left = offLeft + &quot;px&quot;el.style.top = offTop  + &quot;px&quot;</code></pre><h3 id="避免逐条改变样式，使用类名去合并样式"><a href="#避免逐条改变样式，使用类名去合并样式" class="headerlink" title="避免逐条改变样式，使用类名去合并样式"></a>避免逐条改变样式，使用类名去合并样式</h3><p>比如我们可以把这段单纯的代码：</p><pre><code class="js">const container = document.getElementById(&#39;container&#39;)container.style.width = &#39;100px&#39;container.style.height = &#39;200px&#39;container.style.border = &#39;10px solid red&#39;container.style.color = &#39;red&#39;</code></pre><p>优化成一个有 class 加持的样子：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    .basic_style {      width: 100px;      height: 200px;      border: 10px solid red;      color: red;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;script&gt;  const container = document.getElementById(&#39;container&#39;)  container.classList.add(&#39;basic_style&#39;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。</p><p>合并之后，等于我们将所有的更改一次性发出，用一个 style 请求解决掉了。</p><h3 id="将-DOM-“离线”"><a href="#将-DOM-“离线”" class="headerlink" title="将 DOM “离线”"></a>将 DOM “离线”</h3><p>我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。</p><p>仍以我们上文的代码片段为例：</p><pre><code class="js">const container = document.getElementById(&#39;container&#39;)container.style.width = &#39;100px&#39;container.style.height = &#39;200px&#39;container.style.border = &#39;10px solid red&#39;container.style.color = &#39;red&#39;...（省略了许多类似的后续操作）</code></pre><p>离线化后就是这样：</p><pre><code class="js">let container = document.getElementById(&#39;container&#39;)container.style.display = &#39;none&#39;container.style.width = &#39;100px&#39;container.style.height = &#39;200px&#39;container.style.border = &#39;10px solid red&#39;container.style.color = &#39;red&#39;...（省略了许多类似的后续操作）container.style.display = &#39;block&#39;</code></pre><p>有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。</p><h2 id="Flush-队列：浏览器并没有那么简单"><a href="#Flush-队列：浏览器并没有那么简单" class="headerlink" title="Flush 队列：浏览器并没有那么简单"></a>Flush 队列：浏览器并没有那么简单</h2><p>以我们现在的知识基础，理解上面的优化操作并不难。那么现在我问大家一个问题：</p><pre><code class="js">let container = document.getElementById(&#39;container&#39;)container.style.width = &#39;100px&#39;container.style.height = &#39;200px&#39;container.style.border = &#39;10px solid red&#39;container.style.color = &#39;red&#39;</code></pre><p>这段代码里，浏览器进行了多少次的回流或重绘呢？</p><p>“width、height、border是几何属性，各触发一次回流；color只造成外观的变化，会触发一次重绘。”——如果你立刻这么想了，说明你是个能力不错的同学，认真阅读了前面的内容。那么我们现在立刻跑一跑这段代码，看看浏览器怎么说：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntvrsb.ikwaA20kFV7Tbe*xPCA3BcF7IobXADxYraWrTBpBee9zLaTYK8jOQ8sRE80RRF91LgrrkHMo9XZSaVHkE!/b&amp;bo=BAVgAAQFYAADGTw!&amp;rf=viewer_4" alt="img"></p><p>这里为大家截取有“Layout”和“Paint”出镜的片段（这个图是通过 Chrome 的 Performance 面板得到的，后面会教大家用这个东西）。我们看到浏览器只进行了一次回流和一次重绘——和我们想的不一样啊，为啥呢？</p><p>因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。因此我们看到，上面就算我们进行了 4 次 DOM 更改，也只触发了一次 Layout 和一次 Paint。</p><p>大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。</p><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>整个一节读下来，可能会有同学感到疑惑：既然浏览器已经为我们做了批处理优化，为什么我们还要自己操心这么多事情呢？今天避免这个明天避免那个，多麻烦！</p><p>问题在于，<strong>并不是所有的浏览器都是聪明的</strong>。我们刚刚的性能图表，是 Chrome 的开发者工具呈现给我们的。Chrome 里行得通的东西，到了别处（比如 IE）就不一定行得通了。而我们并不知道用户会使用什么样的浏览器。如果不手动做优化，那么一个页面在不同的环境下就会呈现不同的性能效果，这对我们、对用户都是不利的。因此，养成良好的编码习惯、从根源上解决问题，仍然是最周全的方法。</p><h1 id="应用篇-1：优化首屏体验——Lazy-Load-初探"><a href="#应用篇-1：优化首屏体验——Lazy-Load-初探" class="headerlink" title="应用篇 1：优化首屏体验——Lazy-Load 初探"></a>应用篇 1：优化首屏体验——Lazy-Load 初探</h1><p>首先要告诉大家的是，截止到上个章节，我们需要大家绞尽脑汁去理解的“硬核”操作基本告一段落了。从本节开始，我们会一起去实现一些必知必会、同时难度不大的常用优化手段。</p><p>这部分内容不难，但<strong>很关键</strong>。尤其是近期有校招或跳槽需求的同学，还请务必对这部分内容多加留心，说不定下一次的面试题里就有它们的身影。</p><h2 id="Lazy-Load-初相见"><a href="#Lazy-Load-初相见" class="headerlink" title="Lazy-Load 初相见"></a>Lazy-Load 初相见</h2><p>Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片真的太多了，一口气处理这么多任务，浏览器做不到啊！</p><p>但我们再想，用户真的需要这么多图片吗？不对，用户点开页面的瞬间，呈现给他的只有屏幕的一部分（我们称之为首屏）。只要我们可以在页面打开的时候把首屏的图片资源加载出来，用户就会认为页面是没问题的。至于下面的图片，我们完全可以等用户下拉的瞬间再即时去请求、即时呈现给他。这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是 Lazy-Load。</p><p>现在我们打开掘金首页：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnttzLj1hJA25anlR9yinpL*YI5R6mkBjIrVUeRW5USSj6SqsE0WSg7T4ZITY8u*pPcVKttcFkOxBT4DbGK4kTPts!/b&amp;bo=kAVEBJAFRAQDKQw!&amp;rf=viewer_4" alt="img"></p><p>大家留意一栏文章右侧可能会出现的图片，这里咱们给个特写：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntil8GdrLrVLr3djuA6jIa6jxOSj*Ew9yKO0salCZrhFv34xggc7vAxrakGGGSmdaqB4QpEcfF6PWeEVjIJgQTuA!/b&amp;bo=ygCWAsoAlgIDGTw!&amp;rf=viewer_4" alt="img"></p><p>大家现在以尽可能快的速度，疯狂向下拉动页面。发现什么？是不是发现我们图示的这个图片的位置，会出现闪动——有时候我们明明已经拉到目标位置了，文字也呈现完毕了，图片却慢半拍才显示出来。这是因为，掘金首页也采用了懒加载策略。当我们的页面并未滚动至包含图片的 div 元素所在的位置时，它的样式是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knth7hDY1mLePL2M.xXztjAd3Sk2SiZRh9uK2eQNxIub6UzRpXJu4NjD*6SOR07mzUMhdCj5rLrsikdsyiW5ciba0!/b&amp;bo=IAWOACAFjgADGTw!&amp;rf=viewer_4" alt="img"></p><p>我们把代码提出来看一下：</p><pre><code class="html">&lt;div data-v-b2db8566=&quot;&quot;     data-v-009ea7bb=&quot;&quot;     data-v-6b46a625=&quot;&quot;       data-src=&quot;https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1&quot;        class=&quot;lazy thumb thumb&quot;        style=&quot;background-image: none; background-size: cover;&quot;&gt;  &lt;/div&gt;</code></pre><p>我们注意到 style 内联样式中，背景图片设置为了 none。也就是说这个 div 是没有内容的，它只起到一个<strong>占位</strong>的作用。</p><p>这个“占位”的概念，在这个例子里或许体现得不够直观。最直观的应该是淘宝首页的 HTML Preview 效果：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knto8IP2LIfw85QpPvH.OkzJjVlHTTdrER03qI8fYU7CIDPGYhpAMKygXid3jE975boc7.0NV3fA6AdibDcYsVDmM!/b&amp;bo=5AWAAvIIzAMDGWo!&amp;rf=viewer_4" alt="img"></p><p>我们看到，这个还没来得及被图片填充完全的网页，是用大大小小的空 div 元素来占位的。掘金首页也是如此。</p><p>一旦我们通过滚动使得这个 div 出现在了可见范围内，那么 div 元素的内容就会发生变化，呈现如下的内容：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntsHLxFVFquBMdhY3o9unPmFDHP1pMh.06Qi7bfK*ednomp0VTBkp0TZbJQV5qxHIvPHqwfuTlcKm5YmfeS*dN*U!/b&amp;bo=rgT8AK4E*AADGTw!&amp;rf=viewer_4" alt="img"></p><p>我们给 style 一个特写：</p><pre><code class="css">style=&quot;background-image: url(&amp;quot;https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1&amp;quot;); background-size: cover;&quot;</code></pre><p>可以看出，style 内联样式中的背景图片属性从 none 变成了一个在线图片的 URL。也就是说，出现在可视区域的瞬间，div 元素的内容被即时地修改掉了——它被写入了有效的图片 URL，于是图片才得以呈现。这就是懒加载的实现思路。</p><h2 id="一起写一个-Lazy-Load-吧！"><a href="#一起写一个-Lazy-Load-吧！" class="headerlink" title="一起写一个 Lazy-Load 吧！"></a>一起写一个 Lazy-Load 吧！</h2><p>基于上面的实现思路，我们完全可以手动实现一个属于自己的 Lazy-Load。</p><p>（<strong>此处敲黑板划重点，Lazy-Load 的思路及实现方式为大厂面试常考题，还望诸位同学引起重视</strong>）</p><p>首先新建一个空项目，目录结构如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntkyPCa4HrwA2D1mywYdv60Ln.fVtuQ.qaB3HAIETfrwQqicYUz*WOaF.6HO.rjT.TdJCYR5bJuALP729BmKxzPg!/b&amp;bo=0gF0ANIBdAADGTw!&amp;rf=viewer_4" alt="img"></p><p>大家可以往 images 文件夹里塞入各种各样自己喜欢的图片。</p><p>我们在 index.html 中，为这些图片预置 img 标签：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Lazy-Load&lt;/title&gt;  &lt;style&gt;    .img {      width: 200px;      height:200px;      background-color: gray;    }    .pic {      // 必要的img样式    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;img&quot;&gt;      // 注意我们并没有为它引入真实的src      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/1.png&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/2.png&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/3.png&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/4.png&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/5.png&quot;&gt;    &lt;/div&gt;     &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/6.png&quot;&gt;    &lt;/div&gt;     &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/7.png&quot;&gt;    &lt;/div&gt;     &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/8.png&quot;&gt;    &lt;/div&gt;     &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/9.png&quot;&gt;    &lt;/div&gt;     &lt;div class=&quot;img&quot;&gt;      &lt;img class=&quot;pic&quot; alt=&quot;加载中&quot; data-src=&quot;./images/10.png&quot;&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在懒加载的实现中，有两个关键的数值：一个是<strong>当前可视区域的高度</strong>，另一个是<strong>元素距离可视区域顶部的高度</strong>。</p><p><strong>当前可视区域的高度</strong>， 在和现代浏览器及 IE9 以上的浏览器中，可以用 window.innerHeight 属性获取。在低版本 IE 的标准模式中，可以用 document.documentElement.clientHeight 获取，这里我们兼容两种情况：</p><pre><code class="js">const viewHeight = window.innerHeight || document.documentElement.clientHeight </code></pre><p>而<strong>元素距离可视区域顶部的高度</strong>，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。对此 MDN 给出了非常清晰的解释：</p><blockquote><p>该方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的 CSS 边框集合 。</p></blockquote><blockquote><p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p></blockquote><p>其中需要引起我们注意的就是 left、top、right 和 bottom，它们对应到元素上是这样的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntv*ej*pYHZRNf.x.eO6tZ9oTCvERwNlJLMSTuxUWSx*FQfNjLTB6TgSx89EqzYQxfQKDThlXO73ayTWSrKejzio!/b&amp;bo=9AH0AfQB9AEDGTw!&amp;rf=viewer_4" alt="img"></p><p>可以看出，top 属性代表了元素距离可视区域顶部的高度，正好可以为我们所用！</p><p>Lazy-Load 方法开工啦！</p><pre><code class="js">&lt;script&gt;    // 获取所有的图片标签    const imgs = document.getElementsByTagName(&#39;img&#39;)    // 获取可视区域的高度    const viewHeight = window.innerHeight || document.documentElement.clientHeight    // num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出    let num = 0    function lazyload(){        for(let i=num; i&lt;imgs.length; i++) {            // 用可视区域高度减去元素顶部距离可视区域顶部的高度            let distance = viewHeight - imgs[i].getBoundingClientRect().top            // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出            if(distance &gt;= 0 ){                // 给元素写入真实的src，展示图片                imgs[i].src = imgs[i].getAttribute(&#39;data-src&#39;)                // 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出                num = i + 1            }        }    }    // 监听Scroll事件    window.addEventListener(&#39;scroll&#39;, lazyload, false);&lt;/script&gt;</code></pre><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>本节我们实现出了一个最基本的懒加载功能。但是大家要注意一点：这个 scroll 事件，是一个<strong>危险</strong>的事件——它太容易被触发了。试想，用户在访问网页的时候，是不是可以无限次地去触发滚动？尤其是一个页面死活加载不出来的时候，疯狂调戏鼠标滚轮（或者浏览器滚动条）的用户可不在少数啊！</p><p>再回头看看我们上面写的代码。按照我们的逻辑，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。这里就引出了我们下一节的两位主角——throttle 与 debounce。</p><h1 id="应用篇-2：事件的节流（throttle）与防抖（debounce）"><a href="#应用篇-2：事件的节流（throttle）与防抖（debounce）" class="headerlink" title="应用篇 2：事件的节流（throttle）与防抖（debounce）"></a>应用篇 2：事件的节流（throttle）与防抖（debounce）</h1><p>上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。</p><p>频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。</p><h2 id="“节流”与“防抖”的本质"><a href="#“节流”与“防抖”的本质" class="headerlink" title="“节流”与“防抖”的本质"></a>“节流”与“防抖”的本质</h2><p>这两个东西都以<strong>闭包</strong>的形式存在。</p><p>它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p><h2 id="Throttle：-第一个人说了算"><a href="#Throttle：-第一个人说了算" class="headerlink" title="Throttle： 第一个人说了算"></a>Throttle： 第一个人说了算</h2><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p><p>先给大家讲个小故事：现在有一个旅客刚下了飞机，需要用车，于是打电话叫了该机场唯一的一辆机场大巴来接。司机开到机场，心想来都来了，多接几个人一起走吧，这样这趟才跑得值——我等个十分钟看看。于是司机一边打开了计时器，一边招呼后面的客人陆陆续续上车。在这十分钟内，后面下飞机的乘客都只能乘这一辆大巴，十分钟过去后，不管后面还有多少没挤上车的乘客，这班车都必须发走。</p><p>在这个故事里，“司机” 就是我们的节流阀，他控制发车的时机；“乘客”就是因为我们频繁操作事件而不断涌入的回调任务，它需要接受“司机”的安排；而“计时器”，就是我们上文提到的以自由变量形式存在的时间信息，它是“司机”决定发车的依据；最后“发车”这个动作，就对应到回调函数的执行。</p><p>总结下来，所谓的“节流”，是通过在一段时间内<strong>无视后来产生的回调请求</strong>来实现的。只要一位客人叫了车，司机就会为他开启计时器，一定的时间内，后面需要乘车的客人都得排队上这一辆车，谁也无法叫到更多的车。</p><p>对应到实际的交互上是一样一样的：每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“一辆车的乘客”——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。</p><p>理解了大致的思路，我们现在一起实现一个 throttle：</p><pre><code class="js">// fn是我们需要包装的事件回调, interval是时间间隔的阈值function throttle(fn, interval) {  // last为上一次触发回调的时间  let last = 0  // 将throttle处理结果当作函数返回  return function () {      // 保留调用时的this上下文      let context = this      // 保留调用时传入的参数      let args = arguments      // 记录本次触发回调的时间      let now = +new Date()      // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值      if (now - last &gt;= interval) {      // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调          last = now;          fn.apply(context, args);      }    }}// 用throttle来包装scroll的回调const better_scroll = throttle(() =&gt; console.log(&#39;触发了滚动事件&#39;), 1000)document.addEventListener(&#39;scroll&#39;, better_scroll)</code></pre><h2 id="Debounce：-最后一个人说了算"><a href="#Debounce：-最后一个人说了算" class="headerlink" title="Debounce： 最后一个人说了算"></a>Debounce： 最后一个人说了算</h2><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p><p>继续讲司机开车的故事。这次的司机比较有耐心。第一个乘客上车后，司机开始计时（比如说十分钟）。十分钟之内，如果又上来了一个乘客，司机会把计时器清零，重新开始等另一个十分钟（延迟了等待）。直到有这么一位乘客，从他上车开始，后续十分钟都没有新乘客上车，司机会认为确实没有人需要搭这趟车了，才会把车开走。</p><p>我们对比 throttle 来理解 debounce：在throttle的逻辑里，“第一个人说了算”，它只为第一个乘客计时，时间到了就执行回调。而 debounce 认为，“最后一个人说了算”，debounce 会为每一个新乘客设定新的定时器。</p><p>我们基于上面的理解，一起来写一个 debounce：</p><pre><code class="js">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间function debounce(fn, delay) {  // 定时器  let timer = null  // 将debounce处理结果当作函数返回  return function () {    // 保留调用时的this上下文    let context = this    // 保留调用时传入的参数    let args = arguments    // 每次事件被触发时，都去清除之前的旧定时器    if(timer) {        clearTimeout(timer)    }    // 设立新定时器    timer = setTimeout(function () {      fn.apply(context, args)    }, delay)  }}// 用debounce来包装scroll的回调const better_scroll = debounce(() =&gt; console.log(&#39;触发了滚动事件&#39;), 1000)document.addEventListener(&#39;scroll&#39;, better_scroll)</code></pre><h2 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h2><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。</p><p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要delay的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：</p><pre><code class="js">// fn是我们需要包装的事件回调, delay是时间间隔的阈值function throttle(fn, delay) {  // last为上一次触发回调的时间, timer是定时器  let last = 0, timer = null  // 将throttle处理结果当作函数返回  return function () {     // 保留调用时的this上下文    let context = this    // 保留调用时传入的参数    let args = arguments    // 记录本次触发回调的时间    let now = +new Date()    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值    if (now - last &lt; delay) {    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器       clearTimeout(timer)       timer = setTimeout(function () {          last = now          fn.apply(context, args)        }, delay)    } else {        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应        last = now        fn.apply(context, args)    }  }}// 用新的throttle包装scroll的回调const better_scroll = throttle(() =&gt; console.log(&#39;触发了滚动事件&#39;), 1000)document.addEventListener(&#39;scroll&#39;, better_scroll)</code></pre><h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p>throttle 和 debounce 不仅是我们日常开发中的常用优质代码片段，更是前端面试中不可不知的高频考点。“看懂了代码”、“理解了过程”在本节都是不够的，重要的是把它写到自己的项目里去，亲自体验一把节流和防抖带来的性能提升。</p><h1 id="性能监测篇：Performance、LightHouse-与性能-API"><a href="#性能监测篇：Performance、LightHouse-与性能-API" class="headerlink" title="性能监测篇：Performance、LightHouse 与性能 API"></a>性能监测篇：Performance、LightHouse 与性能 API</h1><p>性能监测是前端性能优化的重要一环。监测的目的是为了确定性能瓶颈，从而有的放矢地开展具体的优化工作。</p><p>平时我们比较推崇的性能监测方案主要有两种：<strong>可视化方案、可编程方案</strong>。这两种方案下都有非常优秀、且触手可及的相关工具供大家选择，本节我们就一起来研究一下这些工具的用法。</p><h2 id="可视化监测：从-Performance-面板说起"><a href="#可视化监测：从-Performance-面板说起" class="headerlink" title="可视化监测：从 Performance 面板说起"></a>可视化监测：从 Performance 面板说起</h2><p>Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。</p><h3 id="开始记录"><a href="#开始记录" class="headerlink" title="开始记录"></a>开始记录</h3><p>右键打开开发者工具，选中我们的 Performance 面板：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntiTxceil0.GvmhubXDgYHlFpy77IjcoARlI6lo38yjwqaXqE2s8TCW*biu2Mi2lbWPiskEFGcxUsTfIJxcBJhN4!/b&amp;bo=TgdUBE4HVAQDGTw!&amp;rf=viewer_4" alt="img"></p><p>当我们选中图中所标示的实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；当我们选中圆箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。<br>tips：使用 Performance 工具时，为了规避其它 Chrome 插件对页面的性能影响，我们最好在无痕模式下打开页面：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnHJFzHd*7xW5aZ*A4DOsE.YDPLXHAb.Haf4v51np.RhHcly*K*dcOtmsYiOYH1pNZiYZQ*8TNuOKahj8ypexlM!/b&amp;bo=3ALCANwCwgADGTw!&amp;rf=viewer_4" alt="img"></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntre1fQMZyUZ*9QjL*1ElsgG3zT7BfSePPOKIf.MNU.hWJpiuwoC1F6vbBS5UVtgvSU62gcU8aNuEVuGf*72r3S4!/b&amp;bo=6gRQA.oEUAMDGTw!&amp;rf=viewer_4" alt="img"></p><h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><p>这里我打开掘金首页，选中 Performance 面板中的圆箭头，来看一下页面加载过程中的性能表现：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntrzz63LttBTwwFM0Wu6UoPpXrFFyVBYQ7doneKnQOCTDpw2uUEBr3dInv9MJz0KukNrllHJs*.5y.CpWlqx0*bQ!/b&amp;bo=UgfEBFIHxAQDKQw!&amp;rf=viewer_4" alt="img"></p><p>从上到下，依次为概述面板、详情面板。下我们先来观察一下概述面板，了解页面的基本表现：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntoyTDYYBoFp4614ZZJyigYsktkTaaYoW5sf1Yvi2p*6xSU1sDA82xqQf6rA3refCUcp8FXh1AKyV*AaJHoIlrk8!/b&amp;bo=UgfSAFIH0gADGTw!&amp;rf=viewer_4" alt="img"></p><p>我们看右上角的三个栏目：FPS、CPU 和 NET。</p><p><strong>FPS</strong>：这是一个和动画性能密切相关的指标，它表示每一秒的帧数。图中绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。图中以绿色为主，偶尔出现红块，说明网页性能并不糟糕，但仍有可优化的空间。</p><p><strong>CPU</strong>：表示CPU的使用情况，不同的颜色片段代表着消耗CPU资源的不同事件类型。这部分的图像和下文详情面板中的Summary内容有对应关系，我们可以结合这两者挖掘性能瓶颈。</p><p><strong>NET</strong>：粗略的展示了各请求的耗时与前后顺序。这个指标一般来说帮助不大。</p><h3 id="挖掘性能瓶颈"><a href="#挖掘性能瓶颈" class="headerlink" title="挖掘性能瓶颈"></a>挖掘性能瓶颈</h3><p>详情面板中的内容有很多。但一般来说，我们会主要去看 Main 栏目下的火焰图和 Summary 提供给我们的饼图——这两者和概述面板中的 CPU 一栏结合，可以帮我们迅速定位性能瓶颈（如下图）。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntiKsuHxlzoIZA2rT6E8GsmhyuMxAYbqIVXYKAhi.1.3P8jfdi*5Gg1Ev5oyNwE9M.qLDXjPw*KCvSOmTcE.aWL0!/b&amp;bo=GAWAAlIHmAMDKV0!&amp;rf=viewer_4" alt="img"></p><p>先看 CPU 图表和 Summary 饼图。CPU 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。这样我们在优化的时候，就可以抓到“主要矛盾”，进而有的放矢地开展后续的工作了。</p><p>再看 Main 提供给我们的火焰图。这个火焰图非常关键，它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等）。x 轴表示随时间的记录。每个长条就代表一个活动。更宽的条形意味着事件需要更长时间。y 轴表示调用堆栈，我们可以看到事件是相互堆叠的，上层的事件触发了下层的事件。</p><p>CPU 图标和 Summary 图都是按照“类型”给我们提供性能信息，而 Main 火焰图则将粒度细化到了每一个函数的调用。到底是从哪个过程开始出问题、是哪个函数拖了后腿、又是哪个事件触发了这个函数，这些具体的、细致的问题都将在 Main 火焰图中得到解答。</p><h2 id="可视化监测：-更加聪明的-LightHouse"><a href="#可视化监测：-更加聪明的-LightHouse" class="headerlink" title="可视化监测： 更加聪明的 LightHouse"></a>可视化监测： 更加聪明的 LightHouse</h2><p>Performance 无疑可以为我们提供很多有价值的信息，但它的展示作用大于分析作用。它要求使用者对工具本身及其所展示的信息有充分的理解，能够将晦涩的数据“翻译”成具体的性能问题。</p><p>程序员们许了个愿：如果工具能帮助我们把页面的问题也分析出来就好了！上帝听到了这个愿望，于是给了我们 LightHouse：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntmKMPK4aXY1gmmAPZIRHy6Ap4DvzNUEuxLB3FiLr2cAPXAd8yJSw0YynmNeDTfJFj4c*9I9dv1246hpFeifRKHY!/b&amp;bo=JgPaASYD2gEDGTw!&amp;rf=viewer_4" alt="img"></p><blockquote><p>Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。</p></blockquote><p>敲黑板划重点：它生成的是一个报告！Report！不是干巴巴地数据，而是一个通过测试与分析呈现出来的结果（它甚至会给你的页面跑一个分数出来）。这个东西看起来也真是太赞了，我们这就来体验一下！</p><p>首先在 Chrome 的应用商店里下载一个 LightHouse。这一步 OK 之后，我们浏览器右上角会出现一个小小的灯塔 ICON。打开我们需要测试的那个页面，点击这个 ICON，唤起如下的面板：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnrEPNKh40aGeiRZqV74nhi3Q5t6gOOqdGqkFivAysVtJj9MCXFyz2ZXi.iEdCLI7yCEy1F83vzL4aNNSa49JFI!/b&amp;bo=kAN6ApADegIDGTw!&amp;rf=viewer_4" alt="img"></p><p>然后点击“Generate report”按钮，只需静候数秒，LightHouse 就会为我们输出一个完美的性能报告。</p><p>这里我拿掘金小册首页“开刀”：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntjKCqvjZHdXMgGTcRzs.FGE4fzuvKcnmegHF*UEqogXzamdazCJDlomy.3eNwyWNvYACJiyqnYv*IiC2JEq4TvI!/b&amp;bo=cgpiBXIKYgUDORw!&amp;rf=viewer_4" alt="img"></p><p>稍事片刻，Report 便输出成功了，LightHouse 默认会帮我们打开一个新的标签页来展示报告内容。报告内容非常丰富，首先我们看到的是整体的跑分情况：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntltZDQdFm*WpfFqDpYuVM*kkY4nI.6rkEmd55N2f4EvvPJuPw421lgLRQvC5iE2vQEDaxVeWnPTOmUG7uSKG3ec!/b&amp;bo=0gaAAowHxAIDKRc!&amp;rf=viewer_4" alt="img"></p><p>上述分别是页面性能、PWA（渐进式 Web 应用）、可访问性（无障碍）、最佳实践、SEO 五项指标的跑分。孰强孰弱，我们一看便知。</p><p>向下拉动 Report 页，我们还可以看到每一个指标的细化评估：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntmvEzVvUPguAYqorYmRgO9k*On6XWYCtpJXOghduNbePergHfdkho7O7SuYoipd.I3T6p528BT8q776Ru7A4tLw!/b&amp;bo=hAYKBIQGCgQDKQw!&amp;rf=viewer_4" alt="img"></p><p>在“Opportunities”中，LightHouse 甚至针对我们的性能问题给出了可行的建议、以及每一项优化操作预期会帮我们节省的时间。这份报告的可操作性是很强的——我们只需要对着 LightHouse 给出的建议，一条一条地去尝试，就可以看到自己的页面，在一秒一秒地变快。</p><p>除了直接下载，我们还可以通过命令行使用 LightHouse：</p><pre><code>npm install -g lighthouselighthouse https://juejin.im/books</code></pre><p>同样可以得到掘金小册的性能报告。</p><p>此外，从 Chrome 60 开始，DevTools 中直接加入了基于 LightHouse 的 Audits 面板：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntheMbSG*BUEeZh*Q4lMKi3TRyENHlWTiqFtU6q4LirjB8jdSY36nLcFu6eCAPENy4E2Qu48Tu7vKrrZlV7YJHSU!/b&amp;bo=*AagBPwGoAQDKQw!&amp;rf=viewer_4" alt="img"></p><p>LightHouse 因此变得更加触手可及了，这一操作也足以证明 Chrome 团队对 LightHouse 的推崇。</p><h2 id="可编程的性能上报方案：-W3C-性能-API"><a href="#可编程的性能上报方案：-W3C-性能-API" class="headerlink" title="可编程的性能上报方案： W3C 性能 API"></a>可编程的性能上报方案： W3C 性能 API</h2><p>W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。</p><p>当下的前端世界里，数据可视化的概念已经被炒得非常热了，Performance 面板就是数据可视化的典范。那么为什么要把已经可视化的数据再掏出来处理一遍呢？这是因为，需要这些数据的人不止我们前端——很多情况下，后端也需要我们提供性能信息的上报。此外，Performance 提供的可视化结果并不一定能够满足我们实际的业务需求，只有拿到了真实的数据，我们才可以对它进行二次处理，去做一个更加深层次的可视化。</p><p>在这种需求背景下，我们就不得不祭出 Performance API了。</p><h3 id="访问-performance-对象"><a href="#访问-performance-对象" class="headerlink" title="访问 performance 对象"></a>访问 performance 对象</h3><p>performance 是一个全局对象。我们在控制台里输入 window.performance，就可一窥其全貌：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntpU.fcLxGvgQQbcpstJwLh7.YAE3wLeJsujVEtjqaYGNHSzBIpFsNAIVA244YzadjDhT5BGQ7ZIIY*ORbb8OCw0!/b&amp;bo=TAdQAUwHUAEDKQw!&amp;rf=viewer_4" alt="img"></p><h3 id="关键时间节点"><a href="#关键时间节点" class="headerlink" title="关键时间节点"></a>关键时间节点</h3><p>在 performance 的 timing 属性中，我们可以查看到如下的时间戳：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntlCjU*V7u.1A6eTQeV86VbMfYW8NhXLSwBxOoR2QRC*fW5ORIU5H42rXq7fn74zWw9iaWR6qlskLznl.AVbd4yI!/b&amp;bo=VgPIAlYDyAIDKQw!&amp;rf=viewer_4" alt="img"></p><p>这些时间戳与页面整个加载流程中的关键时间节点有着一一对应的关系：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntlqTOQZK44bKEXMO5efivGlsRqJ2OOptJKA7qfTo2SMaihhQrlJwHK*vIv0nCGKSzccZ1aUPPhiEgu9G4IVeUn8!/b&amp;bo=wQVvA8EFbwMDGTw!&amp;rf=viewer_4" alt="img"></p><p>通过求两个时间点之间的差值，我们可以得出某个过程花费的时间，举个🌰：</p><pre><code class="js">const timing = window.performance.timing// DNS查询耗时timing.domainLookupEnd - timing.domainLookupStart// TCP连接耗时timing.connectEnd - timing.connectStart// 内容加载耗时timing.responseEnd - timing.requestStart···</code></pre><p>除了这些常见的耗时情况，我们更应该去关注一些<strong>关键性能指标</strong>：firstbyte、fpt、tti、ready 和 load 时间。这些指标数据与真实的用户体验息息相关，是我们日常业务性能监测中不可或缺的一部分：</p><pre><code class="js">// firstbyte：首包时间    timing.responseStart – timing.domainLookupStart    // fpt：First Paint Time, 首次渲染时间 / 白屏时间timing.responseEnd – timing.fetchStart// tti：Time to Interact，首次可交互时间    timing.domInteractive – timing.fetchStart// ready：HTML 加载完成时间，即 DOM 就位的时间timing.domContentLoaded – timing.fetchStart// load：页面完全加载时间timing.loadEventStart – timing.fetchStart</code></pre><p>以上这些通过 Performance API 获取到的时间信息都具有较高的准确度。我们可以对此进行一番格式处理之后上报给服务端，也可以基于此去制作相应的统计图表，从而实现更加精准、更加个性化的性能耗时统计。</p><p>此外，通过访问 performance 的 memory 属性，我们还可以获取到内存占用相关的数据；通过对 performance 的其它属性方法的灵活运用，我们还可以把它耦合进业务里，实现更加多样化的性能监测需求——灵活，是可编程化方案最大的优点。</p><h2 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h2><p>本节我们介绍了 Performance 开发者工具、LightHouse 与 Performance API 三种性能监测的方案。只要有 Chrome 浏览器，我们就可以实现上述的所有操作。</p><p>由此可以看出，性能监测本身并不难。它的复杂度是在与业务发生耦合的过程中提升的。我们今天打下了坚实的地基，后续需要大家在业务中去成长、去发掘这些工具的更多的潜力，这样才能建立起属于我们自己的技术金字塔。</p><p>推荐阅读：</p><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank" rel="noopener">Performance 官方文档</a></li><li><a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="noopener">使用 Lighthouse 审查网络应用</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">MDN Performance API 介绍</a></li></ul><h1 id="前方的路：希望成为你的起点"><a href="#前方的路：希望成为你的起点" class="headerlink" title="前方的路：希望成为你的起点"></a>前方的路：希望成为你的起点</h1><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>首先要谢谢每一位读到最后一章的同学。这是我的第一本小册，也是我第一次撰写对外开放的知识内容，谢谢大家选择了这本小册，选择了我这个作者。</p><h2 id="未完成的故事"><a href="#未完成的故事" class="headerlink" title="未完成的故事"></a>未完成的故事</h2><p>对笔者来说，撰写小册的两个月，是挑战重重的两个月。在这个过程中，笔者时时刻刻都在与“程序员”和“技术作者”这两个角色较劲。前者要求我锱铢必较、求深求全，后者则需要我在小册内容的深度、广度与可读性之间作出权衡。正是因为有了这一番又一番的权衡，它才终于被打磨成了一本篇幅短小、卖相可爱的“小册”，而非一本庞大的、令人望而生畏的“手册”。</p><p>但也是因为如此，小册里多出了一些“未完成的故事”。比如网络优化这部分，我想可能会有同学兴致勃勃地想听一听 DNS 的预解析或者 TCP 协议的负载均衡；再比如资源加载这一块，为什么说了 async 和 defer，却没有提 preload 和 prefetch 呢？又或者比较追逐“潮流”的同学，心心念念的是 Service Worker 和 Web Worker 的应用方案；甚至所在团队性能这块还没做起来的同学，希望我可以提供能够耦合进业务的性能监测方案，等等（这些都是非常实际的阅读需求）。</p><p>但正如我开篇所说的，我的初心并非是为大家提供一本面面俱到的“手册”。前端性能优化的知识点零碎、不成体系，这是它学习的痛点，也是小册想要解决的问题。有许多同样精彩的性能知识，我们可以针对它做技术方案测试、可以为它开研讨会，但它并不适合出现在小册的写作大纲里、以短文的形式呈现。我希望呈现给大家的内容，是前后相连，自成体系的“一串”知识。是大家在学习、工作之余，在等公交、搭地铁的间隙，在碎片化的时间里，仍然能够轻松阅读并理解的友好内容。</p><h2 id="前方的路"><a href="#前方的路" class="headerlink" title="前方的路"></a>前方的路</h2><p>小册之愿，是希望成为大家性能优化这条路上的起点。</p><p>相对于模式成熟、方案完善的服务端性能优化来说，前端性能优化整体的起步是比较晚的。但在当今的大环境下，它又是极其重要的一个工作。我们是离用户最近的工程师，需要直接对用户的体验负责。因此，我们需要做的努力还有太多太多。</p><p>既然已经读到了最后一章，我想大家应该都收获了一张属于自己的前端性能优化的核心知识“索引表”——我希望它能成为大家的起点，成为各位今后拓展相关技能的素材。当下前端世界里，提起技术，许多初学者第一反应仍然是学框架、学工具。框架和工具固然重要，但一个合格的前端工程师，还应该具有抽象思维的能力和技术攻关的实力——这两点，都可以在性能优化的学习和实践过程中得到磨炼和凸显。</p><p>在庞大的前端性能知识体系面前，一本单薄的小册是远远不够的。接下来大家要做的，就是实践、实践、再实践！反复地阅读文字、一味地深究理论是无法使我们的技能变“厚”的，最好的办法就是去做，去用，在用的过程中发现问题、解决问题、拓展问题——那些“未完成的故事”，一定会在这个过程中被你书写圆满。</p><p>把这张“索引表”装进行囊，继续征战你的前端性能优化之旅吧！</p><p><a href="https://www.kancloud.cn/sllyli/performance/1242194" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;提起性能优化，大家现在脑海里第一时间会映射出什么内容呢？&lt;/p&gt;
&lt;p&gt;可能是类似&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“雅虎军规”&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/5362856/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《高性能 JavaScript》&lt;/a&gt;这样历久弥香的经典之作，也可能是搜索引擎聚合给你的一篇又一篇以性能优化为主题的个人或团队实践而来的“私货”。至少当我确定自己的研发方向、并接到第一个性能优化任务时，我做的第一件事是向搜索引擎求助，第二件事是买书，然后开始了摸着石头过河，前后花费了大量的时间和精力。我深感性能优化实在是前端知识树中特别的一环——当你需要学习前端框架时，文档和源码几乎可以告诉你所有问题的答案，当你需要学习 Git 时，你也可以找到放之四海皆准的实践方案。但性能优化却不一样，它好像只能是一个摸索的过程。&lt;/p&gt;
&lt;p&gt;这个摸索的过程是痛苦的、漫长的，也是紧要的。因为在如今的互联网环境下，一个前端团队如果只把性能优化这个任务写在纸上，而不投入实践，它将缺失最基本的竞争力。&lt;/p&gt;
&lt;p&gt;笔者写这本小册，是希望通过短短十数个章节的讲解，尽可能降低一些大家学习性能优化的成本。&lt;/p&gt;
&lt;p&gt;一方面，这本小册为没有接触过性能优化的新同学建立起一个正确的前端性能优化的“世界观”，知道性能优化是什么、为什么、怎么做，从而使性能优化这件事情有迹可循，有路可走。这样在面试现场被问到性能优化层面的问题时，能够做到滔滔不绝、言之有物，而非像背书一样罗列干巴巴的知识点，最终淹没在茫茫的求职大军中。另一方面，小册可以为在职的工程师们提供一线团队已经实践过的“方法论”，知道什么场景下该做什么事情，最终在脑海中留下一张涵盖核心原理和实践的、可随时查阅并且高度可扩展的性能优化思路索引表。然后在今后的开发生活中可以去践行它，更进一步去挖掘它。把性能优化变作你前端工程师生涯的一门必修课，进而演化为自己研发方面的核心竞争力。&lt;/p&gt;
&lt;p&gt;同时，相信大家可以明确这样一个学习观念：任何技术的掌握，都离不开一定比例的理论基础和实际操作的支撑。&lt;/p&gt;
&lt;p&gt;具体到前端性能优化这件事情上，我认为它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。所以希望大家阅读本小册时，能够读到一些“书本之外的东西”——最好是一边读一边回忆自己既有的开发经历，尝试去留意哪些知识是已知的，哪些是未知的。&lt;/p&gt;
&lt;p&gt;这样读完之后，就可以有的放矢地把这些知识转换为自己的项目实践——前端技术日新月异，性能方案永远都在更迭，所以一定要形成自己的学习思路。&lt;/p&gt;
&lt;p&gt;建议每一位读者都带着“学了就要用”的心态去读这本小册。如果阅读结束，能够为你带来哪怕一个小小的开发习惯或者优化观念上的改变，这数小时的阅读时间就算没有白费。&lt;/p&gt;
&lt;h2 id=&quot;知识体系：-从一道面试题说起&quot;&gt;&lt;a href=&quot;#知识体系：-从一道面试题说起&quot; class=&quot;headerlink&quot; title=&quot;知识体系： 从一道面试题说起&quot;&gt;&lt;/a&gt;知识体系： 从一道面试题说起&lt;/h2&gt;&lt;p&gt;在展开性能优化的话题之前，我想先抛出一个老生常谈的面试问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从输入 URL 到页面加载完成，发生了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题非常重要，因为我们后续的内容都将以这个问题的答案为骨架展开。我希望正在阅读这本小册的各位可以在心里琢磨一下这个问题——无须你调动太多计算机的专业知识，只需要你用最快的速度在脑海中架构起这个抽象的过程——我们接下来所有的工作，就是围绕这个过程来做文章。&lt;/p&gt;
&lt;p&gt;我们现在站在性能优化的角度，一起简单地复习一遍这个经典的过程：首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作（如下图所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://m.qpic.cn/psc?/V113wYm11CpCjy/r5r.jW0JZFmFKdRYe5qoxrqlAr5fqrbSutHA74Xhp1FZfirxX*8bqKGna7wWrmsnjwUNNSw5GIfHBbg*hBhaQ.edeB*B5hVveVyVwNSv9C8!/b&amp;amp;bo=6QFJAekBSQEDCSw!&amp;amp;rf=viewer_4&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们将这个过程切分为如下的过程片段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 解析&lt;/li&gt;
&lt;li&gt;TCP 连接&lt;/li&gt;
&lt;li&gt;HTTP 请求抛出&lt;/li&gt;
&lt;li&gt;服务端处理请求，HTTP 响应返回&lt;/li&gt;
&lt;li&gt;浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大家谨记，我们任何一个用户端的产品，都需要把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。&lt;/p&gt;
&lt;h2 id=&quot;从原理到实践：各个击破&quot;&gt;&lt;a href=&quot;#从原理到实践：各个击破&quot; class=&quot;headerlink&quot; title=&quot;从原理到实践：各个击破&quot;&gt;&lt;/a&gt;从原理到实践：各个击破&lt;/h2&gt;&lt;p&gt;我们接下来要做的事情，就是针对这五个过程进行分解，各个提问，各个击破。&lt;/p&gt;
&lt;p&gt;具体来说，DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？能——浏览器 DNS 缓存和 DNS prefetch。TCP 每次的三次握手都急死人，有没有解决方案？有——长连接、预连接、接入 SPDY 协议。如果说这两个过程的优化往往需要我们和团队的服务端工程师协作完成，前端单方面可以做的努力有限，那么 HTTP 请求呢？——在减少请求次数和减小请求体积方面，我们应该是专家！再者，服务器越远，一次请求就越慢，那部署时就把静态资源放在离我们更近的 CDN 上是不是就能更快一些？&lt;/p&gt;
&lt;p&gt;以上提到的都是网络层面的性能优化。再往下走就是浏览器端的性能优化——这部分涉及资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等——这正是前端工程师可以真正一展拳脚的地方。学习这些知识，不仅可以帮助我们从根本上提升页面性能，更能够大大加深个人对浏览器底层原理、运行机制的理解，一举两得！&lt;/p&gt;
&lt;p&gt;我们整个的知识图谱，用思维导图展示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntvj32oyDYngqL0SrLOARhYCoJCwDbV9GXy*2FcmGEa4h9VoqcGw4LuDXSLK22d9MPShTHuCxFn8bALQswKYwWUU!/b&amp;amp;bo=rgniBa4J4gUDORw!&amp;amp;rf=viewer_4&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;小册格局&quot;&gt;&lt;a href=&quot;#小册格局&quot; class=&quot;headerlink&quot; title=&quot;小册格局&quot;&gt;&lt;/a&gt;小册格局&lt;/h2&gt;&lt;p&gt;总的来说，我们将从&lt;strong&gt;网络层面&lt;/strong&gt;和&lt;strong&gt;渲染层面&lt;/strong&gt;两个大的维度来逐个点亮前端性能优化的技能树。&lt;/p&gt;
&lt;p&gt;这两个维度的知识面貌各有千秋：在网络层面，我们需要学习一些必需的理论基础作为前置知识。这部分的学习或许不需要大家写特别多的代码，但需要大家对每一个知识点理解透彻，进而应用到自己日常优化的决策中去。网络层面结束后，由本地存储开始，我们会渐渐过渡到浏览器这一端的优化，大家喜闻乐见的“真代码”就会相应地多起来。&lt;/p&gt;
&lt;p&gt;为了使同学们耐心学习一些理论性稍强的知识，我也会尽自己所能去讲述得有趣、易读、可用，同时希望大家可以真的沉下心去理解这些知识，它们与大家喜闻乐见的框架和工具无异，一样是实实在在的生产力。&lt;/p&gt;
&lt;p&gt;“经验丰富的人读书用两只眼睛，一只眼睛看到纸面上的话，另一只眼睛看到纸的背面”。在这本小册，代码片段固然有用，它们是“纸面上的话”，我自然希望大家可以记下来、用起来。而代码之外那些反复讲解的原理，则是“纸的背面”，同样是我希望引起大家重视的内容。&lt;/p&gt;
&lt;p&gt;现在相信大家已经对我们的优化观念、知识结构、小册格局都有了基本认知，那么我们就赶快趁热打铁，进入实战技能的学习吧~&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端 性能 优化" scheme="http://www.icrazyman.cn/tags/%E5%89%8D%E7%AB%AF-%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>图解 Vue 响应式原理</title>
    <link href="http://www.icrazyman.cn/2020/08/06/%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://www.icrazyman.cn/2020/08/06/图解 Vue 响应式原理/</id>
    <published>2020-08-06T08:30:29.000Z</published>
    <updated>2020-08-06T09:11:38.332Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>最近部门分享，有同学提到了 Vue 响应式原理，大家在讨论时，发现一些同学对这一知识理解还不够深入，不能形成一个闭环，为了帮助大家理解这个问题，我重新过了一下 Vue 源码，并整理了多张流程图，便于大家理解。</p><ul><li>Vue 初始化</li><li>模板渲染</li><li>组件渲染</li></ul><blockquote><p>本文 Vue 源码版本：2.6.11，为了便于理解，均有所删减。</p></blockquote><p>本文将从以下两个方面进行探索：</p><ul><li>从 Vue 初始化，到首次渲染生成 DOM 的流程。</li><li>从 Vue 数据修改，到页面更新 DOM 的流程。</li></ul></li></ul><a id="more"></a><h2 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h2><p>先从最简单的一段 Vue 代码开始：</p><pre><code>&lt;template&gt;  &lt;div&gt;    {{ message }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;new Vue({  data() {    return {      message: &quot;hello world&quot;,    };  },});&lt;/script&gt;</code></pre><p>这段代码很简单，最终会在页面上打印一个 hello world，它是如何实现的呢？</p><p>我们从源头：new Vue 的地方开始分析。</p><pre><code>// 执行 new Vue 时会依次执行以下方法// 1. Vue.prototype._init(option)// 2. initState(vm)// 3. observe(vm._data)// 4. new Observer(data)// 5. 调用 walk 方法，遍历 data 中的每一个属性，监听数据的变化。function walk(obj) {  const keys = Object.keys(obj);  for (let i = 0; i &lt; keys.length; i++) {    defineReactive(obj, keys[i]);  }}// 6. 执行 defineProperty 监听数据读取和设置。function defineReactive(obj, key, val) {  // 为每个属性创建 Dep（依赖搜集的容器，后文会讲）  const dep = new Dep();  // 绑定 get、set  Object.defineProperty(obj, key, {    get() {      const value = val;      // 如果有 target 标识，则进行依赖搜集      if (Dep.target) {        dep.depend();      }      return value;    },    set(newVal) {      val = newVal;      // 修改数据时，通知页面重新渲染      dep.notify();    },  });}</code></pre><p>数据描述符绑定完成后，我们就能得到以下的流程图：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/r5r.jW0JZFmFKdRYe5qoxh5HQWOvBBxH5mSi8VntoCiJXmU47uqnC7mbaf7pX4G9UhLkz2DhcDXESEVa7Lxhld2nIYNjl2mwb.92WD5OsE0!/b&amp;bo=RQOAAUUDgAEDCSw!&amp;rf=viewer_4" alt="img"></p><p>图中我们可以看到，Vue 初始化时，进行了数据的 get、set 绑定，并创建了一个 Dep 对象。</p><p>对于数据的 get、set 绑定我们并不陌生，但是 Dep 对象什么呢？</p><p>Dep 对象用于依赖收集，它实现了一个发布订阅模式，完成了数据 Data 和渲染视图 Watcher 的订阅，我们一起来剖析一下。</p><pre><code>class Dep {  // 根据 ts 类型提示，我们可以得出 Dep.target 是一个 Watcher 类型。  static target: ?Watcher;  // subs 存放搜集到的 Watcher 对象集合  subs: Array&lt;Watcher&gt;;  constructor() {    this.subs = [];  }  addSub(sub: Watcher) {    // 搜集所有使用到这个 data 的 Watcher 对象。    this.subs.push(sub);  }  depend() {    if (Dep.target) {      // 搜集依赖，最终会调用上面的 addSub 方法      Dep.target.addDep(this);    }  }  notify() {    const subs = this.subs.slice();    for (let i = 0, l = subs.length; i &lt; l; i++) {      // 调用对应的 Watcher，更新视图      subs[i].update();    }  }}</code></pre><p>根据对 Dep 的源码分析，我们得到了下面这张逻辑图：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntkti3VUUBcWgqEp66.TIg*LIsIl5KRp*Gn6ThshprhRUgAMQvVx5ZMYiafSqjpTha3qMVVFtWVqjQF5M5LNXnac!/b&amp;bo=wgJRAcICUQEDGTw!&amp;rf=viewer_4" alt="img"></p><p>了解 Data 和 Dep 之后，我们来继续揭开 Watcher 的面纱。</p><pre><code>class Watcher {  constructor(vm: Component, expOrFn: string | Function) {    // 将 vm._render 方法赋值给 getter。    // 这里的 expOrFn 其实就是 vm._render，后文会讲到。    this.getter = expOrFn;    this.value = this.get();  }  get() {    // 给 Dep.target 赋值为当前 Watcher 对象    Dep.target = this;    // this.getter 其实就是 vm._render    // vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom。    const value = this.getter.call(this.vm, this.vm);    return value;  }  addDep(dep: Dep) {    // 将当前的 Watcher 添加到 Dep 收集池中    dep.addSub(this);  }  update() {    // 开启异步队列，批量更新 Watcher    queueWatcher(this);  }  run() {    // 和初始化一样，会调用 get 方法，更新视图    const value = this.get();  }}</code></pre><p>源码中我们看到，Watcher 实现了渲染方法 <code>_render</code> 和 Dep 的关联， 初始化 Watcher 的时候，打上 Dep.target 标识，然后调用 get 方法进行页面渲染。加上上文的 Data，目前 Data、Dep、Watcher 三者的关系如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrRkKEBoZiO31D7u5kacc2r1tqvgH4TD198FEaiVZVG7jM.Px7hmSwJShq8MfJAQUxFZEX.zsERhbQenW0FPdgA!/b&amp;bo=4wJdAeMCXQEDGTw!&amp;rf=viewer_4" alt="img"></p><p>我们再拉通串一下整个流程：Vue 通过 <code>defineProperty</code> 完成了 Data 中所有数据的代理，当数据触发 get 查询时，会将当前的 Watcher 对象加入到依赖收集池 Dep 中，当数据 Data 变化时，会触发 set 通知所有使用到这个 Data 的 Watcher 对象去 update 视图。</p><p>目前的整体流程如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntkVkfhTmbq1sfzEMJVG1pWRR5cdesB3FkY2X6g3pZ.XXYVlSXae7Cyjl1I7pM0BSG2xbYx75ASIe6U.PK0oFdQo!/b&amp;bo=cAPVAXAD1QEDGTw!&amp;rf=viewer_4" alt="img"></p><p>上图的流程中 Data 和 Dep 都是 Vue 初始化时创建的，但现在我们并不知道 Wacher 是从哪里创建的，带着这个问题，我们接着往下探索。</p><h2 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h2><p>上文中，我们分析了初始化 Vue 过程中处理数据的部分，接下来，我们分析一下数据渲染的部分。</p><p>其实 new Vue 执行到最后，会调用 mount 方法，将 Vue 实例渲染成 dom 。</p><pre><code>// new Vue 执行流程。// 1. Vue.prototype._init(option)// 2. vm.$mount(vm.$options.el)// 3. render = compileToFunctions(template) ，编译 Vue 中的 template 模板，生成 render 方法。// 4. Vue.prototype.$mount 调用上面的 render 方法挂载 dom。// 5. mountComponent// 6. 创建 Watcher 实例const updateComponent = () =&gt; {  vm._update(vm._render());};// 结合上文，我们就能得出，updateComponent 就是传入 Watcher 内部的 getter 方法。new Watcher(vm, updateComponent);// 7. new Watcher 会执行 Watcher.get 方法// 8. Watcher.get 会执行 this.getter.call(vm, vm) ，也就是执行 updateComponent 方法// 9. updateComponent 会执行 vm._update(vm._render())// 10. 调用 vm._render 生成虚拟 domVue.prototype._render = function (): VNode {  const vm: Component = this;  const { render } = vm.$options;  let vnode = render.call(vm._renderProxy, vm.$createElement);  return vnode;};// 11. 调用 vm._update(vnode) 渲染虚拟 domVue.prototype._update = function (vnode: VNode) {  const vm: Component = this;  if (!prevVnode) {    // 初次渲染    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);  } else {    // 更新    vm.$el = vm.__patch__(prevVnode, vnode);  }};// 12. vm.__patch__ 方法就是做的 dom diff 比较，然后更新 dom，这里就不展开了。</code></pre><p>看完 Vue 模板渲染的过程，我们可以得到如下的流程图：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrCQDlFKxeh5YPod0702yedqvGPeVeo*bH50wVt8TZ71LLWYjvC.oFOXZGGjs.puZZsFxa6IR9yZxrInsi3twVQ!/b&amp;bo=AwO7AQMDuwEDGTw!&amp;rf=viewer_4" alt="img"></p><p>到这里，我们就知道了 Watcher 其实是在 Vue 初始化的阶段创建的，属于生命周期中 beforeMount 的位置创建的，创建 Watcher 时会执行 render 方法，最终将 Vue 代码渲染成真实的 DOM。</p><p>我们再将之前的流程整合一下，就能得到以下的流程：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntpNNi.XgkHoubvtgEquc1Deo97*v5lpHiKRf.aP4ldNTYyX3rS2wT.1nRMR*3Z5DupLn2WBXSN2M*pyKnl43QYI!/b&amp;bo=hwMLAocDCwIDGTw!&amp;rf=viewer_4" alt="img"></p><p>上图分析了 Vue 初始化到渲染 DOM 的整个过程，最后我们再分析一下，当数据变化时，Vue 又是怎么进行更新的？</p><p>其实，在上图也能看出，在 Data 变化时，会调用 Dep.notify 方法，随即调用 Watcher 内部的 update 方法，此方法会将所有使用到这个 Data 的 Watcher 加入一个队列，并开启一个异步队列进行更新，最终执行 <code>_render</code> 方法完成页面更新。</p><p>整体的流程如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntiGxZ9p*6dw2qfZPiQncuubE8EJ67HoYDhCRmbgqrXIbEXJ2Sfv1hJU*agfPcRCgMsmEWT.KXU3Sl.KL1GldmcI!/b&amp;bo=ZwMQAmcDEAIDGTw!&amp;rf=viewer_4" alt="img"></p><p>好了，探索到这里，Vue 的响应式原理，已经被我们分析透彻了，如果你还没有明白，不妨再细品一下上图。</p><h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>本来探索到上面的流程图就结束了，但好奇的我又想到了一个问题 😂。</p><blockquote><p>Vue 组件又是怎么渲染的呢？</p></blockquote><p>带着这个问题，我继续查阅了源码。</p><pre><code>// 从模板编译开始，当发现一个自定义组件时，会执行以下函数// 1. compileToFunctions(template)// 2. compile(template, options);// 3. const ast = parse(template.trim(), options)// 4. const code = generate(ast, options)// 5. createElement// 6. createComponentexport function createComponent(  Ctor: Class&lt;Component&gt; | Function | Object | void,  data: ?VNodeData,  context: Component,  children: ?Array&lt;VNode&gt;,  tag?: string): VNode | Array&lt;VNode&gt; | void {  // $options._base 其实就是全局 Vue 构造函数，在初始化时 initGlobalAPI 中定义的：Vue.options._base = Vue  const baseCtor = context.$options._base;  // Ctor 就是 Vue 组件中 &lt;script&gt; 标签下 export 出的对象  if (isObject(Ctor)) {    // 将组件中 export 出的对象，继承自 Vue，得到一个构造函数    // 相当于 Vue.extend(YourComponent)    Ctor = baseCtor.extend(Ctor);  }  const vnode = new VNode(`vue-component-${Ctor.cid}xxx`);  return vnode;}// 7. 实现组件继承 Vue，并调用 Vue._init 方法，进行初始化Vue.extend = function (extendOptions: Object): Function {  const Super = this;  const Sub = function VueComponent(options) {    // 调用 Vue.prototype._init，之后的流程就和首次加载保持一致    this._init(options);  };  // 原型继承，相当于：Component extends Vue  Sub.prototype = Object.create(Super.prototype);  Sub.prototype.constructor = Sub;  return Sub;};</code></pre><p>看完组件渲染的源码后，结合上文，重新整理了一张流程图，图中的蓝色部分就是渲染组件的过程。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntuKcMnsQ3kmY5bOYwvC7.7aT08nRmrqQMMWz020JYGQ81u5mxsxBdWauLQn3IJN3X9wjiVvtCOnWNaAh4j*fLTw!/b&amp;bo=IQMnAiEDJwIDGTw!&amp;rf=viewer_4" alt="img"></p><p>好了，现在是真的结束了，最终的流程图就是上面的这一张图。</p><p>问个问题，现在你理解 Vue 响应式原理了吗？</p><p>如果仍觉得不好理解，我这里还准备了一张带标注的简图 😂</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntlTDI19a0hcIKwcYBXZIMrqzC*8Qpq.7VL*Kn*JGPg5w3qFcCsyM53tlrOqnV.Lz*4RWvbiQapJuMNFjEMflejU!/b&amp;bo=dQMZAnUDGQIDGTw!&amp;rf=viewer_4" alt="img"></p><h2 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h2><p>本文从源码的角度，介绍了 Vue 响应式原理，来简单回顾一下吧。</p><ol><li>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</li><li>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</li><li>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</li><li>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近部门分享，有同学提到了 Vue 响应式原理，大家在讨论时，发现一些同学对这一知识理解还不够深入，不能形成一个闭环，为了帮助大家理解这个问题，我重新过了一下 Vue 源码，并整理了多张流程图，便于大家理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue 初始化&lt;/li&gt;
&lt;li&gt;模板渲染&lt;/li&gt;
&lt;li&gt;组件渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本文 Vue 源码版本：2.6.11，为了便于理解，均有所删减。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将从以下两个方面进行探索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 Vue 初始化，到首次渲染生成 DOM 的流程。&lt;/li&gt;
&lt;li&gt;从 Vue 数据修改，到页面更新 DOM 的流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端 vue.js javascript 源码" scheme="http://www.icrazyman.cn/tags/%E5%89%8D%E7%AB%AF-vue-js-javascript-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://www.icrazyman.cn/2020/07/30/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.icrazyman.cn/2020/07/30/vue学习笔记/</id>
    <published>2020-07-30T09:39:50.208Z</published>
    <updated>2019-04-18T07:51:55.683Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为换工作，忙着找下家的缘故，好久没做一些学习总结了，趁着新东家的项目都做完的比较空闲的缘故，把最近新学习的技术归纳整理一下吧！之前在学习react的时候就对比了解过vue和react的优势和区别了，虽然react在大型项目上比vue有优势，社区也更强大，但在武汉这个市场绝大部分还是已vue为主，之前工作中用的是react，所以一直都在学的react，同时vue比较简单，学习曲线比较平缓，所以当时也没急着去研究vue了。这次换了新东家，项目是用的vue+vuex+axios+vux框架+webpack搭的项目，正好也跟着项目仔细地研究了vue技术栈，确实没有react那么复杂，现把一些学习和工作中的学习笔记记录下来，以便以后可以复习。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>直接引入链接：建议初学者使用；</li><li>通过node.js的NPM安装Vue；</li><li>通过node.js的NPM安装Vue-cli脚手架（推荐安装方式）；</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>字符串：title: ‘hello world’；</li><li>数字：num:123；</li><li>数组：arrow: [‘apple’, ‘banana’,’orange’]；</li><li>对象：name: {firstName:’ming’,lastName:’Li’}；</li><li>布尔值：true/false；</li></ul><h3 id="模版数据绑定"><a href="#模版数据绑定" class="headerlink" title="模版数据绑定"></a>模版数据绑定</h3><ul><li>：模版解析；</li><li>v-text：文本绑定；</li><li>v-model：数据双向绑定；v-model.lazy：延迟对数据进行更新；<ul><li>v-model.number：对输入的数据字符串转为数字；</li><li>v-model.trim：对数据进行裁剪，去除空格等</li></ul></li></ul><h3 id="表单数据绑定"><a href="#表单数据绑定" class="headerlink" title="表单数据绑定"></a>表单数据绑定</h3><ul><li>checkbox：储存的数据类型是数组；</li><li>radio：储存的数据类型是字符串；</li><li>select：存储的数据类型是字符串；</li></ul><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ul><li>v-bind：标签属性绑定，属于动态绑定，可以简写为：。绑定后的属性为变量，可以是字符串，数组或者是对象；</li><li>v-if/v-if-else-if/v-else：条件渲染，如果成立则执行，不成立则注销；</li><li>v-show：同样是条件渲染，不同的是不成立是隐藏而不是注销；</li></ul><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li>通过v-on:event=”eventName”进行绑定，可简写为@:event=”eventName”;方法通过在methods里进行方法定义；</li><li>在v-on:event.midiflyer添加修改器；</li><li>自定义事件：v-on:diyEvent=”eventName”，通过$emit来触发自定义事件。<code>methods: {my-function () {this.$emit(&#39;diyEvent&#39;), 参数}}</code>；</li></ul><h3 id="计算属性和数据监听"><a href="#计算属性和数据监听" class="headerlink" title="计算属性和数据监听"></a>计算属性和数据监听</h3><ul><li>传值属性：props: [‘xx’,’xx’]。父子组件如果需要传值，必须要在props里进行定义；</li><li>事件属性：methods: {}。所有事件都在这里进行定义；很多情况下在执行事件时需要取消默认事件。function(e){e.preventDefault();}；</li><li>计算属性：computed: {方法 () { return 方法 }}；计算属性的优点：可以直接根据data的属性动态的更改（data中myValue的值变化会同步反映到计算属性里）（计算属性会缓存所依赖的那个值，直到那个值发生变化，否则不会重新取值）与方法调用的缺点：调用方法的时候才会更新，即使data中myValue的值没有变化，调用时依然会去重新取值。使用场景：在耗时、大量搜索的情况下使用，减少dom重复渲染的性能支出。</li><li>创建属性：created:function(){}。方法不需要手动调用，直接执行。</li><li>数据监听：watch: { 方法 () {}}；</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="动态绑定class"><a href="#动态绑定class" class="headerlink" title="动态绑定class"></a>动态绑定class</h4><ul><li>v-bind:class=”{red:true}”；</li><li>v-bind:class={changeClass:changeClass}；</li><li>v-bind:class={active ? true : false}</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>不强制要求按照W3C规则进行命名，但最好遵循。例如：<code>my-template</code>;</li><li>不管组件是大驼峰还是小驼峰，在模版引用的时候一律要转为中横线的命名方式。例如：组件为<code>comName</code>，引用时为：<code>&lt;com-name&gt;&lt;/com-name&gt;</code>；在传递属性时名称也同样。</li></ul><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>全局注册：<code>Vue.component(&#39;my-template&#39;, {template: &#39;...&#39;});</code>  html：<code>&lt;my-template&gt;&lt;/my-template&gt;</code></li><li>局部注册：只在使用的场景进行注册。<code>var myTemplate = {template: &#39;...&#39;};  new Vue({..., components: {&#39;my-template: myTemplate&#39;}})</code></li></ul><h3 id="模版解析"><a href="#模版解析" class="headerlink" title="模版解析"></a>模版解析</h3><ul><li>特殊标签下的模版需要注意，比如table、ol、ul、select等标签，使用<code>is</code>进行挂载。例如:<code>&lt;table&gt;&lt;tr is=&quot;my-tr&quot;&gt;&lt;/tr&gt;&lt;/table&gt;</code>;</li><li><p>推荐使用字符串模版：</p></li><li><p><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>；</p></li><li>javascript内联模版字符串；</li><li><p>vue组件；</p></li><li><p>组件中的data必须是函数。</p></li></ul><h3 id="组件组合"><a href="#组件组合" class="headerlink" title="组件组合"></a>组件组合</h3><ul><li>父组件通过prop进行向下传递；</li><li>子组件通过事件进行发送信息，子组件触发事件，父组件进行监听；</li><li>传值时要主要命名的选择和使用，使用props使用的驼峰式明显需要转变为对应的中横线式。<code>Vue.component(&#39;my-template&#39;, {props: [&#39;myMessage&#39;],template: &#39;...&#39;}); &lt;my-template   my-message=&quot;hello&quot;&gt;&lt;/my-template&gt;</code></li><li>字面量语法和动态语法；</li><li>slot插槽：父组件向子组件插入template模板，父子之间通过slot属性和name属性进行对应<code>&lt;p slot=&quot;header&quot;&gt;我是header&lt;/p&gt;&lt;span slot=&quot;footer&quot;&gt;我是footer&lt;/span&gt;</code>；</li><li>动态组件：利用 <code>:is = &quot;&quot;</code> 进行组件的动态绑定，外层可以用内置组件keep-alive 来进行缓存；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用组件树设计项目，配置文件链接各个组件-命名转换，动态组件；</li><li>父组件向内传递属性-动态属性；</li><li>子组件向外发布事件；</li><li>slot插槽传递模版 - 具名slot；</li></ul><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="动画：使用transition-内置组件，有css过渡和js过渡两种方式。"><a href="#动画：使用transition-内置组件，有css过渡和js过渡两种方式。" class="headerlink" title="动画：使用transition 内置组件，有css过渡和js过渡两种方式。"></a>动画：使用transition 内置组件，有css过渡和js过渡两种方式。</h3><h4 id="css过渡实现原理：给动画的不同阶段加上不同的class名称。"><a href="#css过渡实现原理：给动画的不同阶段加上不同的class名称。" class="headerlink" title="css过渡实现原理：给动画的不同阶段加上不同的class名称。"></a>css过渡实现原理：给动画的不同阶段加上不同的class名称。</h4><ul><li>四个阶段：v-enter/v-enter-active/v-leave/v-leave-active；使用：<code>&lt;transition name=&quot;fade&quot;&gt;&lt;/transition&gt;</code>  .fade-enter/.fade-enter-active/.fade-leave/.fade-leave-active；</li><li>能够接受动画的元素有：v-show/v-if/动态组件加载；</li><li>通过mode=”out-in”/“in-out”实现动画顺序；</li><li>对于多元素模版，如果使用的是同标签名，需要使用key来进行区分；</li></ul><h4 id="js过渡实现原理：通过定义不同的方法来实现动画。"><a href="#js过渡实现原理：通过定义不同的方法来实现动画。" class="headerlink" title="js过渡实现原理：通过定义不同的方法来实现动画。"></a>js过渡实现原理：通过定义不同的方法来实现动画。</h4><p>不同方法名：</p><p><code>&lt;transition      v-on:before-enter=&quot;beforeEnter&quot;      v-on:enter=&quot;enter&quot;      v-on:after-enter=&quot;afterEnter&quot;      v-on:enter-cancelled=&quot;enterCancelled&quot;      v-on:before-leave=&quot;beforeLeave&quot;      v-on:leave=&quot;leave&quot;      v-on:after-leave=&quot;afterLeave&quot;      v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;    ...    &lt;/transition&gt;</code></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><ul><li>方法：主要有两种：局部定义和全局定义。</li><li>使用：inserted和bind是指令的两个配置属性，属性值是一个函数，所以用es6语法。讲inserted函数，，然后然后回到组件，处理el表示使用了指令的元素对象，还有一个binding对象，其中binding.value表示的是使用了指令元素的指令的值，可以是json，然后借这个json（里面放着css相关信息）所包含的数据来修改dom的样式。</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>vue-resource： 发送http请求</li><li>vue-router：   前端路由</li><li>引入步骤：<ul><li>入口js文件 import  from  插件 </li><li>Vue.use(插件)  不过在模块环境中应当始终显式调用 Vue.use() :</li></ul></li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><ul><li>Node.js</li><li>NPM</li><li>Mustache</li><li>ECMAscript</li><li>Javascript</li><li>Ajax</li></ul><h2 id="Vue全家桶"><a href="#Vue全家桶" class="headerlink" title="Vue全家桶"></a>Vue全家桶</h2><ul><li>vue.js</li><li>vue-cli</li><li>vue-router</li><li>vue-axios</li><li>vue-lazyload</li></ul><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><ul><li>Webpack</li><li>Gulp</li><li>Parcel</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul><li>Css-loader</li><li>Sass-loader</li><li>Vue-style-loader</li><li>Superagent</li></ul><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul><li>在开发过程中，如果修改了配置文件，需要重新启动，否则报错；</li><li>手写输入的拼写错误问题，一般会提示出来；</li><li>样式文件中的拼写错误，包括属性、值、图片名称，如果找不到也会报错，一般很难找到，所以出现报错的时候一定先要解决！！</li><li>使用webpack要进行loader依赖的安装；</li><li>proxyTable 反向代理设置；</li><li>在组件中template节点下必须只有一个子节点；</li><li>如果采用webpack进行打包管理，如果数据中有需要在js里引用图片地址，需要使用<code>require()</code>的方式进行引用，否则不会被打包到静态文件目录里；</li><li>在组件使用时候先进行数据绑定；</li><li>在使用属性的时候一定记得要添加作用域，比如this；</li><li>在组件或者模版中使用sass或less文件，一定要在style标签上声明lang，否则报错没商量；</li><li>在组件开发过程中，如果需要传参一定记得定义并且在引用的地方调用；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为换工作，忙着找下家的缘故，好久没做一些学习总结了，趁着新东家的项目都做完的比较空闲的缘故，把最近新学习的技术归纳整理一下吧！之前在学习react的时候就对比了解过vue和react的优势和区别了，虽然react在大型项目上比vue有优势，社区也更强大，但在武汉这个市场绝大部分还是已vue为主，之前工作中用的是react，所以一直都在学的react，同时vue比较简单，学习曲线比较平缓，所以当时也没急着去研究vue了。这次换了新东家，项目是用的vue+vuex+axios+vux框架+webpack搭的项目，正好也跟着项目仔细地研究了vue技术栈，确实没有react那么复杂，现把一些学习和工作中的学习笔记记录下来，以便以后可以复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue 框架 学习 笔记" scheme="http://www.icrazyman.cn/tags/vue-%E6%A1%86%E6%9E%B6-%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>快速了解 React Hooks 原理</title>
    <link href="http://www.icrazyman.cn/2020/07/30/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%20React%20Hooks%20%E5%8E%9F%E7%90%86/"/>
    <id>http://www.icrazyman.cn/2020/07/30/快速了解 React Hooks 原理/</id>
    <published>2020-07-30T08:47:29.000Z</published>
    <updated>2020-07-30T08:49:57.345Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为了保证的可读性，本文采用意译而非直译。</strong></p><p>我们大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？</p><p>React 早期版本，类组件可以通过继承<code>PureComponent</code>来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 <code>React.memo</code>函数。</p><p><strong>React 16.8</strong> 新出来的<code>Hook</code>可以让React 函数组件具有状态，并提供类似 <code>componentDidMount</code>和<code>componentDidUpdate</code>等生命周期方法</p><a id="more"></a><h2 id="类被会替代吗？"><a href="#类被会替代吗？" class="headerlink" title="类被会替代吗？"></a>类被会替代吗？</h2><p><code>Hooks</code>不会替换类，它们只是一个你可以使用的新工具。React 团队表示他们没有计划在React中弃用类，所以如果你想继续使用它们，可以继续用。</p><p>我能体会那种总有新东西要学的感觉有多痛苦，不会就感觉咱们总是落后一样。<code>Hooks</code> 可以当作一个很好的新特性来使用。当然没有必要用 Hook 来重构原来的代码, React团队也建议不要这样做。</p><h2 id="Go-Go"><a href="#Go-Go" class="headerlink" title="Go Go"></a>Go Go</h2><p>来看看<strong>Hooks</strong>的例子,咱们先从最熟悉的开始:函数组件。</p><p>以下 OneTimeButton 是函数组件，所做的事情就是当我们点击的时候调用 <code>sayHi</code> 方法。</p><p>​                        </p><pre><code>import React from &#39;react&#39;;import { render } from &#39;react-dom&#39;;function OneTimeButton(props) {  return (    &lt;button onClick={props.onClick}&gt;        点我点我    &lt;/button&gt;  )}function sayHi() {  console.log(&#39;yo&#39;)}render(  &lt;OneTimeButton onClick={sayHi}/&gt;,  document.querySelector(&#39;#root&#39;))</code></pre><p>我们想让这个组件做的是，跟踪它是否被点击，如果被点击了，禁用按钮，就像一次性开关一样。</p><p>但它需要一个state，因为是一个函数，它不可能有状态(React 16.8之前)，所以需要重构成类。</p><p>函数组件转换为类组件的过程中大概有5个阶段：</p><p>*否认：也许它不需要是一个类，我们可以把 state 放到其它地方。</p><ul><li>实现： 废话，必须把它变成一个<code>class</code>，不是吗？</li><li>接受：好吧，我会改的。</li><li>努力加班重写：首先 写 <code>class Thing extends React.Component</code>，然后 实现 <code>render</code>等等 。</li><li>最后：添加state。</li></ul><p>​                        </p><pre><code>class OneTimeButton extends React.Component {  state = {    clicked: false  }  handleClick = () =&gt; {    this.props.onClick();    // Ok, no more clicking.    this.setState({ clicked: true });  }  render() {    return (      &lt;button        onClick={this.handleClick}        disabled={this.state.clicked}      &gt;        You Can Only Click Me Once      &lt;/button&gt;    );  }}</code></pre><p>这是相当多的代码，组件的结构也发生了很大的变化， 我们需要多个小的功能，就需要改写很多。</p><h2 id="使用-Hook-轻松添加-State"><a href="#使用-Hook-轻松添加-State" class="headerlink" title="使用　Hook　轻松添加　State"></a>使用　Hook　轻松添加　State</h2><p>接下来，使用新的　<code>useState</code>　hook向普通函数组件添加状态：</p><p>​                        </p><pre><code>import React, { useState } from &#39;react&#39;function OneTimeButton(props) {  const [clicked, setClicked] = useState(false)  function doClick() {    props.onClick();    setClicked(true)  }  return (    &lt;button      onClick={clicked ? undefined : doClick}      disabled={clicked}    &gt;      点我点我    &lt;/button&gt;  )}</code></pre><h2 id="这段代码是如何工作的"><a href="#这段代码是如何工作的" class="headerlink" title="这段代码是如何工作的"></a>这段代码是如何工作的</h2><p>这段代码的大部分看起来像我们一分钟前写的普通函数组件，除了<code>useState</code>。</p><p><code>useState</code>是一个hook。 它的名字以<strong>“use”</strong>开头（这是<a href="https://daveceddia.com/intro-to-hooks/#rules-of-hooks" target="_blank" rel="noopener">Hooks的规则</a>之一 - 它们的名字必须以“use”开头）。</p><p><code>useState</code> hook 的参数是 state 的初始值，返回一个包含两个元素的数组:当前state和一个用于更改state 的函数。</p><p>类组件有一个大的state对象，一个函数<code>this.setState</code>一次改变整个state对象。</p><p>函数组件根本没有状态，但<code>useState</code> hook允许我们在需要时添加很小的状态块。 因此，如果只需要一个布尔值，我们就可以创建一些状态来保存它。</p><p>由于<code>Hook</code>以某种特殊方式创建这些状态，并且在函数组件内也没有像<code>setState</code>函数来更改状态，因此 Hook 需要一个函数来更新每个状态。 所以 <code>useState</code> 返回是一对对应关系：一个值，一个更新该值函数。 当然，值可以是任何东西 - 任何JS类型 - 数字，布尔值，对象，数组等。</p><p>现在，你应该有很多疑问，如：</p><ul><li>当组件重新渲染时，每次都不会重新创建新的状态吗？ React如何知道旧状态是什么？</li><li>为什么hook 名称必须以<strong>“use”</strong>开头？ 这看起来很可疑。</li><li>如果这是一个命名规则，那是否意味着我可以自定义 Hook。</li><li>如何存储更复杂的状态，很多场景不单单只有一个状态值这么简单。</li></ul><h2 id="Hooks-的魔力"><a href="#Hooks-的魔力" class="headerlink" title="Hooks 的魔力"></a>Hooks 的魔力</h2><p>将有状态信息存储在看似无状态的函数组件中，这是一个奇怪的悖论。这是第一个关于钩子的问题，咱们必须弄清楚它们是如何工作的。</p><p>原作者得的第一个猜测是某种编译器的在背后操众。搜索代码<code>useWhatever</code>并以某种方式用有状态逻辑替换它。</p><p>然后再听说了调用顺序规则(它们每次必须以相同的顺序调用)，这让我更加困惑。这就是它的工作原理。</p><p>React第一次渲染函数组件时，它同时会创建一个对象与之共存，该对象是该组件实例的定制对象，而不是全局对象。只要组件存在于DOM中，这个组件的对象就会一直存在。</p><p>使用该对象，<code>React</code>可以跟踪属于组件的各种元数据位。</p><p>请记住，React组件甚至函数组件都从未进行过自渲染。它们不直接返回<code>HTML</code>。组件依赖于<code>React</code>在适当的时候调用它们，它们返回的对象结构<code>React</code>可以转换为<code>DOM</code>节点。</p><p>React有能力在调用每个组件之前做一些设置，这就是它设置这个<strong>状态</strong>的时候。</p><p>其中做的一件事设置 <strong>Hooks</strong> 数组。 它开始是空的, 每次调用一个<code>hook</code>时，React 都会向该数组添加该 <code>hook</code>。</p><h2 id="为什么顺序很重要"><a href="#为什么顺序很重要" class="headerlink" title="为什么顺序很重要"></a>为什么顺序很重要</h2><p>假设咱们有以下这个组件：</p><p>​                        </p><pre><code>function AudioPlayer() {  const [volume, setVolume] = useState(80);  const [position, setPosition] = useState(0);  const [isPlaying, setPlaying] = useState(false);  .....}</code></pre><p>因为它调用<code>useState</code> 3次，React 会在第一次渲染时将这三个 hook 放入 Hooks 数组中。</p><p>下次渲染时，同样的<code>3</code>个<code>hooks</code>以相同的顺序被调用，所以<code>React</code>可以查看它的数组，并发现已经在位置<code>0</code>有一个<code>useState</code> hook ，所以<code>React</code>不会创建一个新状态，而是返回现有状态。</p><p>这就是React能够在多个函数调用中创建和维护状态的方式，即使变量本身每次都超出作用域。</p><h2 id="多个useState-调用示例"><a href="#多个useState-调用示例" class="headerlink" title="多个useState 调用示例"></a>多个useState 调用示例</h2><p>让咱们更详细地看看这是如何实现的，第一次渲染：</p><ol><li>React 创建组件时，它还没有调用函数。React 创建元数据对象和Hooks的空数组。假设这个对象有一个名为<code>nextHook</code>的属性，它被放到索引为<code>0</code>的位置上，运行的第一个hook将占用位置<code>0</code>。</li><li>React 调用你的组件（这意味着它知道存储<code>hooks</code>的元数据对象）。</li><li>调用<code>useState</code>，React创建一个新的状态，将它放在<code>hooks</code>数组的第<code>0</code>位，并返回<code>[volume，setVolume]</code>对，并将<code>volume</code> 设置为其初始值<code>80</code>，它还将<code>nextHook</code>索引递增1。</li><li>再次调用<code>useState</code>，React查看数组的第<code>1</code>位，看到它是空的，并创建一个新的状态。 然后它将<code>nextHook</code>索引递增为<code>2</code>，并返回<code>[position，setPosition]</code>。</li><li>第三次调用<code>useState</code>。 React看到位置<code>2</code>为空，同样创建新状态，将<code>nextHook</code>递增到<code>3</code>，并返回<code>[isPlaying，setPlaying]</code>。</li></ol><p>现在，<code>hooks</code> 数组中有<code>3</code>个hook，渲染完成。 下一次渲染会发生什么？</p><ol><li><code>React</code>需要重新渲染组件, 由于 React 之前已经看过这个组件，它已经有了元数据关联。</li><li><code>React</code>将<code>nextHook</code>索引重置为<code>0</code>，并调用组件。</li><li>调用<code>useState</code>，React查看索引<code>0</code>处的hooks数组，并发现它已经在该槽中有一个hook。，所以无需重新创建一个，它将<code>nextHook</code>推进到索引<code>1</code>并返回<code>[volume，setVolume]</code>，其中<code>volume</code>仍设置为<code>80</code>。</li><li>再次调用<code>useState</code>。 这次，<code>nextHook</code>为<code>1</code>，所以<code>React</code>检查数组的索引<code>1</code>。同样，hook 已经存在，所以它递增<code>nextHook</code>并返回<code>[position，setPosition]</code>。</li><li>第三次调用<code>useState</code>，我想你知道现在发生了什么。</li></ol><p>就是这样了，知道了原理，看起来也就不那么神奇了， 但它确实依赖于一些规则，所以才有使用 <strong>Hooks</strong> 规则。</p><h2 id="Hooks-的规则"><a href="#Hooks-的规则" class="headerlink" title="Hooks 的规则"></a>Hooks 的规则</h2><p><a href="https://daveceddia.com/custom-hooks/" target="_blank" rel="noopener">自定义 hooks 函数</a>只需要遵守规则 3 ：它们的名称必须以<strong>“use”</strong>为前缀。</p><p>例如，我们可以从<code>AudioPlayer</code>组件中将3个状态提取到自己的自定义钩子中：</p><p>​                        </p><pre><code>function AudioPlayer() {  // Extract these 3 pieces of state:  const [volume, setVolume] = useState(80);  const [position, setPosition] = useState(0);  const [isPlaying, setPlaying] = useState(false);  // &lt; beautiful audio player goes here &gt;}</code></pre><p>因此，咱们可以创建一个专门处理这些状态的新函数，并使用一些额外的方法返回一个对象，以便更容易启动和停止播放，例如：</p><p>​                        </p><pre><code>function usePlayerState(lengthOfClip) {  const [volume, setVolume] = useState(80);  const [position, setPosition] = useState(0);  const [isPlaying, setPlaying] = useState(false);  const stop = () =&gt; {    setPlaying(false);    setPosition(0);  }  const start = () =&gt; {    setPlaying(true);  }  return {    volume,    position,    isPlaying,    setVolume,    setPosition,    start,    stop  };}</code></pre><p>像这样提取状态的一个好处是可以将相关的逻辑和行为组合在一起。可以提取一组状态和相关事件处理程序以及其他更新逻辑，这不仅可以清理组件代码，还可以使这些逻辑和行为可重用。</p><p>另外，通过在自定义<code>hooks</code>中调用自定义<code>hooks</code>，可以将<code>hooks</code>组合在一起。hooks只是函数，当然，函数可以调用其他函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hooks 提供了一种新的方式来处理React中的问题，其中的思想是很有意思且新奇的。</p><p>React团队整合了一组很棒的<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">文档</a>和一个常见<a href="https://reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">问题解答</a>，从是否需要重写所有的类组件到钩Hooks是否因为在渲染中创建函数而变慢? 以及两者之间的所有东西，所以一定要看看。</p><p>原文：<a href="https://segmentfault.com/a/1190000019966124" target="_blank" rel="noopener">快速了解 React Hooks 原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;为了保证的可读性，本文采用意译而非直译。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？&lt;/p&gt;
&lt;p&gt;React 早期版本，类组件可以通过继承&lt;code&gt;PureComponent&lt;/code&gt;来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 &lt;code&gt;React.memo&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React 16.8&lt;/strong&gt; 新出来的&lt;code&gt;Hook&lt;/code&gt;可以让React 函数组件具有状态，并提供类似 &lt;code&gt;componentDidMount&lt;/code&gt;和&lt;code&gt;componentDidUpdate&lt;/code&gt;等生命周期方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript React Hooks Hook 新技术 API" scheme="http://www.icrazyman.cn/tags/JavaScript-React-Hooks-Hook-%E6%96%B0%E6%8A%80%E6%9C%AF-API/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop</title>
    <link href="http://www.icrazyman.cn/2020/07/21/setTimeout%E5%92%8CsetImmediate%E5%88%B0%E5%BA%95%E8%B0%81%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%9C%AC%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Event%20Loop/"/>
    <id>http://www.icrazyman.cn/2020/07/21/setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop/</id>
    <published>2020-07-21T15:31:29.000Z</published>
    <updated>2020-07-21T15:36:30.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>笔者以前面试的时候经常遇到写一堆<code>setTimeout`</code>setImmediate<code>setImmediate</code>setTimeout(fn, 0)<code>setTimeout(fn, 0)</code>setImmediate<code>setTimeout</code>setImmediate<code>Promise</code>process.nextTick`</li></ul><a id="more"></a><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步异步简单理解就是，同步的代码都是按照书写顺序执行的，异步的代码可能跟书写顺序不一样，写在后面的可能先执行。下面来看个例子：</p><p>​                        </p><pre><code>const syncFunc = () =&gt; {  const time = new Date().getTime();  while(true) {    if(new Date().getTime() - time &gt; 2000) {      break;    }  }  console.log(2);}console.log(1);syncFunc();console.log(3);</code></pre><p>上述代码会先打印出1，然后调用<code>syncFunc</code>，<code>syncFunc</code>里面while循环会运行2秒，然后打印出2，最后打印出3。所以这里代码的执行顺序跟我们的书写顺序是一致，他是同步代码：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntmxhAJg0XjRLwt6phS7Yq1VmhY4HOtQCrKRvlCefnNeAviMmTNeq1sTBZo2cdHe7.PSclfqm5eEAzoJGSkFUofc!/b&amp;bo=5ABVAOQAVQADGTw!&amp;rf=viewer_4" alt="image-20200320144654281"></p><p>再来看个异步例子：</p><p>​                        </p><pre><code>const asyncFunc = () =&gt; {  setTimeout(() =&gt; {    console.log(2);  }, 2000);}console.log(1);asyncFunc();console.log(3);</code></pre><p>上述代码的输出是：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntgyoZQYvZYBfFE9.B3tU9YSMkrdM1ma*lSWeO0EOjDdBG1xx67vZVxewl4*cK0WwDhdeI*OZpeZvWILyyUNBHlI!/b&amp;bo=7wBcAO8AXAADGTw!&amp;rf=viewer_4" alt="image-20200320145012565"></p><p>可以看到我们中间调用的<code>asyncFunc</code>里面的2却是最后输出的，这是因为<code>setTimeout</code>是一个异步方法。他的作用是设置一个定时器，等定时器时间到了再执行回调里面的代码。所以异步就相当于做一件事，但是并不是马上做，而是你先给别人打了个招呼，说xxx条件满足的时候就干什么什么。就像你晚上睡觉前在手机上设置了一个第二天早上7天的闹钟，就相当于给了手机一个异步事件，触发条件是时间到达早上7点。<strong>使用异步的好处是你只需要设置好异步的触发条件就可以去干别的事情了，所以异步不会阻塞主干上事件的执行。特别是对于JS这种只有一个线程的语言，如果都像我们第一个例子那样去<code>while(true)</code>，那浏览器就只有一直卡死了，只有等这个循环运行完才会有响应</strong>。</p><h2 id="JS异步是怎么实现的"><a href="#JS异步是怎么实现的" class="headerlink" title="JS异步是怎么实现的"></a>JS异步是怎么实现的</h2><p>我们都知道JS是单线程的，那单线程是怎么实现异步的呢？事实上所谓的”JS是单线程的”只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntpVobNZY1jCpEKcmoIVUZ7f64srHNVju06EJxNJCmjXWrNWr*YkWMwrX1ePEsmJk9ZPSO6DEk7948VApMtY2oYw!/b&amp;bo=eAKaAXgCmgEDGTw!&amp;rf=viewer_4" alt="image-20200320151227013"></p><p>上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个选项卡崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。</p><p>对于前端工程师来说，主要关心的还是渲染进程，下面来分别看下里面每个线程是做什么的。</p><h3 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h3><p>GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。</p><h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h3><p>这个线程就是负责执行JS的主线程，前面说的”JS是单线程的”就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。<strong>需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的<code>while(true)</code>这样长时间的同步代码在真正开发时是绝对不允许的</strong>。</p><h3 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h3><p>前面异步例子的<code>setTimeout</code>其实就运行在这里，他跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步。JS的定时器方法还有<code>setInterval</code>，也是在这个线程。</p><h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><p>定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。</p><h3 id="异步HTTP请求线程"><a href="#异步HTTP请求线程" class="headerlink" title="异步HTTP请求线程"></a>异步HTTP请求线程</h3><p>这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。</p><p><strong>所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行</strong>。这个流程我们多次提到了任务队列，这其实就是Event Loop，下面我们详细来讲解下。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>所谓Event Loop，就是事件循环，其实就是JS管理事件执行的一个流程，具体的管理办法由他具体的运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。这两个环境的Event Loop还有点区别，我们会分开来讲。</p><h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p>事件循环就是一个循环，是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，这就是事件队列。各个异步线程执行完后，通过事件触发线程将回调事件放到事件队列，主线程每次干完手上的活儿就来看看这个队列有没有新活儿，有的话就取出来执行。画成一个流程图就是这样：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqxfHzpgW786JS8WOM2*YW1G1y6Ukudoy0dY8SUu4hCW2g5lXcYWbdeb5vV60tG*sXoGWyN17SAVL3wfEDRzPx8!/b&amp;bo=XQKdAV0CnQEDGTw!&amp;rf=viewer_4" alt="image-20200320161732238"></p><p>流程讲解如下:</p><blockquote><ol><li>主线程每次执行时，先看看要执行的是同步任务，还是异步的API</li><li>同步任务就继续执行，一直执行完</li><li>遇到异步API就将它交给对应的异步线程，自己继续执行同步任务</li><li>异步线程执行异步API，执行完后，将异步回调事件放入事件队列上</li><li>主线程手上的同步任务干完后就来事件队列看看有没有任务</li><li>主线程发现事件队列有任务，就取出里面的任务执行</li><li>主线程不断循环上述流程</li></ol></blockquote><h3 id="定时器不准"><a href="#定时器不准" class="headerlink" title="定时器不准"></a>定时器不准</h3><p>Event Loop的这个流程里面其实还是隐藏了一些坑的，最典型的问题就是总是先执行同步任务，然后再执行事件队列里面的回调。这个特性就直接影响了定时器的执行，我们想想我们开始那个2秒定时器的执行流程：</p><blockquote><ol><li>主线程执行同步代码</li><li>遇到<code>setTimeout</code>，将它交给定时器线程</li><li>定时器线程开始计时，2秒到了通知事件触发线程</li><li>事件触发线程将定时器回调放入事件队列，异步流程到此结束</li><li>主线程如果有空，将定时器回调拿出来执行，如果没空这个回调就一直放在队列里。</li></ol></blockquote><p>上述流程我们可以看出，如果主线程长时间被阻塞，定时器回调就没机会执行，即使执行了，那时间也不准了，我们将开头那两个例子结合起来就可以看出这个效果：</p><p>​                        </p><pre><code>const syncFunc = (startTime) =&gt; {  const time = new Date().getTime();  while(true) {    if(new Date().getTime() - time &gt; 5000) {      break;    }  }  const offset = new Date().getTime() - startTime;  console.log(`syncFunc run, time offset: ${offset}`);}const asyncFunc = (startTime) =&gt; {  setTimeout(() =&gt; {    const offset = new Date().getTime() - startTime;    console.log(`asyncFunc run, time offset: ${offset}`);  }, 2000);}const startTime = new Date().getTime();asyncFunc(startTime);syncFunc(startTime);</code></pre><p>执行结果如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntlNqpy8hDlfLWP.U5N3DHrevzPlyk.YNU4Eg.*X7jaKEmuFUVctzBqlut8GnEDXXN73EKj8vpsawfH7gU4MADN0!/b&amp;bo=aQFRAGkBUQADGTw!&amp;rf=viewer_4" alt="image-20200320163640760"></p><p>通过结果可以看出，虽然我们先调用的<code>asyncFunc</code>，虽然<code>asyncFunc</code>写的是2秒后执行，但是<code>syncFunc</code>的执行时间太长，达到了5秒，<code>asyncFunc</code>虽然在2秒的时候就已经进入了事件队列，但是主线程一直在执行同步代码，一直没空，所以也要等到5秒后，同步代码执行完毕才有机会执行这个定时器回调。<strong>所以再次强调，写代码时一定不要长时间占用主线程</strong>。</p><h3 id="引入微任务"><a href="#引入微任务" class="headerlink" title="引入微任务"></a>引入微任务</h3><p>前面的流程图我为了便于理解，简化了事件队列，其实事件队列里面的事件还可以分两类：宏任务和微任务。微任务拥有更高的优先级，当事件循环遍历队列时，先检查微任务队列，如果里面有任务，就全部拿来执行，执行完之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。所以完整的流程图如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntuKfUCYGVaVKMDCjga1*LPYDc7nDLa58gMv.xjIZpNshPRcEKhfavFnWRGhrdLDiRYAqHN.eEDYXz3Jg1twmM3U!/b&amp;bo=IAOVASADlQEDGTw!&amp;rf=viewer_4" alt="image-20200322201434386"></p><p>上图需要注意以下几点：</p><blockquote><ol><li>一个Event Loop可以有一个或多个事件队列，但是只有一个微任务队列。</li><li>微任务队列全部执行完会重新渲染一次</li><li>每个宏任务执行完都会重新渲染一次</li><li>requestAnimationFrame处于渲染阶段，不在微任务队列，也不在宏任务队列</li></ol></blockquote><p>所以想要知道一个异步API在哪个阶段执行，我们得知道他是宏任务还是微任务。</p><p>常见宏任务有：</p><blockquote><ol><li><code>script</code> (可以理解为外层同步代码)</li><li><code>setTimeout/setInterval</code></li><li><code>setImmediate</code>(Node.js)</li><li>I/O</li><li>UI事件</li><li><code>postMessage</code></li></ol></blockquote><p>常见微任务有：</p><blockquote><ol><li><code>Promise</code></li><li><code>process.nextTick</code>(Node.js)</li><li><code>Object.observe</code></li><li><code>MutaionObserver</code></li></ol></blockquote><p>上面这些事件类型中要注意<code>Promise</code>，他是微任务，也就是说他会在定时器前面运行，我们来看个例子:</p><p>​                        </p><pre><code>console.log(&#39;1&#39;);setTimeout(() =&gt; {  console.log(&#39;2&#39;);},0);Promise.resolve().then(() =&gt; {  console.log(&#39;5&#39;);})new Promise((resolve) =&gt; {  console.log(&#39;3&#39;);  resolve();}).then(() =&gt; {  console.log(&#39;4&#39;);})</code></pre><p>上述代码的输出是<code>1,3,5,4,2</code>。因为：</p><blockquote><ol><li>先输出1，这个没什么说的，同步代码最先执行</li><li><code>console.log(&#39;2&#39;);</code>在<code>setTimeout</code>里面，<code>setTimeout</code>是宏任务，“2”进入宏任务队列</li><li><code>console.log(&#39;5&#39;);</code>在<code>Promise.then</code>里面，进入微任务队列</li><li><code>console.log(&#39;3&#39;);</code>在Promise构造函数的参数里面，这其实是同步代码，直接输出</li><li><code>console.log(&#39;4&#39;);</code>在then里面，他会进入微任务队列，检查事件队列时先执行微任务</li><li>同步代码运行结果是“1，3”</li><li>然后检查微任务队列，输出“5，4”</li><li>最后执行宏任务队列，输出“2”</li></ol></blockquote><h3 id="Node-js的Event-Loop"><a href="#Node-js的Event-Loop" class="headerlink" title="Node.js的Event Loop"></a>Node.js的Event Loop</h3><p>Node.js是运行在服务端的js，虽然他也用到了V8引擎，但是他的服务目的和环境不同，导致了他API与原生JS有些区别，他的Event Loop还要处理一些I/O，比如新的网络连接等，所以与浏览器Event Loop也是不一样的。Node的Event Loop是分阶段的，如下图所示：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntjNmJSIQNChnV26.wmbjW1UAWoOD*DdKYBRBuvYjaHjZ5gTV2pBLAowLidPfOE2qQBt.fqWnBrxd812Z4iYvxSw!/b&amp;bo=BAPVAQQD1QEDGTw!&amp;rf=viewer_4" alt="image-20200322203318743"></p><blockquote><ol><li>timers: 执行<code>setTimeout</code>和<code>setInterval</code>的回调</li><li>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调</li><li>idle, prepare: 仅系统内部使用</li><li>poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li>check: <code>setImmediate</code>在这里执行</li><li>close callbacks: 一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code> </li></ol></blockquote><p>每个阶段都有一个自己的先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。在每次事件循环之间，Node.js都会检查它是否在等待任何一个I/O或者定时器，如果没有的话，程序就关闭退出了。我们的直观感受就是，如果一个Node程序只有同步代码，你在控制台运行完后，他就自己退出了。</p><p>还有个需要注意的是<code>poll</code>阶段，他后面并不一定每次都是<code>check</code>阶段，<code>poll</code>队列执行完后，如果没有<code>setImmediate</code>但是有定时器到期，他会绕回去执行定时器阶段：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqCAWB8JXtrh2tZd2DcoAKxHnhYBn.VBXspTOTaOogiYfGSk5FaNAQy6GhwLcDV24gAMbp2CmcY5CVYQTrHo3u8!/b&amp;bo=.AHvAfgB7wEDGTw!&amp;rf=viewer_4" alt="image-20200322205308151"></p><h4 id="setImmediate和setTimeout"><a href="#setImmediate和setTimeout" class="headerlink" title="setImmediate和setTimeout"></a><code>setImmediate</code>和<code>setTimeout</code></h4><p>上面的这个流程说简单点就是<strong>在一个异步流程</strong>里，<code>setImmediate</code>会比定时器先执行，我们写点代码来试试：</p><p>​                        </p><pre><code>console.log(&#39;outer&#39;);setTimeout(() =&gt; {  setTimeout(() =&gt; {    console.log(&#39;setTimeout&#39;);  }, 0);  setImmediate(() =&gt; {    console.log(&#39;setImmediate&#39;);  });}, 0);</code></pre><p>上述代码运行如下:</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntgT9kk.JtZpaZiRQCQ3DA0YGYCY9tbvaTL3HKhW3z4t.LWBU5r5wY5rNU7KeGQ6rjQiwQKqYNei*dgmwiVi*k8U!/b&amp;bo=iAI.AIgCPgADGTw!&amp;rf=viewer_4" alt="image-20200322210304757"></p><p>和我们前面讲的一样，<code>setImmediate</code>先执行了。我们来理一下这个流程：</p><blockquote><ol><li>外层是一个<code>setTimeout</code>，所以执行他的回调的时候已经在<code>timers</code>阶段了</li><li>处理里面的<code>setTimeout</code>，因为本次循环的<code>timers</code>正在执行，所以他的回调其实加到了下个<code>timers</code>阶段</li><li>处理里面的<code>setImmediate</code>，将它的回调加入<code>check</code>阶段的队列</li><li>外层<code>timers</code>阶段执行完，进入<code>pending callbacks</code>，<code>idle, prepare</code>，<code>poll</code>，这几个队列都是空的，所以继续往下</li><li>到了<code>check</code>阶段，发现了<code>setImmediate</code>的回调，拿出来执行</li><li>然后是<code>close callbacks</code>，队列是空的，跳过</li><li>又是<code>timers</code>阶段，执行我们的<code>console</code> </li></ol></blockquote><p>但是请注意我们上面<code>console.log(&#39;setTimeout&#39;)</code>和<code>console.log(&#39;setImmediate&#39;)</code>都包在了一个<code>setTimeout</code>里面，如果直接写在最外层会怎么样呢？代码改写如下:</p><p>​                        </p><pre><code>console.log(&#39;outer&#39;);setTimeout(() =&gt; {  console.log(&#39;setTimeout&#39;);}, 0);setImmediate(() =&gt; {  console.log(&#39;setImmediate&#39;);});</code></pre><p>我们来运行下看看效果：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntpa.*J7bA6trO7UNpXoxzAD3yNEUAzhakRb*ksQEnBW8k9X4NEo2jhiKnyKOfwcr08oRRHjJf3a3rTEfanvltrE!/b&amp;bo=fAJAAHwCQAADGTw!&amp;rf=viewer_4" alt="image-20200322214105295"></p><p>好像是<code>setTimeout</code>先输出来，我们多运行几次看看:</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knto8HLB8.x.9zbvrEitK8PVoxyEegwTP6*evRNDF..Dx08M*IQheZ2GjttEMm15kcpqPq7m5gYa9lyhCqYhQriW8!/b&amp;bo=gQI.AIECPgADGTw!&amp;rf=viewer_4" alt="image-20200322214148090"></p><p>怎么<code>setImmediate</code>又先出来了，这代码是见鬼了还是啥？这个世界上是没有鬼怪的，所以事情都有原因的，我们顺着之前的Event Loop再来理一下。在理之前，需要告诉大家一件事情，node.js里面<code>setTimeout(fn, 0)</code>会被强制改为<code>setTimeout(fn, 1)</code>,<a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args" target="_blank" rel="noopener">这在官方文档中有说明</a>。(说到这里顺便提下，HTML 5里面<code>setTimeout</code>最小的时间限制是4ms)。原理我们都有了，我们来理一下流程：</p><blockquote><ol><li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li><li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但是被node.js强制改为1毫秒，塞入<code>times</code>阶段</li><li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li><li>同步代码执行完毕，进入Event Loop</li><li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li><li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li></ol></blockquote><p>通过上述流程的梳理，我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，<code>setTimeout</code>执行，如果1毫秒还没到，就先执行了<code>setImmediate</code>。每次我们运行脚本时，机器状态可能不一样，导致运行时有1毫秒的差距，一会儿<code>setTimeout</code>先执行，一会儿<code>setImmediate</code>先执行。但是这种情况只会发生在还没进入<code>timers</code>阶段的时候。像我们第一个例子那样，因为已经在<code>timers</code>阶段，所以里面的<code>setTimeout</code>只能等下个循环了，所以<code>setImmediate</code>肯定先执行。同理的还有其他<code>poll</code>阶段的API也是这样的，比如：</p><p>​                        </p><pre><code>var fs = require(&#39;fs&#39;)fs.readFile(__filename, () =&gt; {    setTimeout(() =&gt; {        console.log(&#39;setTimeout&#39;);    }, 0);    setImmediate(() =&gt; {        console.log(&#39;setImmediate&#39;);    });});</code></pre><p>这里<code>setTimeout</code>和<code>setImmediate</code>在<code>readFile</code>的回调里面，由于<code>readFile</code>回调是I/O操作，他本身就在<code>poll</code>阶段，所以他里面的定时器只能进入下个<code>timers</code>阶段，但是<code>setImmediate</code>却可以在接下来的<code>check</code>阶段运行，所以<code>setImmediate</code>肯定先运行，他运行完后，去检查<code>timers</code>，才会运行<code>setTimeout</code>。</p><p>类似的，我们再来看一段代码，如果他们两个不是在最外层，而是在<code>setImmediate</code>的回调里面，其实情况跟外层一样，结果也是随缘的，看下面代码:</p><p>​                        </p><pre><code>console.log(&#39;outer&#39;);setImmediate(() =&gt; {  setTimeout(() =&gt; {    console.log(&#39;setTimeout&#39;);  }, 0);  setImmediate(() =&gt; {    console.log(&#39;setImmediate&#39;);  });});</code></pre><p>原因跟写在最外层差不多，因为<code>setImmediate</code>已经在<code>check</code>阶段了，里面的循环会从<code>timers</code>阶段开始，会先看<code>setTimeout</code>的回调，如果这时候已经过了1毫秒，就执行他，如果没过就执行<code>setImmediate</code>。</p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h4><p><code>process.nextTick()</code>是一个特殊的异步API，他不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进行，会马上停下来执行<code>process.nextTick()</code>，这个执行完后才会继续Event Loop。我们写个例子来看下：</p><p>​                        </p><pre><code>var fs = require(&#39;fs&#39;)fs.readFile(__filename, () =&gt; {    setTimeout(() =&gt; {        console.log(&#39;setTimeout&#39;);    }, 0);    setImmediate(() =&gt; {        console.log(&#39;setImmediate&#39;);        process.nextTick(() =&gt; {          console.log(&#39;nextTick 2&#39;);        });    });    process.nextTick(() =&gt; {      console.log(&#39;nextTick 1&#39;);    });});</code></pre><p>这段代码的打印如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntltJ0p4en.Ek.HQf.ZDFXuqm941HK.M.Fh53KPAYDuWDoKItlYnlkYEQ.JddoTaVuUHVai1f..2Ubmb.PksmYXk!/b&amp;bo=fgJLAH4CSwADGTw!&amp;rf=viewer_4" alt="image-20200322221221927"></p><p>我们还是来理一下流程:</p><blockquote><ol><li>我们代码基本都在<code>readFile</code>回调里面，他自己执行时，已经在<code>poll</code>阶段</li><li>遇到<code>setTimeout(fn, 0)</code>，其实是<code>setTimeout(fn, 1)</code>，塞入后面的<code>timers</code>阶段</li><li>遇到<code>setImmediate</code>，塞入后面的<code>check</code>阶段</li><li>遇到<code>nextTick</code>，立马执行，输出’nextTick 1’</li><li>到了<code>check</code>阶段，输出’setImmediate’,又遇到个<code>nextTick</code>,立马输出’nextTick 2’</li><li>到了下个<code>timers</code>阶段，输出’setTimeout’</li></ol></blockquote><p>这种机制其实类似于我们前面讲的微任务，但是并不完全一样,比如同时有<code>nextTick</code>和<code>Promise</code>的时候，肯定是<code>nextTick</code>先执行，原因是<code>nextTick</code>的队列比<code>Promise</code>队列优先级更高。来看个例子:</p><p>​                        </p><pre><code>const promise = Promise.resolve()setImmediate(() =&gt; {  console.log(&#39;setImmediate&#39;);});promise.then(()=&gt;{    console.log(&#39;promise&#39;)})process.nextTick(()=&gt;{    console.log(&#39;nextTick&#39;)})</code></pre><p>代码运行结果如下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntkJShUaiRUbKt0YBM53Re6VQzzBeZxeji4V6Mp7hT2WfRhwLkIoBHSxPYkgrL95sbxwDWA3bVnJ8qVuqbDACYZ4!/b&amp;bo=fAI.AHwCPgADGTw!&amp;rf=viewer_4" alt="image-20200323094907234"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从异步基本概念出发一直讲到了浏览器和Node.js的Event Loop，现在我们再来总结一下：</p><ol><li>JS所谓的“单线程”只是指主线程只有一个，并不是整个运行环境都是单线程</li><li>JS的异步靠底层的多线程实现</li><li>不同的异步API对应不同的实现线程</li><li>异步线程与主线程通讯靠的是Event Loop</li><li>异步线程完成任务后将其放入任务队列</li><li>主线程不断轮询任务队列，拿出任务执行</li><li>任务队列有宏任务队列和微任务队列的区别</li><li>微任务队列的优先级更高，所有微任务处理完后才会处理宏任务</li><li><code>Promise</code>是微任务</li><li>Node.js的Event Loop跟浏览器的Event Loop不一样，他是分阶段的</li><li><code>setImmediate</code>和<code>setTimeout(fn, 0)</code>哪个回调先执行，需要看他们本身在哪个阶段注册的，如果在定时器回调或者I/O回调里面，<code>setImmediate</code>肯定先执行。如果在最外层或者<code>setImmediate</code>回调里面，哪个先执行取决于当时机器状况。</li><li><code>process.nextTick</code>不在Event Loop的任何阶段，他是一个特殊API，他会立即执行，然后才会继续执行Event Loop</li></ol><p>作者：蒋鹏飞<br>        链接：<a href="https://segmentfault.com/a/1190000023315304" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023315304</a><br>        来源：SegmentFault 思否<br>        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;笔者以前面试的时候经常遇到写一堆&lt;code&gt;setTimeout`&lt;/code&gt;setImmediate&lt;code&gt;setImmediate&lt;/code&gt;setTimeout(fn, 0)&lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;setImmediate&lt;code&gt;setTimeout&lt;/code&gt;setImmediate&lt;code&gt;Promise&lt;/code&gt;process.nextTick`&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端 javaScript node.js eventloop" scheme="http://www.icrazyman.cn/tags/%E5%89%8D%E7%AB%AF-javaScript-node-js-eventloop/"/>
    
  </entry>
  
  <entry>
    <title>优秀技术人，如何做到高效沟通？</title>
    <link href="http://www.icrazyman.cn/2020/07/21/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E4%BA%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%EF%BC%9F/"/>
    <id>http://www.icrazyman.cn/2020/07/21/优秀技术人，如何做到高效沟通？/</id>
    <published>2020-07-21T09:30:29.000Z</published>
    <updated>2020-07-21T15:36:19.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>简介：</strong> 世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。</p><p> <img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnKZ92b3oVl5whUSbe.MZ3Bvy9UlUi6.lE*dMlO0.XRwtp*XuZV7*zx8MV5ApmZwNrGa1aBl8H3ZxOHBjjFzVv8!/b&amp;bo=IAOgASADoAEDKQw!&amp;rf=viewer_4" alt="1.png"> </p><p>作者 | 鲁佳(鹿迦) 阿里巴巴项目管理专家</p><p><strong>导读：</strong>世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。</p><a id="more"></a><h1 id="为什么沟通那么重要"><a href="#为什么沟通那么重要" class="headerlink" title="为什么沟通那么重要"></a>为什么沟通那么重要</h1><p>谁都知道在工作中沟通是非常重要的，那大家有没有真正想过为什么沟通这么重要呢？</p><p>首先我们想想看，在你的日常工作时间分配上，“沟通”所用的时间占比多少呢？日常的会议、在钉钉上的讨论、处理邮件等等，反正我个人是远远超过了 50% 的。这就和管理学上的一个著名理论很契合了：</p><blockquote><p>管理者 50% 以上的时间用在了沟通上，但同时工作中 50% 以上的障碍都是在沟通中产生的。</p></blockquote><p>这就是<strong>“双 50% 理论”</strong>，这直观的反应了不论是在占用时间上，还是对工作的影响程度上，沟通都是至关重要的。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knti7CUNIrFFi9kz2L3DKXCTrzaMrpSibaL2KD.jk9V038QL1Y4rVnLH8u28Hss0nW9dpI0efKdKrCtQCB3b4Jj.Q!/b&amp;bo=IAMEAiADBAIDORw!&amp;rf=viewer_4" alt="2.png"></p><p>为什么团队里开会大家总是很沉默，有想法的同学也不吭声？上面这个图大家应该在各种不同的渠道都看到过吧，相信大在第一次看到这个图的时候都会和我一样会心一笑吧。</p><p>为什么这张图能有这样的效果呢？因为这个图所表现出来的问题真的非常好的影射了我们日常实际工作的情况：<strong>由于沟通不到位的问题导致一个产品在不同的角色的理解上造成了这么巨大的差异</strong>。那么在像阿里这样的互联网公司，工作量常见的沟通问题都要哪些呢？</p><p>这里做一些简单的列举：</p><ul><li>为什么推动兄弟团队配合这么难，他们配合的进度完全不可控？</li><li>为什么工作布置给了下属，但是最后又都堆积到了我这里？</li><li>为什么会议讨论留下来的 action 执行起来总是拖拖拉拉完成不了？</li><li>为什么老板最近的消息经常已读不回？</li><li>为什么整天被钉钉消息淹没了，个人的事情只能在夜深人静加班做了？</li><li>……</li></ul><p>这么多的沟通问题，那沟通问什么这么困难呢？这里从最常见的情况来看，特别是在 1 对 1 的沟通中，主要有三个主要的原因：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntvr5ptLRlZnwZgBqR3bcTj3mJAEi0emR5u7mgGpttpyentnUZqFQB47gb7F4yRCYP4os*.VKHNCavG8Si1aI0hg!/b&amp;bo=IAOUASADlAEDGTw!&amp;rf=viewer_4" alt="3.png"></p><p>既然沟通的问题很多，导致问题的原因也非常复杂，那我们的出路在哪里呢？是不是解决办法就是标准化我们的工作，然后通过标准化、流程化来让我们的工作减少沟通的需求，然后大家都可以在自己的工位安安静静写代码、写方案、这样就万事大吉了呢？答案是否定的。</p><p>我们来看这个象限图，这个是李开复博士在对未来 AI 的设想中提到的一个模型：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knti0jcMCt2Ci7bIGWoymBhfiEKVE3Du6cIRlv.O8tjdrNzKokJCwQ3VQbMGTzpG4qYIg8OwdBEWVuNc2b0NhEUgI!/b&amp;bo=IAO3ASADtwEDKQw!&amp;rf=viewer_4" alt="4.png"></p><p>可以看到，在区间图的左下角的岗位对应的是低社交需求，并且是结构化的领域，在这样的领域的岗位，未来 5-10 就会被 AI 机器人所取代。</p><p>如果我们的工作能够简单的通过定义标准化的接口做到按流程执行，从而避免或减少沟通，那我们的工作的价值就会降低，从而最终被机器取代，就像流水线上的工人正在大量被智能机器人所取代那样。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntv1FFeuM8n7CfmKfo4wd7YcmJNrE*5eg5Ib4LevNZfE1rZbjmao8lC4rCTaiaw1dpMYLqALD36puhpsU79n*PTk!/b&amp;bo=IAMbASADGwEDORw!&amp;rf=viewer_4" alt="5.png"></p><p>我想说的意思不是说为了体现工作的价值，要故意提高工作的沟通成本，相反，我们的确需要通过归纳总结梳理标准话的流程、甚至是工具化的手段来降低一个领域的沟通，但我们同时工作在找更复杂、更需要去沟通的场景中，去创造更大的价值。</p><p>所以我们要做的是<strong>保持竞争力，持续提升沟通能力</strong>。这个才是大家每个人要持续努力的方向。</p><h1 id="沟通的基础"><a href="#沟通的基础" class="headerlink" title="沟通的基础"></a>沟通的基础</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntj*aLMNOw88KubHENWOqvhiih9bnVV6f.Go.V169wxyI6J7duk1COOE2s4fe5QezV4lY3rIYQbhpQDHVF4BXTDM!/b&amp;bo=IAMzAiADMwIDSWw!&amp;rf=viewer_4" alt="6.png"></p><p>有一个西方的谚语是这么说的，“世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。”就像图上的这个场景一样，在沟通遇到问题的时候，大家往往都会觉得自己是对的，都想要说服对方，但有都总是困难重重。</p><p>沟通失败的原因总是多种多样，要么是表达上的问题，要么是倾听和反馈上的问题，要么是环境上带来的问题。列举下来，一般的情况有：</p><ul><li>缺乏信息或知识</li><li>没有说明重要性</li><li>只注重了表达、没有注重倾听</li><li>没有完全理解对方的话，以至于询问不当</li><li>没有注重反馈</li><li>时间不够</li><li>不良情绪</li><li>职位的差距、文化的差距</li></ul><p>首先，我们来一起了解一下沟通模型。沟通是从信息发送者出发，到信息接受者收到消息，然后给出反馈到信息发送者的一个完整闭环。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntk9uiF5RI37ymmVus*kLfqAEou*49srIufRwlll8T3KsvMMJebBRF5T*ooGkPzG1pIJPLcKQM0wWR.L4eYnJrpo!/b&amp;bo=IAOcASADnAEDGTw!&amp;rf=viewer_4" alt="7.png"></p><p>这里的编码，可能是文字，也可以是声音，甚至是手势、表情；通道可以是钉钉、邮件、视频、也可以是面对面；各种外界环境可能带来噪音，比如心情不好，或者大家背景不同、缺少共同语言，并行沟通的影响等等。</p><p>可以看到，一个最小闭环的沟通过程，因为涉及多个环节，其实形成了一个较长的链路，链路一旦长了，在链路上的各个环节都容易出现问题，最终就会将问题层层放大。这里就必须给大家介绍一下沟通漏斗的理论了。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntixkNl9.OLEqhOgppV9pvJnKpcwnL7QDPHIl9bl7XQOkUnNBtzdbw3Rd1zezn6XPyD6.wC3eGS1UbKullRlilpo!/b&amp;bo=IAOLASADiwEDGTw!&amp;rf=viewer_4" alt="8.png"></p><p>这里必须要知道沟通漏斗的形成过程。举个例子，比如一个开发的 leader，发现最近项目开发中引入的问题比较多，产品好几次遇到严重的线上质疑，于是他决定开个会整改，晚上睡不着觉心里想怎么解决呢？</p><p>想到了 10 个方面（100%）的问题的，需要与下属员工讲。当第二天站在众人面前开会时，由于没休息好并且紧张，想到的 10 件事情，只说出了其中的 8 件，漏掉了 2 件，也就是只说出了 80%。而这 8 件事在当众讲的时候，由于场地的限制、人员的多少等关系影响，造成员工真正听到的是有 6 件事（60%）。</p><p>又由于员工水平、知识背景的差异，我们的技术 leader 语言表达的高低、语言口音方言等实际情况，真正被别人理解、消化的东西大概只有 40%。等到这些人去落地执行时，由于每件事情与个人关系的大小、执行的意愿强弱等因素，造成到最后得到执行的已经变成 20% 了；虽然这个比例比较夸张，实际并没有这么严重，但是这个沟通造成的漏斗确是实实在在存在的，我们只能想办法将他变得影响越小越好。</p><p>那么到底有没有办法减少或消除这个沟通造成的漏斗现象呢？我们从说、听、问三个角度来看一下。</p><h2 id="沟通基础一：表达"><a href="#沟通基础一：表达" class="headerlink" title="沟通基础一：表达"></a>沟通基础一：表达</h2><p>沟通的基础，第一条就是表达，就是发送信息。我们的马老师是公认的演讲高手，他的表达能力就非常强。</p><p>在表达上，除了我们大家比较了解的，需要有易懂的语言、清晰地逻辑，我们还需要注意什么呢？看马老师的形象我们就清楚了，那就是语气、表情、肢体动作这些。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knttn1TWZHASuZOI9V4SifG8Is6LYbIJfM3hLJuyAAorpZATbgggQef.p5hrAGyIs2KgMJJfk1*LMfvNF4*Yx28r8!/b&amp;bo=IANyASADcgEDKQw!&amp;rf=viewer_4" alt="9.png"></p><p>在沟通管理领域，有一个非常著名的理论，<strong>“沟通 = 7% 内容 + 38% 声音 + 55% 肢体语言”</strong>，这充分说明了身体语言在沟通过程中的重要性。这里，给大家在沟通表达时的身体语言提供一些建议：</p><ul><li>语言和身体语言必须保持一致</li><li>设法一开始引起对方的注意</li><li>如果必要，需要重复、改述</li><li>用对方熟悉的语言</li><li>要：正面面对、点头、微笑、身体前倾、目光接触</li><li>不要：双手抱在胸前、眼神游离、干别的事</li></ul><p>再举一个我们日常中最常见的例子。日常我们用钉钉做沟通比较多，同样的一句话，如果用不同的语调会表示不同的态度、表达不同的意思（如“这个需求提测了吗？”，是询问还是催促？）。所以我在钉钉上询问别人类似的问题时，总担心被误解，一般都会增加一个笑脸的表情包，不知道大家有没有这样的做法呢？^_^</p><h2 id="沟通基础二：倾听"><a href="#沟通基础二：倾听" class="headerlink" title="沟通基础二：倾听"></a>沟通基础二：倾听</h2><p>沟通的第二个基础就是听。沟通的关键往往是接收者、听者，而非说话者。越是成功的人，往往越是擅于倾听的人。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnLDy.qV9BQp3qITpwCUD3pCH4sXiu3Il5Gy3uxJ*pljr4R7PAdlPq7KoJgXNyaEe5oKLSdGnzHg5UNol6eVP3M!/b&amp;bo=IAOkASADpAEDGTw!&amp;rf=viewer_4" alt="10.png"></p><p>相对于简体字（用口听），繁体字的“听”更能体现倾听的精髓（看来我们古人还是的智慧还是很了不起的）：</p><ul><li><strong>“耳王”</strong>：既然是听，最重要的器官无疑是耳朵，所以听的要义就是以耳为王，带着耳朵来，把倾听放在第一位；</li><li><strong>“十四”</strong>：其中的“四”可以看成“目”，也就是眼睛。听不光用耳朵，还要用眼睛，对方的眼神、表情、肢体语言，都包含着丰富的信息，是与对方提供的资料或实物相配合的；</li><li><strong>“一心”</strong>：要达到沟通的目的，收到最佳的效果，必须要用心，而且要一心一意。是用心去听讲，用心去观察，用心去提问，用心去思考。</li></ul><p>倾听也分成几个不同的层次：</p><ul><li>听而不闻</li><li>假装倾听</li><li>选择性倾听</li><li>专注的倾听</li><li>设身处地的倾听</li></ul><p>其他第五层和第四层的区别是，专注的听还是为了对听到的内容作出反应，但设身处地的听是为了了解对方，而不是为了做反应，目的是通过交流了解对方的观念、感受，真正做到同理心。</p><h2 id="沟通基础三：提问"><a href="#沟通基础三：提问" class="headerlink" title="沟通基础三：提问"></a>沟通基础三：提问</h2><p>沟通的第三个基础就是提问，会提问的人更是沟通达人。擅长说的人，沟通的主要时间都是他在讲，不用担心冷场，而且他可以讲得很精彩。典型的就是培训老师；擅长问的人，和他说话时他说的不多，但往往提出一些发人深省的问题，让你娇躯（或者虎躯）一震，打开一个新的世界。所以，善于提问的人才是正在引导沟通方向的人。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntr9UXEbLrKRyF647WJZyUGLvDmabD5p7b*BCZ8RJvFHCjluH3gipjUdcj6kjfA9hnCtS*WsTEgvQLf4987n1Uic!/b&amp;bo=IAOeASADngEDGTw!&amp;rf=viewer_4" alt="11.png"></p><p>一般提问的方式有四种，不同的场合环境和目的需要采用不同的提问方式：</p><ul><li><strong>封闭式</strong>：你同意这个方案吗？我们能按期完成这个任务吗？</li><li><strong>开放式</strong>：你有什么好的建议吗？</li><li><strong>引导式</strong>：如果资源的问题解决了，你第一步打算怎么做？</li><li><strong>反问式</strong>：如果你一味地回答对方问题，就会很容易陷入被动局势。如何让谈话走上你的频道？反问式提问便是一个高招， 例如：“我想问一下，这个需求开发排期是怎么样的？”“那业务的运营节奏是怎样的呢？”</li></ul><h1 id="团队内沟通和跨团队沟通"><a href="#团队内沟通和跨团队沟通" class="headerlink" title="团队内沟通和跨团队沟通"></a>团队内沟通和跨团队沟通</h1><p>接下来给大家介绍三组最常见的沟通场景，这些沟通场景也是日常工作中最容易遇到困难的地方。首先介绍团队内的沟通和跨团队的沟通。</p><h2 id="1-团队内沟通"><a href="#1-团队内沟通" class="headerlink" title="1. 团队内沟通"></a>1. 团队内沟通</h2><p>团队内的沟通是大家每个人首先要面的的场景。在团队里，一般来说有3种沟通的模式。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntoXtLjUy.UiO1g2tZ*6pBnmFpaSMOOxa89MhcmFk*T4Z5ThoFYWmknyloFiCiOznUWrKDHwwzOCOPG4HNycnWs8!/b&amp;bo=IAMOASADDgEDGTw!&amp;rf=viewer_4" alt="12.png"></p><ul><li><strong>链式：</strong>严格遵循正式的指挥链和沟通链，信息线性传递，如在军事化的组织里就比较常见；</li><li><strong>轮式：</strong>轮式沟通仰赖核心人物作为所有成员沟通的引线和中心节点，可以激发强而有力的领导人物出现；</li><li><strong>网式：</strong>允许所有团体成员积极主动的沟通，所有成员均能自由的贡献自我，没有信息的中间节点，也没有明显的领导者角色。</li></ul><p>这里，我们对这三种模式做了一个对比：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntnmu6wLy*09j9c*IvIhyZLq7koGJUvI*yk*cD9pJ3bbFOhgSuYPf8zHKHVQuP.5VfirDTxtXPkmreiMI.yHMV9o!/b&amp;bo=IAOqASADqgEDGTw!&amp;rf=viewer_4" alt="13.png"></p><p>在像阿里这种互联网的公司里，如果没有特别的原因，我们会更倾向引导团队超第三种模式，“网状”的沟通模式发展。推荐网状的沟通模式并不是说我们对准确性的要求不高，相反，因为我们有很多非常有效的工具，能够保障我们在网状沟通中仍然保持较高的信息准确性，比如语雀、Aone、钉钉等。</p><p>在团队沟通里，我们就不得不提团队沟通协作的五大障碍。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntm0TDh7aPzTvXA3mK.isCXKXUoo2gWnpjcIZHdwQRh399RKR7KTLvF.EfP75xMquhiTo8i0y1ucF08TTvKElang!/b&amp;bo=IAN4ASADeAEDGTw!&amp;rf=viewer_4" alt="14.png"></p><ul><li><p>首先在团内里经常出现的问题是“缺少信任“，这个在新组建的团队里特别常见；  </p></li><li><p>缺少信任之后就会给团队带来第二个问题，那就是”害怕冲突“，最常见的就是在会议上大家都沉默不发言；因为缺少信任，大家不知道自己不同的意见会导致别人什么样的反应，为了安全，不发言是最稳妥的；</p></li><li><p>害怕冲突的团队自然会带来第三个问题”缺乏承诺“。可以想象，如果自已不同的观点没有表达出来，那么团队最终达成的结论，我是不会有太强的承诺的，因为自己对这个结论心里并不认同；  </p></li><li><p>缺乏承诺继续会导致问题，那就是”逃避责任“，没有承诺的结论如果后续导致了不好的结果，团队成员自然不想对这个结果承担责任，他会心里想，这个本来就不是我希望的做法，看，果然出问题了吧；  </p></li><li><p>逃避责任的最终就会团队成员”忽视结果“，如果团队成员自己团队的结果都无感了，那么这个团队也就名存实亡了。</p></li></ul><p>如果大家对团队沟通协作的五大障碍有兴趣，希望更深入的了解，推荐大家看一本书《团队协作的五大障碍》。</p><p>那问题来了，对于团队里沟通协作的五大障碍之首的”信任“，要怎么培养呢？在团队里建立信任我们有很多办法，比如从小的来说我们要加强团队成员的相互了解，在阿里，我们常见的有破冰（想必大家都经历过）、team building 等等，还有一个建立信任的说法是”一起同过窗,一起扛过枪“，这样大家就比较容易建立相互信任的关系。</p><p>不过建立信任也不一定是这样刻意，或者一定要经历历史性的大战役才能培养，其实“信任”是在一次次达成并保持的小的约定的基础上建立起来的。比如大家约定的一个文档产出时间，大家约定的一个会前准备工作，只要类似这种小小的约定能持续达成，大家间的信任就能有效的建立。</p><p>团队里的冲突往往是破坏团队沟通氛围的重要因素，不希望团队里有成员的冲突往往是大家共同的想法。不过这里要想和大家聊一聊的是，冲突对于团队的沟通一定是件坏事情吗？</p><p>答案是否定的，团队可以从健康的富有成效的分歧及处理中得到成长。对团队不利的是”破坏性冲突“，但对团队有价值的是”建设性的冲突“，我们一起来看看这两种冲突有什么区别：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntlf2NmndMFhNCo9oB4ieaG9hO5dhOtUcHHGqxVAHBHvHfL3qCYYIXVv1Yo.YROueZU8CczFRDnIpgHo*BcGqLiI!/b&amp;bo=IANlASADZQEDKQw!&amp;rf=viewer_4" alt="15.png"></p><p>在团队里，阻碍健康冲突的原因一般有：</p><ul><li>缺乏信任、尊重和理解</li><li>过强势的管理风格</li><li>团队成员不稳定或跨地域</li></ul><h2 id="2-跨团队沟通"><a href="#2-跨团队沟通" class="headerlink" title="2. 跨团队沟通"></a>2. 跨团队沟通</h2><p>在跨团队沟通我们经常遇到的各种问题，我们先简单给大家罗列一下：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqTV1ZkgFVO3hG4Hjq32RwYY504L6sRLFYFWjO5sLi2jEM8VwYlHUcS4fU64tTD8bawzFmXjrSuLl7yBxrwOS6U!/b&amp;bo=IAPAASADwAEDKQw!&amp;rf=viewer_4" alt="16.png"></p><ul><li>专业有 gap，缺少共同语言。比如业务开发的团队依赖中台的能力，如果业务开发团队不了解中台产品的当前现有的体系，讲不清楚对中台需求的需求，就会出现这种情况，最终导致沟通意愿受损，沟通出问题；</li><li>目标达不成一致（受部门墙的影响），比如你计划一个战略级的项目规划，但是需要其他部门来支持你，在前期调研的时候很配合，真正开始实施了，你也许发现他们的态度发生了变化，他们不打算真的做较大投入了，因为这个和他们团队的目标不匹配；</li><li>进度不透明。和兄弟团队约定好了交付的时间，但是中间过程没有沟通，完全是个黑盒，到了约定的时间快到了才发现很多东西还没有准备好；</li><li>职责不清、问题推诿。沟通中经常遇到大家因为分工不清导致工作相互推诿，一些灰色的工作找不到负责人，一旦灰色领域出了问题，又没有人愿意来背锅。</li></ul><p>那面对这些问题，我们该怎么解决了？这里给大家提供一个跨部门沟通的原则：</p><ul><li>首先是要大家一起确定目标：一个共赢的目标，不能只是你的目标，一开始就要设定一个大家都能实现自己价值的目标，这样对方才有意愿和你合作；</li><li>第二个就是要明确分工、职责、时间、责任人等，做到”亲兄弟、明算账“，俗话说的”丑话说在前面“也是这个意思；</li><li>第三个就是一开始要确认好沟通机制，做到信息互通，比如周会、周报等，确保过程中信息透明；</li><li>第四个就是在问题的处理上要有责任、有担当、同理心，不能是有好处大家都凑过来，一旦出了问题大家就翻脸不认人，和人一样，团队也要注意信誉。</li></ul><p>因为跨团队沟通往往双方不像在团队里那样，双方可能不是很了解，没有太多的信任感，所以当双方刚坐下来，还没开始沟通，大家的座位方式已经极大的影响了沟通的结果。这里给大家介绍一下几种不同沟通座位可能带来的影响。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntsMBQcQacWTS5NetKOpGNxI4IGojFEzIM0pEKQf91iTB4vuDhabahPzTQ7JeZZjSU9mCNgMNQLAXo.48f*tLIOM!/b&amp;bo=IAOfASADnwEDGTw!&amp;rf=viewer_4" alt="17.png"></p><h1 id="向上沟通和向下沟通"><a href="#向上沟通和向下沟通" class="headerlink" title="向上沟通和向下沟通"></a>向上沟通和向下沟通</h1><p>第二组经常遇到问题的沟通场景就是向上沟通和向下沟通。</p><h2 id="1-向上沟通"><a href="#1-向上沟通" class="headerlink" title="1. 向上沟通"></a>1. 向上沟通</h2><p>讲到”向上沟通“，我们就在提一下”向上管理“，先看一下这两个概念的解释。</p><ul><li><strong>向上管理</strong>，为了给上级和自己取得更好的结果而有意识地配合上级一起工作的过程，可以说，这是让上级改变的过程；向上管理不是领导上级，而是通过向上沟通、向上协调去影响及引导上级的看法与自己协调一致；</li><li><strong>向上沟通</strong>，向上沟通是向上管理的主要手段之一，一般指和上级有目的性的沟通行为，从而向上传递必要的信息或影响其决定；</li></ul><p>向上沟通是一种“有目的性的”向上管理行为，如果是那种在teambuilding时候很放松的闲聊，我们暂不归类到向上沟通里面。那向上沟通的难点是什么呢？</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knto*jogIESexcOI6Zn1cDZ56ds3*SZxu7qktfRHOMXdvXUPRRIRH*WdTgAXSzzbRmWpyNo1I6onlB1jOMDir8D5U!/b&amp;bo=IAPuAiAD7gIDORw!&amp;rf=viewer_4" alt="18.png"></p><ul><li><strong>传统观念</strong>：中国人已提到向上管理和向上沟通，可能就各种各样的问题都出来了。就如上图，这个是西周的“天子统三公、三公治诸侯”的一个金字塔，这就是中国过去传统的一个很明确、很强烈的等级观念，比如常见的“官大一级压死人”；在中国，这个是一个历史文化的传承，即使到了今天一个自有民主的社会环境，即使在像阿里这样开明的互联网公司，这中固有的观念还是会潜移默化的影响我们。</li><li><strong>缺乏主动</strong>：缺乏主动性，一定要等到出了大篓子，兜不住的时候才想到要去通报主管。信息不流通，会让主管没有安全感，会有失控感。永远不要让主管从别人那里知道本应该你告诉他的情况。</li><li><strong>信息片面</strong>：你想通过沟通去影响你的老板，如果你发现他现在有一个想法不对，你希望引导他按照你的思路去决策；这个背后还有一个可能性是你获取的信息没有你老板多，你做出的判断是片面的，甚至是错误的。</li><li><strong>直线思维</strong>：直线思维，比如上级说：“小明，你这个事儿做得不对”，“我这事哪儿做得不对了！”。那这种沟通方式肯定就没办法谈下去了，是吧，如果这样沟通下去的结果是什么？可以想象，大家可以掏出手机看阿里味儿了。你可以不认同他的观点，或者他处理问题的方式，但是一定不要在公开的场合当面怼。即使在当场觉得那个方式行不通，处理上存在偏差，也可以在会后，私下沟通，在执行过程中进行修正。</li></ul><p>那么向上沟通的常见问题是哪些呢？</p><ul><li><p><strong>有问题、有疑虑不敢沟通：1.</strong> 给领导展现出一种事事有反馈、积极复盘的认真工作态度，留下良好的第一印象；<strong>2.</strong> 执行时遇到问题，把问题及时反馈，等于把责任分担了出去，提高解决问题的成功率；<strong>3.</strong> 对于自己来说，主动汇报也能使你理清自己的工作，锻炼自己解决问题的能力，提升效率；<strong>4.</strong> 主动汇报，让老板信任，因为不汇报给领导带来失控感。主动汇报，既可以让你的工作“可视化”，也确保执行方向正确；  </p></li><li><p><strong>啰里啰嗦说不清问题和影响：</strong>给老板汇报一定要提前准备，思路清晰，表达清楚，提高效率。关于怎么给老板做汇报，后面还会展开讲一下；</p></li><li><strong>只说问题不给方案：</strong>充分思考，提前准备好方案和建议，让老板做选择题而不是问答题。这个不仅提高了和老板沟通的效率，更重要的是要让老板看到你的思考，做到为老板分担。</li></ul><p>讲到向上汇报，那我们就需要先来讲一下向上汇报的思考框架，通过这个思考框架，你能判断当前的内容是否需要汇报，已经用什么策略来做汇报。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthLxiA2mqoArDgh8gr8dae5xQyjCdWIXWgROC61*mbtaKmeTR30MxTrKeWagX9*ha5m*k8hab4h3BG6kr7Mf1i8!/b&amp;bo=IANrASADawEDKQw!&amp;rf=viewer_4" alt="19.png"></p><ul><li><strong>第一个象限</strong>和老板一起进入重要级别非常高的项目。此时，老板就是你的同事。一起策划一起干活。这个象限里，老板是完全的“参与”。你们之间信息是对称的，这时，重要的汇报形式可能都消失了，因为你们随时都知道对方的信息；</li><li><strong>第二个象限</strong>，老板的角色要给你“指导与决策”。这里老板很关心，但具体进展和细节他不清楚，这里的内容往往是汇报中最重要的，也是向上汇报能力的重点。重点汇报里很有一个可能目标是有困难需要老板来支持的，比如资源不够，需要老板协调，你直接告诉老板需要他做什么就好了（这里就转移到了第四象限）；</li><li><p><strong>第三个象限</strong>都是老板授权给你的事情，是你的职责所在。虽然信息在这里也有不对称，但是老板在宏观面上会知道你的内容（甚至他当年还干过你这个工作），或者内容的重要性不能进入老板的“管理仪表盘”（不涉及他要做的高级别管理决策）。这部分内容只要表达：你在按部就班地在如期进行就好，老板只需阶段性的检视一下就行，不是汇报的重点。常见的误区是：这部分内容总是错误地摆上 PPT，向老板事无巨细的读一遍，大家都很沉闷，成为最没水平的汇报。这个区间里如果有异常情况，异常情况需要转移到第二区间处理；  </p></li><li><p><strong>第四象限</strong>的内容，其缘由和理由都无需论述，老板和你已经达成共识，信息是对称的。但是，这里有下属难以完成的任务，或者超出职权的任务，或者是新范畴的任务，最常见的是下属需要领导帮助解决某种资源。这里老板的角色是“帮助与支持”。</p></li></ul><p>前面说到要主动汇报，那汇报最好的时机是什么时候呢？这里提供了4种最基本的向上汇报时机，大家可以参考：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntp8cCi.XS*MfLyt*kMyLtAD3GE8adZh67XGWmQytsDoc1eJq8ao7kJlkhw7S1TbHRbuxr9S90A5gj.by9skmlbo!/b&amp;bo=IANaASADWgEDGTw!&amp;rf=viewer_4" alt="20.png"></p><p>现在要介绍一下向上汇报的方法了：</p><ul><li><strong>内容精简扼要</strong>：要相信老板都是看过成千上万张 PPT 的，所以他们大多数时候都能够一眼看出 PPT 中所要表达的意思，因此 PPT 的信息需要精简扼要。同时需要使用大量的数据来佐证自己的观点，尽量从客观的角度来陈述；</li><li><strong>直奔主题</strong>：如上面的描述，老板的时间安排极其紧凑，甚至会在汇报过程中由于突发事件而离开，所以汇报一开始就要开门见山的陈述自己的观点或要求，然后再罗列理由和证据，最后再重新陈述一下自己的观点即可。以上即为“电梯游说”的 PREP 结构：Position（观点）、Reason（理由）、Evidence（证据）、Position（观点）；</li><li><strong>做好充分准备</strong>：汇报的内容也需仅有数页 PPT，但是很多时候领导都会顺藤摸瓜的询问一些相关问题。所以作为汇报人，需要同时将相关的信息都要提前了解清楚，以防被问的哑口无言，不但会影响汇报进度，而且会被认为不尽职；</li><li>掌握 10/30 原则：30 分钟的时间计划中，汇报时间最多占用 10 分钟，剩下的 20 分钟留给讨论时间，往往能够产生价值的信息会在讨论时间内产生。</li></ul><h3 id="PREP-汇报方法"><a href="#PREP-汇报方法" class="headerlink" title="PREP 汇报方法"></a>PREP 汇报方法</h3><p>出自麦肯锡的 30 秒电梯理论。麦肯锡要求公司员工能够在最短的时间，把想表达的事情说清楚、讲明白。因此，作出了 PREP 的汇报结构，要求汇报者能够站在一个决策者而不是执行者的角度上汇报工作。其中由四个部分组成：</p><ul><li><strong>观点</strong>：就是首先用一两句话说清楚你想要表达的核心观点，包括：希望领导原则上同意、定下一步计划或者尽快看看你的详细材料等等；</li><li><strong>理由</strong>：你需要仔细分析你的汇报材料，凝结成不超过三个理由，然后试着用简洁而有力的语言表达出来；</li><li><strong>证据</strong>：主要是说明汇报重点中包涵的具体细节，例如：具体现象、数据和效果估计等等；</li><li>重复观点：最后，再一次重复你的要求。</li></ul><h2 id="2-向下沟通"><a href="#2-向下沟通" class="headerlink" title="2. 向下沟通"></a>2. 向下沟通</h2><p>向上沟通有很多困难，那是不是就意味着向下沟通就简单了呢？你的下属都向你汇报，那还有什么难度吗？</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntpj8m0Ig1cUFf0*jQCw1MkTG68Y1Mgw7G9l.Jk665KtIp7zuYEQ8O4CTlhfGWD8yVgCJOZ6Qi8FIphF5YHWpMqM!/b&amp;bo=IAOyASADsgEDORw!&amp;rf=viewer_4" alt="21.png"></p><p>是的，有带团队的同学都能体会，考虑到你每个下属的情况都不相同，向下沟通并不容易。并且如果不考虑到这些差异，糟糕的向下沟通对管理者和团队来说都是一个灾难。“哈佛商业评论”就有一个调研表明：91% 的员工表示，上级糟糕的沟通会损害其领导力！</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knth*iE.U.xjZ7IIDRONW0yRRUlljAEd4zYTatfHM2skv5E87WD*FVL7FBNKl2LTgHIe0Iv1eMqp1RpSSHNqO96tw!/b&amp;bo=IANqASADagEDKQw!&amp;rf=viewer_4" alt="22.png"></p><p>那和下属沟通的技巧都有哪些呢？</p><ul><li><p><strong>发布指令目的清晰，目标明确</strong>。说明任务的重要性，明确任务的 SMART 目标；如果说得不好听，一个含糊的目标（如我们要重视用户体验），你的下属怎么知道你是不是一时兴起，随口说的呢？  </p></li><li><p><strong>给与反馈关注行为及影响</strong>。反馈分为两类：积极性反馈和发展性反馈。顾名思义，积极性反馈是为了表达对被指导者的赞扬与认可，发展性反馈则用于指出需要改善的地方。这里区别于父母常用的唠叨模式，我们同样要有结构，即行为+影响+态度（认可或不足）；如：不能简单粗暴的说 xx 没有团队精神。</p></li><li><strong>建立定期的 one one 沟通渠道</strong>：Oneone 沟通，展现了重视，给与了确定性的准备时间，面对面的沟通更容易进入到更深层面的沟通。</li></ul><p>向下沟通还有非常重要的点是，上级怎么处理下级扔过来的问题。</p><p>当下属找你的时候，他们很多时候不是在寻求解决方案，而是寻求一个能解决问题的人。下属向管理者报告时，应该引导他说“我有一个问题”，而不能说“我们有一个问题”。下属提出问题的时候，应该让他理解这个问题是他的。这里举两个列子：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntm9ugHEirZHv8dNMbj2mWKe27170pSvYBh9ZsoikV7PWHSUG.TF17bFswOjFqYC4I70y3WvsgRAbNTjq5xwG.J4!/b&amp;bo=IANhASADYQEDGTw!&amp;rf=viewer_4" alt="23.png"></p><p>正确的对话方式：“我暂时不能给你建议。你要把你负责的事情再考虑下，下午 4 点半，来我的办公室，提出可行的进一步想法。”或者“我 24 小时内没空处理这个问题，你继续去想，明天再给我汇报新的进展。”</p><p>如果大家对怎么处理和下属中间任务职责的问题感兴趣的话，推荐大家去看一本书：《别让猴子跳回背上》。</p><p>主管的工作，是协助下属完成工作，而不是替下属工作。授人以鱼不如授人以渔的这个道理大家都懂。管理者的目的是培养出更多可以独当一面的员工，如下面的图所示，主管要尽量避免出现自有层级为 1、2 级的员工。不要帮助下属去完成他们分内的事情，培养下属解决问题和思考的能力。面对下属的求助，多问问他“你觉得呢”，让下属自己去想办法解决问题。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqcFNZ*7OBjWh6XgedC.lCo9*3WtP2fzFnkVEhYgIjj82w9*raoFdUOxWiFXM.snb2r3LtA74ArtpsII4y*vzWE!/b&amp;bo=IANwASADcAEDGTw!&amp;rf=viewer_4" alt="24.png"></p><ul><li>5 级、等待指示——连该做什么都不知道；</li><li>4 级、请示要做什么——知道该做什么，但不知道该怎么做；</li><li>3 级、提出建议，按照裁断的结果行动——能提出备选方案，但需要主管进行方案选择；</li><li>2 级、行动，但需立即指示——能决定合适的行动方案，但具体执行时会随时请示；</li><li>1 级、独立行动，主管只需要看他的例行报告。</li></ul><p>自由层级第 1 层级与第 2 层级是争取来的特权——他们不是与生俱来的天然权利。这种特权获得来自于你能向上司成功的推销自己的想法和建议而慢慢积累的名声。这种名声也只有在第 3 层级自由量表中才能培养出来。</p><h1 id="同步沟通和异步沟通"><a href="#同步沟通和异步沟通" class="headerlink" title="同步沟通和异步沟通"></a>同步沟通和异步沟通</h1><p>最后一组要介绍的是同步沟通和异步沟通，这个组词就不像前面那两组那么常见了，不知道大家是不是都理解这两个词的意思？</p><ul><li>同步沟通：同步沟通是指你发出一个消息，接收方立即处理这个信息，并马上回复；</li><li>异步沟通：异步沟通指的是你发出一个消息，并不期待立即得到反馈的沟通方式。</li></ul><p>按照上面的定义，大家就可以把我们日常的沟通方式做一个归类了，比如“会议”、“面对面讨论”、“电话”就属于典型的同步沟通；“邮件”、“语雀”、“Aone”就是典型的异步沟通了。</p><p>那“钉钉”和“微信”应该归在哪一类呢？微信和钉钉一般认为是同时具备同步沟通和异步沟通的特征的，过程中有随时变化的可能，就看大家在沟通的过程中是否实时。不过考虑到钉钉有消息阅读状态的提示，一般我们认为钉钉更加接近同步沟通的方式。</p><p>下面我们就对这两种沟通的方式和场景做一个对比：</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrN0iTvN7*vkGe*tHYe1l60BMSillHFvmZsKFzy9Y6DWK101lGMOM7wnOMf.pK817CfPyIXRVStNUdeHhhHrGq8!/b&amp;bo=IANPASADTwEDGTw!&amp;rf=viewer_4" alt="25.png"></p><p>随着在阿里钉钉的深度使用，同步沟通的比重越来越大，不可否认这种方式让整体的工作效率得到了很大的提升，但任何事情过量就会带来问题。同步沟通常见的问题有：</p><ul><li>频繁打断，大家的工作时间都被切割成了碎片，妨碍了深度工作的开展；</li><li>在线的优先级优于高产。不在线的人连发声机会都没有，事情就已经决定了。于是大家都得被迫实时在线，被迫参加每个可能有关的会议；</li><li>造成不必要的压力。实时在线的期望使人们丧失对时间表的控制。工作时间内，大家响应式回应各方请求，而不是主动地按自己的计划行事。有研究表明，因为常被打断，人们反而会努力把事情做得更快（做得更差为代价），并由此感到更大的压力和困惑；</li><li>导致低质量的讨论和次优方案。因为需要马上回复，人们没有充分的时间来考虑周全。第一时间给出的方案往往不是你能给出的最优方案。</li></ul><p>那在日常的项目管理中，我们怎么有效的利用好各种沟通方式，让这些沟通方式能更好的发挥他们的作用，同时避免一些副作用呢？这里我把项目中最常见的沟通方式放在了一个象限空间中（横坐标是同步或者异步，纵坐标是沟通内容的复杂程度），希望大家可以对比一下自己的日常项目，做个参考。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqSdPbaR*brGsy5WCjMd7puUAKIgM4HdOMvYxRt0.e3oL3.OnOu3Ak9dxpgCJQMV00OqT6.87P.5E6aTpAdSP*Y!/b&amp;bo=IAOQAiADkAIDKQw!&amp;rf=viewer_4" alt="26.png"></p><h1 id="最后，也是最重要的"><a href="#最后，也是最重要的" class="headerlink" title="最后，也是最重要的"></a>最后，也是最重要的</h1><p>终于到了最后（感谢有人能看到这里）。</p><p>本文讲了很多的不同沟通场景中的技巧，这些沟通技巧有的时候换个角度也可以看成沟通中的套路。在这里，我需要强调一下，一个沟通的成败，套路的东西会有效果，但是效果也是有限的，沟通中更重要的还是要看沟通的动机。你沟通的目的是不是希望要实现 “1+1&gt;2” 的效果，你是不是有一个开放的心态，是不是重视差异化、视每次冲突是成长的机会。只要是有一个真诚的心，就算沟通技巧上问题重重，我相信别人还是愿意和你合作。这就是所谓的：“多一点真诚，少一点套路！”</p><p>作者：阿里技术<br>        链接：<a href="https://segmentfault.com/a/1190000023318216" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023318216</a><br>        来源：SegmentFault 思否<br>        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt; 世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnKZ92b3oVl5whUSbe.MZ3Bvy9UlUi6.lE*dMlO0.XRwtp*XuZV7*zx8MV5ApmZwNrGa1aBl8H3ZxOHBjjFzVv8!/b&amp;amp;bo=IAOgASADoAEDKQw!&amp;amp;rf=viewer_4&quot; alt=&quot;1.png&quot;&gt; &lt;/p&gt;
&lt;p&gt;作者 | 鲁佳(鹿迦) 阿里巴巴项目管理专家&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导读：&lt;/strong&gt;世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目 管理 程序员 沟通" scheme="http://www.icrazyman.cn/tags/%E9%A1%B9%E7%9B%AE-%E7%AE%A1%E7%90%86-%E7%A8%8B%E5%BA%8F%E5%91%98-%E6%B2%9F%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>25个你不得不知道的数组reduce高级用法</title>
    <link href="http://www.icrazyman.cn/2020/07/17/25%E4%B8%AA%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E7%BB%84reduce%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://www.icrazyman.cn/2020/07/17/25个你不得不知道的数组reduce高级用法/</id>
    <published>2020-07-17T09:30:29.000Z</published>
    <updated>2020-07-17T14:52:14.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p> <code>reduce</code>作为ES5新增的常规数组方法之一，对比<code>forEach</code>、<code>filter</code>和<code>map</code>，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。 </p><p>下面对reduce的语法进行简单说明，详情可查看MDN的reduce()的相关说明。</p><ul><li><p>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</p></li><li><p>形式：array.reduce((t, v, i, a) =&gt; {}, initValue)</p></li><li><p>参数</p><ul><li>callback：回调函数(必选)</li><li>initValue：初始值(可选)</li></ul></li><li><p>回调函数的参数</p><ul><li>total(t)：累计器完成计算的返回值(必选)</li><li>value(v)：当前元素(必选)</li><li>index(i)：当前元素的索引(可选)</li><li>array(a)：当前元素所属的数组对象(可选)</li></ul></li><li><p>过程</p><ul><li>以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值</li><li>开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t</li><li>进入下一次循环，重复上述操作，直至数组最后一个元素</li><li>结束遍历，返回最终的t</li></ul><p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。下面举个简单的栗子，看看<code>reduce</code>的计算结果。 </p><pre><code class="js">const arr = [3, 5, 1, 4, 2];const a = arr.reduce((t, v) =&gt; t + v);// 等同于const b = arr.reduce((t, v) =&gt; t + v, 0);</code></pre><p> 代码不太明白没关系，贴一个<code>reduce</code>的作用动图应该就会明白了。 </p></li></ul><a id="more"></a><p> <img src="https://img-blog.csdnimg.cn/20200309234456121.gif" alt="reduce"> </p><p> <code>reduce</code>实质上是一个累计器函数，通过用户自定义的累计器对数组成员进行自定义累计，得出一个由累计器生成的值。另外<code>reduce</code>还有一个胞弟<code>reduceRight</code>，两个方法的功能其实是一样的，只不过<code>reduce</code>是升序执行，<code>reduceRight</code>是降序执行。 </p><pre><code class="js">对空数组调用reduce()和reduceRight()是不会执行其回调函数的，可认为reduce()对空数组无效</code></pre><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p> 单凭以上一个简单栗子不足以说明<code>reduce</code>是个什么。为了展示<code>reduce</code>的魅力，我为大家提供25种场景来应用<code>reduce</code>的高级用法。有部分高级用法可能需要结合其他方法来实现，这样为<code>reduce</code>的多元化提供了更多的可能性。 </p><pre><code class="js">部分示例代码的写法可能有些骚，看得不习惯可自行整理成自己的习惯写法</code></pre><h2 id="累加累乘"><a href="#累加累乘" class="headerlink" title="累加累乘"></a>累加累乘</h2><pre><code class="js">function Accumulation(...vals) {    return vals.reduce((t, v) =&gt; t + v, 0);}function Multiplication(...vals) {    return vals.reduce((t, v) =&gt; t * v, 1);}</code></pre><pre><code class="js">Accumulation(1, 2, 3, 4, 5); // 15Multiplication(1, 2, 3, 4, 5); // 120</code></pre><h2 id="权重求和"><a href="#权重求和" class="headerlink" title="权重求和"></a>权重求和</h2><pre><code class="js">const scores = [    { score: 90, subject: &quot;chinese&quot;, weight: 0.5 },    { score: 95, subject: &quot;math&quot;, weight: 0.3 },    { score: 85, subject: &quot;english&quot;, weight: 0.2 }];const result = scores.reduce((t, v) =&gt; t + v.score * v.weight, 0); // 90.5</code></pre><h2 id="代替reverse"><a href="#代替reverse" class="headerlink" title="代替reverse"></a>代替reverse</h2><pre><code class="js">function Reverse(arr = []) {    return arr.reduceRight((t, v) =&gt; (t.push(v), t), []);}</code></pre><pre><code class="js">Reverse([1, 2, 3, 4, 5]); // [5, 4, 3, 2, 1]</code></pre><h2 id="代替map和filter"><a href="#代替map和filter" class="headerlink" title="代替map和filter"></a>代替map和filter</h2><pre><code class="js">const arr = [0, 1, 2, 3];// 代替map：[0, 2, 4, 6]const a = arr.map(v =&gt; v * 2);const b = arr.reduce((t, v) =&gt; [...t, v * 2], []);// 代替filter：[2, 3]const c = arr.filter(v =&gt; v &gt; 1);const d = arr.reduce((t, v) =&gt; v &gt; 1 ? [...t, v] : t, []);// 代替map和filter：[4, 6]const e = arr.map(v =&gt; v * 2).filter(v =&gt; v &gt; 2);const f = arr.reduce((t, v) =&gt; v * 2 &gt; 2 ? [...t, v * 2] : t, []);</code></pre><h2 id="代替some和every"><a href="#代替some和every" class="headerlink" title="代替some和every"></a>代替some和every</h2><pre><code class="js">const scores = [    { score: 45, subject: &quot;chinese&quot; },    { score: 90, subject: &quot;math&quot; },    { score: 60, subject: &quot;english&quot; }];// 代替some：至少一门合格const isAtLeastOneQualified = scores.reduce((t, v) =&gt; t || v.score &gt;= 60, false); // true// 代替every：全部合格const isAllQualified = scores.reduce((t, v) =&gt; t &amp;&amp; v.score &gt;= 60, true); // false</code></pre><h2 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h2><pre><code class="js">function Chunk(arr = [], size = 1) {    return arr.length ? arr.reduce((t, v) =&gt; (t[t.length - 1].length === size ? t.push([v]) : t[t.length - 1].push(v), t), [[]]) : [];}</code></pre><pre><code class="js">const arr = [1, 2, 3, 4, 5];Chunk(arr, 2); // [[1, 2], [3, 4], [5]]</code></pre><h2 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h2><pre><code class="js">function Difference(arr = [], oarr = []) {    return arr.reduce((t, v) =&gt; (!oarr.includes(v) &amp;&amp; t.push(v), t), []);}</code></pre><pre><code class="js">const arr1 = [1, 2, 3, 4, 5];const arr2 = [2, 3, 6]Difference(arr1, arr2); // [1, 4, 5]</code></pre><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><pre><code class="js">function Fill(arr = [], val = &quot;&quot;, start = 0, end = arr.length) {    if (start &lt; 0 || start &gt;= end || end &gt; arr.length) return arr;    return [        ...arr.slice(0, start),        ...arr.slice(start, end).reduce((t, v) =&gt; (t.push(val || v), t), []),        ...arr.slice(end, arr.length)    ];}</code></pre><pre><code class="js">const arr = [0, 1, 2, 3, 4, 5, 6];Fill(arr, &quot;aaa&quot;, 2, 5); // [0, 1, &quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;, 5, 6]</code></pre><h2 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h2><pre><code class="js">function Flat(arr = []) {    return arr.reduce((t, v) =&gt; t.concat(Array.isArray(v) ? Flat(v) : v), [])}</code></pre><pre><code class="js">const arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];Flat(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code></pre><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code class="js">function Uniq(arr = []) {    return arr.reduce((t, v) =&gt; t.includes(v) ? t : [...t, v], []);}</code></pre><pre><code class="js">const arr = [2, 1, 0, 3, 2, 1, 2];Uniq(arr); // [2, 1, 0, 3]</code></pre><h2 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h2><pre><code class="js">function Max(arr = []) {    return arr.reduce((t, v) =&gt; t &gt; v ? t : v);}function Min(arr = []) {    return arr.reduce((t, v) =&gt; t &lt; v ? t : v);}</code></pre><pre><code class="js">const arr = [12, 45, 21, 65, 38, 76, 108, 43];Max(arr); // 108Min(arr); // 12</code></pre><h2 id="数组成员独立拆解"><a href="#数组成员独立拆解" class="headerlink" title="数组成员独立拆解"></a>数组成员独立拆解</h2><pre><code class="js">function Unzip(arr = []) {    return arr.reduce(        (t, v) =&gt; (v.forEach((w, i) =&gt; t[i].push(w)), t),        Array.from({ length: Math.max(...arr.map(v =&gt; v.length)) }).map(v =&gt; [])    );}</code></pre><pre><code class="js">const arr = [[&quot;a&quot;, 1, true], [&quot;b&quot;, 2, false]];Unzip(arr); // [[&quot;a&quot;, &quot;b&quot;], [1, 2], [true, false]]</code></pre><h2 id="数组成员个数统计"><a href="#数组成员个数统计" class="headerlink" title="数组成员个数统计"></a>数组成员个数统计</h2><pre><code class="js">function Count(arr = []) {    return arr.reduce((t, v) =&gt; (t[v] = (t[v] || 0) + 1, t), {});}</code></pre><pre><code class="js">const arr = [0, 1, 1, 2, 2, 2];Count(arr); // { 0: 1, 1: 2, 2: 3 }</code></pre><pre><code class="js">此方法是字符统计和单词统计的原理，入参时把字符串处理成数组即可</code></pre><h2 id="数组成员位置记录"><a href="#数组成员位置记录" class="headerlink" title="数组成员位置记录"></a>数组成员位置记录</h2><pre><code class="js">function Position(arr = [], val) {    return arr.reduce((t, v, i) =&gt; (v === val &amp;&amp; t.push(i), t), []);}</code></pre><pre><code class="js">const arr = [2, 1, 5, 4, 2, 1, 6, 6, 7];Position(arr, 2); // [0, 4]</code></pre><h2 id="数组成员特性分组"><a href="#数组成员特性分组" class="headerlink" title="数组成员特性分组"></a>数组成员特性分组</h2><pre><code class="js">function Group(arr = [], key) {    return key ? arr.reduce((t, v) =&gt; (!t[v[key]] &amp;&amp; (t[v[key]] = []), t[v[key]].push(v), t), {}) : {};}</code></pre><pre><code class="js">const arr = [    { area: &quot;GZ&quot;, name: &quot;YZW&quot;, age: 27 },    { area: &quot;GZ&quot;, name: &quot;TYJ&quot;, age: 25 },    { area: &quot;SZ&quot;, name: &quot;AAA&quot;, age: 23 },    { area: &quot;FS&quot;, name: &quot;BBB&quot;, age: 21 },    { area: &quot;SZ&quot;, name: &quot;CCC&quot;, age: 19 }]; // 以地区area作为分组依据Group(arr, &quot;area&quot;); // { GZ: Array(2), SZ: Array(2), FS: Array(1) }</code></pre><h2 id="数组成员所含关键字统计"><a href="#数组成员所含关键字统计" class="headerlink" title="数组成员所含关键字统计"></a>数组成员所含关键字统计</h2><pre><code class="js">function Keyword(arr = [], keys = []) {    return keys.reduce((t, v) =&gt; (arr.some(w =&gt; w.includes(v)) &amp;&amp; t.push(v), t), []);}</code></pre><pre><code class="js">const text = [    &quot;今天天气真好，我想出去钓鱼&quot;,    &quot;我一边看电视，一边写作业&quot;,    &quot;小明喜欢同桌的小红，又喜欢后桌的小君，真TM花心&quot;,    &quot;最近上班喜欢摸鱼的人实在太多了，代码不好好写，在想入非非&quot;];const keyword = [&quot;偷懒&quot;, &quot;喜欢&quot;, &quot;睡觉&quot;, &quot;摸鱼&quot;, &quot;真好&quot;, &quot;一边&quot;, &quot;明天&quot;];Keyword(text, keyword); // [&quot;喜欢&quot;, &quot;摸鱼&quot;, &quot;真好&quot;, &quot;一边&quot;]</code></pre><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><pre><code class="js">function ReverseStr(str = &quot;&quot;) {    return str.split(&quot;&quot;).reduceRight((t, v) =&gt; t + v);}</code></pre><pre><code class="js">const str = &quot;reduce最牛逼&quot;;ReverseStr(str); // &quot;逼牛最ecuder&quot;</code></pre><h2 id="数字千分化"><a href="#数字千分化" class="headerlink" title="数字千分化"></a>数字千分化</h2><pre><code class="js">function ThousandNum(num = 0) {    const str = (+num).toString().split(&quot;.&quot;);    const int = nums =&gt; nums.split(&quot;&quot;).reverse().reduceRight((t, v, i) =&gt; t + (i % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;);    const dec = nums =&gt; nums.split(&quot;&quot;).reduce((t, v, i) =&gt; t + ((i + 1) % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;);    return str.length &gt; 1 ? `${int(str[0])}.${dec(str[1])}` : int(str[0]);}</code></pre><pre><code class="js">ThousandNum(1234); // &quot;1,234&quot;ThousandNum(1234.00); // &quot;1,234&quot;ThousandNum(0.1234); // &quot;0.123,4&quot;ThousandNum(1234.5678); // &quot;1,234.567,8&quot;</code></pre><h2 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h2><pre><code class="js">async function AsyncTotal(arr = []) {    return arr.reduce(async(t, v) =&gt; {        const at = await t;        const todo = await Todo(v);        at[v] = todo;        return at;    }, Promise.resolve({}));}</code></pre><pre><code class="js">const result = await AsyncTotal(); // 需要在async包围下使用</code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="js">function Fibonacci(len = 2) {    const arr = [...new Array(len).keys()];    return arr.reduce((t, v, i) =&gt; (i &gt; 1 &amp;&amp; t.push(t[i - 1] + t[i - 2]), t), [0, 1]);}</code></pre><pre><code class="js">Fibonacci(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre><h2 id="URL参数反序列化"><a href="#URL参数反序列化" class="headerlink" title="URL参数反序列化"></a>URL参数反序列化</h2><pre><code class="js">function ParseUrlSearch() {    return location.search.replace(/(^\?)|(&amp;$)/g, &quot;&quot;).split(&quot;&amp;&quot;).reduce((t, v) =&gt; {        const [key, val] = v.split(&quot;=&quot;);        t[key] = decodeURIComponent(val);        return t;    }, {});}</code></pre><pre><code class="js">// 假设URL为：https://www.baidu.com?age=25&amp;name=TYJParseUrlSearch(); // { age: &quot;25&quot;, name: &quot;TYJ&quot; }</code></pre><h2 id="URL参数序列化"><a href="#URL参数序列化" class="headerlink" title="URL参数序列化"></a>URL参数序列化</h2><pre><code class="js">function StringifyUrlSearch(search = {}) {    return Object.entries(search).reduce(        (t, v) =&gt; `${t}${v[0]}=${encodeURIComponent(v[1])}&amp;`,        Object.keys(search).length ? &quot;?&quot; : &quot;&quot;    ).replace(/&amp;$/, &quot;&quot;);}</code></pre><pre><code class="js">StringifyUrlSearch({ age: 27, name: &quot;YZW&quot; }); // &quot;?age=27&amp;name=YZW&quot;</code></pre><h2 id="返回对象指定键值"><a href="#返回对象指定键值" class="headerlink" title="返回对象指定键值"></a>返回对象指定键值</h2><pre><code class="js">function GetKeys(obj = {}, keys = []) {    return Object.keys(obj).reduce((t, v) =&gt; (keys.includes(v) &amp;&amp; (t[v] = obj[v]), t), {});}</code></pre><pre><code class="js">const target = { a: 1, b: 2, c: 3, d: 4 };const keyword = [&quot;a&quot;, &quot;d&quot;];GetKeys(target, keyword); // { a: 1, d: 4 }</code></pre><h2 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h2><pre><code class="js">const people = [    { area: &quot;GZ&quot;, name: &quot;YZW&quot;, age: 27 },    { area: &quot;SZ&quot;, name: &quot;TYJ&quot;, age: 25 }];const map = people.reduce((t, v) =&gt; {    const { name, ...rest } = v;    t[name] = rest;    return t;}, {}); // { YZW: {…}, TYJ: {…} }</code></pre><h2 id="Redux-Compose函数原理"><a href="#Redux-Compose函数原理" class="headerlink" title="Redux Compose函数原理"></a>Redux Compose函数原理</h2><pre><code class="js">function Compose(...funs) {    if (funs.length === 0) {        return arg =&gt; arg;    }    if (funs.length === 1) {        return funs[0];    }    return funs.reduce((t, v) =&gt; (...arg) =&gt; t(v(...arg)));}</code></pre><h1 id="兼容和性能"><a href="#兼容和性能" class="headerlink" title="兼容和性能"></a>兼容和性能</h1><p> 好用是挺好用的，但是兼容性如何呢？在<a href="https://caniuse.com/#search=reduce" target="_blank" rel="noopener">Caniuse</a>上搜索一番，兼容性绝对的好，可大胆在任何项目上使用。不要吝啬你的想象力，尽情发挥<code>reduce</code>的<code>compose</code>技能啦。对于时常做一些累计的功能，<code>reduce</code>绝对是首选方法。 </p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZS5wbmc?x-oss-process=image/format,png" alt="caniuse-reduce">  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZVJpZ2h0LnBuZw?x-oss-process=image/format,png" alt="caniuse-reduceRight"></p><p> 另外，有些同学可能会问，<code>reduce</code>的性能又如何呢？下面我们通过对<code>for</code>、<code>forEach</code>、<code>map</code>和<code>reduce</code>四个方法同时做<code>1~100000</code>的累加操作，看看四个方法各自的执行时间。 </p><pre><code class="js">// 创建一个长度为100000的数组const list = [...new Array(100000).keys()];// forconsole.time(&quot;for&quot;);let result1 = 0;for (let i = 0; i &lt; list.length; i++) {    result1 += i + 1;}console.log(result1);console.timeEnd(&quot;for&quot;);// forEachconsole.time(&quot;forEach&quot;);let result2 = 0;list.forEach(v =&gt; (result2 += v + 1));console.log(result2);console.timeEnd(&quot;forEach&quot;);// mapconsole.time(&quot;map&quot;);let result3 = 0;list.map(v =&gt; (result3 += v + 1, v));console.log(result3);console.timeEnd(&quot;map&quot;);// reduceconsole.time(&quot;reduce&quot;);const result4 = list.reduce((t, v) =&gt; t + v + 1, 0);console.log(result4);console.timeEnd(&quot;reduce&quot;);</code></pre><table><thead><tr><th>累加操作</th><th>执行时间</th></tr></thead><tbody><tr><td><strong>for</strong></td><td><code>6.719970703125ms</code></td></tr><tr><td><strong>forEach</strong></td><td><code>3.696044921875ms</code></td></tr><tr><td><strong>map</strong></td><td><code>3.554931640625ms</code></td></tr><tr><td><strong>reduce</strong></td><td><code>2.806884765625ms</code></td></tr></tbody></table><p>以上代码在MacBook Pro 2019 15寸 16G内存 512G闪存的Chrome 79下执行，不同的机器不同的环境下执行以上代码都有可能存在差异。</p><p>我已同时测试过多台机器和多个浏览器，连续做了10次以上操作，发现reduce总体的平均执行时间还是会比其他三个方法稍微快一点，所以大家还是放心使用啦！本文更多是探讨reduce的使用技巧，如对reduce的兼容和性能存在疑问，可自行参考相关资料进行验证。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UteC5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UtMS5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p><p>原文地址：<a href="https://blog.csdn.net/JowayYoung/article/details/104293122" target="_blank" rel="noopener">25个你不得不知道的数组reduce高级用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt; &lt;code&gt;reduce&lt;/code&gt;作为ES5新增的常规数组方法之一，对比&lt;code&gt;forEach&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。 &lt;/p&gt;
&lt;p&gt;下面对reduce的语法进行简单说明，详情可查看MDN的reduce()的相关说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;形式：array.reduce((t, v, i, a) =&amp;gt; {}, initValue)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callback：回调函数(必选)&lt;/li&gt;
&lt;li&gt;initValue：初始值(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回调函数的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;total(t)：累计器完成计算的返回值(必选)&lt;/li&gt;
&lt;li&gt;value(v)：当前元素(必选)&lt;/li&gt;
&lt;li&gt;index(i)：当前元素的索引(可选)&lt;/li&gt;
&lt;li&gt;array(a)：当前元素所属的数组对象(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值&lt;/li&gt;
&lt;li&gt;开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t&lt;/li&gt;
&lt;li&gt;进入下一次循环，重复上述操作，直至数组最后一个元素&lt;/li&gt;
&lt;li&gt;结束遍历，返回最终的t&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt;的精华所在是将累计器逐个作用于数组成员上，&lt;strong&gt;把上一次输出的值作为下一次输入的值&lt;/strong&gt;。下面举个简单的栗子，看看&lt;code&gt;reduce&lt;/code&gt;的计算结果。 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const arr = [3, 5, 1, 4, 2];
const a = arr.reduce((t, v) =&amp;gt; t + v);
// 等同于
const b = arr.reduce((t, v) =&amp;gt; t + v, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 代码不太明白没关系，贴一个&lt;code&gt;reduce&lt;/code&gt;的作用动图应该就会明白了。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码  技巧 reduce" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E6%8A%80%E5%B7%A7-reduce/"/>
    
  </entry>
  
  <entry>
    <title>如何使用JavaScript访问设备摄像头（前后）</title>
    <link href="http://www.icrazyman.cn/2020/06/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JavaScript%E8%AE%BF%E9%97%AE%E8%AE%BE%E5%A4%87%E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%88%E5%89%8D%E5%90%8E%EF%BC%89/"/>
    <id>http://www.icrazyman.cn/2020/06/09/如何使用JavaScript访问设备摄像头（前后）/</id>
    <published>2020-06-09T01:08:20.000Z</published>
    <updated>2020-06-09T01:21:14.563Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将向您展示如何通过JavaScript在网页上访问设备的摄像头，并支持多种浏览器，而无需外部库。</p><a id="more"></a><h1 id="如何使用相机API"><a href="#如何使用相机API" class="headerlink" title="如何使用相机API"></a>如何使用相机API</h1><p>要访问用户的相机（或麦克风），我们使用JavaScript <strong>MediaStream API</strong>。该API允许通过流访问这些设备捕获的视频和音频。</p><p>第一步是检查浏览器是否支持此API：</p><pre><code class="js">if (  &quot;mediaDevices&quot; in navigator &amp;&amp;  &quot;getUserMedia&quot; in navigator.mediaDevices) {  // ok, 浏览器支持它}</code></pre><p>在现代浏览器中，支持是不错的（当然没有Internet Explorer）。</p><h2 id="捕获视频流"><a href="#捕获视频流" class="headerlink" title="捕获视频流"></a>捕获视频流</h2><p>要捕获由摄像机生成的视频流，我们使用 <code>mediaDevices</code> 对象的 <code>getUserMedia</code> 方法。这个方法接收一个对象，其中包含我们要请求的媒体类型（视频或音频）和一些要求。首先，我们可以通过 <code>{video: true}</code> 来获取摄像机的视频。</p><pre><code class="js">const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });</code></pre><p>此调用将询问用户是否允许访问摄像机。如果用户拒绝，它将引发异常并且不返回流。因此，必须在 <code>try/catch</code> 块内完成处理这种情况。</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/2.png" alt></p><p>请注意，它返回一个Promise，因此您必须使用 <code>async/await</code> 或 <code>then</code> 块。在Mac OS系统上还会弹出授权</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/3.png" alt></p><p>点击“好”，就可以访问电脑摄像头了，控制台输出的 <code>videoStream</code> 对象如下</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/4.png" alt></p><h2 id="视频规格（requirements）"><a href="#视频规格（requirements）" class="headerlink" title="视频规格（requirements）"></a>视频规格（requirements）</h2><p>我们可以通过传递有关所需分辨率以及最小和最大限制的信息来改善视频的要求：</p><pre><code class="js">const constraints = {  video: {    width: {      min: 1280,      ideal: 1920,      max: 2560,    },    height: {      min: 720,      ideal: 1080,      max: 1440,    },  },};const videoStream = await navigator.mediaDevices.getUserMedia(constraints);</code></pre><p>这样，流以正确的宽度和高度比例进入，如果它是处于纵向模式的手机，则需要进行尺寸反转。</p><h2 id="在页面上显示视频"><a href="#在页面上显示视频" class="headerlink" title="在页面上显示视频"></a>在页面上显示视频</h2><p>既然有了流，我们该如何处理？</p><p>我们可以在页面上的 <code>video</code> 元素中显示视频：</p><pre><code class="js">// 页面中有一个 &lt;video autoplay id=&quot;video&quot;&gt;&lt;/video&gt; 标签const video = document.querySelector(&quot;#video&quot;);const videoStream = await navigator.mediaDevices.getUserMedia(constraints);video.srcObject = videoStream;</code></pre><p>请注意 <code>video</code> 标签中的自动播放属性 <code>autoplay</code>，没有它，你需要调用 <code>video.play()</code> 才能真正开始显示图像。</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/5.png" alt></p><h2 id="访问手机的前后摄像头"><a href="#访问手机的前后摄像头" class="headerlink" title="访问手机的前后摄像头"></a>访问手机的前后摄像头</h2><p>默认情况下，<code>getUserMedia</code> 将使用系统默认的视频录制设备。如果是有两个摄像头的手机，它使用前置摄像头。</p><p>要访问后置摄像头，我们必须在视频规格中包括 <code>faceModeMode:&quot;environment&quot;</code>：</p><pre><code class="js">const constraints = {  video: {    width: { ... },    height: { ... },    facingMode: &quot;environment&quot;  },};</code></pre><p>默认值为 <code>faceingMode:&quot;user&quot;</code>，即前置摄像头。</p><p>需要注意的是，如果你想在已经播放视频的情况下更换摄像机，你需要先停止当前的视频流，然后再将其替换成另一台摄像机的视频流。</p><pre><code class="js">videoStream.getTracks().forEach((track) =&gt; {  track.stop();});</code></pre><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><p>你可以做的另一件很酷的事情是捕获视频的图像（屏幕快照）。</p><p>你可以在canvas上绘制当前视频帧，例如：</p><pre><code class="js">// 页面中有一个 &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 标签const canvas = document.querySelector(&quot;#canvas&quot;);canvas.width = video.videoWidth;canvas.height = video.videoHeight;canvas.getContext(&quot;2d&quot;).drawImage(video, 0, 0);</code></pre><p>你还可以在 <code>img</code> 元素中显示画布内容。</p><p>在本教程创建的示例中，我添加了一个按钮，该按钮可从画布动态创建图像并将其添加到页面：</p><pre><code class="js">const img = document.createElement(&quot;img&quot;);img.src = canvas.toDataURL(&quot;image/png&quot;);screenshotsContainer.prepend(img);</code></pre><h2 id="完整示例和代码"><a href="#完整示例和代码" class="headerlink" title="完整示例和代码"></a>完整示例和代码</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;摄像头&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        #video {          width: 100%;        }        .is-hidden {          display: none;        }        .btns {          margin-bottom: 10px;        }        button {          font-size: 22px;          padding: 8px 10px;          border: 2px solid #ccc;          border-radius: 10px;        }        .video-screenshot {          display: grid;          grid-template-columns: 1fr 1fr;          grid-column-gap: 10px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;如何使用JavaScript访问设备摄像头（前后）&lt;/h1&gt;&lt;div class=&quot;btns&quot;&gt;  &lt;button class=&quot;button is-hidden&quot; id=&quot;btnPlay&quot;&gt;    播放  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnPause&quot;&gt;    暂停  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnScreenshot&quot;&gt;    截屏  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnChangeCamera&quot; style=&quot;padding: 6px 10px;&quot;&gt;    切换摄像头  &lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;video-screenshot&quot;&gt;  &lt;video autoplay id=&quot;video&quot;&gt;&lt;/video&gt;  &lt;div&gt;    &lt;div id=&quot;screenshotsContainer&quot;&gt;      &lt;canvas id=&quot;canvas&quot; class=&quot;is-hidden&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// https://segmentfault.com/a/1190000022867561window.onload = async function () {  if (    !&quot;mediaDevices&quot; in navigator ||    !&quot;getUserMedia&quot; in navigator.mediaDevices  ) {    document.write(&#39;当前浏览器不支持Camera API，请更新浏览器。&#39;)    return;  }  const video = document.querySelector(&quot;#video&quot;);  const canvas = document.querySelector(&quot;#canvas&quot;);  const screenshotsContainer = document.querySelector(&quot;#screenshotsContainer&quot;);  let videoStream = null  let useFrontCamera = true; // 前置摄像头  const constraints = {    video: {      width: {        min: 1280,        ideal: 1920,        max: 2560,      },      height: {        min: 720,        ideal: 1080,        max: 1440,      }    },  };  // play  btnPlay.addEventListener(&quot;click&quot;, function () {    video.play();    btnPlay.classList.add(&quot;is-hidden&quot;);    btnPause.classList.remove(&quot;is-hidden&quot;);  });  // pause  btnPause.addEventListener(&quot;click&quot;, function () {    video.pause();    btnPause.classList.add(&quot;is-hidden&quot;);    btnPlay.classList.remove(&quot;is-hidden&quot;);  });  // 切换摄像头  btnChangeCamera.addEventListener(&quot;click&quot;, function () {    useFrontCamera = !useFrontCamera;    init();  });  // 停止视频流  function stopVideoStream() {    if (videoStream) {      videoStream.getTracks().forEach((track) =&gt; {        track.stop();      });    }  }  // 截图  btnScreenshot.addEventListener(&quot;click&quot;, function () {    let img = document.getElementById(&#39;screenshot&#39;);    if (!img) {      img = document.createElement(&quot;img&quot;);      img.id = &#39;screenshot&#39;;      img.style.width = &#39;100%&#39;;    }    canvas.width = video.videoWidth;    canvas.height = video.videoHeight;    canvas.getContext(&quot;2d&quot;).drawImage(video, 0, 0);    img.src = canvas.toDataURL(&quot;image/png&quot;);    screenshotsContainer.prepend(img);  });  async function init() {    stopVideoStream();    constraints.video.facingMode = useFrontCamera ? &quot;user&quot; : &quot;environment&quot;;    try {      videoStream = await navigator.mediaDevices.getUserMedia(constraints);      video.srcObject = videoStream;    } catch (error) {      console.log(error)    }  }  init();}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将向您展示如何通过JavaScript在网页上访问设备的摄像头，并支持多种浏览器，而无需外部库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端 javascript" scheme="http://www.icrazyman.cn/tags/%E5%89%8D%E7%AB%AF-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发标准规范</title>
    <link href="http://www.icrazyman.cn/2020/04/08/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/"/>
    <id>http://www.icrazyman.cn/2020/04/08/Web前端开发标准规范/</id>
    <published>2020-04-08T06:28:20.000Z</published>
    <updated>2020-04-09T12:19:40.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2></li><li><h2 id="HTML代码规范"><a href="#HTML代码规范" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h2></li><li><h2 id="CSS和SCSS代码规范"><a href="#CSS和SCSS代码规范" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h2></li><li><h2 id="JavaScript代码规范"><a href="#JavaScript代码规范" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h2></li><li><h2 id="jQuery代码规范"><a href="#jQuery代码规范" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h2></li><li><h2 id="vue代码规范"><a href="#vue代码规范" class="headerlink" title="vue代码规范"></a>vue代码规范</h2></li></ul><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://tgideas.qq.com/doc/frontend/" target="_blank" rel="noopener">腾讯前端开发规范</a></li><li><a href="http://alloyteam.github.io/CodeGuide/#project-naming" target="_blank" rel="noopener">通过分析github代码库总结出来的工程师代码书写习惯</a></li><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">JavaScript Standard Style</a>。</li><li><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue官网风格指南</a></li></ol><h1 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h2><ul><li>全部采用小写方式， 以下划线分隔；</li><li>有明显分类的，使用语义化的命名，无明确意义的，可用page01.html；</li><li>禁止使用特殊字符。</li></ul><pre><code class="js">例：my_project_name</code></pre><h2 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h2><ul><li>参照项目命名规则；</li><li>有复数结构时，要采用复数命名法；</li><li>图片文件夹：img；</li><li>css文件夹：css；</li><li>js文件夹：js；</li><li>include页面片段文件夹：inc。</li></ul><pre><code class="js">例：scripts, styles, images, data_models</code></pre><h2 id="JS文件命名"><a href="#JS文件命名" class="headerlink" title="JS文件命名"></a>JS文件命名</h2><ul><li>参照项目命名规则 。</li></ul><pre><code class="js">例：account_model.js</code></pre><h2 id="CSS-SCSS文件命名"><a href="#CSS-SCSS文件命名" class="headerlink" title="CSS, SCSS文件命名"></a>CSS, SCSS文件命名</h2><ul><li>参照项目命名规则。</li></ul><pre><code class="js">例：retina_sprites.scss</code></pre><h2 id="HTML文件命名"><a href="#HTML文件命名" class="headerlink" title="HTML文件命名"></a>HTML文件命名</h2><ul><li>参照项目命名规则。</li></ul><pre><code class="js">例：error_report.html</code></pre><hr><h1 id="HTML代码规范-1"><a href="#HTML代码规范-1" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h1><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul><li><code>doctype</code>声明使用<code>html5</code> ；</li><li>在html标签上加上lang属性，更多关于 <code>lang</code> 属性的说明<a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element" target="_blank" rel="noopener">在这里</a>，在sitepoint上可以查到<a href="http://reference.sitepoint.com/html/lang-codes" target="_blank" rel="noopener">语言列表</a>；</li><li>缩进使用soft tab（4个空格），嵌套的节点应该缩进；</li><li>清晰、简介的层级嵌套结构，保证嵌套层级最少；</li><li>在属性上，使用双引号，不要使用单引号；</li><li>标签、标签属性全部小写，用中划线做分隔符；</li><li>在无法用标签表明语义的场景下增加适当的注释；</li><li>所有html标签必须有结束符，<code>&lt;img /&gt;</code>, <code>&lt;col /&gt;</code>, <code>&lt;base /&gt;</code>, <code>&lt;link /&gt;</code>, <code>&lt;meta /&gt;</code>,<code>&lt;input /&gt;</code> 除外；</li><li>标签语法无错误，需要符合语义化；</li><li>较长的HTML文件，请在板块之间加入注释，使得结构更清晰，也更利于后期维护；</li><li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式 ；</li><li>统一页面编码格式为<code>utf-8</code> , <code>meta</code>标签<code>charset</code>设置为<code>utf-8</code>;</li><li>给 <code>&lt;a&gt;</code> 标签加上title属性；</li><li><code>&lt;a&gt;</code>标签的href属性必须写上链接地址，暂无的加上<code>javascript:alert(&#39;敬请期待！&#39;)</code>；</li><li>非本专题的页面间跳转，采用打开新窗口模式：<code>target=&quot;_blank&quot;</code>，同时为了避免<a href="https://blog.csdn.net/chinashanzhang/article/details/88537581" target="_blank" rel="noopener">安全问题</a>加上<code>rel=&quot;noopener&quot;</code>；</li><li>标签自定义属性使用<code>data-name=&quot;value&quot;</code>的形式来写, 如果自定义属性特别多, 可以考虑使用标准 json 的方式去写:<code>data-json=&#39;{&quot;a&quot;:&quot;a&quot;, &quot;b&quot;:&quot;b&quot;}&#39;</code>；</li><li>css 引用置于头部<code>&lt;head&gt;</code>标签内；</li><li>js 引用置于底部<code>&lt;/body&gt;</code>标签前；</li><li><code>img</code>标签必须加<code>alt</code>，尤其是logo、商品图片等关键图片信息，对SEO友好 ；</li><li>不要忽略可选的关闭标签，例：</li> 和 。</ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;Page title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;img src=&quot;images/company_logo.png&quot; alt=&quot;Company&quot;&gt;        &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt;        &lt;!-- 活动板块 开始 --&gt;        &lt;div class=&quot;part-act&quot;&gt;            &lt;img/&gt;            ...        &lt;/div&gt;        &lt;!-- 活动板块 结束 --&gt;    &lt;/body&gt;&lt;/html&gt; </code></pre><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul><li>兼容IE11及以上、Firefox、chrome、QQ浏览器；</li><li>页面如无指定，不需要兼容IE6、7、8、9、10；</li><li>不兼容IE6、7、8、9、10的情况下，需要在页面顶部加入提示，并对.browser-tips使用醒目的颜色标识样式。</li></ul><h2 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h2><ul><li>class、id都需小写，首字符必须是字母，禁止数字或其他特殊字符。由以字母开头的小写 字母<code>（a-z）</code>、数字<code>（0-9）</code>、中划线 <code>（-）</code>组成；</li><li>可以是单个单词，也可以是组合单词，要求能够描述清楚模块和元素的含义，使其具有语义化；</li><li>双单词或多单词组合方式：<code>命名空间-模块-元素-修饰</code>，如：<code>wb-demo-header-title</code>；</li><li>样式名不能包含<code>ad</code>、ads、adv、banner、sponsor、guanggao<code>、</code>ads<code>、</code>gg`是广告含义的关键词，避免元素被网页拓展、插件屏蔽；</li><li>涉及数据、交互等需要联调的部分，禁止通过id选择器定义样式，以免开发过程中id名变化，引起页局错乱；</li><li>除非是样式reset需要，禁止对纯元素选择器设置特定样式，避免样式污染；</li><li>自己写的z-index的值不能超过100（通用组件除外），元素内容不能超过10，弹层提示在10-99之间，不允许直接使用1000-9999之类大值；</li><li>命名词穷了怎么办？试下这个工具：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">codelf</a>。</li></ul><h2 id="通用命名"><a href="#通用命名" class="headerlink" title="通用命名"></a>通用命名</h2><h3 id="页面框架命名，一般具有唯一性，推荐用ID命名"><a href="#页面框架命名，一般具有唯一性，推荐用ID命名" class="headerlink" title="页面框架命名，一般具有唯一性，推荐用ID命名"></a>页面框架命名，一般具有唯一性，推荐用ID命名</h3><table><thead><tr><th style="text-align:left">ID名称</th><th style="text-align:left">命名</th><th style="text-align:left">ID名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">头部</td><td style="text-align:left">header</td><td style="text-align:left">主体</td><td style="text-align:left">main</td></tr><tr><td style="text-align:left">脚部</td><td style="text-align:left">footer</td><td style="text-align:left">容器</td><td style="text-align:left">wrapper</td></tr><tr><td style="text-align:left">侧栏</td><td style="text-align:left">sidebar</td><td style="text-align:left">栏目</td><td style="text-align:left">column</td></tr><tr><td style="text-align:left">布局</td><td style="text-align:left">layout</td><td style="text-align:left"></td></tr></tbody></table><h3 id="模块结构命名"><a href="#模块结构命名" class="headerlink" title="模块结构命名"></a>模块结构命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">模块(如：新闻模块)</td><td style="text-align:left">mod (mod-news)</td><td style="text-align:left">标题栏</td><td style="text-align:left">title</td></tr><tr><td style="text-align:left">内容</td><td style="text-align:left">content</td><td style="text-align:left">次级内容</td><td style="text-align:left">sub-content</td></tr></tbody></table><h3 id="导航结构命名"><a href="#导航结构命名" class="headerlink" title="导航结构命名"></a>导航结构命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">导航</td><td style="text-align:left">nav</td><td style="text-align:left">主导航</td><td style="text-align:left">main-nav</td></tr><tr><td style="text-align:left">子导航</td><td style="text-align:left">sub-nav</td><td style="text-align:left">顶部导航</td><td style="text-align:left">top-nav</td></tr><tr><td style="text-align:left">菜单</td><td style="text-align:left">menu</td><td style="text-align:left">子菜单</td><td style="text-align:left">sub-menu</td></tr></tbody></table><h3 id="一般元素命名"><a href="#一般元素命名" class="headerlink" title="一般元素命名"></a>一般元素命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">二级</td><td style="text-align:left">sub</td><td style="text-align:left">面包屑</td><td style="text-align:left">breadcrumb</td></tr><tr><td style="text-align:left">标志</td><td style="text-align:left">logo</td><td style="text-align:left">广告</td><td style="text-align:left">bner(禁用banner或ad)</td></tr><tr><td style="text-align:left">登陆</td><td style="text-align:left">login</td><td style="text-align:left">注册</td><td style="text-align:left">register/reg</td></tr><tr><td style="text-align:left">搜索</td><td style="text-align:left">search</td><td style="text-align:left">加入</td><td style="text-align:left">join</td></tr><tr><td style="text-align:left">状态</td><td style="text-align:left">status</td><td style="text-align:left">按钮</td><td style="text-align:left">btn</td></tr><tr><td style="text-align:left">滚动</td><td style="text-align:left">scroll</td><td style="text-align:left">标签页</td><td style="text-align:left">tab</td></tr><tr><td style="text-align:left">文章列表</td><td style="text-align:left">list</td><td style="text-align:left">短消息</td><td style="text-align:left">msg/message</td></tr><tr><td style="text-align:left">当前的</td><td style="text-align:left">current</td><td style="text-align:left">提示小技巧</td><td style="text-align:left">tips</td></tr><tr><td style="text-align:left">图标</td><td style="text-align:left">icon</td><td style="text-align:left">注释</td><td style="text-align:left">note</td></tr><tr><td style="text-align:left">指南</td><td style="text-align:left">guide</td><td style="text-align:left">服务</td><td style="text-align:left">service</td></tr><tr><td style="text-align:left">热点</td><td style="text-align:left">hot</td><td style="text-align:left">新闻</td><td style="text-align:left">news</td></tr><tr><td style="text-align:left">下载</td><td style="text-align:left">download</td><td style="text-align:left">投票</td><td style="text-align:left">vote</td></tr><tr><td style="text-align:left">合作伙伴</td><td style="text-align:left">partner</td><td style="text-align:left">友情链接</td><td style="text-align:left">link</td></tr><tr><td style="text-align:left">版权</td><td style="text-align:left">copyright</td><td style="text-align:left">演示</td><td style="text-align:left">demo</td></tr><tr><td style="text-align:left">下拉框</td><td style="text-align:left">select</td><td style="text-align:left">摘要</td><td style="text-align:left">summary</td></tr><tr><td style="text-align:left">翻页</td><td style="text-align:left">pages</td><td style="text-align:left">主题风格</td><td style="text-align:left">themes</td></tr><tr><td style="text-align:left">设置</td><td style="text-align:left">set</td><td style="text-align:left">成功</td><td style="text-align:left">suc</td></tr><tr><td style="text-align:left">按钮</td><td style="text-align:left">btn</td><td style="text-align:left">文本</td><td style="text-align:left">txt</td></tr><tr><td style="text-align:left">颜色</td><td style="text-align:left">color/c</td><td style="text-align:left">背景</td><td style="text-align:left">bg</td></tr><tr><td style="text-align:left">边框</td><td style="text-align:left">border/bor</td><td style="text-align:left">居中</td><td style="text-align:left">center</td></tr><tr><td style="text-align:left">上</td><td style="text-align:left">top/t</td><td style="text-align:left">下</td><td style="text-align:left">bottom/b</td></tr><tr><td style="text-align:left">左</td><td style="text-align:left">left/l</td><td style="text-align:left">右</td><td style="text-align:left">right/r</td></tr><tr><td style="text-align:left">添加</td><td style="text-align:left">add</td><td style="text-align:left">删除</td><td style="text-align:left">del</td></tr><tr><td style="text-align:left">间隔</td><td style="text-align:left">sp</td><td style="text-align:left">段落</td><td style="text-align:left">p</td></tr><tr><td style="text-align:left">弹出层</td><td style="text-align:left">pop</td><td style="text-align:left">公共</td><td style="text-align:left">global/gb</td></tr><tr><td style="text-align:left">操作</td><td style="text-align:left">op</td><td style="text-align:left">密码</td><td style="text-align:left">pwd</td></tr><tr><td style="text-align:left">透明</td><td style="text-align:left">tran</td><td style="text-align:left">信息</td><td style="text-align:left">info</td></tr><tr><td style="text-align:left">重点</td><td style="text-align:left">hit</td><td style="text-align:left">预览</td><td style="text-align:left">pvw</td></tr><tr><td style="text-align:left">单行输入框</td><td style="text-align:left">input</td><td style="text-align:left">首页</td><td style="text-align:left">index</td></tr><tr><td style="text-align:left">日志</td><td style="text-align:left">blog</td><td style="text-align:left">相册</td><td style="text-align:left">photo</td></tr><tr><td style="text-align:left">留言板</td><td style="text-align:left">guestbook</td><td style="text-align:left">用户</td><td style="text-align:left">user</td></tr><tr><td style="text-align:left">确认</td><td style="text-align:left">confirm</td><td style="text-align:left">取消</td><td style="text-align:left">cancel</td></tr><tr><td style="text-align:left">报错</td><td style="text-align:left">error</td><td style="text-align:left"></td></tr></tbody></table><h2 id="引入CSS-JS"><a href="#引入CSS-JS" class="headerlink" title="引入CSS, JS"></a>引入CSS, JS</h2><blockquote><p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 <code>type</code>，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是他们的默认值。 </p></blockquote><h3 id="HTML5-规范链接"><a href="#HTML5-规范链接" class="headerlink" title="HTML5 规范链接"></a>HTML5 规范链接</h3><ul><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element" target="_blank" rel="noopener">使用link</a></li><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element" target="_blank" rel="noopener">使用style</a></li><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element" target="_blank" rel="noopener">使用script</a></li></ul><pre><code class="javascript">&lt;!-- 外联样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;reset.css&quot;&gt;&lt;!-- 内联样式 --&gt;&lt;style&gt;    ...&lt;/style&gt;&lt;!-- 外部JS --&gt;&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;!-- 内部JS --&gt;&lt;script&gt;    ...&lt;/script&gt;</code></pre><h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><blockquote><p>属性应该按照特定的顺序出现以保证易读性。</p></blockquote><ul><li><code>id</code></li><li><code>class</code></li><li><code>name</code></li><li><code>data-*</code></li><li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code> , <code>max-length</code>, <code>max</code>, <code>min</code>, <code>pattern</code></li><li><code>placeholder</code>, <code>title</code>, <code>alt</code></li><li><code>aria-*</code>, <code>role</code></li><li><code>required</code></li></ul><blockquote><p>id更加具体且应该尽量少使用，它与JS代码息息相关，所以将它放在第一位；class是为高可复用组件设计的，所以将它放在id后面（第一/二位）。</p></blockquote><pre><code class="html">&lt;a id=&quot;...&quot; class=&quot;...&quot; data-modal=&quot;toggle&quot; href=&quot;#&quot;&gt;Example link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code></pre><h2 id="boolean属性"><a href="#boolean属性" class="headerlink" title="boolean属性"></a>boolean属性</h2><blockquote><p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p></blockquote><blockquote><p>更多内容可以参考 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes" target="_blank" rel="noopener">WhatWG section on boolean attributes</a>：</p></blockquote><blockquote><p><em>boolean属性的存在表示取值为true，不存在则表示取值为false。</em></p></blockquote><pre><code class="html">&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt;    &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="JS生成标签"><a href="#JS生成标签" class="headerlink" title="JS生成标签"></a>JS生成标签</h2><blockquote><p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免在javascript中生成DOM。</p></blockquote><h2 id="减少标签数量"><a href="#减少标签数量" class="headerlink" title="减少标签数量"></a>减少标签数量</h2><blockquote><p>在编写HTML代码时，需要尽量避免多余的父节点；很多时候，需要通过迭代和重构来使HTML变得更少。</p></blockquote><pre><code class="html">&lt;!-- bad --&gt;&lt;span class=&quot;avatar&quot;&gt;    &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- good --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt;</code></pre><h2 id="实用高于完美"><a href="#实用高于完美" class="headerlink" title="实用高于完美"></a>实用高于完美</h2><blockquote><p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p></blockquote><hr><h1 id="CSS和SCSS代码规范-1"><a href="#CSS和SCSS代码规范-1" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>CSS类名命名参考样式命名；</li><li>让规则越具体越好，尽量不要使用<strong><code>ul li a {}</code></strong>这样长的选择器，最好使用<strong><code>.wb-list-wrapper {}</code></strong>之类的选择器；</li><li>禁止使用层级过深的选择器，最多5级；</li><li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式；</li><li>除非是样式reset需要，禁止对标签选择器设置特定样式，避免样式污染；</li><li>样式文件中不要出现大写的标签定义, 不要对 JS 钩子进行样式定义；</li><li>避免使用*来选择元素；</li><li>避免使用float、position，优先使用flex和grid；</li><li>避免使用<code>!important</code>, 如果必须请加注释；</li></ul><pre><code class="css"> //会导致页面所有的a标签都被加上背景 a{background:url(xxx);} //后期修改可能会添加一些span标签，如果刚好在div里面，会被污染；不利于后期维护 div span{display:block}</code></pre><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p>使用soft tab（4个空格）。 </p></blockquote><pre><code class="scss">.element {    position: absolute;    top: 10px;    left: 10px;    border-radius: 10px;    width: 50px;    height: 50px;}</code></pre><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><blockquote><p>每个属性声明末尾都要加分号。</p></blockquote><pre><code class="scss">.element {    width: 20px;    height: 20px;    background-color: red;}</code></pre><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><blockquote><p>以下几种情况不需要空格：</p></blockquote><ul><li>属性名后</li><li>多个规则的分隔符’,’前</li><li><code>!important</code> ‘!’后</li><li>属性值中’(‘后和’)’前</li><li>行末不要有多余的空格</li></ul><blockquote><p>以下几种情况需要空格：</p></blockquote><ul><li>属性值前</li><li>选择器’&gt;’, ‘+’, ‘~’前后</li><li>‘{‘前</li><li><code>!important</code> ‘!’前</li><li><code>@else</code> 前后</li><li>属性值中的’,’后</li><li>注释’/*‘后和’*/‘前</li></ul><pre><code class="scss">/* not good */.element {    color :red! important;    background-color: rgba(0,0,0,.5);}/* good */.element {    color: red !important;    background-color: rgba(0, 0, 0, .5);}/* not good */.element ,.dialog{    ...}/* good */.element,.dialog {}/* not good */.element&gt;.dialog{    ...}/* good */.element &gt; .dialog{    ...}/* not good */.element{    ...}/* good */.element {    ...}/* not good */@if{    ...}@else{    ...}/* good */@if {    ...} @else {    ...}</code></pre><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><blockquote><p>以下几种情况需要空行：</p></blockquote><ul><li>文件最后保留一个空行；</li><li>‘}’后最好跟一个空行，包括scss中嵌套的规则；</li><li>属性之间需要适当的空行，具体见后面属性声明顺序。</li></ul><pre><code class="scss">/* not good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}/* good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}</code></pre><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><blockquote><p>以下几种情况不需要换行：</p></blockquote><ul><li>‘{‘前</li></ul><blockquote><p>以下几种情况需要换行：</p></blockquote><ul><li>‘{‘后和’}’前</li><li>每个属性独占一行</li><li>多个规则的分隔符’,’后</li></ul><pre><code class="scss">/* not good */.element{color: red; background-color: black;}/* good */.element {    color: red;    background-color: black;}/* not good */.element, .dialog {    ...}/* good */.element,.dialog {    ...}</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释统一用’/<em> </em>/‘（scss中也不要用’//‘），具体参照下面的写法；</li><li>缩进与下一行代码保持一致；</li><li>难于理解的代码添加注释；</li><li>可能被错误理解的代码添加注释；</li><li>工具类等公共方法添加文档注释；</li><li>浏览器特性hack添加注释；</li><li>修改别人的 CSS 请添加注释 ；</li><li><strong>可位于一个代码行的末尾，与代码间隔一个空格。</strong></li></ul><pre><code class="scss">/* Modal header */.modal-header {    ...}/* * Modal header */.modal-header {    ...}.modal-header {    /* 50px */    width: 50px;    color: red; /* color red */}</code></pre><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li>最外层统一使用双引号；</li><li>url的内容要用引号；</li><li>属性选择器中的属性值需要引号。</li></ul><pre><code class="scss">.element:after {    content: &quot;&quot;;    background-image: url(&quot;logo.png&quot;);}li[data-type=&quot;single&quot;] {    ...}</code></pre><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>类名使用小写字母，以中划线分隔。推荐BEM命名法</li><li>id采用驼峰式命名</li><li>scss中的变量、函数、混合、placeholder采用驼峰式命名</li></ul><pre><code class="scss">/* class */.block-element-modifier {    ...}/* id */#myDialog {    ...}/* 变量 */$colorBlack: #000;/* 函数 */@function pxToRem($px) {    ...}/* 混合 */@mixin centerBlock {    ...}/* placeholder */%myDialog {    ...}</code></pre><h2 id="属性声明顺序"><a href="#属性声明顺序" class="headerlink" title="属性声明顺序"></a>属性声明顺序</h2><blockquote><p>相关的属性声明按下面的顺序做分组处理，组之间需要有一个空行。</p><ul><li>位置属性（position，top。，right， z-index， display， float等）；</li><li>大小（width, height, padding, margin）；</li><li>文字系列（font，line-height， letter-spacing，color- text-align等）；</li><li>背景边框（background，border等）；</li><li>其他（animation，transition等）；</li></ul></blockquote><pre><code class="scss">.declaration-order {    display: block;    float: right;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 100;    border: 1px solid #e5e5e5;    border-radius: 3px;    width: 100px;    height: 100px;    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;    line-height: 1.5;    text-align: center;    color: #333;    background-color: #f5f5f5;    opacity: 1;}// 下面是推荐的属性的顺序[    [        &quot;display&quot;,        &quot;visibility&quot;,        &quot;float&quot;,        &quot;clear&quot;,        &quot;overflow&quot;,        &quot;overflow-x&quot;,        &quot;overflow-y&quot;,        &quot;clip&quot;,        &quot;zoom&quot;    ],    [        &quot;table-layout&quot;,        &quot;empty-cells&quot;,        &quot;caption-side&quot;,        &quot;border-spacing&quot;,        &quot;border-collapse&quot;,        &quot;list-style&quot;,        &quot;list-style-position&quot;,        &quot;list-style-type&quot;,        &quot;list-style-image&quot;    ],    [        &quot;-webkit-box-orient&quot;,        &quot;-webkit-box-direction&quot;,        &quot;-webkit-box-decoration-break&quot;,        &quot;-webkit-box-pack&quot;,        &quot;-webkit-box-align&quot;,        &quot;-webkit-box-flex&quot;    ],    [        &quot;position&quot;,        &quot;top&quot;,        &quot;right&quot;,        &quot;bottom&quot;,        &quot;left&quot;,        &quot;z-index&quot;    ],    [        &quot;margin&quot;,        &quot;margin-top&quot;,        &quot;margin-right&quot;,        &quot;margin-bottom&quot;,        &quot;margin-left&quot;,        &quot;-webkit-box-sizing&quot;,        &quot;-moz-box-sizing&quot;,        &quot;box-sizing&quot;,        &quot;border&quot;,        &quot;border-width&quot;,        &quot;border-style&quot;,        &quot;border-color&quot;,        &quot;border-top&quot;,        &quot;border-top-width&quot;,        &quot;border-top-style&quot;,        &quot;border-top-color&quot;,        &quot;border-right&quot;,        &quot;border-right-width&quot;,        &quot;border-right-style&quot;,        &quot;border-right-color&quot;,        &quot;border-bottom&quot;,        &quot;border-bottom-width&quot;,        &quot;border-bottom-style&quot;,        &quot;border-bottom-color&quot;,        &quot;border-left&quot;,        &quot;border-left-width&quot;,        &quot;border-left-style&quot;,        &quot;border-left-color&quot;,        &quot;-webkit-border-radius&quot;,        &quot;-moz-border-radius&quot;,        &quot;border-radius&quot;,        &quot;-webkit-border-top-left-radius&quot;,        &quot;-moz-border-radius-topleft&quot;,        &quot;border-top-left-radius&quot;,        &quot;-webkit-border-top-right-radius&quot;,        &quot;-moz-border-radius-topright&quot;,        &quot;border-top-right-radius&quot;,        &quot;-webkit-border-bottom-right-radius&quot;,        &quot;-moz-border-radius-bottomright&quot;,        &quot;border-bottom-right-radius&quot;,        &quot;-webkit-border-bottom-left-radius&quot;,        &quot;-moz-border-radius-bottomleft&quot;,        &quot;border-bottom-left-radius&quot;,        &quot;-webkit-border-image&quot;,        &quot;-moz-border-image&quot;,        &quot;-o-border-image&quot;,        &quot;border-image&quot;,        &quot;-webkit-border-image-source&quot;,        &quot;-moz-border-image-source&quot;,        &quot;-o-border-image-source&quot;,        &quot;border-image-source&quot;,        &quot;-webkit-border-image-slice&quot;,        &quot;-moz-border-image-slice&quot;,        &quot;-o-border-image-slice&quot;,        &quot;border-image-slice&quot;,        &quot;-webkit-border-image-width&quot;,        &quot;-moz-border-image-width&quot;,        &quot;-o-border-image-width&quot;,        &quot;border-image-width&quot;,        &quot;-webkit-border-image-outset&quot;,        &quot;-moz-border-image-outset&quot;,        &quot;-o-border-image-outset&quot;,        &quot;border-image-outset&quot;,        &quot;-webkit-border-image-repeat&quot;,        &quot;-moz-border-image-repeat&quot;,        &quot;-o-border-image-repeat&quot;,        &quot;border-image-repeat&quot;,        &quot;padding&quot;,        &quot;padding-top&quot;,        &quot;padding-right&quot;,        &quot;padding-bottom&quot;,        &quot;padding-left&quot;,        &quot;width&quot;,        &quot;min-width&quot;,        &quot;max-width&quot;,        &quot;height&quot;,        &quot;min-height&quot;,        &quot;max-height&quot;    ],    [        &quot;font&quot;,        &quot;font-family&quot;,        &quot;font-size&quot;,        &quot;font-weight&quot;,        &quot;font-style&quot;,        &quot;font-variant&quot;,        &quot;font-size-adjust&quot;,        &quot;font-stretch&quot;,        &quot;font-effect&quot;,        &quot;font-emphasize&quot;,        &quot;font-emphasize-position&quot;,        &quot;font-emphasize-style&quot;,        &quot;font-smooth&quot;,        &quot;line-height&quot;,        &quot;text-align&quot;,        &quot;-webkit-text-align-last&quot;,        &quot;-moz-text-align-last&quot;,        &quot;-ms-text-align-last&quot;,        &quot;text-align-last&quot;,        &quot;vertical-align&quot;,        &quot;white-space&quot;,        &quot;text-decoration&quot;,        &quot;text-emphasis&quot;,        &quot;text-emphasis-color&quot;,        &quot;text-emphasis-style&quot;,        &quot;text-emphasis-position&quot;,        &quot;text-indent&quot;,        &quot;-ms-text-justify&quot;,        &quot;text-justify&quot;,        &quot;letter-spacing&quot;,        &quot;word-spacing&quot;,        &quot;-ms-writing-mode&quot;,        &quot;text-outline&quot;,        &quot;text-transform&quot;,        &quot;text-wrap&quot;,        &quot;-ms-text-overflow&quot;,        &quot;text-overflow&quot;,        &quot;text-overflow-ellipsis&quot;,        &quot;text-overflow-mode&quot;,        &quot;-ms-word-wrap&quot;,        &quot;word-wrap&quot;,        &quot;-ms-word-break&quot;,        &quot;word-break&quot;    ],    [        &quot;color&quot;,        &quot;background&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;,        &quot;background-color&quot;,        &quot;background-image&quot;,        &quot;background-repeat&quot;,        &quot;background-attachment&quot;,        &quot;background-position&quot;,        &quot;-ms-background-position-x&quot;,        &quot;background-position-x&quot;,        &quot;-ms-background-position-y&quot;,        &quot;background-position-y&quot;,        &quot;-webkit-background-clip&quot;,        &quot;-moz-background-clip&quot;,        &quot;background-clip&quot;,        &quot;background-origin&quot;,        &quot;-webkit-background-size&quot;,        &quot;-moz-background-size&quot;,        &quot;-o-background-size&quot;,        &quot;background-size&quot;    ],    [        &quot;outline&quot;,        &quot;outline-width&quot;,        &quot;outline-style&quot;,        &quot;outline-color&quot;,        &quot;outline-offset&quot;,        &quot;opacity&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.Alpha(Opacity&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.Alpha&quot;,        &quot;-ms-interpolation-mode&quot;,        &quot;-webkit-box-shadow&quot;,        &quot;-moz-box-shadow&quot;,        &quot;box-shadow&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;text-shadow&quot;    ],    [        &quot;-webkit-transition&quot;,        &quot;-moz-transition&quot;,        &quot;-ms-transition&quot;,        &quot;-o-transition&quot;,        &quot;transition&quot;,        &quot;-webkit-transition-delay&quot;,        &quot;-moz-transition-delay&quot;,        &quot;-ms-transition-delay&quot;,        &quot;-o-transition-delay&quot;,        &quot;transition-delay&quot;,        &quot;-webkit-transition-timing-function&quot;,        &quot;-moz-transition-timing-function&quot;,        &quot;-ms-transition-timing-function&quot;,        &quot;-o-transition-timing-function&quot;,        &quot;transition-timing-function&quot;,        &quot;-webkit-transition-duration&quot;,        &quot;-moz-transition-duration&quot;,        &quot;-ms-transition-duration&quot;,        &quot;-o-transition-duration&quot;,        &quot;transition-duration&quot;,        &quot;-webkit-transition-property&quot;,        &quot;-moz-transition-property&quot;,        &quot;-ms-transition-property&quot;,        &quot;-o-transition-property&quot;,        &quot;transition-property&quot;,        &quot;-webkit-transform&quot;,        &quot;-moz-transform&quot;,        &quot;-ms-transform&quot;,        &quot;-o-transform&quot;,        &quot;transform&quot;,        &quot;-webkit-transform-origin&quot;,        &quot;-moz-transform-origin&quot;,        &quot;-ms-transform-origin&quot;,        &quot;-o-transform-origin&quot;,        &quot;transform-origin&quot;,        &quot;-webkit-animation&quot;,        &quot;-moz-animation&quot;,        &quot;-ms-animation&quot;,        &quot;-o-animation&quot;,        &quot;animation&quot;,        &quot;-webkit-animation-name&quot;,        &quot;-moz-animation-name&quot;,        &quot;-ms-animation-name&quot;,        &quot;-o-animation-name&quot;,        &quot;animation-name&quot;,        &quot;-webkit-animation-duration&quot;,        &quot;-moz-animation-duration&quot;,        &quot;-ms-animation-duration&quot;,        &quot;-o-animation-duration&quot;,        &quot;animation-duration&quot;,        &quot;-webkit-animation-play-state&quot;,        &quot;-moz-animation-play-state&quot;,        &quot;-ms-animation-play-state&quot;,        &quot;-o-animation-play-state&quot;,        &quot;animation-play-state&quot;,        &quot;-webkit-animation-timing-function&quot;,        &quot;-moz-animation-timing-function&quot;,        &quot;-ms-animation-timing-function&quot;,        &quot;-o-animation-timing-function&quot;,        &quot;animation-timing-function&quot;,        &quot;-webkit-animation-delay&quot;,        &quot;-moz-animation-delay&quot;,        &quot;-ms-animation-delay&quot;,        &quot;-o-animation-delay&quot;,        &quot;animation-delay&quot;,        &quot;-webkit-animation-iteration-count&quot;,        &quot;-moz-animation-iteration-count&quot;,        &quot;-ms-animation-iteration-count&quot;,        &quot;-o-animation-iteration-count&quot;,        &quot;animation-iteration-count&quot;,        &quot;-webkit-animation-direction&quot;,        &quot;-moz-animation-direction&quot;,        &quot;-ms-animation-direction&quot;,        &quot;-o-animation-direction&quot;,        &quot;animation-direction&quot;    ],    [        &quot;content&quot;,        &quot;quotes&quot;,        &quot;counter-reset&quot;,        &quot;counter-increment&quot;,        &quot;resize&quot;,        &quot;cursor&quot;,        &quot;-webkit-user-select&quot;,        &quot;-moz-user-select&quot;,        &quot;-ms-user-select&quot;,        &quot;user-select&quot;,        &quot;nav-index&quot;,        &quot;nav-up&quot;,        &quot;nav-right&quot;,        &quot;nav-down&quot;,        &quot;nav-left&quot;,        &quot;-moz-tab-size&quot;,        &quot;-o-tab-size&quot;,        &quot;tab-size&quot;,        &quot;-webkit-hyphens&quot;,        &quot;-moz-hyphens&quot;,        &quot;hyphens&quot;,        &quot;pointer-events&quot;    ]]</code></pre><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><blockquote><p>颜色16进制用小写字母；颜色16进制尽量用简写。</p></blockquote><pre><code class="scss">/* not good */.element {    color: #ABCDEF;    background-color: #001122;}/* good */.element {    color: #abcdef;    background-color: #012;}</code></pre><h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><blockquote><p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p></blockquote><blockquote><p><code>margin</code> 和 <code>padding</code> 相反，需要使用简写；</p></blockquote><blockquote><p>常见的属性简写包括：</p></blockquote><ul><li><code>font</code></li><li><code>background</code></li><li><code>transition</code></li><li><code>animation</code></li></ul><pre><code class="scss">/* not good */.element {    transition: opacity 1s linear 2s;}/* good */.element {    transition-delay: 2s;    transition-timing-function: linear;    transition-duration: 1s;    transition-property: opacity;}</code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p><pre><code class="scss">.element {    ...}.element-avatar{    ...}@media (min-width: 480px) {    .element {        ...    }    .element-avatar {        ...    }}</code></pre><h2 id="SCSS相关"><a href="#SCSS相关" class="headerlink" title="SCSS相关"></a>SCSS相关</h2><ul><li>声明顺序：<ul><li><code>@extend</code></li><li>不包含 <code>@content</code> 的 <code>@include</code></li><li>包含 <code>@content</code> 的 <code>@include</code></li><li>自身属性</li><li>嵌套规则</li></ul></li><li>提交的代码中不要有 <code>@debug</code>；</li><li><code>@import</code> 引入的文件不需要开头的’_’和结尾的’.scss’；</li><li>嵌套最多不能超过5层；</li><li><code>@extend</code> 中使用placeholder选择器；</li><li>去掉不必要的父级引用符号’&amp;’。</li></ul><pre><code class="scss">/* not good */@import &quot;_dialog.scss&quot;;/* good */@import &quot;dialog&quot;;/* not good */.fatal {    @extend .error;}/* good */.fatal {    @extend %error;}/* not good */.element {    &amp; &gt; .dialog {        ...    }}/* good */.element {    &gt; .dialog {        ...    }}</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>不允许有空的规则；</li><li>元素选择器用小写字母；</li><li>去掉小数点前面的0；</li><li>去掉数字中不必要的小数点和末尾的0；</li><li>属性值’0’后面不要加单位；</li><li>同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法；</li><li>无前缀的标准属性应该写在有前缀的属性后面；</li><li>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</li><li>不要在一个文件里出现两个相同的规则；</li><li>用 <code>border: 0;</code> 代替 <code>border: none;</code>；</li><li>选择器不要超过5层（在scss中如果超过5层应该考虑用嵌套的方式来写）；</li><li>发布的代码中不要有 <code>@import</code>；</li><li>尽量少用’*’选择器。</li></ul><pre><code class="scss">/* not good */.element {}/* not good */LI {    ...}/* good */li {    ...}/* not good */.element {    color: rgba(0, 0, 0, 0.5);}/* good */.element {    color: rgba(0, 0, 0, .5);}/* not good */.element {    width: 50.0px;}/* good */.element {    width: 50px;}/* not good */.element {    width: 0px;}/* good */.element {    width: 0;}/* not good */.element {    border-radius: 3px;    -webkit-border-radius: 3px;    -moz-border-radius: 3px;    background: linear-gradient(to bottom, #fff 0, #eee 100%);    background: -webkit-linear-gradient(top, #fff 0, #eee 100%);    background: -moz-linear-gradient(top, #fff 0, #eee 100%);}/* good */.element {    -webkit-border-radius: 3px;       -moz-border-radius: 3px;            border-radius: 3px;    background: -webkit-linear-gradient(top, #fff 0, #eee 100%);    background:    -moz-linear-gradient(top, #fff 0, #eee 100%);    background:         linear-gradient(to bottom, #fff 0, #eee 100%);}/* not good */.element {    color: rgb(0, 0, 0);    width: 50px;    color: rgba(0, 0, 0, .5);}/* good */.element {    color: rgb(0, 0, 0);    color: rgba(0, 0, 0, .5);}</code></pre><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><h3 id="图片命名"><a href="#图片命名" class="headerlink" title="图片命名"></a>图片命名</h3><ul><li>图片名称必须小写，禁止使用特殊字符、中文；</li><li>使用英文或拼音缩写，禁止特殊字符；</li><li>名称间隔使用-符号；</li><li>命名需要能体现图片的大概用途；</li><li>禁止文件名和实际图片内容不符。反面例子：图片名为’weixin-qrcode’，图片内容却是头像。</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>图片体积不能超过300K；</li><li>JPG图片必须压缩，一般80%品质即可，保证文字清晰；</li><li>JPG图片必须使用渐进式图片：使用Photoshop的“存储为web所用格式”时候，勾选“连续”；</li><li>透明PNG图片必须使用<a href="https://tgideas.qq.com/doc/frontend/tool/imagecompress.html" target="_blank" rel="noopener">压缩工具</a>压缩后提供。</li></ul><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><ul><li>img图片必须填写width、height、alt属性；</li><li>移动端必须填写<code>alt</code>属性；</li><li><code>alt</code>不能为无意义字符，需要能表现出图片的含义，如图片为道具图，则应该为道具的名称。</li></ul><h3 id="合理切图"><a href="#合理切图" class="headerlink" title="合理切图"></a>合理切图</h3><ul><li>文字禁止切到图片中，如果不确定是否需要变动，请咨询接口人；</li><li>序后台动态生成的图片，如道具图片、头像、奖品，必须单独切割出来；</li><li>图片合并成精灵图或做成字体图标，减少页面请求。</li></ul><hr><h1 id="JavaScript代码规范-1"><a href="#JavaScript代码规范-1" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h1><h2 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p>使用soft tab（2个空格）。</p></blockquote><pre><code class="js">if (x &lt; y) {  x += 10;} else {  x += 1;}</code></pre><h2 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h2><blockquote><p>不要超过100，但如果编辑器开启word wrap可以不考虑单行长度。</p></blockquote><h2 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h2><blockquote><p>以下几种情况后需加分号：</p></blockquote><ul><li>变量声明</li><li>表达式</li><li>return</li><li>throw</li><li>break</li><li>continue</li><li>do-while</li></ul><blockquote><p>以下几种情况后无需分号</p></blockquote><ul><li>for</li><li>function</li><li>if</li><li>switch</li><li>try</li><li>while</li></ul><pre><code class="js">/* var declaration */var x = 1;/* expression statement */x++;/* do-while */do {    x++;} while (x &lt; 10);</code></pre><h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><blockquote><p>以下几种情况不需要空格：</p></blockquote><ul><li>对象的属性名后；</li><li>前缀一元运算符后；</li><li>后缀一元运算符前；</li><li>函数调用括号前；</li><li>无论是函数声明还是函数表达式，’(‘前不要空格；</li><li>数组的’[‘后和’]’前；</li><li>对象的’{‘后和’}’前；</li><li>运算符’(‘后和’)’前。</li></ul><blockquote><p>以下几种情况需要空格：</p></blockquote><ul><li>二元运算符前后；</li><li>三元运算符’?:’前后；</li><li>代码块’{‘前；</li><li>下列关键字前：<code>else</code>, <code>while</code>, <code>catch</code>, <code>finally；</code></li><li>下列关键字后：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>case</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>, <code>return</code>, <code>typeof；</code></li><li>单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后；</li><li>对象的属性值前；</li><li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格；</li><li>无论是函数声明还是函数表达式，’{‘前一定要有空格；</li><li>函数的参数之间。</li></ul><pre><code class="js">// not goodvar a = {    b :1};// goodvar a = {    b: 1};// not good++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2;// not goodvar a = [ 1, 2 ];// goodvar a = [1, 2];// not goodvar a = ( 1+2 )*3;// goodvar a = (1 + 2) * 3;// no space before &#39;(&#39;, one space before &#39;{&#39;, one space between function parametersvar doSomething = function(a, b, c) {    // do something};// no space before &#39;(&#39;doSomething(item);// not goodfor(i=0;i&lt;6;i++){    x++;}// goodfor (i = 0; i &lt; 6; i++) {    x++;}</code></pre><h2 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h2><blockquote><p>以下几种情况需要空行：</p></blockquote><ul><li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）；</li><li>连续空行数控制在 1 ~ 3 行（根据代码块层次来控制空行数）；</li><li>注释前（当注释在代码块的第一行时，则无需空行）；</li><li>代码块后（在函数调用、数组、对象中则无需空行）；</li><li>语法意义上相互独立的代码将用空行分隔；</li><li>文件最后保留一个空行。</li></ul><pre><code class="js">// need blank line after variable declarationvar x = 1;// not need blank line when variable declaration is last expression in the current blockif (x &gt;= 1) {    var y = x + 1;}var a = 2;// need blank line before line commenta++;function b() {    // not need blank line when comment is first line of block    return a;}// need blank line after blocksfor (var i = 0; i &lt; 2; i++) {    if (true) {        return false;    }    continue;}var obj = {    foo: function() {        return 1;    },    bar: function() {        return 2;    }};// not need blank line when in argument list, array, objectfunc(    2,    function() {        a++;    },    3);var foo = [    2,    function() {        a++;    },    3];var foo = {    a: 2,    b: function() {        a++;    },    c: 3};</code></pre><h2 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h2><ul><li>(建议)每行代码不要超过 80 字符。当一条语句一行写不下时, 折行；</li><li>“{}” (大括号)前面不需要换行, 例如函数定义、if 语句、while 语句、switch 等；</li><li>换行的地方，行末必须有’,’或者运算符；</li><li>以下几种情况不需要换行：<ul><li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li><li>代码块’{‘前</li></ul></li><li>以下几种情况需要换行：<ul><li>代码块’{‘后和’}’前</li><li>变量赋值后</li></ul></li></ul><pre><code class="js">// not goodvar a = {    b: 1    , c: 2};x = y    ? 1 : 2;// goodvar a = {    b: 1,    c: 2};x = y ? 1 : 2;x = y ?    1 : 2;// no need line break with &#39;else&#39;, &#39;catch&#39;, &#39;finally&#39;if (condition) {    ...} else {    ...}try {    ...} catch (e) {    ...} finally {    ...}// not goodfunction test(){    ...}// goodfunction test() {    ...}// not goodvar a, foo = 7, b,    c, bar = 8;// goodvar a,    foo = 7,    b, c, bar = 8;</code></pre><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><ul><li>双斜线后，必须跟一个空格；</li><li>缩进与下一行代码保持一致；</li><li>可位于一个代码行的末尾，与代码间隔一个空格。</li></ul><pre><code class="js">if (condition) {    // if you made it here, then all security checks passed    allowed();}var zhangsan = &#39;zhangsan&#39;; // one space after code</code></pre><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ul><li>最少三行, ‘*’后跟一个空格，具体参照右边的写法；</li><li>建议在以下情况下使用：<ul><li>难于理解的代码段</li><li>可能存在错误的代码段</li><li>浏览器特殊的HACK代码</li><li>业务逻辑强相关的代码</li></ul></li></ul><pre><code class="js">/* * one space after &#39;*&#39; */var x = 1;</code></pre><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><blockquote><p>各类标签@param, @method等请参考<a href="http://usejsdoc.org/" target="_blank" rel="noopener">usejsdoc</a>和<a href="http://yuri4ever.github.io/jsdoc/" target="_blank" rel="noopener">JSDoc Guide</a>；</p></blockquote><blockquote><p>建议在以下情况下使用：</p></blockquote><ul><li>所有常量</li><li>所有函数</li><li>所有类</li></ul><pre><code class="js">** * @func * @desc 一个带参数的函数 * @param {string} a - 参数a * @param {number} b=1 - 参数b默认值为1 * @param {string} c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx * @param {object} d - 参数d为一个对象 * @param {string} d.e - 参数d的e属性 * @param {string} d.f - 参数d的f属性 * @param {object[]} g - 参数g为一个对象数组 * @param {string} g.h - 参数g数组中一项的h属性 * @param {string} g.i - 参数g数组中一项的i属性 * @param {string} [j] - 参数j是一个可选参数 */function foo(a, b, c, d, g, j) {    ...}</code></pre><h2 id="引号-1"><a href="#引号-1" class="headerlink" title="引号"></a>引号</h2><blockquote><p>最外层统一使用单引号。</p></blockquote><pre><code class="js">// not goodvar x = &quot;test&quot;;// goodvar y = &#39;foo&#39;,    z = &#39;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#39;;</code></pre><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul><li>精简短小, 见名知意。 必须是有意义的文件名， 文件名中严禁出现中文 ， 多个英文单词请用大小驼峰命名法。尽量保持所有名称最短, 但是一定要保证名称具有描述性；</li><li>字符串变量值统一用单引号；</li><li>变量的命名, 不得使用 js 保留字；</li><li>请不要在文件名后加数字, 来实现相同功能的多个版本；</li><li>除非必要, 请不要使用全局变量, 避免出现全局变量污染。</li><li>函数内部的变量, 请在函数定义的头部声明。出于避免造成不必要消耗的考虑, 复杂类型的变量可以只声明不赋值。唯一特殊的情况, 是 for 循环的下标变量, 可以使用的时候实时声明；</li><li>函数内两次以上使用到的同一全局变量或者外部对象, 定义为一个局部变量, 以保证程序性能最优, 例如: var doc = document, win = window；</li><li>私有化变量和方法名应该以下划线 _ 开头；</li><li>变量不要先使用后声明；</li><li>不使用(汉语拼音/拼音英文数字组合/不规范的英文缩写)作为文件名；</li><li>尽量使用英文小写作为文件名, 免某些系统不区分文件名大小写；</li><li>常量全大写，用下划线连接，避免魔术常量，优先使用const，其次let，最后才是var；</li><li>变量名fetch或async代表异步，get代表获取，set或put代表修改，is、has、can代表布尔值，handle代表普通函数。</li></ul><pre><code class="js">var thisIsMyName;var MAX_COUNT = 10;function Person(name) {    this.name = name;}</code></pre><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><blockquote><p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。 </p></blockquote><pre><code class="js">function doSomethingWithItems(items) {    // use one var    var value = 10,        result = value + 10,        i,        len;    for (i = 0, len = items.length; i &lt; len; i++) {        result += 10;    }}</code></pre><h2 id="条件语句-循环"><a href="#条件语句-循环" class="headerlink" title="条件语句/循环"></a>条件语句/循环</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li>if语句, 即使只有单行, 也要用花括号括起来；</li><li>使用三元运算符, 替代单一的 if else 语句；</li><li>if/else/while/for 条件表达式必须有小括号, 且自占一行；</li><li>利用 &amp;&amp; 和 || 短路来简化代码；</li><li>使用严格的条件判断符。用 === 代替 ==, 用!== 代替 !=。</li></ul><pre><code class="js">if (val != 0) {     return foo();} else {    return bar();}// 可以写作:return val ? foo() : bar();function foo(opt_win) {    var win;    if (opt_win) {        win = opt_win;    } else {        win = window;    }    // ...}// 可以写作:function foo(opt_win) {    var win = opt_win || window;    // ...}</code></pre><h3 id="amp-amp-短路"><a href="#amp-amp-短路" class="headerlink" title="&amp;&amp; 短路:"></a>&amp;&amp; 短路:</h3><pre><code class="javascript">if (node) {    if (node.kids) {        if (node.kids[index]) {            foo(node.kids[index]);        }    }}// 可以写作:if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) {    foo(node.kids[index]);}// 或者var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) {    foo(kid);}</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>尽量避免 for-in 循环, 只用于 object/hash 的遍历, 数组的遍历使用 for 循环；</li><li>for-in 循环体中必须用 hasOwnProperty 方法检查成员是否为自身成员, 避免来自原型链上的污染；</li><li>避免在 if 和 while 语句的条件部分进行赋值。</li></ul><pre><code class="js">// (错误)var i = 10;while (i = i - 2) {    statement;}// 应该写作: (正确)var i = 10;while (i &gt; 0) {    statement;    i = i - 2;}</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>一个函数的内容不宜太长, 较复杂的逻辑, 需拆分成多个函数来实现, 使代码逻辑清晰；</li><li>对外暴露的 API 型函数, 尽量保持输入输出的稳定, 减小调用者修改代码的成本和风险；</li><li>无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格；</li><li>函数调用括号前不需要空格；</li><li>立即执行函数外必须包一层括号；</li><li>参数之间用’, ‘分隔，注意逗号后有一个空格；</li><li>拥抱函数式编程，遵循单一原则；</li><li>尽量减少参数数量，一般超过3个参数用对象代替；</li><li>可以嵌套函数, 用于减少重复代码, 隐藏一些局部函数等, 但不要在块内声明一个函数。因为 JS 并不支持块级作用域, 虽然很多 js 引擎都支持块内声明函数, 但它不属于 ECMAScript 规范 (见 ECMA-262, 第 13 和 14 条)。各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背。ECMAScript 只允 许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量。</li></ul><pre><code class="js">// (错误)if (x){    function foo () {}}// 应该写作: (正确)if (x) {    var foo = function () {};}// no space before &#39;(&#39;, but one space before&#39;{&#39;var doSomething = function(item) {    // do something};function doSomething(item) {    // do something}// not gooddoSomething (item);// gooddoSomething(item);// requires parentheses around immediately invoked function expressions(function() {    return 1;})();// not good[1, 2].forEach(function x() {    ...});// good[1, 2].forEach(function() {    ...});// not goodvar a = [1, 2, function a() {    ...}];// goodvar a = [1, 2, function() {    ...}];// use &#39;, &#39; between function parametersvar doSomething = function(a, b, c) {    // do something};</code></pre><h2 id="数组、对象"><a href="#数组、对象" class="headerlink" title="数组、对象"></a>数组、对象</h2><ul><li>对象属性名不需要加引号；</li><li>对象以缩进的形式书写，不要写在一行；</li></ul><pre><code class="js">// not goodvar a = {    &#39;b&#39;: 1};var a = {b: 1};var a = {    b: 1,    c: 2,};// goodvar a = {    b: 1,    c: 2,};</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>number to string的转换，建议使用<strong><code>1 + &#39;&#39;</code></strong> 或 <strong><code>Sring(1)</code></strong>，不使用<strong><code>new String(1)</code></strong> 或 <strong><code>1.tiString()</code></strong> 的方式；</li><li>string to number的转换，建议使用<strong><code>parseInt</code></strong>；</li><li>float to integer 的转换，建议使用<strong><code>Math.floor/Math.round/Math.ceil</code></strong>方法，不使用<strong><code>parseInt</code></strong>。</li></ul><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><blockquote><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p></blockquote><pre><code class="js">// not goodif (condition)    doSomething();// goodif (condition) {    doSomething();}</code></pre><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><blockquote><p>适用场景：</p></blockquote><ul><li>初始化一个将来可能被赋值为对象的变量</li><li>与已经初始化的变量做比较</li><li>作为一个参数为对象的函数的调用传参</li><li>作为一个返回对象的函数的返回值</li></ul><blockquote><p>不适用场景：</p></blockquote><ul><li>不要用null来判断函数调用时有无传参</li><li>不要与未初始化的变量做比较</li></ul><pre><code class="js">// not goodfunction test(a, b) {    if (b === null) {        // not mean b is not supply        ...    }}var a;if (a === null) {    ...}// goodvar a = null;if (a === null) {    ...}</code></pre><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><ul><li>永远不要直接使用undefined进行变量判断；</li><li>使用typeof和字符串’undefined’对变量进行判断。</li></ul><pre><code class="js">// not goodif (person === undefined) {    ...}// goodif (typeof person === &#39;undefined&#39;) {    ...}</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>不要使用 void、eval, with, 只在将 ajax 响应的文本解析为 json 时使用 eval()；</li><li>不要使用 function 构造器；</li><li>代码中调试用的 alert、console.log、console.dir、debugger 等代码, 在提交到 git 之前, 必须完全清理掉；</li><li>不要在内置对象的原型上添加方法，如Array, Date；</li><li>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</li><li>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</li><li>不要在同个作用域下声明同名变量；</li><li>不要在一些不需要的地方加括号，例：delete(a.b)；</li><li>不要使用未声明的变量；</li><li>不要声明了变量却不使用；</li><li>不要在应该做比较的地方做赋值；</li><li>数组中不要存在空元素；</li><li>不要在循环内部声明函数；</li><li>不要像这样使用构造函数，例：<code>new function () { ... }</code>, <code>new Object</code>；</li><li>不要混用tab和space；</li><li>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名；</li><li>行尾不要有空白字符；</li><li>switch的falling through和no default的情况一定要有注释特别说明；</li><li>避免硬编码；</li><li>关键的代码添加适当的异常处理；</li><li>自测要保证每一个方法、每一个变量的所有场景都覆盖到；</li><li>不允许有空的代码块。</li></ul><pre><code class="js">// not goodif (a == 1) {    a++;}// goodif (a === 1) {    a++;}// goodfor (key in obj) {    if (obj.hasOwnProperty(key)) {        // be sure that obj[key] belongs to the object and was not inherited        console.log(obj[key]);    }}// not goodArray.prototype.count = function(value) {    return 4;};// not goodvar x = 1;function test() {    if (true) {        var x = 0;    }    x += 1;}// not goodfunction test() {    console.log(x);    var x = 1;}// not goodnew Person();// goodvar person = new Person();// not gooddelete(obj.attr);// gooddelete obj.attr;// not goodif (a = 10) {    a++;}// not goodvar a = [1, , , 2, 3];// not goodvar nums = [];for (var i = 0; i &lt; 10; i++) {    (function(i) {        nums[i] = function(j) {            return i + j;        };    }(i));}// not goodvar singleton = new function() {    var privateVar;    this.publicMethod = function() {        privateVar = 1;    };    this.publicMethod2 = function() {        privateVar = 2;    };};// not goodvar a   = 1;function Person() {    // not good    var me = this;    // good    var _this = this;    // good    var that = this;    // good    var self = this;}// goodswitch (condition) {    case 1:    case 2:        ...        break;    case 3:        ...    // why fall through    case 4        ...        break;    // why no default}// not good with empty blockif (condition) {}</code></pre><hr><h1 id="jQuery代码规范-1"><a href="#jQuery代码规范-1" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h1><h2 id="jQuery变量"><a href="#jQuery变量" class="headerlink" title="jQuery变量"></a>jQuery变量</h2><ul><li>所有用于存储、缓存jQuery对象的变量应该以$前缀命名；</li><li>最好把使用选择器返回的jQuery对象缓存到变量里，以便复用；</li><li>使用<a href="http://en.wikipedia.org/wiki/CamelCase" target="_blank" rel="noopener">驼峰法</a>命名变量。</li></ul><pre><code class="js">const $userName = $(&#39;#userName&#39;);</code></pre><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><ul><li>尽可能的使用ID选择器；</li><li>使用类（class）选择器时，不要使用元素类型；</li><li>对于ID-&gt;child的方式，使用find比用嵌套选择器高效；</li><li>给选择器一个范围，如<strong><code>$(&#39;.class&#39;, &#39;.context&#39;)</code></strong>；</li><li>避免使用全局选择器，如<strong><code>$(&#39;div.class &gt; *&#39;)</code></strong>；</li></ul><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><ul><li>字符串拼接可用ES6的模版字符串；</li><li>使用字符串连接符或者array.join()，比append高效；</li><li>不要操作空对象。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>每个页面只使用一次document的ready事件；</li><li>尽量不要使用匿名函数绑定事件，因为匿名函数不利于调试、维护、测试、重用；</li><li>不要在html标签中写事件调用，始终使用jquery来绑定、删除事件；</li><li>如果有必要，使用自定义事件（即：给事件一个作用域），这样可以方便解除事件，而不影响其它事件；</li><li>当需要给多个对象绑定相同事件时，使用事件委托。</li></ul><pre><code class="js">$(&quot;#J_my-link&quot;).on(&quot;click.mySpecialClick&quot;, myEventHandler);</code></pre><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><ul><li>将链式操作看成变量缓存和多选择器请求的替代方式；</li><li>当链式操作超过三个或者因为事件绑定变得复杂时，使用换行和缩进提高链式操作可读性；</li><li>对于长的链式操作来说，也可以把中间对象缓存成一个变量。</li></ul><pre><code class="js">$(&#39;#userName&#39;).html(&#39;zhangsan&#39;)              .siblings(&#39;#userAge&#39;)              .html(&#39;20&#39;)              .siblings(&#39;#gender&#39;)              .html(&#39;男&#39;)</code></pre><h1 id="vue代码规范-1"><a href="#vue代码规范-1" class="headerlink" title="vue代码规范"></a>vue代码规范</h1><h2 id="必要的"><a href="#必要的" class="headerlink" title="必要的"></a>必要的</h2><ul><li>组件的<code>data</code>必须是一个函数；</li><li><code>Prop</code>定义应该尽量详细；</li><li>为<code>v-for</code>设置键值<code>key</code>；</li><li>避免<code>v-if</code>和<code>v-for</code>用在一起，<code>v-for</code>的优先级要高于<code>v-if</code>；</li><li>为组件样式设置作用域<strong>（注：scss有替代解决方案）</strong>；</li></ul><pre><code class="js">export default {  data() {    return {      foo: &#39;bar&#39;    }  },  props: {    status: {      type: String,      required: true,      validator: function (value) {        return [          &#39;syncing&#39;,          &#39;synced&#39;,          &#39;version-conflict&#39;,          &#39;error&#39;        ].indexOf(value) !== -1      }    }  }}</code></pre><pre><code class="html">&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;  &lt;li    v-for=&quot;user in users&quot;    :key=&quot;user.id&quot;  &gt;    {{ user.text }}  &lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="scss">&lt;style scoped&gt;.wrapper {}.title {}&lt;/style&gt;&lt;style lang=&quot;scss&quot;&gt;.wrapper {    .title {}}&lt;/style&gt;</code></pre><h2 id="强烈推荐"><a href="#强烈推荐" class="headerlink" title="强烈推荐"></a>强烈推荐</h2><ul><li>单文件组件的文件名应该要么始终是大驼峰命名，要么始终是中划线命名；</li><li>应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或无状态的组件）应该全部以一个特定的前缀开头；</li><li>只应该用有单个活跃实例的组件应该以<code>The</code>前缀命名，以示其唯一性；</li><li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名；</li><li>组件名应该以高级别的单词开头，以描述性的修饰词结尾；</li><li>对于绝大多数项目来说，在单文件组件和字符串模版中组件名应该总是大驼峰命名，但在DOM模版中总是中划线命名；</li><li>组件名应该倾向于完整单词而不是缩写；</li><li>在声明<code>prop</code>的时候，其命名应该始终使用大驼峰，而在模版中应该始终使用中划线；</li><li>多个属性的元素应该分多行，每个属性一行；</li><li>组件模版应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法；</li><li>应该把复杂计算属性分割为尽可能多的更 简单的属性；</li><li>非空的属性值应该始终带引号（单引号或双引号，选你JS里不用的那个）；</li><li>指令缩写；</li><li>其它参考Vue官网的风格指南。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;HTML代码规范&quot;&gt;&lt;a href=&quot;#HTML代码规范&quot; class=&quot;headerlink&quot; title=&quot;HTML代码规范&quot;&gt;&lt;/a&gt;HTML代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;CSS和SCSS代码规范&quot;&gt;&lt;a href=&quot;#CSS和SCSS代码规范&quot; class=&quot;headerlink&quot; title=&quot;CSS和SCSS代码规范&quot;&gt;&lt;/a&gt;CSS和SCSS代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;JavaScript代码规范&quot;&gt;&lt;a href=&quot;#JavaScript代码规范&quot; class=&quot;headerlink&quot; title=&quot;JavaScript代码规范&quot;&gt;&lt;/a&gt;JavaScript代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;jQuery代码规范&quot;&gt;&lt;a href=&quot;#jQuery代码规范&quot; class=&quot;headerlink&quot; title=&quot;jQuery代码规范&quot;&gt;&lt;/a&gt;jQuery代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;vue代码规范&quot;&gt;&lt;a href=&quot;#vue代码规范&quot; class=&quot;headerlink&quot; title=&quot;vue代码规范&quot;&gt;&lt;/a&gt;vue代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="代码 前端 开发 标准 规范 质量" scheme="http://www.icrazyman.cn/tags/%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF-%E5%BC%80%E5%8F%91-%E6%A0%87%E5%87%86-%E8%A7%84%E8%8C%83-%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端代码质量的思考与实践</title>
    <link href="http://www.icrazyman.cn/2020/03/16/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.icrazyman.cn/2020/03/16/代码质量提升的思考与实践/</id>
    <published>2020-03-16T06:28:20.000Z</published>
    <updated>2020-03-20T02:18:06.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端代码质量的思考与实践"><a href="#前端代码质量的思考与实践" class="headerlink" title="前端代码质量的思考与实践"></a>前端代码质量的思考与实践</h1><p>编写可读的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是能够被阅读，其次才是能够被正确执行。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结，除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p><p>JavaScript 是动态和弱类型的语言，使用起来比较轻松随意，在IE6那个刀耕火种的时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端工程化技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p><a id="more"></a><h1 id="分享与共勉"><a href="#分享与共勉" class="headerlink" title="分享与共勉"></a>分享与共勉</h1><blockquote><ol><li><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.      —— Martin Fowler</p></li><li><p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, “How can I improve the code so that this comment isn’t needed?”               ——Steve McConnell</p></li><li>Programs must be written for people to read, and only incidentally for machines to execute.   —— Harold Abelson</li></ol></blockquote><h2 id="HTML中的实践"><a href="#HTML中的实践" class="headerlink" title="HTML中的实践"></a>HTML中的实践</h2><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMOcYJhBQLaq05rZi5yu9lFKrXZnpijz2VeCefrbR0CyNNnP2pOfW4aK*x7lupyOOwQ!!/b&amp;bo=jAEjAYwBIwEDCSw!&amp;rf=viewer_4" alt></p><ul><li><p>使用语义化标签</p></li><li><p>清晰、简洁的层级嵌套结构</p></li><li><p>尽可能少地使用无意义的标签，如div和span</p></li><li><p>语义不明显，可以用p也可以用div，优先用p标签</p></li><li><p>在无法用标签表明语义的场景下增加适当的注释</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2yC28RF9x3naE7Gy8FpNQOfLxe5IVY16QJ1P64SI7Z2AwXvgsCMngyFR7y2Ptvp9RQ!!/b&amp;bo=vwX.Ab8F*gEDKQw!&amp;rf=viewer_4" alt></p></li></ul><h2 id="CSS中的实践"><a href="#CSS中的实践" class="headerlink" title="CSS中的实践"></a>CSS中的实践</h2><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xgnO5gqaLn54n17E2fw0O.DfbXw1lsknXg8xE7DW*c2tUyxue2W1ZUELC*H5X4R0Q!!/b&amp;bo=kAFkAZABZAEDGTw!&amp;rf=viewer_4" alt></p><ul><li>引入sass或其他css预处理器</li><li>命名可以参考借鉴BEM命名法和中划线命名法</li><li>根节点用id选择器，其它用类选择器，子代替代后代</li><li>css属性书写采用约定的顺序</li><li>类命名中划线分隔不超过4级，超过了从0开始</li><li>尽量避免使用float，position，采用flex布局和grid布局</li><li>如果只能直接编写css，也可以参考上述体现的思路</li><li>如果无法直接引入sass，可用IDE或终端进行手动转译</li></ul><h2 id="javascript和jQuery的实践"><a href="#javascript和jQuery的实践" class="headerlink" title="javascript和jQuery的实践"></a>javascript和jQuery的实践</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>　　变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p><p>　　命名必须传递足够的信息，形如 getData 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 fetchUserInfoAsync 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 Async 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p><ul><li>命名的基础。用名词命名对象，用动词命名函数，用复数表示集合，也可以加上List或Map后缀来显示地表示出来，使代码接近于自然语言。变量命名建议用小驼峰，类建议用大驼峰。</li><li>命名规范。时刻按照某种规则来命名变量和函数，不用担心变量污染和能够见名知意了。如：fetch或async代表异步，get代表获取，set代表设置，is、has、can代表一个布尔值，handle代表普通函数等。.</li><li>命名的上下文。变量都是处在上下文（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。</li><li>匈牙利命名法。基本原则：变量名=属性+类型+描述。其中每一个对象的名称都要求有明确含义，可以取对象全称或简写。例如：sUserName，代表用户姓名的字符串。拥有一定的学习成本，自行取舍。.</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xS7LHFisL2UuNcq9tyvnA57nsCHTVc9sf0RSFNj6gzQvwm6a1eiQLuMO3ynK9ylOQ!!/b&amp;bo=OQGWATkBlgEDGTw!&amp;rf=viewer_4" alt></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>　　在ECMAScript 6之前，JavaScript中并没有真正的常量的概念。然而，这并不能组织开发者将变量用作常量。为了区分普通的变量（变量的值是可变的）和常量（常量的值初始化之后就不能变了），一种通用的命名约定应运而生。这个约定源自于C语言，它使用大写字母和下划线来命名，下划线用以分隔单词。</p><ul><li>约定命名。变量名全部用大写字母，多个单词用下划线分隔</li><li>魔术常量。同一个常量（值）在不同的上下文中可能代表着不同的含义。引申到js中，就是要使用有意义的变量名代替魔术常量，以提高代码的维护性和可读性。</li><li>避免硬编码。对于代码中重复使用次数较多、未来可能会变动的数据，最好抽离成变量或配置项，实现代码逻辑和业务松耦合，增强维护性。</li><li>常量的声明。按关键字优先使用顺序：const =&gt; let =&gt; var。能用const和let的尽量不要用var，var声明有副作用。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M22WMg2mLZUCVABtDtZCdO1Z8.2*4usStHIQRfxhxl7FS5r3y0dk*CeLHBP11kxbOsA!!/b&amp;bo=iQISAokCEgIDKQw!&amp;rf=viewer_4" alt></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>　　何时添加注释是具有争议的一个话提。代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p><ul><li>难于理解的代码。逻辑比较复杂或特殊的业务逻辑时都应当加注释。关键是让其他人更容易读懂这段代码。</li><li>可能被错误理解的代码。在团队开发中，当自己写的代码可能会被其他同事认为有错误时，需要添加注释。</li><li>浏览器特性hack。兼容性代码会让人看不明白，此时应当添加适当的注释解释其用途。</li><li>文档注释。对于工具类等公共方法，添加文档注释，解释其用途、参数和返回值，让人看注释就能明白使用方法，而不用关心方法内部的实现。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2zi24H4VLsBBQoPLNB9S5tGFifc7*JQ42kvVMTRUMLv0sehXvdQy03ifIM9jOwPUHw!!/b&amp;bo=KQJUAikCVAIDKQw!&amp;rf=viewer_4" alt></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>　　JS是一种多范式编程语言。函数式编程是一种编程范式，一种构建计算机程序结构和元素的方式，将计算视为数学函数的评估并避免改变状态和可变数据。它使你能够构建无副作用的功能，而函数式编程的一些优点，也使得系统变得更加容易维护。</p><ul><li><p>纯函数。给出相同的参数，它返回相同的结果（确定性）；不会引起任何可观察到的副作用；容易测试。</p></li><li><p>闭包。通过闭包可以在函数外部能访问到函数内部的变量，过度地使用闭包会造成内存泄露。</p></li><li><p>单一原则。如果一个方法承担了过多的职责，在需求发生变化的过程中，需要改写这个方法的可能性就越大。</p></li><li><p>面向切面编程。非侵入性的改造函数。保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用现有功能模块。</p></li><li><p>健壮性。web开发安全守则：永远不要相信用户的输入。对数据最好做异常处理，增强其健壮性。例如XSS。</p></li><li><p>参数。形参越少越好，不超过3个，超过3的用对象代替，这样可以极大地减少该方法的UT自测场景。</p></li><li><p><a href="https://segmentfault.com/a/1190000014277519" target="_blank" rel="noopener">注：尾调用和尾递归</a></p></li></ul><h2 id="前端异常的处理"><a href="#前端异常的处理" class="headerlink" title="前端异常的处理"></a>前端异常的处理</h2><p>  　　前端异常的处理也属于代码健壮性的一部分。JavaScript不像Java一样，有专门的语法去定义和实现异常处理，前端代码是离用户最近的代码，异常的处理更多的是从用户体验和代码健壮性出发的，后端代码异常的处理更多的是从业务角度和数据安全性出发的。所以JavaScript的异常处理方法主要是对页面内容（用户输入和接口输入）的校验上，在异常的时候能给出用户能看懂的提示，另一方面，从代码角度来上来说，研发也能够从页面的提示上快速地定位问题、修复问题，提升解决问题的效率。</p><h2 id="使用全等-替代相等-（副作用）"><a href="#使用全等-替代相等-（副作用）" class="headerlink" title="使用全等===替代相等==（副作用）"></a>使用全等===替代相等==（副作用）</h2><p>　　javascript具有强制类型转换机制，判断相等的操作是很微妙的。对于某些运算来说，为了得到成功的结果，强制类型转换会驱使某种类型的变量自动转换成其他不同类型，这种情形往往会造成意想不到的结果。</p><p>　　发生强制类型转换最常见的场景就是，使用了判断相等运算符==和!=的时候。当要比较的两个值的类型不同时，这两个运算符都会有强制类型转换。但在很多实际情况中，代码并不按照我所期望的方式运行。Crockford的编程规范、jQuery核心风格指南、SproutCore编程风格指南推荐使用===和!==。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M29FFoZar4Ed9fGnZt3A95nhiT9tFTUbYFB0EejZvcl12atXNcTEHE7nRnNetrb0MiA!!/b&amp;bo=aQF.AWkBfgEDGTw!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M22T6agWuiSJY4RsmAba0zLnCiaSPP8TQUPenfp.A0VxIOC*xaWkGAb*5zqitw0o*AA!!/b&amp;bo=UQHRAFEB0QADGTw!&amp;rf=viewer_4" alt></p><h2 id="jQuery效率提升建议"><a href="#jQuery效率提升建议" class="headerlink" title="jQuery效率提升建议"></a>jQuery效率提升建议</h2><ul><li><p>正确使用选择器。Id &gt; tag &gt; class &gt; 属性和伪类</p></li><li><p>层级选择器尽量使用find方法，效率较高</p></li><li><p>缓存 jQuery 对象</p></li><li><p>链式调用</p></li><li><p>事件委托</p></li><li><p>少改动DOM</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMPvKCeTos0jToyTqBi1rRBT6dOhVBeGRoVS.F3JWQeUZ2iHUvGs.yFs12V8SfdNVBQ!!/b&amp;bo=tgEtAbYBLQEDCSw!&amp;rf=viewer_4" alt></p></li></ul><h2 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h2><p>　　设计模式是在软件设计过程中针对特定问题的简洁而优雅的解决方案。《parctical common lisp》的作者曾说，如果你需要一种模式，那一定是哪里出了问题。他所说的问题是指因为语言的天生缺陷，不得不去寻求和总结一种通用的解决方案。不管是弱类型或强类型，静态或动态语言，命令式或说明式语言、每种语言都有天生的优缺点。</p><p>　　单例模式比较好理解，它是一个对象，我们创建这个对象的目地是为了系统管理代码中的一些公用的变量，对象，函数，避免出现变量污染，一般我们声明一些变量和函数的时候，我们是在封闭的函数中，一般不会造成变量污染情况，但是以防万一，原因是在js中，全局变量和局部变量的关系比较复杂（有时候还夹杂着一部分变量提升问题），不少coder经常会因为此问题出现bug老半天找不到原因，创建好这个对象以后我们只是对外暴露一个对象入口，使用里面的变量时我们可以以object.变量名的形式来调用变量，其实也是为了实现js代码块的划分命名空间来设计的。</p><p>　　我之前写了几年的php和jQuery，经过了项目中不断地摸索与总结，得出了一个结论：在jquery技术栈的实际项目开发中，近乎95%的需求都可以通过单例模式来满足实现。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M23yoqG.R4bU9GAe2In3aKAmMOlYqZziNn0h5jrmD0bbwnadQl6LAL23g98wyqu8tzA!!/b&amp;bo=igFfAYoBXwEDGTw!&amp;rf=viewer_4" alt></p><h2 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h2><p>　　适配器模式是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。</p><p>　　适用场景：</p><ul><li><p>使用一个已经存在的对象，但其方法或属性接口不符合你的要求</p></li><li><p>你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作</p></li><li><p>想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2*plLxWLNIFHV2noL3MqPTwV6D4tjhYmKuX.7ktGSq55RDg*9RUVHZQXQoKn6Ei86w!!/b&amp;bo=NQGGATUBhgEDGTw!&amp;rf=viewer_4" alt></p></li></ul><h2 id="推荐ES6，其次ES5，最后ES3"><a href="#推荐ES6，其次ES5，最后ES3" class="headerlink" title="推荐ES6，其次ES5，最后ES3"></a>推荐ES6，其次ES5，最后ES3</h2><ul><li>使用const，let，不使用var</li><li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号</li><li>使用数组成员对变量赋值时，优先使用解构赋值</li><li>立即执行函数可以写成箭头函数的形式。</li><li>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</li><li>使用扩展运算符（…）拷贝数组。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xVHPGGJLk3W62UE6tyKSTJxIoiL1WNfqY2Z.4BwTFJ6ThQ*T6b1iW*JaqdLFMr96w!!/b&amp;bo=fgGDAX4BgwEDGTw!&amp;rf=viewer_4" alt></p><h1 id="VUE中的实践"><a href="#VUE中的实践" class="headerlink" title="VUE中的实践"></a><strong>VUE中的实践</strong></h1><h2 id="大道至简，通俗易懂"><a href="#大道至简，通俗易懂" class="headerlink" title="大道至简，通俗易懂"></a>大道至简，通俗易懂</h2><ul><li>语义化的标签，可以配合类名实现</li><li>层次结构清晰、简洁，用最少的嵌套实现最复杂的结构</li><li>充分利用sass的作用域，样式私有化，把css样式影响范围最小化</li><li>使用大众化的写法，减少学习的成本</li><li>尽量多使用类选择器，少用标签选择器，实现复用</li><li>CSS样式属性的顺序可以参考前面章节《CSS中的实践》</li><li>把视图展示的部分放在template中，视图层主要负责展示</li><li>把数据（entity）放在data和computed中，数据层主要负责声明（interface, abstract）</li><li>把逻辑放在methods和其他几个api里，控制层主要负责实现</li><li>单向数据流的思想。数据改变可记录、可跟踪，源头易追溯；数据只有唯一入口和出口，更直观更容易理解，提高可维护性。</li><li>注：95%的业务场景最多只需要使用到3-4个生命周期，如果超过了，检查一下自己的代码</li><li>代码风格可参考：<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/</a></li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M25XPE37S.PJb5R.TDgtTRx81Ish1w4ydp8aKx*nIGxP.IzzlF9s.fOfD0V4r*k8h9Q!!/b&amp;bo=OQGRATkBkQEDGTw!&amp;rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M24VY5agn5qVwBEh85A0PcopKQb2zs9c4RGnfmVDuvk5Lhk.nD8Ru1nVcKOG.DPISiQ!!/b&amp;bo=hwGiAYcBogEDGTw!&amp;rf=viewer_4" alt></p><h1 id="前端发展的各个阶段"><a href="#前端发展的各个阶段" class="headerlink" title="前端发展的各个阶段"></a>前端发展的各个阶段</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMEY8.2bYL3bj6kzhLfcGo0DOE.J6TQwslagnORkrmyOK8w*X5kLIqIvjaOyxocXvpg!!/b&amp;bo=eAV6AngFegIDCSw!&amp;rf=viewer_4" alt></p><h1 id="前端框架的对比"><a href="#前端框架的对比" class="headerlink" title="前端框架的对比"></a>前端框架的对比</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMFVfzlATmBYJhyyzdFoRAeC*aEdCjYFOTgf7ZRVGMNX0622SbM6Vk1r5zRYedAO1mQ!!/b&amp;bo=1ARPAtQETwIDCSw!&amp;rf=viewer_4" alt></p><h1 id="常用设计模式与代码的结合"><a href="#常用设计模式与代码的结合" class="headerlink" title="常用设计模式与代码的结合"></a>常用设计模式与代码的结合</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M24RthCo7qOxsNTQFCAzzN1QKessjCP2kiRLyTeaEiqTWmJ*9I3a9rcT6N3jvQkv58g!!/b&amp;bo=IgV.ASIFfgEDKQw!&amp;rf=viewer_4" alt></p><h1 id="JavaScript语言的特点"><a href="#JavaScript语言的特点" class="headerlink" title="JavaScript语言的特点"></a>JavaScript语言的特点</h1><ul><li>声明提升。代码在执行的时候，js解析器会先把funtion声明和var声明放在前面，然后顺序执行对应的语句。推荐用es6的const，其次let，不推荐用var。</li><li>私有变量。可以通过闭包来实现私有变量的声明，但闭包会让私有变量常驻内存，滥用闭包会造成内存泄露，所以要谨慎使用闭包。</li><li>for-in。对象可以采用传统for-in循环遍历，但该方式会遍历出原型链上的属性，产生意想不到的结果。推荐使用ES6的Object.keys和Object.values结合数组的api。</li><li>多态。JS没有多态，某种意义上说多态与函数的单一原则是对立的，所以建议多类型参数执行的是同一类逻辑的时候用多态。参考：jquery源码的Sizzle引擎。</li><li>单线程。通过异步解决单线程的弊端。但传统异步解决方案通过回调实现，大量嵌套的回调会造成回调地狱的现象，代码可读性很差，不利于维护。推荐使用ES6的Promise和async/await。</li><li>副作用。全面拥抱函数式编程，避免使用有副作用的代码，如ES3中var的声明提升，for-in的副作用，==的隐式转换， BOM中alert的阻塞效果等。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M299*8GeMdpjGTKCCRJriLP8pPZ3Cwl1Lg6EhtloA37OiaK73R8KGxyX4RREM4272Ow!!/b&amp;bo=ZwGWAWcBlgEDGTw!&amp;rf=viewer_4" alt></p><h1 id="书籍以及社区"><a href="#书籍以及社区" class="headerlink" title="书籍以及社区"></a>书籍以及社区</h1><ul><li><p>《JavaScript权威指南》：犀牛书可以先大致通读几遍，也可以把其当作工具书，时时翻阅。 </p></li><li><p>《JavaScript高级程序设计》：红宝书虽然号称高级，但其实是帮助入门的。小红书配合犀牛书，相互印证。 </p></li><li><p>《你不知道的JavaScript 上中下》：这本绝对是神书，让你了解JavaScript不为人知的另一面，把闭包、异步这些讲得很通透。 </p></li><li><p>《ES6 标准入门（第3版）》阮老师的书，ES6入门书籍。</p></li><li><p>《锋利的jQuery》循序渐进地对jQuery的各种API进行了介绍</p></li><li><p>《 JavaScript模式》陈新 译，系统地讲解了编写高质量代码的技巧和开发过程中最常用的几种设计模式。</p></li><li><p>《重构-改善既有代码的设计》一些写代码的思想层次的东西。</p></li><li><p>《编写可维护的JavaScript 》包括具体风格和原则的介绍，也包括示例和技巧说明</p></li><li><p><a href="http://www.segmentfault.com/" target="_blank" rel="noopener">思否社区</a>：中国版<a href="http://www.stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></p></li></ul><h1 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h1><p>　　软件bug的修改是需要成本的，并且这项成本总是在不断地增加，特别是对于已经广泛发布的产品代码而言，更是如此。最好的情况是当我们一发现bug，立刻就可以修改它，这种情况只发生在刚写完这些代码后不久。否则转移到新的任务上，忘记了这部分代码，就需要重新阅读这些代码。</p><p>　　对于大型项目而言，还存在着另一个问题，就是最终修改代码的人，往往并不是当初写代码的人，也不是发现bug的人。因此，减少理解自己以前写的代码的时间，或者减少理解团队中他人写的代码的时间，就变得非常关键。</p><p>　　另外一个事实在于，软件开发人员通常读代码比写代码更耗时间。通常的情形是，当我们专注于某个问题时，会坐下来花一下午的时间编写出大量的代码。这些代码可能当天就可运行，但要想成为一项成熟的应用，需要我们对代码进行重新检查、重新校正、重新调整。</p><p>　　编写高质量的代码是十分重要的，不仅对于成功地完成项目十分有利，而且有利于开发者与开发团队的其他人员进行交流。提高代码的质量，可能最初只是几小时工时写出来的代码，最终需要花费几周的工时来阅读。这就是为什么编写易维护的高质量的代码对项目具有举足轻重的作用。</p><p>　　代码的质量从某种意义上来说就是一个系统的生命线，任何上线的系统都是通过了测试的，但代码的质量决定了这个系统能走多远！我在新闻上听说过有人删库跑路的，也见过有人接手老项目后马上离职的，其中有一些就和老代码的质量问题有着必然的联系。</p><p>　　代码质量和效率之间有着天然的矛盾，怎么去平衡值得我们去思考，下面是我的一点心得与体会：1、代码风格；2、code review；3、抽离、封装、复用；4、持续学习和持续实践；5、开发周期与代码质量的平衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端代码质量的思考与实践&quot;&gt;&lt;a href=&quot;#前端代码质量的思考与实践&quot; class=&quot;headerlink&quot; title=&quot;前端代码质量的思考与实践&quot;&gt;&lt;/a&gt;前端代码质量的思考与实践&lt;/h1&gt;&lt;p&gt;编写可读的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是能够被阅读，其次才是能够被正确执行。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结，除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。&lt;/p&gt;
&lt;p&gt;JavaScript 是动态和弱类型的语言，使用起来比较轻松随意，在IE6那个刀耕火种的时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端工程化技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码 质量 实践 思考 可读性" scheme="http://www.icrazyman.cn/tags/%E4%BB%A3%E7%A0%81-%E8%B4%A8%E9%87%8F-%E5%AE%9E%E8%B7%B5-%E6%80%9D%E8%80%83-%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「译」编写更好的 JavaScript 条件式和匹配条件的技巧</title>
    <link href="http://www.icrazyman.cn/2019/06/26/%E3%80%8C%E8%AF%91%E3%80%8D%E7%BC%96%E5%86%99%E6%9B%B4%E5%A5%BD%E7%9A%84%20JavaScript%20%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.icrazyman.cn/2019/06/26/「译」编写更好的 JavaScript 条件式和匹配条件的技巧/</id>
    <published>2019-06-26T12:46:29.000Z</published>
    <updated>2019-06-26T12:48:09.691Z</updated>
    
    <content type="html"><![CDATA[<ol start="10"><li>原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria</li></ol><ul><li>原文作者：Milos Protic</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。</p><p>正如我在另一篇文章 <a href="https://devinduct.com/blogpost/22/javascript-clean-code-best-practices" target="_blank" rel="noopener">JavaScript 整洁代码的最佳实践</a>里提到的，你写的代码不单单是给机器看的，还是给“<b>未来的自己</b>”以及“<b>其他人</b>”看的。</p><p>从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。</p><a id="more"></a><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>以下是关于如何构造 <code>if...else</code> 语句以及如何用更少的代码实现更多功能的技巧。阅读愉快！</p><h2 id="1-要事第一。小细节，但很重要"><a href="#1-要事第一。小细节，但很重要" class="headerlink" title="1. 要事第一。小细节，但很重要"></a>1. 要事第一。小细节，但很重要</h2><p>不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 <code>boolean</code> 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。</p><p>不好的：</p><pre><code class="js">const isEmailNotVerified = (email) =&gt; {    // 实现}if (!isEmailNotVerified(email)) {    // 做一些事...}if (isVerified === true) {    // 做一些事...}</code></pre><p>好的：</p><pre><code class="js">const isEmailVerified = (email) =&gt; {    // 实现}if (isEmailVerified(email)) {    // 做一些事...}if (isVerified) {    // 做一些事...}</code></pre><p>现在，理清了上面的事情后，我们就可以开始了。</p><h2 id="2-对于多个条件，使用-Array-includes"><a href="#2-对于多个条件，使用-Array-includes" class="headerlink" title="2. 对于多个条件，使用 Array.includes"></a>2. 对于多个条件，使用 <code>Array.includes</code></h2><p>假设我们想要在函数中检查汽车模型是 <code>renault</code> 还是 <code>peugeot</code>。那么代码可能是这样的：</p><pre><code class="js">const checkCarModel = (model) =&gt; {    if(model === &#39;renault&#39; || model === &#39;peugeot&#39;) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 <code>or</code> 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数</p><pre><code class="js">const checkCarModel = (model) =&gt; {    if([&#39;peugeot&#39;, &#39;renault&#39;].includes(model)) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：</p><pre><code class="js">const checkCarModel = (model) =&gt; {    const models = [&#39;peugeot&#39;, &#39;renault&#39;];    if(models.includes(model)) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 <code>models</code> 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。</p><h2 id="3-匹配所有条件，使用-Array-every-或者-Array-find"><a href="#3-匹配所有条件，使用-Array-every-或者-Array-find" class="headerlink" title="3. 匹配所有条件，使用 Array.every 或者 Array.find"></a>3. 匹配所有条件，使用 <code>Array.every</code> 或者 <code>Array.find</code></h2><p>在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：</p><pre><code class="js">const cars = [  { model: &#39;renault&#39;, year: 1956 },  { model: &#39;peugeot&#39;, year: 1968 },  { model: &#39;ford&#39;, year: 1977 }];const checkEveryModel = (model) =&gt; {  let isValid = true;  for (let car of cars) {    if (!isValid) {      break;    }    isValid = car.model === model;  }  return isValid;}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><p>如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 <code>Array.every</code> 或者 <code>Array.find</code> 来达到相同的结果。</p><pre><code class="js">const checkEveryModel = (model) =&gt; {  return cars.every(car =&gt; car.model === model);}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><p>通过使用 <code>Array.find</code> 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 <code>falsy</code> 项时立即返回 <code>false</code>。</p><pre><code class="js">const checkEveryModel = (model) =&gt; {  return cars.find(car =&gt; car.model !== model) === undefined;}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><h2 id="4-匹配部分条件，使用-Array-some"><a href="#4-匹配部分条件，使用-Array-some" class="headerlink" title="4. 匹配部分条件，使用 Array.some"></a>4. 匹配部分条件，使用 <code>Array.some</code></h2><p><code>Array.every</code> 匹配所有条件，这个方法则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。</p><p>我们可以通过编写一个类似的 <code>for...loop</code> 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。</p><pre><code class="js">const cars = [  { model: &#39;renault&#39;, year: 1956 },  { model: &#39;peugeot&#39;, year: 1968 },  { model: &#39;ford&#39;, year: 1977 }];const checkForAnyModel = (model) =&gt; {  return cars.some(car =&gt; car.model === model);}console.log(checkForAnyModel(&#39;renault&#39;)); // 输出 true</code></pre><h2 id="5-提前返回而不是使用-if-else-分支"><a href="#5-提前返回而不是使用-if-else-分支" class="headerlink" title="5. 提前返回而不是使用 if...else 分支"></a>5. 提前返回而不是使用 <code>if...else</code> 分支</h2><p>当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 <code>if...else</code> 嵌套将会让我们感到很痛苦。</p><p>另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。</p><p>举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：</p><pre><code class="js">const checkModel = (car) =&gt; {  let result; // 首先，定义一个 result 变量  // 检查是否有车  if(car) {    // 检查是否有车的模型    if (car.model) {      // 检查是否有车的年份      if(car.year) {        result = `Car model: ${car.model}; Manufacturing year: ${car.year};`;      } else {        result = &#39;No car year&#39;;      }    } else {      result = &#39;No car model&#39;    }     } else {    result = &#39;No car&#39;;  }  return result; // 我们的单独的返回语句}console.log(checkModel()); // 输出 &#39;No car&#39;console.log(checkModel({ year: 1988 })); // 输出 &#39;No car model&#39;console.log(checkModel({ model: &#39;ford&#39; })); // 输出 &#39;No car year&#39;console.log(checkModel({ model: &#39;ford&#39;, year: 1988 })); // 输出 &#39;Car model: ford; Manufacturing year: 1988;&#39;</code></pre><p>正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 <code>if...else</code> 语句。</p><p>我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 <code>&amp;&amp;</code> 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。</p><pre><code class="js">const checkModel = ({model, year} = {}) =&gt; {  if(!model &amp;&amp; !year) return &#39;No car&#39;;  if(!model) return &#39;No car model&#39;;  if(!year) return &#39;No car year&#39;;  // 这里可以任意操作模型或年份  // 确保它们存在  // 无需更多检查  // doSomething(model);  // doSomethingElse(year);  return `Car model: ${model}; Manufacturing year: ${year};`;}console.log(checkModel()); // 输出 &#39;No car&#39;console.log(checkModel({ year: 1988 })); // 输出 &#39;No car model&#39;console.log(checkModel({ model: &#39;ford&#39; })); // 输出 &#39;No car year&#39;console.log(checkModel({ model: &#39;ford&#39;, year: 1988 })); // 输出 &#39;Car model: ford; Manufacturing year: 1988;&#39;</code></pre><p>在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 <code>undefined</code> 时有可用于解构的值。注意，如果传入 <code>null</code> ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 null 的时候会输出 <code>&#39;No car&#39;</code>。</p><p>对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。</p><p>根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 <code>if...else</code> 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。</p><h2 id="6-使用索引或者映射，而不是-switch-语句"><a href="#6-使用索引或者映射，而不是-switch-语句" class="headerlink" title="6. 使用索引或者映射，而不是 switch 语句"></a>6. 使用索引或者映射，而不是 <code>switch</code> 语句</h2><p>假设我们想要基于给定的国家获取汽车模型。</p><pre><code class="js">const getCarsByState = (state) =&gt; {  switch (state) {    case &#39;usa&#39;:      return [&#39;Ford&#39;, &#39;Dodge&#39;];    case &#39;france&#39;:      return [&#39;Renault&#39;, &#39;Peugeot&#39;];    case &#39;italy&#39;:      return [&#39;Fiat&#39;];    default:      return [];  }}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); // 输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;italy&#39;)); // 输出 [&#39;Fiat&#39;]</code></pre><p>上诉代码可以重构，完全去除 <code>switch</code> 语句。</p><pre><code class="js">const cars = new Map()  .set(&#39;usa&#39;, [&#39;Ford&#39;, &#39;Dodge&#39;])  .set(&#39;france&#39;, [&#39;Renault&#39;, &#39;Peugeot&#39;])  .set(&#39;italy&#39;, [&#39;Fiat&#39;]);const getCarsByState = (state) =&gt; {  return cars.get(state) || [];}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); //输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;italy&#39;)); // 输出 [&#39;Fiat&#39;]</code></pre><p>或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。</p><pre><code class="js">const carState = {  usa: [&#39;Ford&#39;, &#39;Dodge&#39;],  france: [&#39;Renault&#39;, &#39;Peugeot&#39;],  italy: [&#39;Fiat&#39;]};const getCarsByState = (state) =&gt; {  return carState[state] || [];}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); // 输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;france&#39;)); // 输出 [&#39;Renault&#39;, &#39;Peugeot&#39;]</code></pre><h2 id="7-使用自判断链接和空合并"><a href="#7-使用自判断链接和空合并" class="headerlink" title="7. 使用自判断链接和空合并"></a>7. 使用自判断链接和空合并</h2><p>到了这一小节，我终于可以说“最后”了。在我看来，这两个功能对于 JavaScript 语言来说是非常有用的。作为一个来自 C# 世界的人，可以说我经常使用它们。</p><p>在写这篇文章的时候，这些还没有得到完全的支持。因此，对于以这种方式编写的代码，你需要使用 Babel 进行编译。你可以在自判断链接这里以及在空合并这里查阅。</p><p>自判断链接允许我们在没有显式检查中间节点是否存在的时候处理树形结构，空合并可以确保节点不存在时会有一个默认值，配合自判断链接使用会有不错的效果。</p><p>让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：</p><pre><code class="js">const car = {  model: &#39;Fiesta&#39;,  manufacturer: {    name: &#39;Ford&#39;,    address: {      street: &#39;Some Street Name&#39;,      number: &#39;5555&#39;,      state: &#39;USA&#39;    }  }}// 获取汽车模型const model = car &amp;&amp; car.model || &#39;default model&#39;;// 获取厂商地址const street = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.street || &#39;default street&#39;;// 请求一个不存在的属性const phoneNumber = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.phoneNumber;console.log(model) // 输出 &#39;Fiesta&#39;console.log(street) // 输出 &#39;Some Street Name&#39;console.log(phoneNumber) // 输出 undefined</code></pre><p>因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：</p><pre><code class="js">const checkCarManufacturerState = () =&gt; {  if(car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.state === &#39;USA&#39;) {    console.log(&#39;Is from USA&#39;);  }}checkCarManufacturerState() // 输出 &#39;Is from USA&#39;</code></pre><p>我无需再赘述如果对象结构更加复杂的话，代码会多么混乱了。许多库，例如 lodash，有自己的函数作为替代方案。不过这不是我们想要的，我们想要的是在原生 js 中也能做同样的事。我们来看一下新的方法：</p><pre><code class="js">// 获取汽车模型const model = car?.model ?? &#39;default model&#39;;// 获取厂商地址const street = car?.manufacturer?.address?.street ?? &#39;default street&#39;;// 检查汽车厂商是否来自 USAconst checkCarManufacturerState = () =&gt; {  if(car?.manufacturer?.address?.state === &#39;USA&#39;) {    console.log(&#39;Is from USA&#39;);  }}</code></pre><p>这看起来更加漂亮和简洁，对我来说，非常符合逻辑。如果你想知道为什么应该使用 <code>??</code> 而不是 <code>||</code> ，只需想一想什么值可以当做 <code>true</code> 或者 <code>false</code>，你将可能有意想不到的输出。</p><p>顺便说句题外话。自判断链接同样支持 DOM API，这非常酷，意味着你可以这么做：</p><pre><code class="js">const value = document.querySelector(&#39;input#user-name&#39;)?.value;</code></pre><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><blockquote><p>对于编码过程中的面条式代码和嵌套式的if/else判断深恶痛绝，但又无可奈何，最近看了一些技术文章，专门提到过javascript复杂判断的优雅写法，深入地学习了一下，现在总算知道一些复杂场景导致复杂的判断如何优雅地编码了，以后尽量不要再写if/else了，都是有更好的解决方案的。以下是自己学习中写的demo，记录一下：</p></blockquote><pre><code class="js">// 一般写法 var status = 1 if(status === 1) {   console.log(status) } else if(status === 2) {   console.log(status) } else if(status === 3) {   console.log(status) } else if(status === 4) {   console.log(status) } else {   console.log(status) }// switch写法 var status = 1 console.log(typeof status); switch(status - 0) {   case 1:     console.log(1);     break;   case 2:   case 3:     console.log(3);     break;   case 4:     console.log(4);     break;   default:     console.log(5);     break; }// 用对象实现多分支判断 var status = 3 const actions1 = {   1: () =&gt; { console.log(1) },   2: () =&gt; { console.log(2) },   3: () =&gt; { console.log(3) },   4: () =&gt; { console.log(4) },   &#39;default&#39;: () =&gt; { console.log(5) }, } actions1[status] ? actions1[status]() : actions1[&#39;default&#39;]() // 3//用es6的Map对象封装逻辑 var status = 2 const actions = new Map([   [1, () =&gt; console.log(1)],   [2, () =&gt; console.log(2)],   [3, () =&gt; console.log(3)],   [4, () =&gt; console.log(4)],   [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)], ]) actions.get(status - 0) ? actions.get(status - 0)() : actions.get(&#39;default&#39;)() // 2// 二元判断 var identify = &#39;guest3&#39; var status = 2 var actions = new Map([     [&#39;guest1_1&#39;, () =&gt; console.log(&#39;guest_1&#39;)],     [&#39;guest2_2&#39;, () =&gt; console.log(&#39;guest_2&#39;)],     [&#39;guest3_3&#39;, () =&gt; console.log(&#39;guest_3&#39;)],     [&#39;guest4_4&#39;, () =&gt; console.log(&#39;guest_4&#39;)],     [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)] ]) actions.get(`${identify}_${status}`) ? actions.get(`${identify}_${status}`)() : actions.get(&#39;default&#39;)() // default// 用对象也可以作二元判断 var identify = &#39;guest2&#39; var status = 3 var actions = {     &#39;guest1_1&#39;: () =&gt; console.log(&#39;guest1_1&#39;),     &#39;guest2_2&#39;: () =&gt; console.log(&#39;guest2_2&#39;),     &#39;guest3_3&#39;: () =&gt; console.log(&#39;guest3_3&#39;),     &#39;guest4_4&#39;: () =&gt; console.log(&#39;guest4_4&#39;),     &#39;default&#39;: () =&gt; console.log(&#39;default&#39;), } actions[`${identify}_${status}`] ? actions[`${identify}_${status}`]() : actions[&#39;default&#39;]() //  default</code></pre><h2 id="关于多元判断的解决方案如下："><a href="#关于多元判断的解决方案如下：" class="headerlink" title="关于多元判断的解决方案如下："></a>关于多元判断的解决方案如下：</h2><pre><code class="js">const status1 = 3;const status2 = 2;const actions = new Map([  [&#39;11&#39;, () =&gt; console.log(&#39;11&#39;)],  [&#39;12&#39;, () =&gt; console.log(&#39;12&#39;)],  [&#39;13&#39;, () =&gt; console.log(&#39;13&#39;)],  [&#39;21&#39;, () =&gt; console.log(&#39;21&#39;)],  [&#39;22&#39;, () =&gt; console.log(&#39;22&#39;)],  [&#39;23&#39;, () =&gt; console.log(&#39;23&#39;)],  [&#39;31&#39;, () =&gt; console.log(&#39;31&#39;)],  [&#39;32&#39;, () =&gt; console.log(&#39;32&#39;)],  [&#39;33&#39;, () =&gt; console.log(&#39;33&#39;)],  [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)]])actions.get(`${status1}${status2}`) ? actions.get(`${status1}${status2}`)() : actions.get(&#39;default&#39;)() // 23</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;原文作者：Milos Protic&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。&lt;/p&gt;
&lt;p&gt;正如我在另一篇文章 &lt;a href=&quot;https://devinduct.com/blogpost/22/javascript-clean-code-best-practices&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 整洁代码的最佳实践&lt;/a&gt;里提到的，你写的代码不单单是给机器看的，还是给“&lt;b&gt;未来的自己&lt;/b&gt;”以及“&lt;b&gt;其他人&lt;/b&gt;”看的。&lt;/p&gt;
&lt;p&gt;从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 风格 编码 技巧" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E9%A3%8E%E6%A0%BC-%E7%BC%96%E7%A0%81-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>新手使用vue-router传参时注意事项</title>
    <link href="http://www.icrazyman.cn/2019/06/12/%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8vue-router%E4%BC%A0%E5%8F%82%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://www.icrazyman.cn/2019/06/12/新手使用vue-router传参时注意事项/</id>
    <published>2019-06-12T14:03:27.000Z</published>
    <updated>2019-06-18T11:22:41.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新手使用vue-router传参时注意事项"><a href="#新手使用vue-router传参时注意事项" class="headerlink" title="新手使用vue-router传参时注意事项"></a>新手使用vue-router传参时注意事项</h1><p>vue-router里路由传参推荐用path和query的组合，或者是name和params的组合。其中name+params传参在刷新页面后路由参数会丢失，可以在路由配置时把参数配在url上，path+query的传参刷新页面后不会丢失，但是传参会拼接到url后，有长度的限制。具体用哪一种传参方式取决于业务的需要和实际的应用场景。</p><a id="more"></a><h1 id="使用name和params组合传参"><a href="#使用name和params组合传参" class="headerlink" title="使用name和params组合传参"></a>使用name和params组合传参</h1><blockquote><pre><code class="javascript">this.$router.push({name: &#39;details&#39;, params: {&#39;id&#39;: 233}})    </code></pre></blockquote><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><pre><code class="javascript">import Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;Vue.use(Router)export default new Router({    mode: &#39;history&#39;,    routes: [        {            path: &#39;/details&#39;,            name: &#39;details&#39;,            component: resolve =&gt; require([&#39;../components/details&#39;], resolve)        }    ]})</code></pre><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><pre><code class="javascript">this.$route.params.id // 233</code></pre><p><img src="C:\Users\Administrator\Desktop\1.png" alt="1"></p><h2 id="刷新参数丢失-显示-undefined"><a href="#刷新参数丢失-显示-undefined" class="headerlink" title="刷新参数丢失 显示 undefined"></a>刷新参数丢失 显示 undefined</h2><pre><code class="javascript">this.$route.params.id // undefined</code></pre><p><img src="https://segmentfault.com/img/bVbtyj2?w=1414&amp;h=1022" alt="图片"></p><p>注意：此方法第一次跳转是没有问题的，参数也可以传过去，但是刷新页面后，参数就没了 (ps: 这个地方其实还有一个问题，当你传递的参数是number类型，第一次是没有问题的，获取的时候也是number类型，但是当你刷新页面后，number变成string类型，如果涉及计算的建议先类型转换一下)</p><p>第一次是预期结果 // 234</p><pre><code class="javascript">console.log(this.$route.params.id + 1)</code></pre><p><img src="https://segmentfault.com/img/bVbtyon?w=1290&amp;h=1016" alt></p><p>刷新页面后直接字符串拼接了 // 2331</p><p><img src="https://segmentfault.com/img/bVbtyoo?w=1006&amp;h=1050" alt></p><h2 id="参数丢失解决方案"><a href="#参数丢失解决方案" class="headerlink" title="参数丢失解决方案"></a>参数丢失解决方案</h2><pre><code class="javascript">routes: [    {        path: &#39;/details/:id&#39;, // 这里配置的要和你传递的参数名保持一致        name: &#39;details&#39;,        component: resolve =&gt; require([&#39;../components/details&#39;], resolve)    }]</code></pre><h1 id="path和query组合传参"><a href="#path和query组合传参" class="headerlink" title="path和query组合传参"></a>path和query组合传参</h1><pre><code class="javascript">this.$router.push({path: &#39;/details&#39;, query: {id: 666}})this.$route.query.id // 666</code></pre><p><img src="https://segmentfault.com/img/bVbtyqO?w=1150&amp;h=1046" alt></p><p>此方法参数会跟在问号后面 例如：/details?id=666，该方法刷新页面不会丢失参数</p><p>最后：根据自己的项目选择合适的传参方式</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新手使用vue-router传参时注意事项&quot;&gt;&lt;a href=&quot;#新手使用vue-router传参时注意事项&quot; class=&quot;headerlink&quot; title=&quot;新手使用vue-router传参时注意事项&quot;&gt;&lt;/a&gt;新手使用vue-router传参时注意事项&lt;/h1&gt;&lt;p&gt;vue-router里路由传参推荐用path和query的组合，或者是name和params的组合。其中name+params传参在刷新页面后路由参数会丢失，可以在路由配置时把参数配在url上，path+query的传参刷新页面后不会丢失，但是传参会拼接到url后，有长度的限制。具体用哪一种传参方式取决于业务的需要和实际的应用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue vue-router 框架" scheme="http://www.icrazyman.cn/tags/vue-vue-router-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>手写一个简单版本的Promise</title>
    <link href="http://www.icrazyman.cn/2019/02/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E7%9A%84Promise/"/>
    <id>http://www.icrazyman.cn/2019/02/14/手写一个简单版本的Promise/</id>
    <published>2019-02-14T12:59:11.000Z</published>
    <updated>2019-02-14T13:08:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h1><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p></blockquote><blockquote><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、resolved（已成功）和rejected（已失败）。一旦成功就不允许失败，一旦失败就不允许成功。</p></blockquote><a id="more"></a><h1 id="先把一个空架子搭出来"><a href="#先把一个空架子搭出来" class="headerlink" title="先把一个空架子搭出来"></a>先把一个空架子搭出来</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 失败回调列表    function resolve() {}; // 成功的方法    function rejecte() {}; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then(function(onFulfilled, onRejected) {})</code></pre><h1 id="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"><a href="#因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法" class="headerlink" title="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"></a>因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 拒绝回调列表    function resolve(value) {        self.status = RESOLVED; // 把状态改为resolved        self.value = value;        self.resolvedCallbacks.map(cb =&gt; cb(self.value)); // 分别执行成功回调列表里的方法，并传入value    }; // 成功的方法    function reject(value) {        self.status = REJECTED; // 把状态改为rejected        self.value = value;        self.rejectedCallbacks.map(cb =&gt; cb(self.value)); //分别执行拒绝回调列表里的方法，并传入value    }; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then(function(onFulfilled, onRejected) {})</code></pre><h1 id="返回的promise具有then方法，并能获取到初始化数据"><a href="#返回的promise具有then方法，并能获取到初始化数据" class="headerlink" title="返回的promise具有then方法，并能获取到初始化数据"></a>返回的promise具有then方法，并能获取到初始化数据</h1><pre><code class="js">MyPromise.prototype.then = function(onFulfilled, onRejected) {    const self = this;    if(self.status === PENDING) { // 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里        self.resolvedCallbacks.push(onFulfilled);        self.rejectedCallbacks.push(onRejected);    }    // 初始化后再调用then方法根据初始化的状态分别执行对应的方法    if(self.status === RESOLVED) {        onFulfilled(self.value);    }    if(self.status === REJECTED) {        onRejected(self.value);    }    return self; // 链式调用}</code></pre><h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><pre><code class="js">new MyPromise(function(resolve, reject) {    setTimeout(function(){        resolve(&#39; test &#39;)    }, 2000);}).then(function(value) {    console.log(&#39;resolve&#39; + value);}, function(value) {    console.log(&#39;reject&#39; + value);})// 结果: resolve test </code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 拒绝回调列表    function resolve(value) {        self.status = RESOLVED; // 把状态改为resolved        self.value = value;        self.resolvedCallbacks.map(cb =&gt; cb(self.value)); // 分别执行成功回调列表里的方法，并传入value    }; // 成功的方法    function reject(value) {        self.status = REJECTED; // 把状态改为rejected        self.value = value;        self.rejectedCallbacks.map(cb =&gt; cb(self.value)); //分别执行拒绝回调列表里的方法，并传入value    }; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then = function(onFulfilled, onRejected) {    const self = this;    if(self.status === PENDING) { // 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里        self.resolvedCallbacks.push(onFulfilled);        self.rejectedCallbacks.push(onRejected);    }    // 初始化后再调用then方法根据初始化的状态分别执行对应的方法    if(self.status === RESOLVED) {        onFulfilled(self.value);    }    if(self.status === REJECTED) {        onRejected(self.value);    }    return self; // 链式调用}new MyPromise(function(resolve, reject) {    setTimeout(function(){        resolve(&#39; test &#39;)    }, 2000);}).then(function(value) {    console.log(&#39;resolve&#39; + value);}, function(value) {    console.log(&#39;reject&#39; + value);})</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>首先是利用构造函数模式初始化一个promise对象，在原型上绑定实例方法，注意初始化调用then方法的时候此时状态为pending，在执行传入的方法改变状态后再调用then方法会根据修改后的状态执行不同的逻辑</p></blockquote><blockquote><p>我觉得promise对象利用了构造函数设计模式解决了js异步回调嵌套的问题，完美解决了返回数据嵌套依赖的问题，也就是俗称的回调地狱。现在算是把长久以来关于promise的疑惑搞明白了，over！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是promise&quot;&gt;&lt;a href=&quot;#什么是promise&quot; class=&quot;headerlink&quot; title=&quot;什么是promise&quot;&gt;&lt;/a&gt;什么是promise&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise对象代表一个异步操作，有三种状态：pending（进行中）、resolved（已成功）和rejected（已失败）。一旦成功就不允许失败，一旦失败就不允许成功。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="promise 异步 es6" scheme="http://www.icrazyman.cn/tags/promise-%E5%BC%82%E6%AD%A5-es6/"/>
    
  </entry>
  
  <entry>
    <title>react优化总结</title>
    <link href="http://www.icrazyman.cn/2019/01/31/react%E4%BC%98%E5%8C%96/"/>
    <id>http://www.icrazyman.cn/2019/01/31/react优化/</id>
    <published>2019-01-31T12:43:32.000Z</published>
    <updated>2019-01-31T12:43:41.090Z</updated>
    
    <content type="html"><![CDATA[<p>写了一段时间的react之后，渐渐的喜欢上了使用react来写应用。</p><p>我们知道，Facebook在推出react时打出的旗号之一就是高性能。</p><p>今天我们还一起来聊一聊react的性能优化，思考还能通过哪些手段来提升React的性能，使我们的react更快，性能更好。</p><a id="more"></a><h1 id="请慎用setState，因其容易导致重新渲染"><a href="#请慎用setState，因其容易导致重新渲染" class="headerlink" title="请慎用setState，因其容易导致重新渲染"></a>请慎用setState，因其容易导致重新渲染</h1><blockquote><p>既然将数据主要交给了Redux来管理，那就尽量使用Redux管理你的数据和状态state，除了少数情况外，别忘了shouldComponentUpdate也需要比较state。</p></blockquote><h1 id="请将方法的bind一律置于constructor"><a href="#请将方法的bind一律置于constructor" class="headerlink" title="请将方法的bind一律置于constructor"></a>请将方法的bind一律置于constructor</h1><blockquote><p>Component的render里不动态bind方法，方法都在constructor里bind好，如果要动态传参，方法可使用闭包返回一个最终可执行函数。如：showDelBtn(item) { return (e) =&gt; {}; }。如果每次都在render里面的jsx去bind这个方法，每次都要绑定会消耗性能。</p></blockquote><h1 id="请只传递component需要的props"><a href="#请只传递component需要的props" class="headerlink" title="请只传递component需要的props"></a>请只传递component需要的props</h1><blockquote><p>传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（）。</p></blockquote><h1 id="请尽量使用const-element"><a href="#请尽量使用const-element" class="headerlink" title="请尽量使用const element"></a>请尽量使用const element</h1><blockquote><p>我们可以将不怎么变动，或者不需要传入状态的component写成const element的形式，这样能加快这个element的初始渲染速度。</p></blockquote><h1 id="保证key值唯一"><a href="#保证key值唯一" class="headerlink" title="保证key值唯一"></a>保证key值唯一</h1><blockquote><p>保证key值唯一方便diff算法比较，注意不要用数组的index作为key，原因非唯一性</p></blockquote><h1 id="合理使用shouldComponentUpdate"><a href="#合理使用shouldComponentUpdate" class="headerlink" title="合理使用shouldComponentUpdate"></a>合理使用shouldComponentUpdate</h1><blockquote><p>子组件更新时候对props作出新老数据比对，如果改变了，才render子组件</p></blockquote><h1 id="使用pureComponent"><a href="#使用pureComponent" class="headerlink" title="使用pureComponent"></a>使用pureComponent</h1><blockquote><p>使用pureComponent会默认添加shouldComponentUpdate并进行浅比较</p></blockquote><h1 id="使用Immutablejs"><a href="#使用Immutablejs" class="headerlink" title="使用Immutablejs"></a>使用Immutablejs</h1><blockquote><p>使用不可变的数据来解决数据状态的变化比对，提高性能</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了一段时间的react之后，渐渐的喜欢上了使用react来写应用。&lt;/p&gt;
&lt;p&gt;我们知道，Facebook在推出react时打出的旗号之一就是高性能。&lt;/p&gt;
&lt;p&gt;今天我们还一起来聊一聊react的性能优化，思考还能通过哪些手段来提升React的性能，使我们的react更快，性能更好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react 规范 优化" scheme="http://www.icrazyman.cn/tags/react-%E8%A7%84%E8%8C%83-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://www.icrazyman.cn/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.icrazyman.cn/2019/01/20/数据结构/</id>
    <published>2019-01-20T14:47:32.000Z</published>
    <updated>2019-01-21T14:55:11.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。</p></blockquote><a id="more"></a><h1 id="为什么需要学习数据结构？"><a href="#为什么需要学习数据结构？" class="headerlink" title="为什么需要学习数据结构？"></a>为什么需要学习数据结构？</h1><h2 id="语言是相通的"><a href="#语言是相通的" class="headerlink" title="语言是相通的?"></a>语言是相通的?</h2><p>人们常说，编程语言是相通的，掌握了一门，其他语言很容易就能掌握，个人认为这是一个似是而非的观点。</p><p>每门编程语言都离不开变量，数组，循环，条件判断这些概念，这似乎能够支持上面的观点，但是，每门编程语言都有自己的适用范围。都有自己擅长的事情，即便是有了node.js这种能够一统前后端的语言，也总有它不能胜任的工作，比如机器学习。像python这样的近乎万能的语言，也总有无能为力的时候，比如面对高性能计算，许多python库的底层实现可都是C语言哦。</p><p>多年的工作经验告诉我，真正相通的不是语言，而是数据结构和算法。</p><p>数据结构和算法是脱离编程语言而存在的，不同的语言有不同的实现版本，但内在的逻辑却不会有变化，所体现的编程思想不会有变化。</p><h2 id="一段亲身经历"><a href="#一段亲身经历" class="headerlink" title="一段亲身经历"></a>一段亲身经历</h2><p>我曾经在工作有过这样一次经历，我在后端通过websockt向前端发送数据，数据是一个具体的坐标，前端的同学得到坐标后，要在前端的中国地图上根据坐标显示一个光圈。这是一个非常简单的事情，但却遇到了麻烦，后端向前端推送数据是一个不定时的行为，有时1秒钟推了3条数据，有时3秒钟才推1条数据，当我推送数据频繁的时候，如果这些坐标都在地图上显示，地图会非常乱。长时间不推送数据时，前端页面不应该一直显示之前推送过的坐标，因为每一个坐标代表一个用户刚刚在我们的网站上做了一项操作。</p><p>于是，我们对前端显示做了限制，前端同一个时刻最多显示10个坐标，如果已经有10个，新来的坐标要把之前最早到来的坐标挤掉，每个坐标最多显示5秒钟。就是这样一个简单的要求，前端同学却迟迟不能实现该功能，因为他无法兼顾最多显示10个坐标和每个坐标最多显示5秒钟的要求。</p><p>后来，我让他用队列来实现。前端在收到坐标后，将坐标和收到时间构造成一个新的对象，一同放入到队列中，如果列队元素已经有10个，则把队列头部的元素删除，于此同时，每隔1秒钟就对队列里的元素检查一次，队列头部的元素都是最早到来的，如果当前时间距离到来时间超过5秒，则删除队列头部元素。</p><p>就这样，前端同学使用队列，非常快的实现了这个功能，而且对数据结构产生了浓厚的兴趣。</p><p>每当你怀疑学习数据结构的必要性和作用时，请提醒自己，如果你手里只有锤子，那么目光所及之处都是钉子。</p><h2 id="学习数据结构的目标"><a href="#学习数据结构的目标" class="headerlink" title="学习数据结构的目标"></a>学习数据结构的目标</h2><ul><li><p>提高程序设计能力</p></li><li><p>提高算法能力</p></li><li><p>找工作面试的时候hold住面试官</p></li></ul><p>数据结构的精髓在于总结提炼了许多存储管理和使用数据的模式，这些模式的背后是最精华的编程思想，这些思想的领悟需要时间，不要想当然的认为学会了几种数据结构就可以在工作中大显身手，但学会了数据结构，对自身能力的提升是不言而喻的。</p><p>当然，在没有参悟这些数据管理方式和编程思想之前，我们先学习具体的工具和方法。</p><h2 id="学习数据结构需要准备哪些知识"><a href="#学习数据结构需要准备哪些知识" class="headerlink" title="学习数据结构需要准备哪些知识"></a>学习数据结构需要准备哪些知识</h2><p>你需要熟练地使用数组这种数据类型，我想这没什么困难，再有就是知道如何在javascript中定义类，这里推荐一篇文章<a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="noopener">Javascript定义类（class）的三种方法</a>本系列课程主要使用构造函数法定义类。</p><h1 id="数据结构之—-栈"><a href="#数据结构之—-栈" class="headerlink" title="数据结构之—-栈"></a>数据结构之—-栈</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈是一种特殊的线性表，仅能够在栈顶进行操作，有着先进后出(后进先出)的特性，下面这张图展示了栈的工作特点：</p><p><img src="https://i.imgur.com/k0yBPn0.png" alt></p><p>对于栈的理解，你必须牢牢抓住一点，那便是你只能在栈顶进行操作，生活中有一个非常贴切的例子，玩羽毛球的同学都会买一桶羽毛球，羽毛球桶就是典型的栈结构。</p><p><img src="https://i.imgur.com/lNPG23S.jpg" alt></p><p>每次取羽毛球时，都只能从顶部取，最底下的羽毛球，你是取不到的，用完了羽毛球后，也只能从顶部放回去。</p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>上一小节，我们对栈这种数据结构有了视觉上的接触和理解，接下来，我们要对栈进行定义，毕竟，我们写一个栈，为的是使用它，那么就必须先定义数据存储在哪里，提供什么样的方法。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>从数据存储的角度看，实现栈有两种方式，一种是以数组做基础，一种是以链表做基础，数组是最简单的实现方式，链表在后面会作为单独的一种数据结构来讲解。本次课程将使用数组来实现栈和队列，数组是大家平时用的最频繁的，也是最了解熟悉的数据类型。</p><p>我们先定义一个简单的Stack类</p><pre><code>function Stack() {    var items = [];  // 使用数组存储数据};</code></pre><p>数据将存储在items数组之中，现在，这个类没有任何方法。</p><h3 id="栈的方法"><a href="#栈的方法" class="headerlink" title="栈的方法"></a>栈的方法</h3><p>栈有以下几个方法：</p><ul><li>push 添加一个元素到栈顶（向桶里放入一个羽毛球）</li></ul><pre><code>// push方法向栈里压入一个元素this.push = function(item){    items.push(item);};</code></pre><ul><li>pop 弹出栈顶元素（从桶里拿出一个羽毛球）</li></ul><pre><code>// pop方法把栈顶的元素弹出this.pop = function(){    return items.pop();};</code></pre><p>数组的pop方法会删除最靠后的那个元素，同时return该元素</p><ul><li>top 返回栈顶元素，注意，不是弹出（看一眼桶里最顶端的羽毛球，但是不拿）</li></ul><pre><code>// top 方法返回栈顶元素this.top = function(){    return items[items.length - 1];};</code></pre><p>top方法只是想查看一下最顶端的元素</p><ul><li>isEmpty 判断栈是否为空（看看羽毛球是不是都用完了）</li></ul><pre><code>// isEmpty返回栈是否为空this.isEmpty = function(){    return items.length == 0;};</code></pre><ul><li>size 返回栈里元素的个数（数一下桶里还有多少羽毛球）</li></ul><pre><code>// size方法返回栈的大小this.size = function(){    return items.length;};</code></pre><ul><li>clear 清空栈（把桶里的羽毛球都倒出来扔掉）</li></ul><pre><code>// clear 清空栈this.clear = function(){    items = []}</code></pre><p>最终完成版的代码如下</p><pre><code>function Stack() {    var items = [];  // 使用数组存储数据    // push方法向栈里压入一个元素    this.push = function(item){        items.push(item);    };    // 获取数组    this.get = function() {        return items;    }    // pop方法把栈顶的元素弹出    this.pop = function(){        return items.pop();    };    // top 方法返回栈顶元素    this.top = function(){        return items[items.length - 1];    };    // isEmpty返回栈是否为空    this.isEmpty = function(){        return items.length == 0;    };    // size方法返回栈的大小    this.size = function(){        return items.length;    };    // clear 清空栈    this.clear = function(){        items = []    }}</code></pre><h3 id="被欺骗的错觉"><a href="#被欺骗的错觉" class="headerlink" title="被欺骗的错觉"></a>被欺骗的错觉</h3><p>看完上面的实现，难道你没有一种被欺骗的感觉么？传的那么神乎其神的数据结构，这里实现的栈，竟然就只是对数组做了一层封装而已啊！！！</p><p>只是做了一层封装么？请思考下面几个问题：</p><ul><li><p>给你一个数组，你可以通过索引操作任意一个元素，但是给你一个栈，你能操作任意元素么？栈提供的方法只允许你操作栈顶的元素，也就是数组的最后一个元素，这种限制其实提供给我们一种思考问题的方式，这个方式也就是栈的特性，后进先出。</p></li><li><p>既然栈的底层实现其实就是数组，栈能做的事情，数组一样可以做啊，为什么弄出一个栈来，是不是多此一举？封装是为了隐藏实现细节，站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便，后面的练习题你将有所体会。</p></li><li><p>既然栈的底层就是对数组的操作，而你平时对数组的使用已经到了非常熟练的程度了，那么请问问自己，为什么就从来都没有自己实现过一个栈呢？是你此前不知道栈的这个概念，还是知道栈的概念但是不知道它有哪些具体方法？不论是哪一种情况，都表明栈对你来说是一个全新的知识，尽管底层的实现是那么的简单，可是越简单就越能说明问题，为啥，你自己就没想出栈这个东西？</p></li></ul><h2 id="栈的应用练习"><a href="#栈的应用练习" class="headerlink" title="栈的应用练习"></a>栈的应用练习</h2><p>通过两个练习题，你或许能够明白我前面所说的站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便。</p><h3 id="合法括号"><a href="#合法括号" class="headerlink" title="合法括号"></a>合法括号</h3><ul><li>题目要求</li></ul><p>下面的字符串中包含小括号，请编写一个函数判断字符串中的括号是否合法，所谓合法，就是括号成对出现</p><pre><code>sdf(ds(ew(we)rw)rwqq)qwewe   合法(sd(qwqw)sd(sd))             合法()()sd()(sd()fw))(           不合法</code></pre><ul><li>思路分析</li></ul><p>括号存在嵌套关系，也存在并列关系，如果是用数组存储这些括号，然后再想办法一对一对的抵消掉，似乎是一个可行的办法，可是如何判断一个左括号对应的是哪个右括号呢？站在数组的肩膀上思考这个问题，就陷入到一种无从下手的绝望之中。</p><p>现在，我们站在栈的肩膀上思考这个问题，解题的步骤就非常简单，我们可以使用for循环遍历字符串的每一个字符，对每个字符做如下的操作：</p><ul><li><p>遇到左括号，就把左括号压如栈中</p></li><li><p>遇到右括号，判断栈是否为空，为空说明没有左括号与之对应，缺少左括号，字符串括号不合法，如果栈不为空，则把栈顶元素移除，这对括号抵消掉了</p></li></ul><p>当for循环结束之后，如果栈是空的，就说明所有的左右括号都抵消掉了，如果栈里还有元素，则说明缺少右括号，字符串括号不合法。</p><ul><li>示例代码</li></ul><pre><code>function is_leagl_brackets(string){    var stack = new Stack();    for(var i=0; i&lt;string.length; i++ ){        var item = string[i];        if(item == &quot;(&quot;){            // 将左括号压入栈            stack.push(item);        }else if (item==&quot;)&quot;){            // 如果为空,就说明没有左括号与之抵消            if(stack.isEmpty()){                return false;            }else{                // 将栈顶的元素弹出                stack.pop();            }        }    }    return stack.size() == 0;};console.log(is_leagl_brackets(&quot;()()))&quot;));console.log(is_leagl_brackets(&quot;sdf(ds(ew(we)rw)rwqq)qwewe&quot;));console.log(is_leagl_brackets(&quot;()()sd()(sd()fw))(&quot;));</code></pre><ul><li>小结</li></ul><p>栈的底层是不是使用了数组这不重要，重要的是栈的这种后进先出的特性，重要的是你只能操作栈顶元素的的限制，一定要忽略掉栈的底层如何实现，而只去关心栈的特性。</p><p>我们在编辑文档时，包括写代码，经常进行回退的操作，control+z就可以了，那么你有没有想过，这其实就可以用栈来实现，每一步操作都放入到栈中，当你想回退的时候，就使用pop方法把栈顶元素弹出，于是得到了你之前的一步操作。</p><hr><h3 id="计算逆波兰表达式"><a href="#计算逆波兰表达式" class="headerlink" title="计算逆波兰表达式"></a>计算逆波兰表达式</h3><ul><li>题目要求</li></ul><p>逆波兰表达式，也叫后序表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式，例如 (a+b)<em>(c+d)转换为ab+cd+</em>。</p><pre><code>[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] 等价于(4 + (13 / 5)) = 6[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;] 等价于((10 * (6 / ((9 + 3) * -11))) + 17) + 5</code></pre><p>请编写函数calc_exp(exp) 实现逆波兰表达式计算，exp的类型是数组。</p><ul><li>思路分析</li></ul><p>[“4”, “13”, “5”, “/“, “+”] 就是一个数组，在数组层面上思考这个问题，遇到 / 时，把13 和 5 拿出来计算，然后把13 和 5 删除并把结果放入到4的后面，天哪，太复杂了，太笨拙了，我已经无法继续思考了。</p><p>如果是使用栈来解决这个问题，一切就那么的自然而简单，使用for循环遍历数组，对每一个元素做如下操作：</p><ol><li><p>如果元素不是 + - * / 中的某一个，就压入栈中</p></li><li><p>如果元素是 + - * / 中的某一个，则从栈里连续弹出两个元素，并对这两个元素进行计算，将计算结果压入栈中</p></li></ol><p>for循环结束之后，栈里只有一个元素，这个元素就是整个表达式的计算结果</p><ul><li>示例代码</li></ul><pre><code>function calc_exp(arr) {    var stack = new Stack();    for(var i = 0, len = arr.length; i &lt; len; i ++) {        var item = arr[i];        if (~[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;].indexOf(item)) {            // 注意这里需要用到后序表达式或中序表达式转换一下            var v1 = stack.pop();            var v2 = stack.pop();            var exp_res = parseInt(eval(v2 + item + v1));            stack.push(exp_res);        } else {            stack.push(item);        }    }    return stack.pop();}console.log(&quot;-----------------------------------------&quot;);console.log(calc_exp([&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;])); // 6</code></pre><h3 id="课后练习题"><a href="#课后练习题" class="headerlink" title="课后练习题"></a>课后练习题</h3><ul><li>实现一个有min方法的栈</li></ul><p>实现一个栈，除了常见的push，pop方法以外，提供一个min方法，返回栈里最小的元素，且时间复杂度为o(1)</p><ul><li>思路分析</li></ul><p>使用两个栈来存储数据，其中一个命名为data_stack,专门用来存储数据，另一个命名为min_stack，专门用来存储栈里最小的数据。</p><p>注意了，我接下来的分析过程非常重要，我希望你能多阅读几遍。</p><ol><li><p>我们要实现的是一个栈，除了常规的方法，还要有一个min方法，data_stack就是专门为常规方法而存在的，min_stack就是为了这个min方法而存在的。</p></li><li><p>编程思想里有一个分而治之的思想，简单来说，就是分开想，分开处理。那么我们现在考虑data_stack，这个时候别管min方法，你就只关心data_stack，它就是一个普通的栈啊，没什么特别的，一个简单的栈你还不会么，就是push，pop那些方法，正常实现就可以了。</p></li><li><p>data_stack处理完了以后，再考虑min_stack，这个时候，你就别想data_stack了，只关心min_stack，它要存储栈里的最小值，我们先考虑边界情况，如果min_stack为空，这个时候，如果push进来一个数据，那这个数据一定是最小的，所以此时，直接放入min_stack即可。如果min_stack不为空，这个时候它的栈顶不正是栈的最小元素么，如果push进来的元素比栈顶元素还小，放入min_stack就好了，这样，min_stack的栈顶始终都是栈里的最小值。</p></li></ol><ul><li>示例代码:</li></ul><pre><code>function MinStack() {    var data_stack = new Stack();    var min_stack = new Stack();    this.push = function(item) {        data_stack.push(item);        if (min_stack.isEmpty() || min_stack.top &gt; item) {            min_stack.push(item);        } else {            min_stack.push(min_stack.top());        }    }    this.pop = function() {        min_stack.pop();        return data_stack.pop();    }    this.get = function() {        return data_stack.get();    }    this.min = function() {        return min_stack.top();    }}var minstack = new MinStack();minstack.push(3);minstack.push(6);minstack.push(8);console.log(minstack.get()); // [3, 6, 8]console.log(minstack.min()); // 3minstack.push(2);console.log(minstack.min()); // 3</code></pre><h3 id="使用栈，完成中序表达式转后序表达式"><a href="#使用栈，完成中序表达式转后序表达式" class="headerlink" title="使用栈，完成中序表达式转后序表达式"></a>使用栈，完成中序表达式转后序表达式</h3><pre><code>输入:[&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]输出:[&quot;12&quot;,&quot;3&quot;,&quot;+&quot;]输入:[&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;]输出:[ &#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;9&#39;, &#39;8&#39;, &#39;+&#39;, &#39;+&#39; ]输入:[&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;,&#39;)&#39;, &#39;/&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]输出:[&#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;4&#39;,&#39;/&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;6&#39;, &#39;8&#39;, &#39;+&#39;, &#39;3&#39;, &#39;*&#39;, &#39;+&#39;]</code></pre><ul><li>思路分析</li></ul><p>定义数组postfix_lst，用于存储后序表达式，遍历中序表达式，对每一个遍历到的元素做如处理:</p><ol><li><p>如果是数字,直接放入到postfix_lst中</p></li><li><p>遇到左括号入栈</p></li><li><p>遇到右括号,把栈顶元素弹出并放入到postfix_lst中,直到遇到左括号，最后弹出左括号</p></li><li><p>遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符， 把弹出的运算符加入到postfix_lst，当前的运算符入栈</p></li><li><p>for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中</p></li></ol><pre><code>// 定义运算符的优先级var priority_map = {    &quot;+&quot;: 1,    &quot;-&quot;: 1,    &quot;*&quot;: 2,    &quot;/&quot;: 2};function infix_exp_2_postfix_exp(exp){    var stack = new Stack();    var postfix_lst = [];    for(var i = 0;i&lt;exp.length;i++){        var item = exp[i];        // 如果是数字,直接放入到postfix_lst中        if(!isNaN(item)){            postfix_lst.push(item);        }else if (item == &quot;(&quot;){            // 遇到左括号入栈            stack.push(item);        }else if (item == &quot;)&quot;){            // 遇到右括号,把栈顶元素弹出,直到遇到左括号            while(stack.top() != &quot;(&quot;){                postfix_lst.push(stack.pop());            }            stack.pop();   // 左括号出栈        }else{            // 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符            while(!stack.isEmpty() &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(stack.top()) &gt;= 0 &amp;&amp; priority_map[stack.top()] &gt;= priority_map[item]){                // 把弹出的运算符加入到postfix_lst                postfix_lst.push(stack.pop());            }            // 当前的运算符入栈            stack.push(item);        }    }    // for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中    while(!stack.isEmpty()) {        postfix_lst.push(stack.pop())    }    return postfix_lst};// 12+3console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]))// 2-3+2console.log(infix_exp_2_postfix_exp([&quot;2&quot;,&quot;-&quot;, &quot;3&quot;, &quot;+&quot;, &quot;2&quot;]))// (1+(4+5+3)-3)+(9+8)var exp = [&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;];console.log(infix_exp_2_postfix_exp(exp))// (1+(4+5+3)/4-3)+(6+8)*3var exp = [&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;)&#39;, &#39;/&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]console.log(infix_exp_2_postfix_exp(exp))console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;,&quot;*&quot;, &quot;5&quot;]))console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;*&quot;, &quot;3&quot;,&quot;+&quot;, &quot;5&quot;]))</code></pre><ul><li>算法思路推理过程</li></ul><p>推理的过程要从简入繁，先考虑最简单的情况</p><ul><li>只有一个运算符</li></ul><pre><code>中序: 1 + 2后序: 1 2 +</code></pre><p>后序表达式，数值在前，操作符在后，因此，遇到数值时直接放入到后序表达式中。将操作符放入栈中，等到中序表达式遍历结束后，将栈里的操作符弹出放入到后序表达式中</p><ul><li>多个运算符，栈顶操作符优先级和当前运算符相同</li></ul><p>多个运算符，似乎也可以像第一步推理中那样操作，但实际不行</p><pre><code>中序: 1 + 2 - 3后序: 1 2 + 3 -</code></pre><p>每次遇到操作符时，如果栈里有操作符，说明前面有需要计算的数值，且计算的操作符就在栈顶，应该弹出放入到后缀表达式中，如果都等到中缀表达式结束再弹出，就会变成 1 2 3 + -</p><p>就本示例而言，遇到减号时，后缀表达式里是 1 2 ，栈里是+，1和2需要计算，进行计算的操作符就在栈顶，因此需要弹出，放入到后缀表达式，之后减号入栈，中缀表达式遍历结束后，后缀表达式是 1 2 + 3， 栈里是-，将栈里的操作符去全部弹出，放入到后缀表达式，最终结果为 1 2 + 3 -。</p><pre><code>中序: 1 * 2 + 3后序: 1 2 * 3 +</code></pre><p>栈顶运算符优先级高，和第2步的分析一致，前面有需要计算的数值，应该弹出放入到后缀表达式中</p><ul><li>多个运算符，栈顶操作符优先级大于当前运算符相同</li></ul><pre><code>中序: 1 + 2 * 3后序: 1 2 3 * +</code></pre><p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p><ul><li>多个运算符，栈顶操作符优先级小于当前运算符相同</li></ul><pre><code>中序: 1 + 2 * 3后序: 1 2 3 * +</code></pre><p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p><ul><li>有括号的情况</li></ul><p>括号里的的表达式可以视为一个独立的中缀表达式，因此，前面4步的分析都适用，但是括号里的中缀表达式在一个更大的表达式中，因此需要与其他部分分隔，分隔的方法就是遇到小括号后压栈，此后的操作遵循前面的推理逻辑，当遇到右括号时，说明括号内的表达式结束了，根据第一步的分析，应该把所有属于这个括号内表达式的操作符都弹出来放入到后缀表达式，最后一步弹出左括号。</p><p><strong>还在学习ing…，学习后再补充</strong></p><h1 id="数据结构之—-队列"><a href="#数据结构之—-队列" class="headerlink" title="数据结构之—-队列"></a>数据结构之—-队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><h3 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a>数据存储</h3><h3 id="队列的方法"><a href="#队列的方法" class="headerlink" title="队列的方法"></a>队列的方法</h3><ul><li>enqueue方法</li><li>dequeue方法</li><li>head方法</li><li>size方法</li><li>clear方法</li><li>isEmpty方法</li><li>tail方法<h2 id="队列的应用练习"><a href="#队列的应用练习" class="headerlink" title="队列的应用练习"></a>队列的应用练习</h2><h3 id="约瑟夫环（普通模式）"><a href="#约瑟夫环（普通模式）" class="headerlink" title="约瑟夫环（普通模式）"></a>约瑟夫环（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h3 id="斐波那契数列（普通模式）"><a href="#斐波那契数列（普通模式）" class="headerlink" title="斐波那契数列（普通模式）"></a>斐波那契数列（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码</li><li>小结<h3 id="用队列实现栈（困难模式）"><a href="#用队列实现栈（困难模式）" class="headerlink" title="用队列实现栈（困难模式）"></a>用队列实现栈（困难模式）</h3></li><li>题目要求</li><li>思路分析</li><li>代码示例<h3 id="打印杨辉三角（困难模式）"><a href="#打印杨辉三角（困难模式）" class="headerlink" title="打印杨辉三角（困难模式）"></a>打印杨辉三角（困难模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="用两个栈实现一个队列（普通模式）"><a href="#用两个栈实现一个队列（普通模式）" class="headerlink" title="用两个栈实现一个队列（普通模式）"></a>用两个栈实现一个队列（普通模式）</h3></li><li>思路分析</li><li>思路分析<h3 id="迷宫问题（地狱模式）"><a href="#迷宫问题（地狱模式）" class="headerlink" title="迷宫问题（地狱模式）"></a>迷宫问题（地狱模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h1 id="数据结构之—-链表"><a href="#数据结构之—-链表" class="headerlink" title="数据结构之—-链表"></a>数据结构之—-链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h3 id="首尾节点"><a href="#首尾节点" class="headerlink" title="首尾节点"></a>首尾节点</h3><h3 id="有头链表和无头链表"><a href="#有头链表和无头链表" class="headerlink" title="有头链表和无头链表"></a>有头链表和无头链表</h3><h3 id="猴子捞月"><a href="#猴子捞月" class="headerlink" title="猴子捞月"></a>猴子捞月</h3><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="定义链表类"><a href="#定义链表类" class="headerlink" title="定义链表类"></a>定义链表类</h3><h3 id="链表的方法"><a href="#链表的方法" class="headerlink" title="链表的方法"></a>链表的方法</h3></li><li>append方法</li><li>print方法</li><li>insert方法</li><li>remove方法</li><li>get方法</li><li>indexOf方法<h2 id="基于链表实现的Stack-和-Queue"><a href="#基于链表实现的Stack-和-Queue" class="headerlink" title="基于链表实现的Stack 和 Queue"></a>基于链表实现的Stack 和 Queue</h2><h2 id="链表常见面试题"><a href="#链表常见面试题" class="headerlink" title="链表常见面试题"></a>链表常见面试题</h2><h3 id="翻转链表（困难模式）"><a href="#翻转链表（困难模式）" class="headerlink" title="翻转链表（困难模式）"></a>翻转链表（困难模式）</h3></li><li>题目要求</li><li>迭代翻转思路分析</li><li>递归翻转链表思路分析<h3 id="从尾到头打印链表（普通模式）"><a href="#从尾到头打印链表（普通模式）" class="headerlink" title="从尾到头打印链表（普通模式）"></a>从尾到头打印链表（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h3 id="合并两个两个有序链表-困难模式"><a href="#合并两个两个有序链表-困难模式" class="headerlink" title="合并两个两个有序链表(困难模式)"></a>合并两个两个有序链表(困难模式)</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h2 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="查找单链表中的倒数第K个节点（k-gt-0）（普通模式）"><a href="#查找单链表中的倒数第K个节点（k-gt-0）（普通模式）" class="headerlink" title="查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）"></a>查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）</h3><h3 id="查找单链表的中间结点（普通模式）"><a href="#查找单链表的中间结点（普通模式）" class="headerlink" title="查找单链表的中间结点（普通模式）"></a>查找单链表的中间结点（普通模式）</h3><h3 id="实现双向链表（地狱模式）"><a href="#实现双向链表（地狱模式）" class="headerlink" title="实现双向链表（地狱模式）"></a>实现双向链表（地狱模式）</h3><h1 id="数据结构之—-BitMap"><a href="#数据结构之—-BitMap" class="headerlink" title="数据结构之—-BitMap"></a>数据结构之—-BitMap</h1><h2 id="一个简单的问题"><a href="#一个简单的问题" class="headerlink" title="一个简单的问题"></a>一个简单的问题</h2><h3 id="毫无难度的实现"><a href="#毫无难度的实现" class="headerlink" title="毫无难度的实现"></a>毫无难度的实现</h3><h3 id="更快的方法"><a href="#更快的方法" class="headerlink" title="更快的方法"></a>更快的方法</h3><h3 id="更节省空间的算法"><a href="#更节省空间的算法" class="headerlink" title="更节省空间的算法"></a>更节省空间的算法</h3><h2 id="街边的路灯"><a href="#街边的路灯" class="headerlink" title="街边的路灯"></a>街边的路灯</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><h3 id="新的实现方式"><a href="#新的实现方式" class="headerlink" title="新的实现方式"></a>新的实现方式</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="大数据排序"><a href="#大数据排序" class="headerlink" title="大数据排序"></a>大数据排序</h3><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><h3 id="BoolmFilter-类"><a href="#BoolmFilter-类" class="headerlink" title="BoolmFilter 类"></a>BoolmFilter 类</h3></li><li>操作二进制位</li><li>add方法</li><li>isExist方法<h2 id="课后练习题-1"><a href="#课后练习题-1" class="headerlink" title="课后练习题"></a>课后练习题</h2><h3 id="两个集合取交集（普通模式）"><a href="#两个集合取交集（普通模式）" class="headerlink" title="两个集合取交集（普通模式）"></a>两个集合取交集（普通模式）</h3></li><li>示例代码<h3 id="支持负数（困难模式）"><a href="#支持负数（困难模式）" class="headerlink" title="支持负数（困难模式）"></a>支持负数（困难模式）</h3></li><li>思路分析</li><li>示例代码<h3 id="查找不重复的数（地狱模式）"><a href="#查找不重复的数（地狱模式）" class="headerlink" title="查找不重复的数（地狱模式）"></a>查找不重复的数（地狱模式）</h3></li><li>思路分析</li><li>示例代码<h1 id="数据结构之—-树"><a href="#数据结构之—-树" class="headerlink" title="数据结构之—-树"></a>数据结构之—-树</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2>###结构<br>###节点<br>###节点的度<br>###叶节点<br>###分支节点<br>###子女节点<h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h3 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h3><h3 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h3><h3 id="节点所在层次"><a href="#节点所在层次" class="headerlink" title="节点所在层次"></a>节点所在层次</h3><h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><h3 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h3><h3 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h3><h3 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h3><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3></li><li>满二叉树</li><li>完全二叉树<h3 id="二叉树的类定义"><a href="#二叉树的类定义" class="headerlink" title="二叉树的类定义"></a>二叉树的类定义</h3></li><li>定义节点</li><li>定义二叉树类</li><li>init_tree</li><li>in_order 中序遍历算法</li><li>pre_order 前序遍历算法</li><li>post_order 后序遍历算法</li><li>size 返回节点数量</li><li>height 返回树的高度</li><li>查找节点<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3></li><li>求一棵树的镜像(普通模式)<ul><li>思路分析</li><li>示例代码</li></ul></li><li>使用非递归方式实现前序遍历<ul><li>思路分析</li><li>示例代码<h3 id="课后练习题-2"><a href="#课后练习题-2" class="headerlink" title="课后练习题"></a>课后练习题</h3></li></ul></li><li>使用非递归方式实现中，后两种遍历方法（普通模式+）</li><li>寻找两个节点的最近公共祖先（困难模式）</li><li>分层打印二叉树（困难模式+）</li><li>输出指定层的节点个数（困难模式+）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript 数据结构" scheme="http://www.icrazyman.cn/tags/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>你需要了解的几种JavaScript设计模式</title>
    <link href="http://www.icrazyman.cn/2019/01/15/%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A7%8DJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.icrazyman.cn/2019/01/15/你需要了解的几种种JavaScript设计模式/</id>
    <published>2019-01-15T13:54:57.000Z</published>
    <updated>2019-01-20T11:07:39.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><ul><li><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p></li><li><p>设计模式主要是为了解决对象的生成和整合问题。</p></li><li><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p></li></ul><p><strong>读万卷书，不如行万里路。接下来要贴代码了，从代码中就可以理解常用设计模式的主要概念。</strong></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>单例模式</li><li>观察者模式（发布\订阅模式）</li><li>中介者模式</li><li>策略模式/状态模式</li><li>命令模式</li><li>迭代器模式</li><li>参与者模式</li><li>数据访问对象模式</li><li>等待者模式</li><li>同步模块模式</li><li>异步模块模式</li><li>链模式</li><li>构造函数模式</li><li>职责链模式</li><li>MVC模式</li><li>MVP模式</li><li>MVVM模式</li><li>享元模式</li><li>状态模式</li><li>模板方法模式</li></ol><a id="more"></a><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><pre><code>var Singleton = function() {    var midseason = getMidseason();    return {        midseason: midseason, // 单例模式私有变量         sendAjax: function(api, formData, callback) {             // 代码...        },        submitForm: function(dlg){             // 代码...        },        cancelForm: function(dlg){            // 代码...        },        initChosen: function(selector, options){            // 代码...        },        initDataTable: function(selector, options) {            // 代码...        },        editInventoryType: function(data){            // 代码...            Singleton.initChosen($(&#39;.check-goods-type&#39;));        },        changePriceCardStatus: function(data) {            Singleton.sendAjax(&#39;api&#39;, {&#39;data&#39;: data}, function(data) {                // 代码...            })        }    }}()</code></pre><h1 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布\订阅模式）"></a>观察者模式（发布\订阅模式）</h1><pre><code>var Observer = (function() {    var _message = {};    return {        regist: function(type, fn) {            if (typeof _message[type] === &#39;undefined&#39;) {                _message[type] = [fn];            } else {                _message[type].push(fn);            }        },        fire: function(type, args) {            if (!_message[type]) return;            var events = {                type: type,                args: args || {}            }            for ( var i = _message[type].length -1 ; i &gt;= 0; i --) {                _message[type][i].call(this, events);            }        },        remove: function(type, fn) {            if (_message[type] instanceof Array) {                for( var i = _message[type]; i&gt;= 0; i -- ) {                    _message[type][i] === fn &amp;&amp; _message[type].splice(i ,1);                }            };        }    }})()Observer.regist(&#39;test&#39;, function(e) {    console.log(e.type, e.args.msg);})Observer.fire(&#39;test&#39;, {msg: &#39;传递参数&#39;});</code></pre><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><pre><code>var Mediator = function() {    var _msg = {};    return {        register: function(type, action) {            if (_msg[type]) {                _msg[type].push(action);            } else {                _msg[type] = [];                _msg[type].push(action);            }            return this;        },        send: function(type) {            if (_msg[type]) {                for (var i = 0, len = _msg[type].length; i &lt; len; i++) {                    _msg[type][i] &amp;&amp; _msg[type][i]();                };            };            return this;        }    }}();Mediator.register(&#39;demo&#39;, function() {    console.log(&quot;first&quot;);}).register(&#39;demo&#39;, function() {    console.log(&quot;second&quot;);}).send(&#39;demo&#39;);</code></pre><h1 id="策略模式与状态模式类似，区别是调用指定的方法传参"><a href="#策略模式与状态模式类似，区别是调用指定的方法传参" class="headerlink" title="策略模式与状态模式类似，区别是调用指定的方法传参"></a>策略模式与状态模式类似，区别是调用指定的方法传参</h1><pre><code>var Pattern = function() {    var status = {        return30: function(price) {            console.log(price+&#39;折扣&#39;);        },        return50: function(price) {            console.log(price+&#39;折扣&#39;);        }    }    return function(item, price) {        return status[item] &amp;&amp; status[item](price);    }}()Pattern(&#39;return30&#39;, 300)</code></pre><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;     var CanvasCommand = function() {         var canvas = document.getElementById(&#39;canvas&#39;),             ctx = canvas.getContext(&#39;2d&#39;);         var Action = {             fillStyle: function(c) {                 ctx.fillStyle = c;             },             fillRect: function(x, y, width, height) {                 ctx.fillRect(x, y, width, height);             }         }         return {             excute: function(msg) {                 if (!msg) return;                 if (msg.length) {                     for(var i = 0, len = msg.length; i &lt; len; i ++) {                         arguments.callee(msg[i]);                     }                 } else {                     msg.param = Object.prototype.toString.call(msg.param) === &#39;[object Array]&#39; ? msg.param : [msg.param];                     Action[msg.command].apply(Action, msg.param);                 }             }         }     }()     CanvasCommand.excute([         {command: &#39;fillStyle&#39;, param: &#39;red&#39;},         {command: &#39;fillRect&#39;, param: [20, 20, 100, 100]}     ])&lt;/script&gt;</code></pre><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><pre><code>&lt;ul id=&quot;container&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var Iterator = function(items, container) {        var container = container &amp;&amp; document.getElementById(&#39;container&#39;) || document,            items = container.getElementsByTagName(items),            length = items.length,            index = 0;        var splice = [].splice;        return {            // 获取第一个元素            first: function() {                index = 0;                return items[index];            },            // 获取最后一个元素            last: function() {                index = length - 1;                return items[index];            },            // 获取前一个元素            pre: function() {                if (--index &gt; 0) {                    return items[index];                } else {                    index = 0;                    return null;                }            },            // 获取后一个元素            next: function() {                if (++index &lt; length) {                    return items[index];                } else {                    index = length - 1;                    return null;                }            },            // 获取某一个元素            get: function(num) {                index = num &gt;= 0 ? num % length : num % length + length;                return items[index];            },            // 对每一个元素执行某一个方法            dealEach: function(fn) {                var args = splice.call(arguments, 1);                for (var i = 0; i &lt; length; i++) {                    fn.apply(items[i], args);                };            },            // 对某一个元素执行某一个方法            dealItem: function(num, fn) {                fn.apply(this.get(num), splice.call(arguments, 2));            },            // 排他方式处理某一个元素            exclusive: function(num, allFn, numFn) {                this.dealEach(allFn);                if (Object.prototype.toString.call(num) === &#39;[object Array]&#39;) {                    for (var i = 0, len = num.length; i &lt; len; i++) {                        this.dealItem(num[i], numFn);                    };                } else {                    this.dealItem(num, numFn);                }            },        }    }    var demo = new Iterator(&#39;li&#39;, &#39;container&#39;);    console.log(demo.first());    console.log(demo.last());    console.log(demo.pre());    console.log(demo.next());    console.log(demo.get(1));    demo.dealEach(function(text, color) {        this.innerHTML = text;        this.style.background = color;    }, &#39;test&#39;, &#39;pink&#39;);    demo.exclusive([2, 3], function() {        this.innerHTML = &#39;被排除的&#39;;        this.style.background = &#39;green&#39;;    }, function() {        this.innerHTML = &#39;被选中的&#39;;        this.style.background = &#39;red&#39;;    })&lt;/script&gt;</code></pre><h1 id="参与者模式"><a href="#参与者模式" class="headerlink" title="参与者模式"></a>参与者模式</h1><p>其实就是把函数绑定和函数柯里化结合起来的设计模式</p><pre><code>if (Function.prototype.bind === undefined) {    Function.prototype.bind = function(context) {        var slice = Array.prototype.slice,            args = slice.call(arguments, 1),            that = this;        return function() {            var addArgs = slice.call(arguments),                allArgs = args.concat(addArgs);            return that.apply(context, allArgs);        }        }};</code></pre><h1 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h1><pre><code>&lt;script&gt;    // 数据访问对象模式可以方便我们对前端存储的管理，并且使用时更方便    var BaseLocalStorage = function(preId, timeSign) {        this.preId = preId; // 定义本地存储数据前缀        this.timeSign = timeSign || &#39;|-|&#39;; // 定义时间戳与存储数据之间的拼接符    }    BaseLocalStorage.prototype = {        status: {            SUCCESS: 0, // 成功            FAILURE: 1, // 失败            OVERFLOW: 2, // 溢出            TIMEOUT: 3, // 过期        }, // 操作状态        storage: localStorage || window.localStorage, // 保存本地存储链接        getKey: function(key) {            return this.preId + key;        }, // 获取本地存储数据库数据真实字段        /**         * 添加修改数据         * @param {string}   key      数据字段标识         * @param {string}   value    数据值         * @param {Function} callback 回调函数         * @param {time}     time     添加时间         */        set: function(key, value, callback, time) {            var status = this.status.SUCCESS,                key = this.getKey[key];            try {                time = new Date(time).getTime() || time.getTime();            } catch(e) {                time = Date.now() + 1000 * 60 * 60 * 24 * 31;            }            try {                this.storage.setItem[key, time + this.timeSign + value];            } catch(e) {                status = this.status.OVERFLOW;            }            callback &amp;&amp; callback.call(this, status, key, value);        },        /**         * 获取数据         * @param  {string}   key      数据字段标识         * @param  {Function} callback 回调函数         * @return {[object]}          值和状态         */        get: function(key, callback) {            var status = this.status.SUCCESS,                key = this.getKey[key],                value = null,                timeSignLen = this.timeSign.length,                that = this,                index,                time,                result;            try {                value = that.storage.getItem(key);            } catch(e) {                result = {                    status: that.status.FAILURE,                    value: null,                }                callback &amp;&amp; callback.call(this, result.status, result.value);                return result;            }            if (value) {                index = value.indexOf(that.timeSign);                time = +value.slice(0, index);                if (new Date(time).getTime() &gt; Date.now() || time == 0) {                    value = value.slice(index + timeSignLen);                } else {                    value = null,                    status = that.status.TIMEOUT;                    that.remove(key);                }            } else {                status = that.status.FAILURE;            }            result = {                status: status,                value: value            };            callback &amp;&amp; callback.call(this, result.status, result.value);            return result;        },        /**         * 删除数据         * @param  {string}   key      数据字段标识         * @param  {Function} callback 回调函数         */        remove: function(key, callback) {            var status = this.status.FAILURE,                key = this.getKey[key],                value = null;            try {                value = this.storage.getItem(key);            } catch(e) {}            if (value) {                try {                    this.storage.removeItem(key);                    status = this.status.SUCCESS;                } catch(e) {}            };            callback &amp;&amp; callback.call(this, status, status &gt; 0 ? null : value.slice(value.indexOf(this.timeSign) + this.timeSign.length))        }    }    var LS = new BaseLocalStorage(&#39;LS__&#39;);    LS.set(&#39;a&#39;, &#39;xiao ming&#39;, function() {console.log(arguments);})    LS.remove(&#39;a&#39;, function() {console.log(arguments);})    LS.remove(&#39;a&#39;, function() {console.log(arguments);})    LS.get(&#39;a&#39;, function() {console.log(arguments);})&lt;/script&gt;</code></pre><h1 id="等待者模式"><a href="#等待者模式" class="headerlink" title="等待者模式"></a>等待者模式</h1><pre><code>&lt;script&gt;var Waiter = function() {    var dfd = [], // 注册等待对象容器        doneArr = [], // 成功回调方法容器        failArr = [], // 失败回调方法容器        slice = Array.prototype.slice,        that = this;    // 监控对象类    var Primise = function() {        this.resolved = false;        this.rejected = false;    }    // 监控对象类原型方法    Primise.prototype = {        resolve: function() {            this.resolved = true;            if (!dfd.length) return;            for(var i = dfd.length - 1; i &gt;= 0; i--) {                // 如果有任意一个监控对象没有被解决或者解决失败则返回                if (dfd[i] &amp;&amp; !dfd[i].resolved || dfd[i].rejected) {                    return;                };                // 清除监控对象                dfd.splice(i, 1);            }            // 执行解决成功回调方法            _exec(doneArr);        },        reject: function() {            this.rejected = true;            if (!dfd.length) return;            // 清除所有监控对象            dfd.splice(0);            // 执行解决成功回调方法            _exec(failArr);        }    }    // 创建监控对象    that.Deferred = function() {        return new Primise();    }    // 回调执行方法    function _exec(arr) {        var i = 0,            len = arr.length;        for(; i &lt; len; i ++) {            try {                arr[i] &amp;&amp; arr[i]();            } catch(e) {}        }    };    // 监控异步方法 参数 监控对象    that.when = function() {        dfd = slice.call(arguments);        var i = dfd.length;        for( --i; i &gt;= 0; i --) {            // 如果不存在监控对象，或者监控对象已经解决，或者不是监控对象            if(!dfd || dfd[i].resolved || dfd[i].rejected || !dfd[i] instanceof Primise) {                dfd.splice(i, 1);            }        }        return that;    };    // 解决成功回调函数添加方法    that.done = function() {        doneArr = doneArr.concat(slice.call(arguments));        return that;    };    // 解决失败回调函数添加方法    that.fail = function() {        failArr = failArr.concat(slice.call(arguments));        return that;    };}var waiter = new Waiter();var first = function() {    var dtd = waiter.Deferred();    setTimeout(function(){        console.log(&quot;first finish&quot;);        // 发布解决成功消息        dtd.resolve();    }, 500)    return dtd;}();var second = function() {    var dtd = waiter.Deferred();    setTimeout(function(){        console.log(&quot;second finish&quot;);        // 发布解决成功消息        dtd.resolve();    }, 500)    return dtd;}();waiter    .when(first, second)    .done(function() {        console.log(&quot;success&quot;);    }, function() {        console.log(&quot;success again&quot;);    })    .fail(function() {        console.log(&quot;fail&quot;);    })// first finish// second finish// success// success again&lt;/script&gt;</code></pre><h1 id="同步模块模式"><a href="#同步模块模式" class="headerlink" title="同步模块模式"></a>同步模块模式</h1><pre><code>&lt;div id=&quot;test&quot;&gt;                fsadas         &lt;/div&gt;&lt;script&gt;(function() {    var F = F || {};    /**     * 定义模块方法     * @param  {string}   str 模块路由     * @param  {Function} fn  模块方法     */    F.define = function(str, fn) {        var parts = str.split(&#39;.&#39;),            old = parent = this,            i = len = 0;        // 如果第一个模式是模块管理器单体对象，则移除        if (parts[0] === &#39;F&#39;) {            parts = parts.slice(1);        };        // 屏蔽对define与module模块方法的重写        if (parts[0] === &#39;define&#39; || parts[0] === &#39;module&#39;) {            return;        };        for(len = parts.length; i &lt; len; i ++) {            if (typeof parent[parts[i]] === &#39;undefined&#39;) {                // 生命当前模块                parent[parts[i]] = {};            };        }        // 缓存下一层的祖父模块        old = parent;        // 缓存下一层级父模块        parent = parent[parts[i]];        if (fn) {            old[parts[-- i]] = fn();        };    }    F.module = function() {        var args = [].slice.call(arguments),            // 获取回调执行函数            fn = args.pop(),            // 获取依赖模块，如果args[0]是数组，则依赖模块为args[0]，否则依赖模块为arg            parts = args[0] &amp;&amp; args[0] instanceof Array ? args[0] : args,            // 依赖模块列表            modules = [],            // 模块路由            modIds = &#39;&#39;,            // 依赖模块索引            i = 0,            // 依赖模块长度            ilen = parts.length,            // 父模块，模块路由层级索引，模块路由层级长度            parent, j, jlen;        // 遍历依赖模块        while(i &lt; ilen) {            // 如果是路由模块            if (typeof parts[i] === &#39;string&#39;) {                // 设置当前模块父对象F                parent = this;                // 解析模块路由，并屏蔽掉模块父对象                modIds = parts[i].replace(/^F\./, &#39;&#39;).split(&#39;.&#39;)                // 遍历模块路由层级                for(j = 0, jlen = modIds.length; j &lt; jlen; j ++) {                    // 重置父模块                    parent = parent[modIds[j]] || false;                }                // 将模块添加到依赖模块列表中                modules.push(parent);            } else { // 如果是模块对象                // 直接加入依赖模块列表中                modules.push(parts[i]);            }            i ++;        }        fn.apply(null, modules);    }    F.define(&#39;string&#39;, function() {        return {            trim: function(str) {                return str.replace(/^\s+|\s+$/g, &#39;&#39;);            }        }    })    F.define(&#39;dom&#39;, function() {        var $ = function(id) {            $.dom = document.getElementById(id);            return $;        }        $.html = function(html) {            if (html) {                this.dom.innerHTML = html;                return this;            } else {                return this.dom.innerHTML;            }        }        return $;    });    console.log(F.dom(&#39;test&#39;).html());    console.log(F.string.trim(&#39;    范德萨更大噶  &#39;));    F.module(&#39;dom&#39;, &#39;string.trim&#39;, function(dom, trim) {        var html = dom(&#39;test&#39;).html();        var str = trim(html);        console.log(&#39;***&#39; + html + &#39;***&#39; + str + &#39;***&#39;);    })})()&lt;/script&gt;</code></pre><h1 id="异步模块模式"><a href="#异步模块模式" class="headerlink" title="异步模块模式"></a>异步模块模式</h1><pre><code>&lt;script&gt;// 向闭包中传入模块管理器对象F，~屏蔽压缩文件时，前面漏写;报错~(function(F) {    // 模块缓存器。存储已创建模块    var moduleCache = {        /**         * 设置模块并执行模块构造函数         * @param {[type]}   moduleName 模块id名称         * @param {[type]}   params     依赖模块         * @param {Function} callback   模块构造函数         */        setModule: function(moduleName, params, callback) {            // 模块容器，模块文件加载完成回调函数            var _module, fn;            // 如果模块被调用过            if (moduleCach[moduleName]) {                // 获取模块                _module = moduleCache[moduleName];                // 设置模块已经加载完成                _module.status = &#39;loaded&#39;;                // 矫正模块接口                _module.exports = callback ? callback.apply(_module, params) : null;                // 执行模块文件加载完成回调函数                while(fn = _module.onload.shift()) {                    fn(_module.exports);                }            } else {                // 模块不存在，则直接执行构造函数                callback &amp;&amp; callback.apply(null, params)            }        },        /**         * 异步加载依赖模块所在文件         * @param  {[type]} moduleName 模块路径         * @param  {[Function]} callback  模块加载完成回调函数         * @return {[type]}            [description]         */        loadModule: function(moduleName, callback) {            // 依赖模块            var _module;            // 如果依赖模块被要求加载过            if (moduleCache[moduleName]) {                // 获取该模块信息                _module = moduleCache[moduleName];                // 如果模块加载完成                if (_module.status === &#39;loaded&#39;) {                    // 执行模块加载完成回调函数                    setTimeout(callback(_module.exports), 0);                } else {                    // 缓存该模块所处文件加载完成回调函数                    _module.onload.push(callback);                }            } else { // 模块第一次被依赖引用                // 缓存该模块初始化信息                moduleCache[moduleName] = {                    moduleName: moduleName,                    status: &#39;loading&#39;, // 模块对应文件加载状态，默认加载中                    exports: null, // 模块接口                    onload: [callback] // 模块对应文件加载完成回调函数缓冲器                }            };            // 加载模块对应文件            loadScript(getUrl[moduleName]);        }    };    // 获取文件路径    getUrl: function(moduleName) {        return String(moduleName).replace(/\.js$/g, &#39;&#39;) + &#39;.js&#39;;    },    // 加载脚本文件    loadScript: function(src) {        var _script = document.createElement(&#39;script&#39;);        _script.type = &#39;text/JavaScript&#39;;        _script.charset = &#39;UTF-8&#39;;        _script.async = true;        _script.src = src;        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(_script);    }})((function() {    // 创建模块管理对象F,并保存在全局作用域中    return window.F = {        /**         * 创建或调用模块方法         * @param  {string} url         参数为模块url         * @param  {[type]} modDeps     参数为依赖模块         * @param  {[type]} modCallback 参数为模块主函数         */        module: function(url, modDeps, modCallback) {                // 将参数转化为数组            var args = [].slice.call(arguments),                // 获取模块构造函数（参数数组中最后一个参数成员）                callback = args.pop(),                // 获取依赖模块（紧邻回调函数参数，且数据类型为数组）                deps = (args.length &amp;&amp; args[args.length - 1] instanceof Array) ? args.pop() : [];                // 该模块url                url = args.length ? args.pop() : null,                // 依赖模块序列                params = [],                // 未加载的依赖模块数量统计                depsCount = 0,                // 依赖模块序列中索引值                i = 0,                // 依赖模块序列长度                len;            // 获取依赖模块长度            if (len = deps.length) {                // 遍历依赖模块                while(i &lt; len) {                    // 闭包保存i                    (function(i) {                        // 增加未加载依赖模块数量统计                        depsCount ++;                        // 异步加载依赖模块                        loadModule(deps[i], function(mod) {                            // 依赖模块序列中添加依赖模块接口引用                            params[i] = mod;                            // 依赖模块加载完成，依赖模块数量统计减一                            depsCount --;                            // 如果依赖模块全部加载                            if (depsCount === 0) {                                // 在模块缓存器中矫正该模块，并执行构造函数                                setModule(url, param, callback);                            };                        })                    })(i)                    i ++;                }            } else { // 无依赖模块，直接执行回调函数                // 在模块缓存器中矫正该模块，并执行构造函数                setModule(url, [], callback);            }        }    };})());&lt;/script&gt;</code></pre><h1 id="链模式（仿jquery）"><a href="#链模式（仿jquery）" class="headerlink" title="链模式（仿jquery）"></a>链模式（仿jquery）</h1><pre><code>&lt;div id=&quot;demo&quot;&gt;123&lt;/div&gt;&lt;script&gt;    var A = function(selector, context) {        return new A.fn.init(selector, context);    }    A.fn = A.prototype = {        constructor: A,        init: function(selector, context) {            this.length = 0,            context = context || document;            if(~selector.indexOf(&#39;#&#39;)) {                this[0] = document.getElementById(selector.slice(1));            } else {                var domes = context.getElementsByTagName(selector),                    i = 0,                    len = doms.length;                for(; i &lt; len; i ++) {                    this[i] = doms[i];                }                this.lenth = len;            }            this.context = context;            this.selector = selector;            return this;        }    }    console.log(A(&#39;#demo&#39;));&lt;/script&gt;</code></pre><h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><pre><code>&lt;script&gt;    var obj = {        &#39;name&#39;: &#39;zs&#39;,        &#39;age&#39;: 11,        &#39;say&#39;: function(){            console.log(this.name);        }    }console.log(&#39;-----------------------------------------------------------------------&#39;);    var Singletom = function(name, age){        this.name = name;        this.age = age;        this.instance = null;        this.say = function(){            console.log(this.name);        }    }    function getInstance(name, age){        return this.instance || (this.instance = new Singletom(name, age));     }    var a = getInstance(&#39;zs&#39;, 11);    var b = getInstance(&#39;ls&#39;, 12);    a.say();    b.say();    console.log(a);    console.log(b);    console.log(a.name);    console.log(a.age);console.log(&#39;-----------------------------------------------------------------------&#39;);    var getInstance2 = function(fn){        var result;        return function(){            return result || (result = fn.call(this, arguments));        }    }    // 创建div    var createWindow = function(){        var div = document.createElement(&quot;div&quot;);        div.innerHTML = &quot;我是弹窗内容&quot;;        div.style.display = &#39;none&#39;;        document.body.appendChild(div);        return div;    };    var divs = getInstance2(createWindow);    console.log(divs());&lt;/script&gt;</code></pre><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><pre><code>职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个对象分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，他都可能是请求的发起者也可能是请求的接收者。通过这样的方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与元请求的接收者之间的耦合。当然也方便对每个阶段对象进行单元测试。同时对于中途插入的请求，此模式依然使用，并可顺利对请求执行并产出结果。对于职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费，并且多个对象参与请求的传递，这在代码调试时增加了调试成本。有感：职责链模式就是把一个复杂的逻辑处理分解成更细粒度的单元，结合项目中，就是把请求，弹框等功能分解封装好，职责链这种设计模式有利于实现那种某些需求点不确定的需求，把不确定的需求单独抽离出来并且单独封装，其他的功能点或需求点不影响，有利于分别对各个功能点做测试。</code></pre><h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><pre><code>&lt;script&gt;// MVC架构模式很好地解决了页面中数据层、视图层、业务逻辑层（控制器）之间的耦合关系，使它们得到显性的区分，这也使得层次之间的耦合度降低。我们在开发中可以不用顾忌所有需求而专注于某一层次开发，降低了开发与维护成本，提升了开发效率。如果页面系统足够复杂，某些视图要共享同一组数据，或者某些需求的实现引用类似视图，此时MVC模式便可提高某些视图与数据的复用率。$(function() {    var MVC = MVC || {};    MVC.model = function() {        // 内部数据对象        var M = {};        // 服务器端获取的数据，通常通过ajax获取并存储        M.data = {};        // 配置数据，页面加载时即提供        M.conf = {};        // 返回数据模型层对象操作方法        return {            // 获取服务器端数据            getData: function(m) {                return M.data[m];            },            // 获取配置数据            getConf: function(c) {                return M.conf[c];            },            // 设置服务器端数据            setData: function(m, v) {                M.data[m] = v;                return this;            },            // 设置配置数据            setConf: function(c, v) {                M.conf[c] = v;                return this;            }        }    }();    MVC.view = function() {        // 模型数据层对象操作方法引用        var M = MVC.model;        // 内部视图创建方法对象        var V = {};        // 获取视图接口方法        return function(v) {            // 根据视图名称返回视图            V[v]();        }    }();    MVC.controller = function() {        // 模型数据层对象操作方法引用        var M = MVC.model;        // 视图数据层对象操作方法引用        var V = MVC.view;        // 控制器创建方法对象        var C = {};    }();})&lt;/script&gt;</code></pre><h1 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h1><pre><code>&lt;script&gt;~(function(window) {    var MVP = function() {};    MVP.model = function() {        var M = {};        M.data = [            {                text: &#39;新闻头条&#39;,                mode: &#39;news&#39;,                url: &#39;http://www.example.com/01&#39;            },            {                text: &#39;最新电影&#39;,                mode: &#39;movie&#39;,                url: &#39;http://www.example.com/02&#39;            }        ];        M.conf = {};        return {            getData: function(m) {                return M.data(m);            },            /**             * 设置数据             * @param {[type]} m 模块名称             * @param {[type]} v 模块数据             */            setData: function(m, v) {                M.data[m] = v;                return v;            },            getConf: function(c) {                return M.conf[c]            },            /**             * 设置配置             * @param {[type]} c 配置项名称             * @param {[type]} v 配置项值             */            setConf: function(c, v) {                M.conf[c] = v;                return v;            }        }    }();    MVP.view = function() {        // 子元素或者兄弟元素替换模板        var REPLACEKEY = &#39;__REPLACEKEY__&#39;;        // 获取完整元素模板        function getHTML(str, type) {            return str                    .replace(/^(\w+)()[^\{\}*]?(\{([@\w]+)\})?(.*?)$/, function(match, $1, $2, $3, $4, $5) {                        $2 = $2 || &#39;&#39;;                        $3 = $3 || &#39;&#39;;                        $4 = $4 || &#39;&#39;;                        $5 = $5.replace(/\{([@\w]+)\}/g, &#39;&#39;);                        return type === &#39;in&#39; ?                        &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + REPLACEKEY + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39;:                            type === &#39;add&#39; ?                            &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39; + REPLACEKEY                            :                            &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39;                    })                    .replace(/#([@\-\w]+)/g, &#39; id=&quot;$1&quot;&#39;)                    .replace(/\.([@\-\s\w]+/g, &#39; class=&quot;$1&quot;&#39;)                    .replace(/\[(.+)\]/g, function(match, key) {                        var a = key                                .replace(/&#39;|&quot;/g, &#39;&#39;)                                .split(&#39; &#39;),                            h = &#39;&#39;;                        for(var j = 0, len = a.length; j &lt; len; j ++) {                            h += &#39; &#39; + a[j].replace(/=(.*)/g, &#39;=&quot;$1&quot;&#39;);                        }                        return h;                    })                    .replace(/@(\w+)/g, &#39;&#39;);        }        function eachArray(arr, fn) {            for(var i = 0, len = arr.length; i &lt; len; i ++) {                // 将索引值、索引对应值、数组长度传入回调函数中并执行                fn(i, arr[i], len);            }        }        /**         * 替换兄弟元素模板或者子元素模板         * @param  {[type]} str 原始字符串         * @param  {[type]} rep 兄弟元素模板或者子元素模板         */        function formateItem(str, rep) {            // 用对应元素字符串替换兄弟元素模板或者子元素模板            return str.replace(new RegExp(REPLACEKEY, &#39;g&#39;), rep);        }        return function(str) {            var part = str                .replace(/^\s+|\s+$/g, &#39;&#39;)                .replace(/^\s+(&gt;)\s+/g, &#39;$1&#39;)                .split(&#39;&gt;&#39;),                html = REPLACEKEY,                item,                nodeTpl;            eachArray(part, function(partIndex, partValue, partLen) {                item = partValue.split(&#39;+&#39;);                nodeTpl = REPLACEKEY;                eachArray(item, function(itemIndex, itemValue, itemLen) {                    nodeTpl = formateItem(nodeTpl, getHTML(itemValue, itemIndex === itemLen - 1 ? (partIndex === partLen - 1 ? &#39;&#39; : &#39;in&#39;) : &#39;add&#39;));                })                html = formateItem(html, nodeTpl);            })            return html;        }    }()    MVP.presenter = function() {        var V = MVP.view;        var M = MVP.model;        var C = {};        return {            init: function() {                for(var i in C) {                    C[i] &amp;&amp; C[i](M, V, i);                }            },            add: function(modName, pst) {                C[modName] = pst;                return this;            }        }    }();    MVP.init = function() {};    window.MVP = MVP;})(window)var C = {    nav: function(M, V) {        var data = M.getData(&#39;nav&#39;);        data[0].choose = &#39;choose&#39;;        data[data.length - 1].last = &#39;last&#39;;        var tpl = V(&#39;li.@mode @choose @last[data-mode=@mode]&gt;a#nax_@mode.nav-@mode[href=@url title=@text]&gt;i.nav-icon-@mode-@mode+span{@text}&#39;);        $        .create(&#39;ul&#39;, {            &#39;class&#39;: &#39;navigator&#39;,            &#39;id&#39;: &#39;nav&#39;        })        .html(            A.formateString(tpl, data)        )        .appendTo(&#39;#container&#39;);    }}window.onload = function() {    MVP.init();}&lt;/script&gt;</code></pre><h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><pre><code>&lt;div class=&quot;first&quot; data-bind=&quot;type: &#39;slider&#39;, data: demo1&quot;&gt;test1&lt;/div&gt;&lt;div class=&quot;second&quot; data-bind=&quot;type: &#39;slider&#39;, data: demo2&quot;&gt;test2&lt;/div&gt;&lt;div class=&quot;third&quot; data-bind=&quot;type: &#39;progressbar&#39;, data: demo3&quot;&gt;test3&lt;/div&gt;&lt;script&gt;~(function() {    var window = this || (0, eval)(&#39;this&#39;);    // 获取页面字体大小，作为创建页面UI尺寸参照物    var FONTSIZE = function() {        // 获取页面body元素字体大小并转化成整数。        return parseInt(document.body.currentStyle ? document.body.currentStyle[&#39;fontSize&#39;] : getComputedStyle(document.body, false)[&#39;fontSize&#39;]);    }();    // 视图模型对象（策略对象）    var VM = function() {        var Method = {            progressbar: function(dom, data) {                // 进度条进度完成容器                var progress = document.createElement(&#39;div&#39;),                    param = data.data;                // 设置进度完成容器尺寸                progress.style.width = (param.position || 100) + &#39;%&#39;;                // 为进度条组件添加UI样式                dom.className += &#39; ui-progressbar&#39;;                // 进度完成容器元素插入进度条容器中                dom.appendChild(progress);            },            slider: function(dom, data) {                // 滚动条拨片                var bar = document.createElement(&#39;span&#39;),                    // 滑动条进度容器                    progress = document.createElement(&#39;div&#39;),                    // 滑动条容量提示信息                    totleText = null,                    // 滑动条拨片提示信息                    progressText = null,                    // 数据模型数据，结构{position: 60, totle: 200}                    param = data.data,                    // 容器元素宽度                    width = dom.clientWidth,                    // 容器元素横坐标值                    left = dom.offsetLeft,                    // 拨片位置                    realWidth = (param.position || 100) * width / 100;                // 清空滑动条容器，为创建滑动条作准备                dom.innerHTML = &#39;&#39;;                // 如果模型数据中提供容器总量信息，则创建滚动条提示文案                if (param.totle) {                    // 容器总量提示文案                    text = document.createElement(&#39;b&#39;);                    // 拨片位置提示文案                    progressText = document.createElement(&#39;em&#39;);                    // 设置容器总量提示文案                    text.innerHTML = param.totle;                    // 将容器总量提示文案元素添加到滑动条组件中                    dom.appendChild(text);                    // 将拨片位置提示文案元素添加到滑动条组件中                    dom.appendChild(progressText);                };                // 设置滑动条                setStyle(realWidth);                // 为滑动条组件添加UI样式                dom.className += &#39; ui-slider&#39;;                // 将进度容器添加到滑动条组件中                dom.appendChild(progress);                // 将拨片添加到滑动条组件中                dom.appendChild(bar);                // 设置滑动条                function setStyle(w) {                    // 设置进度容器宽度                    progress.style.width = w + &#39;px&#39;;                    // 设置拨片横坐标                    bar.style.left = w - FONTSIZE / 2 + &#39;px&#39;;                    // 如果有拨片提示文案                    if (progressText) {                        // 设置拨片提示文案横坐标                        progressText.style.left = w - FONTSIZE / 2 * 2.4 + &#39;px&#39;;                        // 设置拨片提示文案内容                        progressText.innerHTML = parseFloat(w / width * 100).toFixed(2) + &#39;%&#39;;                    };                }                //创建组件逻辑 按下鼠标拨片                bar.onmousedown = function() {                    // 移动拨片（鼠标光标在页面中滑动，事件绑定给document是为了优化交互体验，使鼠标光标可以在页面中自由滑动）                    document.onmousemove = function(event) {                        var e = event || window.event;                        var w = e.clientX - left;                        // 设置滑动条                        setStyle(w &lt; width ? ( w &gt; 0 ? w : 0) : width);                    }                    // 阻止页面滑动选取事件                    document.onselectstart = function() {                        return false;                    }                    // 停止滑动交互                    document.onmouseup = function() {                        // 取消文档鼠标光标移动事件                        document.onmousemove = null;                        // 取消文档滑动选取事件                        document.onselectstart = null;                    }                }            }        }        /**         * 获取视图层组件渲染数据的映射信息         * @param  {[type]} dom 组件元素         */        function getBindData(dom) {            // 获取组件自定义属性data-bind值            var data = dom.getAttribute(&#39;data-bind&#39;);            // 将自定义属性data-bind值转化为对象            return !!data &amp;&amp; (new Function(&quot;return ({&quot;+ data +&quot;})&quot;))();        }        // 组件实例化方法        return function() {            var doms = document.body.getElementsByTagName(&#39;*&#39;),            // 元素自定义数据句柄                ctx = null;            // ui处理是会向页面中插入元素，此时doms.length会改变，此时动态获取dom.length            for(var i = 0; i &lt; doms.length; i ++) {                // 获取元素自定义数据                ctx = getBindData(doms[i]);                // 如果元素是ui组件，则根据自定义属性中组件类型，渲染该组件                ctx.type &amp;&amp; Method[ctx.type] &amp;&amp; Method[ctx.type](doms[i], ctx);            }        }    }();    // 将视图模型对象绑定在Window上，供外部获取    window.VM = VM;})()var demo1 = {        position: 60,        totle: 200    },    demo2 = {        position: 20    },    demo3 = {position: 50};window.onload = function() {    VM();}&lt;/script&gt;</code></pre><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><pre><code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;// 其实就是js里组合继承，构造函数绑定属性，原型绑定方法// 每页显示5条数据，不够5条从最前面取var FlyWeight = function() {    var created = [];    function create() {        var dom = document.createElement(&#39;div&#39;);        document.getElementById(&#39;container&#39;).appendChild(dom);        created.push(dom);        return dom;    }    return {        getDiv: function() {            if (created.length &lt; 5) {                return create();            } else {                var div = created.shift();                created.push(div);                return div;            }        }    }}()console.log(FlyWeight.getDiv());for(var i = 0; i &lt; 5; i ++) {    FlyWeight.getDiv().innerHTML = i;}&lt;/script&gt;</code></pre><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><pre><code>var MarrySate = function() {    var _currentState = {},        status = {            jump: function() { console.log(&quot;jump&quot;); },            move: function() { console.log(&quot;move&quot;); },            shoot: function() { console.log(&quot;shoot&quot;); },            squat: function() { console.log(&quot;squat&quot;); }        };    var Action = {        changeState: function() {            var arg = arguments;            _currentState = {};            for(var i = 0, len = arg.length; i &lt; len; i ++) {                _currentState[arg[i]] = true;            }            return this;        },        goes: function() {            console.log(&quot;触发了&quot;);            for(var k in _currentState) {                _currentState[k] &amp;&amp; status[k]();            }        }    }    return {        change: Action.changeState,        goes: Action.goes    }}MarrySate()        .change(&#39;jump&#39;, &#39;move&#39;)        .goes()// 触发了// jump// move</code></pre><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>可以利用该模式封装弹层插件<br><code>`</code></p></blockquote><p><script><br>var Alert = function(data) {<br>    if (!data) return;<br>    // 设置内容<br>    this.content = data.content;<br>    // 创建提示框面板<br>    this.panel = document.createElement(‘div’);<br>    // 创建提示内容组件<br>    this.contentNode = document.createElement(‘p’);<br>    // 创建确定按钮组件<br>    this.confirmBtn = document.createElement(‘span’);<br>    // 创建关闭按钮组件<br>    this.closeBtn = document.createElement(‘b’);<br>    // 为提示框面板增加类<br>    this.panel.className = ‘alert’;<br>    // 为关闭按钮增加类<br>    this.closeBtn.className = ‘a-close’;<br>    // 为确定按钮增加类<br>    this.confirmBtn.className = ‘a-confirm’;<br>    // 为关闭按钮增加文案<br>    this.closeBtn.innerHTML = data.close || ‘关闭’;<br>    // 为确定按钮增加文案<br>    this.confirmBtn.innerHTML = data.confirm || ‘确定’;<br>    // 为提示内容增加文本<br>    this.contentNode.innerHTML = this.content;<br>    // 点击确定按钮执行方法 如果data中有succuess方法则为success方法，否则为空函数<br>    this.success = data.success || function() {};<br>    // 点击关闭按钮执行方法<br>    this.fail = data.fail || function() {};<br>}<br>// 提示框原型方法<br>Alert.prototype = {<br>    init: function() {<br>        this.panel.appendChild(this.closeBtn);<br>        this.panel.appendChild(this.contentNode);<br>        this.panel.appendChild(this.confirmBtn);<br>        document.body.appendChild(this.panel);<br>        this.bindEvent();<br>        this.show();<br>    },<br>    bindEvent: function() {<br>        var self = this;<br>        this.closeBtn.onclick = function() {<br>            self.fail();<br>            self.hide();<br>        }<br>        this.confirmBtn.onclick = function() {<br>            self.success();<br>            self.hide();<br>        }<br>    },<br>    hide: function() {<br>        this.panel.style.display = ‘none’;<br>    },<br>    show: function() {<br>        this.panel.style.display = ‘block’;<br>    }<br>}<br>new Alert({<br>    ‘content’: ‘test’,<br>    ‘close’: ‘close test’<br>}).init()</p><p>var RightAlert = function(data) {<br>    Alert.call(this, data);<br>    this.confirmBtn.className = this.confirmBtn.className + ‘ right’;<br>}<br>RightAlert.prototype = new Alert();<br>new RightAlert({<br>    ‘content’: ‘test’,<br>    ‘close’: ‘right close test’<br>}).init()<br></script><br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习设计模式？&quot;&gt;&lt;/a&gt;为什么要学习设计模式？&lt;/h1&gt;&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读万卷书，不如行万里路。接下来要贴代码了，从代码中就可以理解常用设计模式的主要概念。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;观察者模式（发布\订阅模式）&lt;/li&gt;
&lt;li&gt;中介者模式&lt;/li&gt;
&lt;li&gt;策略模式/状态模式&lt;/li&gt;
&lt;li&gt;命令模式&lt;/li&gt;
&lt;li&gt;迭代器模式&lt;/li&gt;
&lt;li&gt;参与者模式&lt;/li&gt;
&lt;li&gt;数据访问对象模式&lt;/li&gt;
&lt;li&gt;等待者模式&lt;/li&gt;
&lt;li&gt;同步模块模式&lt;/li&gt;
&lt;li&gt;异步模块模式&lt;/li&gt;
&lt;li&gt;链模式&lt;/li&gt;
&lt;li&gt;构造函数模式&lt;/li&gt;
&lt;li&gt;职责链模式&lt;/li&gt;
&lt;li&gt;MVC模式&lt;/li&gt;
&lt;li&gt;MVP模式&lt;/li&gt;
&lt;li&gt;MVVM模式&lt;/li&gt;
&lt;li&gt;享元模式&lt;/li&gt;
&lt;li&gt;状态模式&lt;/li&gt;
&lt;li&gt;模板方法模式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 设计模式" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码简洁之道</title>
    <link href="http://www.icrazyman.cn/2019/01/08/JavaScript%20%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://www.icrazyman.cn/2019/01/08/JavaScript 代码简洁之道/</id>
    <published>2019-01-08T13:54:29.000Z</published>
    <updated>2019-01-08T14:58:59.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。"><a href="#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。" class="headerlink" title="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。"></a>测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</h1><p>代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。</p><p>本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。</p><p>我们将从几个方面展开讨论：</p><ol><li><p>变量</p></li><li><p>函数</p></li><li><p>对象和数据结构</p></li><li><p>类</p></li><li><p>SOLID</p></li><li><p>测试</p></li><li><p>异步</p></li><li><p>错误处理</p></li><li><p>代码风格</p></li><li><p>注释</p></li></ol><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="用有意义且常用的单词命名变量"><a href="#用有意义且常用的单词命名变量" class="headerlink" title="用有意义且常用的单词命名变量"></a>用有意义且常用的单词命名变量</h2><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad:"></a>Bad:</h3><p><code>const yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;);</code></p><h3 id="Good"><a href="#Good" class="headerlink" title="Good:"></a>Good:</h3><p><code>const currentDate = moment().format(&#39;YYYY/MM/DD&#39;);</code></p><h2 id="保持统一"><a href="#保持统一" class="headerlink" title="保持统一"></a>保持统一</h2><p>可能同一个项目对于获取用户信息，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 codelf 搜索，看别人是怎么取名的。</p><h3 id="Bad-1"><a href="#Bad-1" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  getUserInfo();  getClientData();  getCustomerRecord();</code></pre><h3 id="Good-1"><a href="#Good-1" class="headerlink" title="Good:"></a>Good:</h3><p><code>getUser()</code></p><h2 id="每个常量都该命名"><a href="#每个常量都该命名" class="headerlink" title="每个常量都该命名"></a>每个常量都该命名</h2><p>可以用 buddy.js 或者 ESLint 检测代码中未命名的常量。</p><h3 id="Bad-2"><a href="#Bad-2" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 三个月之后你还能知道 86400000 是什么吗?setTimeout(blastOff, 86400000);</code></pre><h3 id="Good-2"><a href="#Good-2" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const MILLISECOND_IN_A_DAY = 86400000;setTimeout(blastOff, MILLISECOND_IN_A_DAY);</code></pre><h2 id="可描述"><a href="#可描述" class="headerlink" title="可描述"></a>可描述</h2><p>通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。</p><h3 id="Bad-3"><a href="#Bad-3" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;saveCityZipCode(ADDRESS.match(CITY_ZIP_CODE_REGEX)[1],                ADDRESS.match(CITY_ZIP_CODE_REGEX)[2]);</code></pre><h3 id="Good-3"><a href="#Good-3" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;const [, city, zipCode] = ADDRESS.match(CITY_ZIP_CODE_REGEX) || [];saveCityZipCode(city, zipCode);</code></pre><h2 id="直接了当"><a href="#直接了当" class="headerlink" title="直接了当"></a>直接了当</h2><h3 id="Bad-4"><a href="#Bad-4" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];locations.forEach((l) =&gt; {  doStuff();  doSomeOtherStuff();  // ...  // ...  // ...  // 需要看其他代码才能确定 &#39;l&#39; 是干什么的。  dispatch(l);});</code></pre><h3 id="Good-4"><a href="#Good-4" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];locations.forEach((location) =&gt; {  doStuff();  doSomeOtherStuff();  // ...  // ...  // ...  dispatch(location);});</code></pre><h2 id="避免无意义的前缀"><a href="#避免无意义的前缀" class="headerlink" title="避免无意义的前缀"></a>避免无意义的前缀</h2><p>如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</p><h3 id="Bad-5"><a href="#Bad-5" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  const car = {    carMake: &#39;Honda&#39;,    carModel: &#39;Accord&#39;,    carColor: &#39;Blue&#39;  };  function paintCar(car) {    car.carColor = &#39;Red&#39;;  }</code></pre><h3 id="Good-5"><a href="#Good-5" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const car = {  make: &#39;Honda&#39;,  model: &#39;Accord&#39;,  color: &#39;Blue&#39;};function paintCar(car) {  car.color = &#39;Red&#39;;}</code></pre><h2 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h2><h3 id="Bad-6"><a href="#Bad-6" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMicrobrewery(name) {  const breweryName = name || &#39;Hipster Brew Co.&#39;;  // ...}</code></pre><h3 id="Good-6"><a href="#Good-6" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMicrobrewery(name = &#39;Hipster Brew Co.&#39;) {  // ...}</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数越少越好"><a href="#参数越少越好" class="headerlink" title="参数越少越好"></a>参数越少越好</h2><p>如果参数超过两个，使用 ES2015/ES6 的解构语法，不用考虑参数的顺序。（注：不要超过3个参数，如果确实需要3个以上的参数，用对象包起来）</p><h3 id="Bad-7"><a href="#Bad-7" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMenu(title, body, buttonText, cancellable) {  // ...}</code></pre><h3 id="Good-7"><a href="#Good-7" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#39;Foo&#39;,  body: &#39;Bar&#39;,  buttonText: &#39;Baz&#39;,  cancellable: true});</code></pre><h2 id="只做一件事情"><a href="#只做一件事情" class="headerlink" title="只做一件事情"></a>只做一件事情</h2><p>这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。</p><h3 id="Bad-8"><a href="#Bad-8" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function emailClients(clients) {  clients.forEach((client) =&gt; {    const clientRecord = database.lookup(client);    if (clientRecord.isActive()) {      email(client);    }  });}</code></pre><h3 id="Good-8"><a href="#Good-8" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function emailActiveClients(clients) {  clients    .filter(isActiveClient)    .forEach(email);}function isActiveClient(client) {  const clientRecord = database.lookup(client);      return clientRecord.isActive();}</code></pre><h2 id="顾名思义"><a href="#顾名思义" class="headerlink" title="顾名思义"></a>顾名思义</h2><p>看函数名就应该知道它是干啥的。(注：其实就是语义化命名，代码是给人看的)</p><h3 id="Bad-9"><a href="#Bad-9" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function addToDate(date, month) {  // ...}const date = new Date();// 很难知道是把什么加到日期中addToDate(date, 1);</code></pre><h3 id="Good-9"><a href="#Good-9" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function addMonthToDate(month, date) {  // ...}const date = new Date();addMonthToDate(1, date);</code></pre><h2 id="只需要一层抽象层"><a href="#只需要一层抽象层" class="headerlink" title="只需要一层抽象层"></a>只需要一层抽象层</h2><p>如果函数嵌套过多会导致很难复用以及测试。</p><h3 id="Bad-10"><a href="#Bad-10" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function parseBetterJSAlternative(code) {  const REGEXES = [    // ...  ];  const statements = code.split(&#39; &#39;);  const tokens = [];  REGEXES.forEach((REGEX) =&gt; {    statements.forEach((statement) =&gt; {      // ...    });  });  const ast = [];  tokens.forEach((token) =&gt; {    // lex...  });  ast.forEach((node) =&gt; {    // parse...  });}</code></pre><h3 id="Good-10"><a href="#Good-10" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function parseBetterJSAlternative(code) {  const tokens = tokenize(code);  const ast = lexer(tokens);  ast.forEach((node) =&gt; {    // parse...  });}function tokenize(code) {  const REGEXES = [    // ...  ];  const statements = code.split(&#39; &#39;);  const tokens = [];  REGEXES.forEach((REGEX) =&gt; {    statements.forEach((statement) =&gt; {      tokens.push( /* ... */ );    });  });  return tokens;}function lexer(tokens) {  const ast = [];  tokens.forEach((token) =&gt; {    ast.push( /* ... */ );  });  return ast;}</code></pre><h2 id="删除重复代码"><a href="#删除重复代码" class="headerlink" title="删除重复代码"></a>删除重复代码</h2><p>很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。</p><p>要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 SOLID 原则（SOLID 是什么？稍后会详细介绍）。</p><h3 id="Bad-11"><a href="#Bad-11" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function showDeveloperList(developers) {  developers.forEach((developer) =&gt; {    const expectedSalary = developer.calculateExpectedSalary();    const experience = developer.getExperience();    const githubLink = developer.getGithubLink();    const data = {      expectedSalary,      experience,      githubLink    };    render(data);  });}function showManagerList(managers) {  managers.forEach((manager) =&gt; {    const expectedSalary = manager.calculateExpectedSalary();    const experience = manager.getExperience();    const portfolio = manager.getMBAProjects();    const data = {      expectedSalary,      experience,      portfolio    };    render(data);  });}</code></pre><h3 id="Good-11"><a href="#Good-11" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function showEmployeeList(employees) {  employees.forEach(employee =&gt; {    const expectedSalary = employee.calculateExpectedSalary();    const experience = employee.getExperience();    const data = {      expectedSalary,      experience,    };    switch(employee.type) {      case &#39;develop&#39;:        data.githubLink = employee.getGithubLink();        break      case &#39;manager&#39;:        data.portfolio = employee.getMBAProjects();        break    }    render(data);  })}</code></pre><h2 id="对象设置默认属性"><a href="#对象设置默认属性" class="headerlink" title="对象设置默认属性"></a>对象设置默认属性</h2><h3 id="Bad-12"><a href="#Bad-12" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const menuConfig = {  title: null,  body: &#39;Bar&#39;,  buttonText: null,  cancellable: true};function createMenu(config) {  config.title = config.title || &#39;Foo&#39;;  config.body = config.body || &#39;Bar&#39;;  config.buttonText = config.buttonText || &#39;Baz&#39;;  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;}createMenu(menuConfig);</code></pre><h3 id="Good-12"><a href="#Good-12" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const menuConfig = {  title: &#39;Order&#39;,  // &#39;body&#39; key 缺失  buttonText: &#39;Send&#39;,  cancellable: true};function createMenu(config) {  config = Object.assign({    title: &#39;Foo&#39;,    body: &#39;Bar&#39;,    buttonText: &#39;Baz&#39;,    cancellable: true  }, config);  // config 就变成了: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}  // ...}createMenu(menuConfig);</code></pre><h2 id="不要传-flag-参数"><a href="#不要传-flag-参数" class="headerlink" title="不要传 flag 参数"></a>不要传 flag 参数</h2><p>通过 flag 的 true 或 false，来判断执行逻辑，违反了一个函数干一件事的原则。(这个持保留意见，只能说尽量不要把分支判断放在函数里面)</p><h3 id="Bad-13"><a href="#Bad-13" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createFile(name, temp) {  if (temp) {    fs.create(`./temp/${name}`);  } else {    fs.create(name);  }}</code></pre><h3 id="Good-13"><a href="#Good-13" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createFile(name) {  fs.create(name);}function createFileTemplate(name) {  createFile(`./temp/${name}`)}</code></pre><h2 id="避免副作用（第一部分）"><a href="#避免副作用（第一部分）" class="headerlink" title="避免副作用（第一部分）"></a>避免副作用（第一部分）</h2><p>函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。</p><p>当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。</p><p>副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。</p><p>（注：这就是纯函数的作用，同样的输入，返回的一定是同样的输入，这样对于结果是可预料的，不会出现意料之外甚至很难修复的问题）</p><h3 id="Bad-14"><a href="#Bad-14" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 全局变量被一个函数引用// 现在这个变量从字符串变成了数组，如果有其他的函数引用，会发生无法预见的错误。var name = &#39;Ryan McDermott&#39;;function splitIntoFirstAndLastName() {  name = name.split(&#39; &#39;);}splitIntoFirstAndLastName();console.log(name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h3 id="Good-14"><a href="#Good-14" class="headerlink" title="Good:"></a>Good:</h3><pre><code>var name = &#39;Ryan McDermott&#39;;var newName = splitIntoFirstAndLastName(name)function splitIntoFirstAndLastName(name) {  return name.split(&#39; &#39;);}console.log(name); // &#39;Ryan McDermott&#39;;console.log(newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h2 id="避免副作用（第二部分）"><a href="#避免副作用（第二部分）" class="headerlink" title="避免副作用（第二部分）"></a>避免副作用（第二部分）</h2><p>在 JavaScript 中，基本类型通过赋值传递，对象和数组通过引用传递。以引用传递为例：</p><p>假如我们写一个购物车，通过 addItemToCart() 方法添加商品到购物车，修改 购物车数组。此时调用 purchase() 方法购买，由于引用传递，获取的 购物车数组 正好是最新的数据。</p><p>看起来没问题对不对？</p><p>如果当用户点击购买时，网络出现故障， purchase() 方法一直在重复调用，与此同时用户又添加了新的商品，这时网络又恢复了。那么 purchase() 方法获取到 购物车数组 就是错误的。</p><p>为了避免这种问题，我们需要在每次新增商品时，克隆 购物车数组 并返回新的数组。</p><h3 id="Bad-15"><a href="#Bad-15" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {  cart.push({ item, date: Date.now() });};</code></pre><h3 id="Good-15"><a href="#Good-15" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {  return [...cart, {item, date: Date.now()}]};</code></pre><h2 id="不要写全局方法"><a href="#不要写全局方法" class="headerlink" title="不要写全局方法"></a>不要写全局方法</h2><p>在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 Array.prototype 上新增一个 diff 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 diff 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 Array 进行扩展。</p><h3 id="Bad-16"><a href="#Bad-16" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>Array.prototype.diff = function diff(comparisonArray) {  const hash = new Set(comparisonArray);  return this.filter(elem =&gt; !hash.has(elem));};</code></pre><h3 id="Good-16"><a href="#Good-16" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class SuperArray extends Array {  diff(comparisonArray) {    const hash = new Set(comparisonArray);    return this.filter(elem =&gt; !hash.has(elem));          }}</code></pre><h2 id="比起命令式我更喜欢函数式编程"><a href="#比起命令式我更喜欢函数式编程" class="headerlink" title="比起命令式我更喜欢函数式编程"></a>比起命令式我更喜欢函数式编程</h2><p>函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。</p><h3 id="Bad-17"><a href="#Bad-17" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const programmerOutput = [  {    name: &#39;Uncle Bobby&#39;,    linesOfCode: 500  }, {    name: &#39;Suzie Q&#39;,    linesOfCode: 1500  }, {    name: &#39;Jimmy Gosling&#39;,    linesOfCode: 150  }, {    name: &#39;Gracie Hopper&#39;,    linesOfCode: 1000  }];let totalOutput = 0;for (let i = 0; i &lt; programmerOutput.length; i++) {  totalOutput += programmerOutput[i].linesOfCode;</code></pre><h3 id="Good-17"><a href="#Good-17" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const programmerOutput = [  {    name: &#39;Uncle Bobby&#39;,    linesOfCode: 500  }, {    name: &#39;Suzie Q&#39;,    linesOfCode: 1500  }, {    name: &#39;Jimmy Gosling&#39;,    linesOfCode: 150  }, {    name: &#39;Gracie Hopper&#39;,    linesOfCode: 1000  }];let totalOutput = programmerOutput  .map(output =&gt; output.linesOfCode)  .reduce((totalLines, lines) =&gt; totalLines + lines, 0)</code></pre><h2 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h2><h2 id="Bad-18"><a href="#Bad-18" class="headerlink" title="Bad:"></a>Bad:</h2><pre><code>if (fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) {  // ...}</code></pre><h2 id="Good-18"><a href="#Good-18" class="headerlink" title="Good:"></a>Good:</h2><pre><code>// 持保留意见function shouldShowSpinner(fsm, listNode) {  return fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode);}if (shouldShowSpinner(fsmInstance, listNodeInstance)) {  // ...}</code></pre><h2 id="尽量别用“非”条件句"><a href="#尽量别用“非”条件句" class="headerlink" title="尽量别用“非”条件句"></a>尽量别用“非”条件句</h2><h3 id="Bad-19"><a href="#Bad-19" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function isDOMNodeNotPresent(node) {  // ...}if (!isDOMNodeNotPresent(node)) {  // ...}</code></pre><h3 id="Good-19"><a href="#Good-19" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function isDOMNodePresent(node) {  // ...}if (isDOMNodePresent(node)) {  // ...}</code></pre><h2 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h2><p>Q：不用条件语句写代码是不可能的。</p><p>A：绝大多数场景可以用多态替代。</p><p>Q：用多态可行，但为什么就不能用条件语句了呢？</p><p>A：为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则。</p><h3 id="Bad-20"><a href="#Bad-20" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Airplane {  // ...  // 获取巡航高度  getCruisingAltitude() {    switch (this.type) {      case &#39;777&#39;:        return this.getMaxAltitude() - this.getPassengerCount();      case &#39;Air Force One&#39;:        return this.getMaxAltitude();      case &#39;Cessna&#39;:        return this.getMaxAltitude() - this.getFuelExpenditure();    }  }}</code></pre><h3 id="Good-20"><a href="#Good-20" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Airplane {  // ...}// 波音777class Boeing777 extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude() - this.getPassengerCount();  }}// 空军一号class AirForceOne extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude();  }}// 赛纳斯飞机class Cessna extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude() - this.getFuelExpenditure();  }}// 利用对象使用分支判断var Airplane = {    &#39;777&#39;: function() {        return this.getMaxAltitude() - this.getPassengerCount();    },    &#39;Air Force One&#39;: function() {        return this.getMaxAltitude();    },    &#39;Cessna&#39;: function() {        return this.getMaxAltitude() - this.getFuelExpenditure();    },}</code></pre><h2 id="避免类型检查（第一部分）"><a href="#避免类型检查（第一部分）" class="headerlink" title="避免类型检查（第一部分）"></a>避免类型检查（第一部分）</h2><p>JavaScript 是无类型的，意味着你可以传任意类型参数，这种自由度很容易让人困扰，不自觉的就会去检查类型。仔细想想是你真的需要检查类型还是你的 API 设计有问题？（注：持保留意见）</p><h3 id="Bad-21"><a href="#Bad-21" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function travelToTexas(vehicle) {  if (vehicle instanceof Bicycle) {    vehicle.pedal(this.currentLocation, new Location(&#39;texas&#39;));  } else if (vehicle instanceof Car) {    vehicle.drive(this.currentLocation, new Location(&#39;texas&#39;));  }}</code></pre><h3 id="Good-21"><a href="#Good-21" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function travelToTexas(vehicle) {  vehicle.move(this.currentLocation, new Location(&#39;texas&#39;));}</code></pre><h2 id="避免类型检查（第二部分）"><a href="#避免类型检查（第二部分）" class="headerlink" title="避免类型检查（第二部分）"></a>避免类型检查（第二部分）</h2><p>如果你需要做静态类型检查，比如字符串、整数等，推荐使用 TypeScript，不然你的代码会变得又臭又长。</p><pre><code class="Bad:">function combine(val1, val2) {  if (typeof val1 === &#39;number&#39; &amp;&amp; typeof val2 === &#39;number&#39; ||      typeof val1 === &#39;string&#39; &amp;&amp; typeof val2 === &#39;string&#39;) {    return val1 + val2;  }  throw new Error(&#39;Must be of type String or Number&#39;);}</code></pre><h3 id="Good-22"><a href="#Good-22" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(val1, val2) {  return val1 + val2;}</code></pre><h2 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h2><p>现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间，想知道现代浏览器优化了哪些内容，请点这里。（注：持保留意见，低版本的浏览器没有做该优化，虽然性能提升不大，但这是一个好的编码习惯）</p><h3 id="Bad-22"><a href="#Bad-22" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 在老的浏览器中，由于 `list.length` 没有做缓存，每次迭代都会去计算，造成不必要开销。// 现代浏览器已对此做了优化。for (let i = 0, len = list.length; i &lt; len; i++) {  // ...}</code></pre><h3 id="Good-23"><a href="#Good-23" class="headerlink" title="Good:"></a>Good:</h3><pre><code>for (let i = 0; i &lt; list.length; i++) {  // ...}</code></pre><h2 id="删除弃用代码"><a href="#删除弃用代码" class="headerlink" title="删除弃用代码"></a>删除弃用代码</h2><p>很多时候有些代码已经没有用了，但担心以后会用，舍不得删。</p><p>如果你忘了这件事，这些代码就永远存在那里了。</p><p>放心删吧，你可以在代码库历史版本中找他它。</p><p>（持保留意见，因为保留部分注释的重要代码是以防出现问题可以直接线上恢复代码而不用上紧急版本）</p><h3 id="Bad-23"><a href="#Bad-23" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function oldRequestModule(url) {  // ...}function newRequestModule(url) {  // ...}const req = newRequestModule;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);</code></pre><h3 id="Good-24"><a href="#Good-24" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function newRequestModule(url) {  // ...}const req = newRequestModule;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);</code></pre><h1 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h1><h2 id="用-get、set-方法操作数据"><a href="#用-get、set-方法操作数据" class="headerlink" title="用 get、set 方法操作数据"></a>用 get、set 方法操作数据</h2><p>这样做可以带来很多好处，比如在操作数据时打日志，方便跟踪错误；在 set 的时候很容易对数据进行校验…</p><h3 id="Bad-24"><a href="#Bad-24" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function makeBankAccount() {  // ...  return {    balance: 0,    // ...  };}const account = makeBankAccount();account.balance = 100;</code></pre><h3 id="Good-25"><a href="#Good-25" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeBankAccount() {  // 私有变量  let balance = 0;  function getBalance() {    return balance;  }  function setBalance(amount) {    // ... 在更新 balance 前，对 amount 进行校验    balance = amount;  }  return {    // ...    getBalance,    setBalance,  };}const account = makeBankAccount();account.setBalance(100);</code></pre><h2 id="使用私有变量"><a href="#使用私有变量" class="headerlink" title="使用私有变量"></a>使用私有变量</h2><p>可以用闭包来创建私有变量</p><h3 id="Bad-25"><a href="#Bad-25" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const Employee = function(name) {  this.name = name;};Employee.prototype.getName = function getName() {  return this.name;};const employee = new Employee(&#39;John Doe&#39;);console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined</code></pre><h3 id="Good-26"><a href="#Good-26" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeEmployee(name) {  return {    getName() {      return name;    },  };}const employee = makeEmployee(&#39;John Doe&#39;);console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe</code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="使用-class"><a href="#使用-class" class="headerlink" title="使用 class"></a>使用 class</h2><p>在 ES2015/ES6 之前，没有类的语法，只能用构造函数的方式模拟类，可读性非常差。</p><h3 id="Bad-26"><a href="#Bad-26" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 动物const Animal = function(age) {  if (!(this instanceof Animal)) {    throw new Error(&#39;Instantiate Animal with `new`&#39;);  }  this.age = age;};Animal.prototype.move = function move() {};// 哺乳动物const Mammal = function(age, furColor) {  if (!(this instanceof Mammal)) {    throw new Error(&#39;Instantiate Mammal with `new`&#39;);  }  Animal.call(this, age);  this.furColor = furColor;};Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function liveBirth() {};// 人类const Human = function(age, furColor, languageSpoken) {  if (!(this instanceof Human)) {    throw new Error(&#39;Instantiate Human with `new`&#39;);  }  Mammal.call(this, age, furColor);  this.languageSpoken = languageSpoken;};Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function speak() {};</code></pre><h3 id="Good-27"><a href="#Good-27" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 动物class Animal {  constructor(age) {    this.age = age  };  move() {};}// 哺乳动物class Mammal extends Animal{  constructor(age, furColor) {    super(age);    this.furColor = furColor;  };  liveBirth() {};}// 人类class Human extends Mammal{  constructor(age, furColor, languageSpoken) {    super(age, furColor);    this.languageSpoken = languageSpoken;  };  speak() {};</code></pre><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>这种模式相当有用，可以在很多库中发现它的身影，比如 jQuery、Lodash 等。它让你的代码简洁优雅。实现起来也非常简单，在类的方法最后返回 this 可以了。</p><h3 id="Bad-27"><a href="#Bad-27" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;  }  setModel(model) {    this.model = model;  }  setColor(color) {    this.color = color;  }  save() {    console.log(this.make, this.model, this.color);  }}const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;);car.setColor(&#39;pink&#39;);car.save();</code></pre><h3 id="Good-28"><a href="#Good-28" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;)  .setColor(&#39;pink&#39;);  .save();</code></pre><h2 id="不要滥用继承"><a href="#不要滥用继承" class="headerlink" title="不要滥用继承"></a>不要滥用继承</h2><p>很多时候继承被滥用，导致可读性很差，要搞清楚两个类之间的关系，继承表达的一个属于关系，而不是包含关系，比如 Human-&gt;Animal vs. User-&gt;UserDetails</p><h3 id="Bad-28"><a href="#Bad-28" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Employee {  constructor(name, email) {    this.name = name;    this.email = email;  }  // ...}// TaxData（税收信息）并不是属于 Employee（雇员），而是包含关系。class EmployeeTaxData extends Employee {  constructor(ssn, salary) {    super();    this.ssn = ssn;    this.salary = salary;  }  // ...}</code></pre><h3 id="Good-29"><a href="#Good-29" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class EmployeeTaxData {  constructor(ssn, salary) {    this.ssn = ssn;    this.salary = salary;  }  // ...}class Employee {  constructor(name, email) {    this.name = name;    this.email = email;  }  setTaxData(ssn, salary) {    this.taxData = new EmployeeTaxData(ssn, salary);  }  // ...}</code></pre><h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。</p><h2 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 The Single Responsibility Principle"></a>单一功能原则 The Single Responsibility Principle</h2><p>如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p><h3 id="Bad-29"><a href="#Bad-29" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class UserSettings {  constructor(user) {    this.user = user;  }  changeSettings(settings) {    if (this.verifyCredentials()) {      // ...    }  }  verifyCredentials() {    // ...  }}</code></pre><h3 id="Good-30"><a href="#Good-30" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class UserAuth {  constructor(user) {    this.user = user;  }  verifyCredentials() {    // ...  }}class UserSetting {  constructor(user) {    this.user = user;    this.auth = new UserAuth(this.user);  }  changeSettings(settings) {    if (this.auth.verifyCredentials()) {      // ...    }  }}</code></pre><h2 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 The Open Closed Principle"></a>开闭原则 The Open Closed Principle</h2><p>“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。</p><h3 id="Bad-30"><a href="#Bad-30" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = &#39;ajaxAdapter&#39;;  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = &#39;nodeAdapter&#39;;  }}class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    if (this.adapter.name === &#39;ajaxAdapter&#39;) {      return makeAjaxCall(url).then((response) =&gt; {        // 传递 response 并 return      });    } else if (this.adapter.name === &#39;httpNodeAdapter&#39;) {      return makeHttpCall(url).then((response) =&gt; {        // 传递 response 并 return      });    }  }}function makeAjaxCall(url) {  // 处理 request 并 return promise}function makeHttpCall(url) {  // 处理 request 并 return promise}</code></pre><h3 id="Good-31"><a href="#Good-31" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = &#39;ajaxAdapter&#39;;  }  request(url) {    // 处理 request 并 return promise  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = &#39;nodeAdapter&#39;;  }  request(url) {    // 处理 request 并 return promise  }}class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    return this.adapter.request(url).then((response) =&gt; {      // 传递 response 并 return    });  }}</code></pre><h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 Liskov Substitution Principle"></a>里氏替换原则 Liskov Substitution Principle</h2><p>名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。</p><h3 id="Bad-31"><a href="#Bad-31" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 长方形class Rectangle {  constructor() {    this.width = 0;    this.height = 0;  }  setColor(color) {    // ...  }  render(area) {    // ...  }  setWidth(width) {    this.width = width;  }  setHeight(height) {    this.height = height;  }  getArea() {    return this.width * this.height;  }}// 正方形class Square extends Rectangle {  setWidth(width) {    this.width = width;    this.height = width;  }  setHeight(height) {    this.width = height;    this.height = height;  }}function renderLargeRectangles(rectangles) {  rectangles.forEach((rectangle) =&gt; {    rectangle.setWidth(4);    rectangle.setHeight(5);    const area = rectangle.getArea();     rectangle.render(area);  });}const rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);</code></pre><h3 id="Good-32"><a href="#Good-32" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Shape {  setColor(color) {    // ...  }  render(area) {    // ...  }}class Rectangle extends Shape {  constructor(width, height) {    super();    this.width = width;    this.height = height;  }  getArea() {    return this.width * this.height;  }}class Square extends Shape {  constructor(length) {    super();    this.length = length;  }  getArea() {    return this.length * this.length;  }}function renderLargeShapes(shapes) {  shapes.forEach((shape) =&gt; {    const area = shape.getArea();    shape.render(area);  });}const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes);</code></pre><h2 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 The Interface Segregation Principle"></a>接口隔离原则 The Interface Segregation Principle</h2><p>JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。</p><h3 id="Bad-32"><a href="#Bad-32" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.animationModule.setup();  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName(&#39;body&#39;),  animationModule() {} // Most of the time, we won&#39;t need to animate when traversing.  // ...});</code></pre><h3 id="Good-33"><a href="#Good-33" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.options = settings.options;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.setupOptions();  }  setupOptions() {    if (this.options.animationModule) {      // ...    }  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName(&#39;body&#39;),  options: {    animationModule() {}  }});</code></pre><h2 id="依赖倒置原则-The-Dependency-Inversion-Principle"><a href="#依赖倒置原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则 The Dependency Inversion Principle"></a>依赖倒置原则 The Dependency Inversion Principle</h2><p>说就两点：</p><ul><li><p>高层次模块不能依赖低层次模块，它们依赖于抽象接口。</p></li><li><p>抽象接口不能依赖具体实现，具体实现依赖抽象接口。</p></li></ul><p>总结下来就两个字，解耦。</p><h3 id="Bad-33"><a href="#Bad-33" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 库存查询class InventoryRequester {  constructor() {    this.REQ_METHODS = [&#39;HTTP&#39;];  }  requestItem(item) {    // ...  }}// 库存跟踪class InventoryTracker {  constructor(items) {    this.items = items;    // 这里依赖一个特殊的请求类，其实我们只是需要一个请求方法。    this.requester = new InventoryRequester();  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;]);inventoryTracker.requestItems();</code></pre><h3 id="Good-34"><a href="#Good-34" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 库存跟踪class InventoryTracker {  constructor(items, requester) {    this.items = items;    this.requester = requester;  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}// HTTP 请求class InventoryRequesterHTTP {  constructor() {    this.REQ_METHODS = [&#39;HTTP&#39;];  }  requestItem(item) {    // ...  }}// webSocket 请求class InventoryRequesterWS {  constructor() {    this.REQ_METHODS = [&#39;WS&#39;];  }  requestItem(item) {    // ...  }}// 通过依赖注入的方式将请求模块解耦，这样我们就可以很轻易的替换成 webSocket 请求。const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;], new InventoryRequesterHTTP());inventoryTracker.requestItems();</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>随着项目变得越来越庞大，时间线拉长，有的老代码可能半年都没碰过，如果此时上线，你有信心这部分代码能正常工作吗？测试的覆盖率和你的信心是成正比的。</p><p>PS: 如果你发现你的代码很难被测试，那么你应该优化你的代码了。</p><h2 id="单一化"><a href="#单一化" class="headerlink" title="单一化"></a>单一化</h2><h3 id="Bad-34"><a href="#Bad-34" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import assert from &#39;assert&#39;;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {  it(&#39;handles date boundaries&#39;, () =&gt; {    let date;    date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);    date.addDays(30);    assert.equal(&#39;1/31/2015&#39;, date);    date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);    date.addDays(28);    assert.equal(&#39;02/29/2016&#39;, date);    date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);    date.addDays(28);    assert.equal(&#39;03/01/2015&#39;, date);  });});</code></pre><h3 id="Good-35"><a href="#Good-35" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import assert from &#39;assert&#39;;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {  it(&#39;handles 30-day months&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);    date.addDays(30);    assert.equal(&#39;1/31/2015&#39;, date);  });  it(&#39;handles leap year&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);    date.addDays(28);    assert.equal(&#39;02/29/2016&#39;, date);  });  it(&#39;handles non-leap year&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);    date.addDays(28);    assert.equal(&#39;03/01/2015&#39;, date);  });});</code></pre><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="不再使用回调"><a href="#不再使用回调" class="headerlink" title="不再使用回调"></a>不再使用回调</h2><p>不会有人愿意去看嵌套回调的代码，用 Promises 替代回调吧。</p><h3 id="Bad-35"><a href="#Bad-35" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request&#39;;import { writeFile } from &#39;fs&#39;;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;, (requestErr, response) =&gt; {  if (requestErr) {    console.error(requestErr);  } else {    writeFile(&#39;article.html&#39;, response.body, (writeErr) =&gt; {      if (writeErr) {        console.error(writeErr);      } else {        console.log(&#39;File written&#39;);      }    });  }});</code></pre><h3 id="Good-36"><a href="#Good-36" class="headerlink" title="Good:"></a>Good:</h3><pre><code>get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)  .then((response) =&gt; {    return writeFile(&#39;article.html&#39;, response);  })  .then(() =&gt; {    console.log(&#39;File written&#39;);  })  .catch((err) =&gt; {    console.error(err);  });</code></pre><h2 id="Async-Await-比起-Promises-更简洁"><a href="#Async-Await-比起-Promises-更简洁" class="headerlink" title="Async/Await 比起 Promises 更简洁"></a>Async/Await 比起 Promises 更简洁</h2><h3 id="Bad-36"><a href="#Bad-36" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request-promise&#39;;import { writeFile } from &#39;fs-promise&#39;;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)  .then((response) =&gt; {    return writeFile(&#39;article.html&#39;, response);  })  .then(() =&gt; {    console.log(&#39;File written&#39;);  })  .catch((err) =&gt; {    console.error(err);  });</code></pre><h3 id="Good-37"><a href="#Good-37" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import { get } from &#39;request-promise&#39;;import { writeFile } from &#39;fs-promise&#39;;async function getCleanCodeArticle() {  try {    const response = await get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;);    await writeFile(&#39;article.html&#39;, response);    console.log(&#39;File written&#39;);  } catch(err) {    console.error(err);  }}</code></pre><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要忽略抛异常"><a href="#不要忽略抛异常" class="headerlink" title="不要忽略抛异常"></a>不要忽略抛异常</h2><h3 id="Bad-37"><a href="#Bad-37" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>try {  functionThatMightThrow();} catch (error) {  console.log(error);}</code></pre><h3 id="Good-38"><a href="#Good-38" class="headerlink" title="Good:"></a>Good:</h3><pre><code>try {  functionThatMightThrow();} catch (error) {  // 这一种选择，比起 console.log 更直观  console.error(error);  // 也可以在界面上提醒用户  notifyUserOfError(error);  // 也可以把异常传回服务器  reportErrorToService(error);  // 其他的自定义方法}</code></pre><h2 id="不要忘了在-Promises-抛异常"><a href="#不要忘了在-Promises-抛异常" class="headerlink" title="不要忘了在 Promises 抛异常"></a>不要忘了在 Promises 抛异常</h2><h3 id="Bad-38"><a href="#Bad-38" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>getdata()  .then((data) =&gt; {    functionThatMightThrow(data);  })  .catch((error) =&gt; {    console.log(error);  });</code></pre><h3 id="Good-39"><a href="#Good-39" class="headerlink" title="Good:"></a>Good:</h3><pre><code>getdata()  .then((data) =&gt; {    functionThatMightThrow(data);  })  .catch((error) =&gt; {    // 这一种选择，比起 console.log 更直观    console.error(error);    // 也可以在界面上提醒用户    notifyUserOfError(error);    // 也可以把异常传回服务器    reportErrorToService(error);    // 其他的自定义方法  });</code></pre><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。</p><h2 id="常量大写"><a href="#常量大写" class="headerlink" title="常量大写"></a>常量大写</h2><h3 id="Bad-39"><a href="#Bad-39" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const DAYS_IN_WEEK = 7;const daysInMonth = 30;const songs = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];const Artists = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];function eraseDatabase() {}function restore_database() {}class animal {}class Alpaca {}</code></pre><h3 id="Good-40"><a href="#Good-40" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const DAYS_IN_WEEK = 7;const DAYS_IN_MONTH = 30;const SONGS = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];const ARTISTS = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];function eraseDatabase() {}function restoreDatabase() {}class Animal {}class Alpaca {}</code></pre><h2 id="先声明后调用"><a href="#先声明后调用" class="headerlink" title="先声明后调用"></a>先声明后调用</h2><p>就像我们看报纸文章一样，从上到下看，所以为了方便阅读把函数声明写在函数调用前面。</p><h3 id="Bad-40"><a href="#Bad-40" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class PerformanceReview {  constructor(employee) {    this.employee = employee;  }  lookupPeers() {    return db.lookup(this.employee, &#39;peers&#39;);  }  lookupManager() {    return db.lookup(this.employee, &#39;manager&#39;);  }  getPeerReviews() {    const peers = this.lookupPeers();    // ...  }  perfReview() {    this.getPeerReviews();    this.getManagerReview();    this.getSelfReview();  }  getManagerReview() {    const manager = this.lookupManager();  }  getSelfReview() {    // ...  }}const review = new PerformanceReview(employee);review.perfReview();</code></pre><h3 id="Good-41"><a href="#Good-41" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class PerformanceReview {  constructor(employee) {    this.employee = employee;  }  perfReview() {    this.getPeerReviews();    this.getManagerReview();    this.getSelfReview();  }  getPeerReviews() {    const peers = this.lookupPeers();    // ...  }  lookupPeers() {    return db.lookup(this.employee, &#39;peers&#39;);  }  getManagerReview() {    const manager = this.lookupManager();  }  lookupManager() {    return db.lookup(this.employee, &#39;manager&#39;);  }  getSelfReview() {    // ...  }}const review = new PerformanceReview(employee);review.perfReview();</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="只有业务逻辑需要注释"><a href="#只有业务逻辑需要注释" class="headerlink" title="只有业务逻辑需要注释"></a>只有业务逻辑需要注释</h2><p>代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p><h3 id="Bad-41"><a href="#Bad-41" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function hashIt(data) {  // 这是初始值  let hash = 0;  // 数组的长度  const length = data.length;  // 循环数组  for (let i = 0; i &lt; length; i++) {    // 获取字符代码    const char = data.charCodeAt(i);    // 修改 hash    hash = ((hash &lt;&lt; 5) - hash) + char;    // 转换为32位整数    hash &amp;= hash;  }}</code></pre><h3 id="Good-42"><a href="#Good-42" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function hashIt(data) {  let hash = 0;  const length = data.length;  for (let i = 0; i &lt; length; i++) {    const char = data.charCodeAt(i);    hash = ((hash &lt;&lt; 5) - hash) + char;    // 转换为32位整数    hash &amp;= hash;  }}</code></pre><h2 id="删掉注释的代码"><a href="#删掉注释的代码" class="headerlink" title="删掉注释的代码"></a>删掉注释的代码</h2><p>git 存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧。</p><h3 id="Bad-42"><a href="#Bad-42" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff();</code></pre><h3 id="Good-43"><a href="#Good-43" class="headerlink" title="Good:"></a>Good:</h3><pre><code>doStuff();</code></pre><p>javascript</p><p>不要记日记<br>记住你有 git！，git log 可以帮你干这事。</p><h3 id="Bad-43"><a href="#Bad-43" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>/** * 2016-12-20: 删除了 xxx * 2016-10-01: 改进了 xxx * 2016-02-03: 删除了第12行的类型检查 * 2015-03-14: 增加了一个合并的方法 */function combine(a, b) {  return a + b;}</code></pre><h3 id="Good-44"><a href="#Good-44" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(a, b) {  return a + b;}</code></pre><h2 id="注释不需要高亮"><a href="#注释不需要高亮" class="headerlink" title="注释不需要高亮"></a>注释不需要高亮</h2><p>注释高亮，并不能起到提示的作用，反而会干扰你阅读代码。（注：在联调或临时修改代码调试的时候可以用此方法引起自己的注意，保证在提交代码的时候可以注意到此处，不会造成调试代码的提交）</p><h3 id="Bad-44"><a href="#Bad-44" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////$scope.model = {  menu: &#39;foo&#39;,  nav: &#39;bar&#39;};////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////const actions = function() {  // ...};</code></pre><h3 id="Good-45"><a href="#Good-45" class="headerlink" title="Good:"></a>Good:</h3><pre><code>$scope.model = {  menu: &#39;foo&#39;,  nav: &#39;bar&#39;};const actions = function() {  // ...};</code></pre><p>文末推荐一篇很好的讲述前端代码规范的文章，包含前端各种代码的规范，我觉得可以根据自己公司项目的实际情况借鉴一二。<a href="https://guide.aotu.io/docs/index.html" target="_blank" rel="noopener">前端代码规范</a></p><blockquote><p>翻译自 ryanmcdermott 的 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a>，本文对原文进行了一些修改。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。&quot;&gt;&lt;a href=&quot;#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。&quot; class=&quot;headerlink&quot; title=&quot;测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。&quot;&gt;&lt;/a&gt;测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。&lt;/h1&gt;&lt;p&gt;代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。&lt;/p&gt;
&lt;p&gt;本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。&lt;/p&gt;
&lt;p&gt;我们将从几个方面展开讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象和数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SOLID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码风格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 风格 编码" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E9%A3%8E%E6%A0%BC-%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运算符优先级和隐式转换</title>
    <link href="http://www.icrazyman.cn/2018/12/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.icrazyman.cn/2018/12/26/JavaScript运算符优先级和隐式转换/</id>
    <published>2018-12-26T12:40:51.000Z</published>
    <updated>2018-12-26T15:28:19.783Z</updated>
    
    <content type="html"><![CDATA[<p>昨天圣诞节，本应该是一个开心的日子，但对有些程序猿来说，是非常糟糕的一天。在很多技术开发群里，在技术论坛以及github社区都炸天了。我想说的是，使用开源的人，得有感激之心，但是贡献开源的人更应该要有敬畏之心。我们要感谢每一个开源的人，他们为这个世界贡献了自己的力量，为这个社会提高了效率，而开源的人也应该怀有敬畏之心，尊重每一个使用者，更好地回馈使用者，使用者和开源这相互成就。</p><p>好了，话说回来，今天看了一篇文章，其中有一个题目感觉非常有趣，我也给大家送一个彩蛋吧，其中也引发了我对JavaScript运算符和隐式转换的思考了，所以还是坐下来静下心把JavaScript的运算符和隐式转换学习总结了一下，但其中难免会有些错误，不喜勿喷啊！</p><p>先贴个彩蛋：</p><p><code>({}+[])[[~!+[]]*~+[]]+(!(~+[])+{})[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]</code></p><p>各位童鞋，你算出来了吗？点击后将揭晓答案哦！当然，等不及的童鞋肯定自己在控制台复制粘贴得出结果了吧，呵呵！</p><a id="more"></a><p>答案就是：</p><p><img src="https://i.imgur.com/8IpzJoy.png" alt></p><p>哈哈，是不是被骂了还在问人这段代码是什么意思呢？</p><p>我来告诉你：</p><p>这段代码为什么会输出sb呢？其实这段代码考的是js的类型转化的一些基本原理。</p><p>首先要运用到的第一个知识就是js运算符的优先级，因为这么长一段运算看的人眼花，我们必须得先根据优先级分成n小段，然后再各个击破。</p><h1 id="js运算符的优先级"><a href="#js运算符的优先级" class="headerlink" title="js运算符的优先级"></a>js运算符的优先级</h1><p>优先级的排列如下表，优先级从高到低：</p><p><img src="https://i.imgur.com/b834A7c.jpg" alt></p><p>根据此规则，我们把这一串运算分为以下表达式：</p><p><img src="https://i.imgur.com/cdDv5jr.png" alt></p><p>其实中括号[]也是一个运算符，用来通过索引访问数组项，另外也可以访问字符串的子字符，有点类似charAt方法，如：’abcd’[1] // 返回’b’。而且中括号的优先级还是最高的哦。</p><p>接下来需要运用的就是JavaScript的类型转化知识了，我们先说说什么情况下需要进行类型转化。当操作符两边的操作数类型不一致或者不是基本类型（也叫原始类型）时，需要进行类型转化。</p><p>让我们快速的复习一下，在JavaScript中，一共有两种类型的值：原始值(primitives)和对象值(objects)。</p><p>原始值有：undefined、null、布尔值(booleans)、数字(numbers)、还有字符串(strings)。</p><p>其他的所有值都是对象类型的值，包括数组(arrays)和函数(functions)。</p><h1 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h1><p>先按运算符来分一下类：</p><p>减号-，乘号*，肯定是进行数学运算，所以操作数需转化为number类型。</p><p>加号+，可能是字符串拼接，也可能是数学运算，所以可能会转化为number或string。</p><p>一元运算，如+[]，只有一个操作数的，转化为number类型。</p><p>下面来看一下转化规则。</p><h2 id="对于非原始类型的，通过ToPrimitive-将值转换成原始类型"><a href="#对于非原始类型的，通过ToPrimitive-将值转换成原始类型" class="headerlink" title="对于非原始类型的，通过ToPrimitive()将值转换成原始类型"></a>对于非原始类型的，通过ToPrimitive()将值转换成原始类型</h2><p><code>ToPrimitive(input, PreferredType?)</code></p><p>可选参数PreferredType是Number或者是String。返回值为任何原始值。</p><p>如果PreferredType是Number，执行顺序如下：</p><ol><li><p>如果input为primitive，返回；</p></li><li><p>如果input为Object。调用obj.valueOf()，如果结果是primitive，返回；</p></li><li><p>否则，调用obj.toString()，如果结果是primitive，返回；</p></li><li><p>否则，抛出TypeError。</p></li></ol><p>如果 PreferredType是String，步骤2跟3互换，如果PreferredType没有，Date实例被设置成String，其他都是Number。</p><h2 id="通过ToNumber-将值转换为数字"><a href="#通过ToNumber-将值转换为数字" class="headerlink" title="通过ToNumber()将值转换为数字"></a>通过ToNumber()将值转换为数字</h2><p>通过ToNumber()把值转换成Number，直接看ECMA 9.3的表格：</p><p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,Number)将该对象转换为原始值，然后在调用ToNumber()将这个原始值转换为数字。</p><h2 id="通过ToString-将值转换为字符串"><a href="#通过ToString-将值转换为字符串" class="headerlink" title="通过ToString()将值转换为字符串"></a>通过ToString()将值转换为字符串</h2><p>通过ToString()把值转化成字符串， 直接看ECMA 9.8的表格</p><p><img src="https://i.imgur.com/9hKHPCu.jpg" alt></p><p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,String)将该对象转换为原始值，然后再调用ToString()将这个原始值转换为字符串.规则就这么多，接下来实践一下，根据我们上面划分出的子表达式，一步一步将这个神奇的代码给执行出来。开工~</p><p>先看最简单的子表达式：</p><p><code>+[]</code></p><p>只有一个操作数[]，肯定是转化为number了，根据上面的规则2，[]是个数组，object类型，即对象。所以得先调用toPrimitive转化为原始类型，并且PreferredType为number，这个参数表示更“倾向于”转化的类型，这里肯定是number了。然后首先调用数组的valueOf方法，数组调用valueOf会返回自身，</p><p>这个时候，我们得到一个空串“”，还没有结束，看上面的规则2描述，继续调用toNumber，转化为number类型，大功告成！子表达式16转化完毕，+[]，最终得到0。</p><p>来看子表达式：</p><p><code>[~+&quot;&quot;]</code></p><p>空串””前面有两个一元操作符，但是操作数还是只有一个，所以，最终要转化为的类型是number。看规则2吧，空串调用toNumber得到0。接下来是~，这是个什么东东呢？它是位运算符，作用可以记为把数字取负然后减一，所以~0就是-1 。</p><p>别忘了，这个子表达式外头还包着中括号，所以最终的值为[-1]，即一个数组，里面只有一个元素-1.</p><p>接下来看子表达式就简单了</p><p>把以上求出来的填进去，就变成了这样：–[-1][0]，取数组的第0个元素，然后自减，结果为-2，是不so easy!</p><p>继续往后走，子表达式：</p><p><code>[~+[]]</code></p><p>其实把上面的原理用上就非常明显了，答案[-1]。</p><p>继续，此刻它已变成：-2<em>[-1]，有稍许不一样，不过没关系，我们还是按照规则来，运算符是乘号</em>，当然是做数学运算，那后面的[-1]就得转化为number，过程如下：</p><ol><li><p>调用toPrimitive，发现是object类型</p></li><li><p>调用valueOf，返回自身[-1]</p></li><li><p>因为不是原始类型，继续调用toString，返回”-1”</p></li><li><p>“-1”是原始类型了，然后调用toNumber，返回-1</p></li><li><p>与-2相乘，返回2</p></li></ol><p>子表达式：</p><p><code>~~!+[]</code></p><p>不多说了，答案1。就是从右往左依次一元计算。</p><p>此刻它已经长这样了：2+1， 好，我不多说了。</p><p>继续看表达式：</p><p><code>!(~+[])，~+[]=-1</code></p><p>这个根据上面已经知道了，那!-1是什么呢？这里要说一下这个感叹号，它是逻辑取非的意思，会把表达式转化为布尔类型，转化规则和js的Truthy和Falsy原则是一样的，后面跟数字的，除0以外都为false，后面跟字符串的，除空串以外都为false。这里的!-1当然就是false了。</p><p>接下来这个表达式3：false+{}有点关键</p><p>一个布尔加一个对象，那这个{}应该先转化为原始类型，流程如下：</p><ol><li><p>调用toPrimitive，发现是object类型</p></li><li><p>调用valueOf，返回自身{}，</p></li><li><p>不是原始类型，调用toString，返回</p></li><li><p>[objectObject]</p></li><li><p>false与[objectObject]相加，false先转化为字符串”false”</p></li></ol><p>相加得结果false[objectObject] 此时它是这样的：false[objectObject][3]，因为这个[]可以取字符串的子字符，像charAt一样，所以得到了结果”s”</p><p>经过上面艰难的流程，我们拿到了字符”s”，也就是那张图的左半边，剩下的那个”b”，相同的原理可以搞出来，我这里就不一一演示了，留给你练练吧~</p><p>回顾一下这个过程其实也不复杂，只是有一些需要重复劳动的，只要你掌握了运算的优先级，能把大串分解成一个个小串，然后运用类型转化的知识挨个处理就搞定了。怎么样，看到这里你还觉得神奇吗？</p><p>同样的，中文字符也是由这样组成的，跟英文同样的道理。</p><h1 id="操作符也会影响数据的类型转换"><a href="#操作符也会影响数据的类型转换" class="headerlink" title="操作符也会影响数据的类型转换"></a>操作符也会影响数据的类型转换</h1><ol><li><p>当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为数字类型</p></li><li><p>当+号作为二元操作符时，如果两个操作数中存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串</p></li><li><p>当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作</p></li><li><p>当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。</p></li></ol><h1 id="引用对象如何转换为简单值"><a href="#引用对象如何转换为简单值" class="headerlink" title="引用对象如何转换为简单值"></a>引用对象如何转换为简单值</h1><ol><li><p>一个复杂对象在转为基础类型的时候会调用ToPrimitive(hint)方法来指定其目标类型</p></li><li><p>如果传入的hint值为number,那么就先调用对象的valueOf()方法，调用完valueOf()方法后，如果返回的是原始值，则结束ToPrimitive操作</p></li><li><p>如果返回的不是原始值，则继续调用对象的toString()方法，调用完toString()方法之后如果返回的是一个原始值，则结束ToPrimitive操作</p></li><li><p>如果返回的还是复杂值，则抛出异常。如果传入的hint值为string，则先调用toString()方法，再调用valueOf()方法，其余的过程一样。</p></li></ol><h1 id="那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？"><a href="#那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？" class="headerlink" title="那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？"></a>那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？</h1><ol><li><p>如果运行环境非常明确的需要将一个复杂对象转换为数字则传入number如 Number(value) 和 +value 则传入number</p></li><li><p>如果运行环境非常明确的需要将一个复杂对象转换为字符串则传入string如String(value) 和 alert(value) 则传入string</p></li><li><p>如果是用+号连接两个操作数，操作数在确定确定其中只要有一个为字符串的时候另外一个操作数会转为字符串，ToPrimitive()会传入string，但是如果两个操作数都不能确定是字符串的时候则默认传入number(Date对象是一个例外，它会默认传入string)进行数据类型转换。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天圣诞节，本应该是一个开心的日子，但对有些程序猿来说，是非常糟糕的一天。在很多技术开发群里，在技术论坛以及github社区都炸天了。我想说的是，使用开源的人，得有感激之心，但是贡献开源的人更应该要有敬畏之心。我们要感谢每一个开源的人，他们为这个世界贡献了自己的力量，为这个社会提高了效率，而开源的人也应该怀有敬畏之心，尊重每一个使用者，更好地回馈使用者，使用者和开源这相互成就。&lt;/p&gt;
&lt;p&gt;好了，话说回来，今天看了一篇文章，其中有一个题目感觉非常有趣，我也给大家送一个彩蛋吧，其中也引发了我对JavaScript运算符和隐式转换的思考了，所以还是坐下来静下心把JavaScript的运算符和隐式转换学习总结了一下，但其中难免会有些错误，不喜勿喷啊！&lt;/p&gt;
&lt;p&gt;先贴个彩蛋：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;({}+[])[[~!+[]]*~+[]]+(!(~+[])+{})[--[~+&amp;quot;&amp;quot;][+[]]*[~+[]] + ~~!+[]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;各位童鞋，你算出来了吗？点击后将揭晓答案哦！当然，等不及的童鞋肯定自己在控制台复制粘贴得出结果了吧，呵呵！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript 运算符 优先级 隐式转换" scheme="http://www.icrazyman.cn/tags/JavaScript-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%BC%98%E5%85%88%E7%BA%A7-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>js 事件循环（Event Loop）机制</title>
    <link href="http://www.icrazyman.cn/2018/12/22/js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event%20Loop%EF%BC%89%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.icrazyman.cn/2018/12/22/js 事件循环（Event Loop）机制/</id>
    <published>2018-12-22T01:56:26.000Z</published>
    <updated>2019-02-14T13:53:14.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先放个测试题，压压惊</p></blockquote><pre><code>const interval = setInterval(()=&gt;{  console.log(&#39;setInterval&#39;);},0);setTimeout(()=&gt;{  console.log(&#39;setTimeout 1&#39;);  Promise.resolve()    .then(()=&gt;{      console.log(&#39;promise1&#39;);      })    .then(()=&gt;{      setTimeout(()=&gt;{        console.log(&#39;setTimeout 2&#39;);        clearInterval(interval);      },0);    })},0);Promise.resolve()  .then(()=&gt;{     console.log(&#39;promise2&#39;);})</code></pre><p><strong>末尾揭晓答案</strong></p><a id="more"></a><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p><p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p><p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><h1 id="单线程的优劣势"><a href="#单线程的优劣势" class="headerlink" title="单线程的优劣势"></a>单线程的优劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><p>降低处理复杂性，简化开发，例如不用考虑竞争机制等。</p></li><li><p>作为用于预处理与用户互动的脚本语言，可以更加容易地处理状态同步的问题。</p></li><li><p>JS核心维护人员自身的理解与设计。</p></li><li><p>越简单越容易推广，快速上手。</p></li></ol><h2 id="明显的劣势"><a href="#明显的劣势" class="headerlink" title="明显的劣势"></a>明显的劣势</h2><ol><li><p>并发处理能力，任务处于 I/O 等待状态，导致CPU处理资源的浪费。</p></li><li><p>于是JavaScript语言将任务的执行模分成两种：同步任务和异步任务。通过事件循环处理任务。</p></li><li><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p></li><li><p>异步任务：不进入主线程、而进入任务队列（Task queue），只有任务通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p></li></ol><h1 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h1><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p><p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并吧这个执行环境销毁。接着继续执行队列里的下一段代码。</p><h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><p>先看一段伪代码</p><pre><code>// eventLoop是一个用作队列的数组，（先进，先出）var eventLoop = [ ];var event;// “永远”执行while (true){  if (eventLoop.length &gt; 0){    // 拿到队列中的下一个事件    event = eventLoop.shift();    // 现在，执行下一个事件    try {      event();    }catch (err){      reportError(err);    }  }</code></pre><p>这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。</p><p>再贴张流程图</p><p><img src="https://i.imgur.com/Vvg8kzp.png" alt="流程图"></p><p>事件循环的具体步骤</p><ol><li><p>同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。</p></li><li><p>系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。</p></li><li><p>执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。</p></li></ol><p>请看下面一段代码</p><pre><code>console.log(&#39;A&#39;+ new Date());setTimeout(function(){ console.log(&#39;B&#39;+new Date());},1000);var end = Date.now()+3000;while(Date.now()&lt;end){}console.log(&#39;C&#39;+new Date());</code></pre><p>A,B,C输出的顺序，以及输出的时间 ?</p><p>A会被立即输出，执行到setTimeout(…)时，将会等待1秒后在任务队列添加一个打印B的任务，然后继续往下执行。JS主线程会在while循环通过后继续往下执行，在等待3秒后C被打印，此时任务队列中还有个定时任务回调函数。JS执行栈执行完一个任务之后会再去任务队列取任务，所以C输出后。直接输出B。</p><p>PS：一定要清楚， setTimeout(..) 并 没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。</p><h1 id="macro-task-宏任务-与micro-task-微任务"><a href="#macro-task-宏任务-与micro-task-微任务" class="headerlink" title="macro task(宏任务)与micro task(微任务)"></a>macro task(宏任务)与micro task(微任务)</h1><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li>script</li><li>setInterval()</li><li>setTimeout()</li><li>setImmediate</li><li>用户交互操作</li><li>UI渲染</li></ul><p>以下事件属于微任务</p><ul><li>new Promise()</li><li>process.nextTick</li><li>new MutaionObserver()</li><li>Object.observe</li></ul><p>事件循环做的事情如下：</p><ol><li><p>检查Macrotask 队列是否为空（同步代码），若不为空，则进行下一步，若为空，则跳到3；</p></li><li><p>从Macrotask队列中取首个任务推入执行栈执行，执行完后进入下一步；</p></li><li><p>检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）；</p></li><li><p>从Microtask队列取首个任务执行，执行完后，跳到3；</p></li><li><p>然后开始下一轮 Event loop，执行宏任务中的异步代码；</p></li></ol><p><strong>简单来讲，整体的js代码这个macrotask先执行，同步代码执行完后有microtask执行microtask，没有microtask执行下一个macrotask，如此往复循环；</strong></p><hr><p>文首测试题的答案为：</p><p>promise2</p><p>setInterval</p><p>setTimeout 1</p><p>promise1</p><p>setInterval</p><p>setTimeout2</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先放个测试题，压压惊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
const interval = setInterval(()=&amp;gt;{
  console.log(&amp;#39;setInterval&amp;#39;);
},0);

setTimeout(()=&amp;gt;{
  console.log(&amp;#39;setTimeout 1&amp;#39;);
  Promise.resolve()
    .then(()=&amp;gt;{
      console.log(&amp;#39;promise1&amp;#39;);  
    })
    .then(()=&amp;gt;{
      setTimeout(()=&amp;gt;{
        console.log(&amp;#39;setTimeout 2&amp;#39;);
        clearInterval(interval);
      },0);
    })
},0);

Promise.resolve()
  .then(()=&amp;gt;{
     console.log(&amp;#39;promise2&amp;#39;);
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;末尾揭晓答案&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript　js　事件循环 eventloop" scheme="http://www.icrazyman.cn/tags/javascript-js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-eventloop/"/>
    
  </entry>
  
  <entry>
    <title>不破不立的哲学与个人成长</title>
    <link href="http://www.icrazyman.cn/2018/12/02/%E4%B8%8D%E7%A0%B4%E4%B8%8D%E7%AB%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    <id>http://www.icrazyman.cn/2018/12/02/不破不立的哲学与个人成长/</id>
    <published>2018-12-02T01:23:40.000Z</published>
    <updated>2018-12-02T01:35:51.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从团建狼人杀说起"><a href="#从团建狼人杀说起" class="headerlink" title="从团建狼人杀说起"></a>从团建狼人杀说起</h1><p>一切要从上周五团队团建中的狼人杀游戏说起。第一局我是狼人，韬光养晦，不鸣不飞，胜；后两局不起眼神职，点兵点将，“瞎指一通”，侃侃而谈，结果都是大胜。</p><p>这种看似有些破坏正常套路的行为站在宏观层面来看，实际上可以大大增加好人获胜的概率。</p><p>对于狼人，取胜之匙可以简单归结为“避免身份被暴露”，对于好人，取胜之匙则是“让狼人身份暴露”。</p><p>要知道狼在在暗处，如果按部就班，要想让狼人暴露，就比较考验直觉和运气了，如果一开始不能灭掉几个狼人，越拖则越不利。如何让狼人暴露呢？我的策略就是破坏平衡，不怕犯错，让狼人露出马脚，从而提高获胜的概率。</p><p>一开始狼人对彼此身份是互相知道的，胡乱指两个人，其中有狼人概率相当高，此时狼人的表现就很容易暴露一些重要信息；就算指的都是好人，狼人表现也会不一样，可能指认的人数会稍稍多一些，此时，人已经开始分组，同时也透露出你指的人好人概率更大之类的判断信息，所有这些加起来都会提高获胜的概率，也就是一开始想办法让狼人也参与进来，狼人是知道彼此的身份，说得越多做的越多透出信息越多。但是，如果一开始大家就巴拉巴拉说些有的没的话，第一局基本上就靠运气，狼人已经占得先机了。</p><p>我们工作中很多事情与之都是类似的道理。例如软件开发中的bug测试，软件中的bug我们可以看出是狼人杀中的狼人，要让这些bug出现，我们平时正常的操作套路是远远不够的。必须要进行破坏性的极端测试边界测试来让这些bug暴露，例如没有数据情况，网络异常情况，网络访问突然峰值10倍情况等。</p><p>可以看到，要想让潜在的问题，潜在的坏蛋出现，破坏平衡，故意出错，引蛇出洞是一个非常行之有效的方法。这种策略也是自己工作与学习成长的策略。</p><a id="more"></a><h1 id="不破不立的哲学"><a href="#不破不立的哲学" class="headerlink" title="不破不立的哲学"></a>不破不立的哲学</h1><p>如果把我们的人生发展看成是一局狼人杀，则停滞、重复、局限以及安逸就可以看成是狼人，我们需要把它们找出来扼杀掉，但是，人总是习惯呆在舒适区，轻松省力，往往就看不到背后的狼人其实每晚都在杀害你内心的那些好人，久而久之，你的人生可能就会被狼人给弄失败。</p><p>举个例子，很多开发人员进入互联网圈子后，头1~2年成长会非常快，每天接触很多新鲜的东西，总有很多不会的东西，然而，等工作个2~3年，等业务驾轻就熟之后，就会发现每天的工作好像没有什么挑战，工作内容也重复，每天好像没有明显成长，此时，显然就已经进入舒适区了，也可以看成是成长的瓶颈。很多人的做法是换个换个工作，不同业务不同团队不同文化重新刺激自己，确实很很有效，但这并不是长久之计，当换来换去后你会发现大同小异，通常10年左右，你就会发现又陷入了瓶颈，一切并没有本质变化，而且年龄越大，换工作成本越高，不得不呆在一个地方舒适下去，然后眼睁睁看着后辈超越自己，所谓中年危机就是这么来的。</p><p>所以，要想人生有所成，尤其新兴且竞争激烈的互联网行业，关键还是要练自己的内功远离舒适区，而不是依赖于环境，通过自身的行为和策略把藏在暗处的狼人揪出来，灭之，则你就能取得人生的胜利。</p><p>如何揪出这些狼人呢？我的做法和上面狼人杀是一致的，进行破坏，所谓不破不立，具体做法包括下面几点：破坏平衡，主动犯错，广度刺激，自造难度。</p><h2 id="破坏平衡"><a href="#破坏平衡" class="headerlink" title="破坏平衡"></a>破坏平衡</h2><p><img src="https://image.zhangxinxu.com/image/blog/201808/niuniu-car.jpg" alt="破坏平衡"></p><p>上图这个叫做“扭扭车”，家里小朋友很喜欢玩，玩得还很溜。扭扭车的动力很有意思，其要前进，必须要扭来扭去，通过不平衡来制造前进的动力。这其实很技术的成长，或者人生的前进类似，你需要一些不平衡在获得前进的东西。</p><p>如果说远点，这个其实跟阶级差异贫富差异内在是类似的。会想以前吃大锅饭，人人均等的时代，社会经济的发展是很慢的，看上去的平衡却造成了前进停滞；而估计能者居上，产生不平衡后，国家40年来的经济发展就非常迅速，不平衡可以产生动力，只要掌握好这个平衡度，不翻车，就能持续前进。</p><p>人生也是如此，如果满于现状，觉得都挺好的，无欲无求；或者迷茫，不知道未来路在哪里，自己想要什么，则发展就会停滞，对于互联网行业，如果停滞意味就会被赶超，是非常危险的。</p><p>如果你是这种状态，则需要打破这种平衡，来获得前进动力。方法很多，比方说斗破苍穹里面萧炎被悔婚，算是一种平衡的打破；或者谈一场轰轰烈烈但失败的恋爱，让我想起了董明珠如果不是丈夫去世，怕没有今天的成就；或者让老大给你打个1星激励下。</p><p>我以前是通过刺激打破迷茫的状态，而现在则是通过设立目标来获得前进动力。</p><p>比方说我想要改变世界，发现现在离这个目标还很远，必须要加油，然后每天就很努力，因为当前状态和目标状态相比是一种不平衡的状态，这种不平衡就产生了前进的动力。</p><p><img src="https://image.zhangxinxu.com/image/blog/201808/change-wrold.png" alt></p><p>当然，你的目标可以不是改变世界这么虚这么远的，可以是短期的，例如这个季度我要在团队完成10个分享，我1个月时间翻译某某文档。也不一定工作上的，也可以连续一个月每天中午和女朋友打个电话，你们关系一定会变得更好，每周至少去健身一次等等。</p><p>制作不平衡，远离当下状态，获得成长动力。</p><h2 id="主动犯错"><a href="#主动犯错" class="headerlink" title="主动犯错"></a>主动犯错</h2><p>不怕犯错，甚至主动犯错。</p><p>可以举举我开车识路的例子。</p><p><img src="https://image.zhangxinxu.com/image/blog/201808/car-drive.jpg" alt></p><p>对于经常走的路线，例如回老家，或者上班，在前期，我几乎病态地每次都开不一样的路，比方说回老家，先不说沪常高速，京沪高速，沈海高速这几个高速主干道开了个遍，我多次直接不走高速从下面慢慢溜达，走过全程不走高速，走过一半省道一半高速，市区内各条小道也是走了个遍。结果这些偏门道路80%都是糟糕的选择，比方说高速2小时，下面屁颠屁颠开了4小时，一路上大货车一堆，红绿灯一堆，拍照一堆，有一次还擦擦碰碰，那些省道也不是免费的，芝麻点路还收10块钱，比高速还贵。看起来这些决策是错误的，费时有费力，带来的是痛苦，但是，这种主动犯错带来的经验与学习却是宝贵的，令人印象深刻的，不同道路的不同特色就了然于心，识路的技能成长就很快，在日后会带来巨大的价值。果然，节假日来了，高速堵车堵成了狗屎，而我，则和老婆大人在车里，吃着火锅，哼着小曲，沿着下面道路，完美避开拥堵，一路畅通回到了家，比堵车的这些家伙快了1倍时间。</p><p>成为道路达人的的秘诀就是主动尝试，不怕犯错，失败才能快速成长，只要发现一条曲径通幽的道路就是赚到，就是赚不到，沿途的风景也是不错的收获。</p><p>我在技能学习的时候，也会各种尝试，不怕犯错，人生有些错误是不能挽回的，但是，代码和技能不是这样的，不要怕，勇敢的上。</p><p>例如我在学习padStart()和padEnd()这两个ES6 API的时候，后面的补全参数按照道理应该是字符串，但是自己就主动犯错，各种数据类型都试一遍，结果发现了以外的收获，同样是一个API的学习，所get到的知识点，知识细节就比按部就班浅尝辄止学习的同学多很多，当你有无数多个这样的积累的时候，你就可以甩别人一条长安街了。</p><h2 id="广度刺激"><a href="#广度刺激" class="headerlink" title="广度刺激"></a>广度刺激</h2><p>通过换工作寻求新的刺激成本是比较高的，通常而言，大多数企业是不喜欢频繁的换工作的员工的。但是，我们通过广度刺激自己远离安逸和惰性则是百益无一害的。</p><p>广度刺激一方面是关注新技术，不一定要深知，至少要了解，可以扩展自己的技术选型的广度。有些技术如果对团队非常有帮助，则可以推动在团队落地，容易出好的绩效，升职加薪那就自然而然就来了。</p><p>另外一方面是关注新的模式，新的业务。例如去年直播很多，还有抖音，拼多多的崛起，对这些新模式新业务的了解有助于开阔自己的眼界，不至于坐井观天。否则一直呆在公司这点弹丸之地，不对外部事物保持关注，很容易淹没在滚滚潮流中，被时代淘汰。</p><p>以前很多在IBM这类公司工作人，被这个传统IT公司所累，很多认知都落后于时代，在新兴的互联网企业完全玩不开，掌握的理论都过时，是很危险的，大家可以引以为鉴，有效避之。</p><h2 id="自造难度"><a href="#自造难度" class="headerlink" title="自造难度"></a>自造难度</h2><p>人在江湖，身不由己。难免会接到没有技术含量的枯燥工作，对于前端而言，做一些简单的运营活动就是件很无趣的事情。你是按部就班完成工作把生命无形中浪费掉，还是有点追求在工作中给自己自增难度找点乐子呢？</p><p>所谓找点乐子，就是不要老是把自己掌握的那丁点技术重复来重复去使用，抓住每一次机会给自己来一个有意思的挑战，实现快速成长。</p><p>举一些我自己给自己下挑战的例子：</p><ul><li>这个图标我纯CSS绘制；</li><li>这个效果纯CSS实现；</li><li>这个效果我用SVG实现试试；</li><li>这个页面所有资源加载尺寸我要控制100K以内；</li><li>重复工作好无聊，写个自动化工具，这个页面我正好让我测一测工具跑起来怎么样；</li><li>最近学了点新技术，用在大项目中风险比较高，这个也就内部同事看看的运营页面正好可以用来试试手；</li><li>……</li></ul><p>等等等等。<strong>为什么觉得工作无聊，因为重复，那就想办法不重复，给自己增加点挑战不就好了，越折腾越成长，虽然说多花了点时间，但是，你让原本半天没有意义浪费生命的时光也变得有意义了，自己也成长了，然后再和同事分享分享，那不得了，影响力也有了，自然更容易取得人生上的成功了。</strong></p><h1 id="没有掉馅饼的事"><a href="#没有掉馅饼的事" class="headerlink" title="没有掉馅饼的事"></a>没有掉馅饼的事</h1><p>在互联网这个新兴行业，你想指望每天划划水，呆在自己舒适的小天地，同时升职加薪走上人生巅峰，那是不可能的。</p><p>互联网行业是目前而言相对比较公平的行业，你努力付出，积极进度，能力出众，技术优秀，自然会得到符合的报酬和地位，因为行业里这样的人稀缺无比。同样的，那些守着前几年学的点东西指望在公司养老一辈子的，也一定会被淘汰，被边缘，消失在滚滚红尘中。这就是公平，这也是为什么中国互联网的发展在全球处于领先的原因之一。</p><p>本文转载自【<a href="http://www.zhangxinxu.com/life/?p=801" title="不破不立的哲学与个人成长" target="_blank" rel="noopener">不破不立的哲学与个人成长</a>】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从团建狼人杀说起&quot;&gt;&lt;a href=&quot;#从团建狼人杀说起&quot; class=&quot;headerlink&quot; title=&quot;从团建狼人杀说起&quot;&gt;&lt;/a&gt;从团建狼人杀说起&lt;/h1&gt;&lt;p&gt;一切要从上周五团队团建中的狼人杀游戏说起。第一局我是狼人，韬光养晦，不鸣不飞，胜；后两局不起眼神职，点兵点将，“瞎指一通”，侃侃而谈，结果都是大胜。&lt;/p&gt;
&lt;p&gt;这种看似有些破坏正常套路的行为站在宏观层面来看，实际上可以大大增加好人获胜的概率。&lt;/p&gt;
&lt;p&gt;对于狼人，取胜之匙可以简单归结为“避免身份被暴露”，对于好人，取胜之匙则是“让狼人身份暴露”。&lt;/p&gt;
&lt;p&gt;要知道狼在在暗处，如果按部就班，要想让狼人暴露，就比较考验直觉和运气了，如果一开始不能灭掉几个狼人，越拖则越不利。如何让狼人暴露呢？我的策略就是破坏平衡，不怕犯错，让狼人露出马脚，从而提高获胜的概率。&lt;/p&gt;
&lt;p&gt;一开始狼人对彼此身份是互相知道的，胡乱指两个人，其中有狼人概率相当高，此时狼人的表现就很容易暴露一些重要信息；就算指的都是好人，狼人表现也会不一样，可能指认的人数会稍稍多一些，此时，人已经开始分组，同时也透露出你指的人好人概率更大之类的判断信息，所有这些加起来都会提高获胜的概率，也就是一开始想办法让狼人也参与进来，狼人是知道彼此的身份，说得越多做的越多透出信息越多。但是，如果一开始大家就巴拉巴拉说些有的没的话，第一局基本上就靠运气，狼人已经占得先机了。&lt;/p&gt;
&lt;p&gt;我们工作中很多事情与之都是类似的道理。例如软件开发中的bug测试，软件中的bug我们可以看出是狼人杀中的狼人，要让这些bug出现，我们平时正常的操作套路是远远不够的。必须要进行破坏性的极端测试边界测试来让这些bug暴露，例如没有数据情况，网络异常情况，网络访问突然峰值10倍情况等。&lt;/p&gt;
&lt;p&gt;可以看到，要想让潜在的问题，潜在的坏蛋出现，破坏平衡，故意出错，引蛇出洞是一个非常行之有效的方法。这种策略也是自己工作与学习成长的策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编码 成长" scheme="http://www.icrazyman.cn/tags/%E7%BC%96%E7%A0%81-%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
</feed>
