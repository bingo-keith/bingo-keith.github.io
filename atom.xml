<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>科瑞兹曼的博客</title>
  <icon>https://www.gravatar.com/avatar/affa8020d9d54afc774924f7f7fe256a</icon>
  <subtitle>专注于前端开发技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.icrazyman.cn/"/>
  <updated>2020-07-17T14:50:33.005Z</updated>
  <id>http://www.icrazyman.cn/</id>
  
  <author>
    <name>科瑞兹曼</name>
    <email>hg.wb.zheng@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>25个你不得不知道的数组reduce高级用法</title>
    <link href="http://www.icrazyman.cn/2020/07/17/25%E4%B8%AA%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E7%BB%84reduce%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://www.icrazyman.cn/2020/07/17/25个你不得不知道的数组reduce高级用法/</id>
    <published>2020-07-17T09:30:29.000Z</published>
    <updated>2020-07-17T14:50:33.005Z</updated>
    
    <content type="html"><![CDATA[<ol start="10"><li><p>原文地址：<a href="https://blog.csdn.net/JowayYoung/article/details/104293122" target="_blank" rel="noopener">25个你不得不知道的数组reduce高级用法</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>reduce</code>作为ES5新增的常规数组方法之一，对比<code>forEach</code>、<code>filter</code>和<code>map</code>，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。 </p></li></ol><p>下面对reduce的语法进行简单说明，详情可查看MDN的reduce()的相关说明。</p><ul><li><p>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</p></li><li><p>形式：array.reduce((t, v, i, a) =&gt; {}, initValue)</p></li><li><p>参数</p><ul><li>callback：回调函数(必选)</li><li>initValue：初始值(可选)</li></ul></li><li><p>回调函数的参数</p><ul><li>total(t)：累计器完成计算的返回值(必选)</li><li>value(v)：当前元素(必选)</li><li>index(i)：当前元素的索引(可选)</li><li>array(a)：当前元素所属的数组对象(可选)</li></ul></li><li><p>过程</p><ul><li>以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值</li><li>开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t</li><li>进入下一次循环，重复上述操作，直至数组最后一个元素</li><li>结束遍历，返回最终的t</li></ul><p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。下面举个简单的栗子，看看<code>reduce</code>的计算结果。 </p><pre><code class="js">const arr = [3, 5, 1, 4, 2];const a = arr.reduce((t, v) =&gt; t + v);// 等同于const b = arr.reduce((t, v) =&gt; t + v, 0);</code></pre><p> 代码不太明白没关系，贴一个<code>reduce</code>的作用动图应该就会明白了。 </p></li></ul><a id="more"></a><p> <img src="https://img-blog.csdnimg.cn/20200309234456121.gif" alt="reduce"> </p><p> <code>reduce</code>实质上是一个累计器函数，通过用户自定义的累计器对数组成员进行自定义累计，得出一个由累计器生成的值。另外<code>reduce</code>还有一个胞弟<code>reduceRight</code>，两个方法的功能其实是一样的，只不过<code>reduce</code>是升序执行，<code>reduceRight</code>是降序执行。 </p><pre><code class="js">对空数组调用reduce()和reduceRight()是不会执行其回调函数的，可认为reduce()对空数组无效</code></pre><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p> 单凭以上一个简单栗子不足以说明<code>reduce</code>是个什么。为了展示<code>reduce</code>的魅力，我为大家提供25种场景来应用<code>reduce</code>的高级用法。有部分高级用法可能需要结合其他方法来实现，这样为<code>reduce</code>的多元化提供了更多的可能性。 </p><pre><code class="js">部分示例代码的写法可能有些骚，看得不习惯可自行整理成自己的习惯写法</code></pre><h2 id="累加累乘"><a href="#累加累乘" class="headerlink" title="累加累乘"></a>累加累乘</h2><pre><code class="js">function Accumulation(...vals) {    return vals.reduce((t, v) =&gt; t + v, 0);}function Multiplication(...vals) {    return vals.reduce((t, v) =&gt; t * v, 1);}</code></pre><pre><code class="js">Accumulation(1, 2, 3, 4, 5); // 15Multiplication(1, 2, 3, 4, 5); // 120</code></pre><h2 id="权重求和"><a href="#权重求和" class="headerlink" title="权重求和"></a>权重求和</h2><pre><code class="js">const scores = [    { score: 90, subject: &quot;chinese&quot;, weight: 0.5 },    { score: 95, subject: &quot;math&quot;, weight: 0.3 },    { score: 85, subject: &quot;english&quot;, weight: 0.2 }];const result = scores.reduce((t, v) =&gt; t + v.score * v.weight, 0); // 90.5</code></pre><h2 id="代替reverse"><a href="#代替reverse" class="headerlink" title="代替reverse"></a>代替reverse</h2><pre><code class="js">function Reverse(arr = []) {    return arr.reduceRight((t, v) =&gt; (t.push(v), t), []);}</code></pre><pre><code class="js">Reverse([1, 2, 3, 4, 5]); // [5, 4, 3, 2, 1]</code></pre><h2 id="代替map和filter"><a href="#代替map和filter" class="headerlink" title="代替map和filter"></a>代替map和filter</h2><pre><code class="js">const arr = [0, 1, 2, 3];// 代替map：[0, 2, 4, 6]const a = arr.map(v =&gt; v * 2);const b = arr.reduce((t, v) =&gt; [...t, v * 2], []);// 代替filter：[2, 3]const c = arr.filter(v =&gt; v &gt; 1);const d = arr.reduce((t, v) =&gt; v &gt; 1 ? [...t, v] : t, []);// 代替map和filter：[4, 6]const e = arr.map(v =&gt; v * 2).filter(v =&gt; v &gt; 2);const f = arr.reduce((t, v) =&gt; v * 2 &gt; 2 ? [...t, v * 2] : t, []);</code></pre><h2 id="代替some和every"><a href="#代替some和every" class="headerlink" title="代替some和every"></a>代替some和every</h2><pre><code class="js">const scores = [    { score: 45, subject: &quot;chinese&quot; },    { score: 90, subject: &quot;math&quot; },    { score: 60, subject: &quot;english&quot; }];// 代替some：至少一门合格const isAtLeastOneQualified = scores.reduce((t, v) =&gt; t || v.score &gt;= 60, false); // true// 代替every：全部合格const isAllQualified = scores.reduce((t, v) =&gt; t &amp;&amp; v.score &gt;= 60, true); // false</code></pre><h2 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h2><pre><code class="js">function Chunk(arr = [], size = 1) {    return arr.length ? arr.reduce((t, v) =&gt; (t[t.length - 1].length === size ? t.push([v]) : t[t.length - 1].push(v), t), [[]]) : [];}</code></pre><pre><code class="js">const arr = [1, 2, 3, 4, 5];Chunk(arr, 2); // [[1, 2], [3, 4], [5]]</code></pre><h2 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h2><pre><code class="js">function Difference(arr = [], oarr = []) {    return arr.reduce((t, v) =&gt; (!oarr.includes(v) &amp;&amp; t.push(v), t), []);}</code></pre><pre><code class="js">const arr1 = [1, 2, 3, 4, 5];const arr2 = [2, 3, 6]Difference(arr1, arr2); // [1, 4, 5]</code></pre><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><pre><code class="js">function Fill(arr = [], val = &quot;&quot;, start = 0, end = arr.length) {    if (start &lt; 0 || start &gt;= end || end &gt; arr.length) return arr;    return [        ...arr.slice(0, start),        ...arr.slice(start, end).reduce((t, v) =&gt; (t.push(val || v), t), []),        ...arr.slice(end, arr.length)    ];}</code></pre><pre><code class="js">const arr = [0, 1, 2, 3, 4, 5, 6];Fill(arr, &quot;aaa&quot;, 2, 5); // [0, 1, &quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;, 5, 6]</code></pre><h2 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h2><pre><code class="js">function Flat(arr = []) {    return arr.reduce((t, v) =&gt; t.concat(Array.isArray(v) ? Flat(v) : v), [])}</code></pre><pre><code class="js">const arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];Flat(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code></pre><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code class="js">function Uniq(arr = []) {    return arr.reduce((t, v) =&gt; t.includes(v) ? t : [...t, v], []);}</code></pre><pre><code class="js">const arr = [2, 1, 0, 3, 2, 1, 2];Uniq(arr); // [2, 1, 0, 3]</code></pre><h2 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h2><pre><code class="js">function Max(arr = []) {    return arr.reduce((t, v) =&gt; t &gt; v ? t : v);}function Min(arr = []) {    return arr.reduce((t, v) =&gt; t &lt; v ? t : v);}</code></pre><pre><code class="js">const arr = [12, 45, 21, 65, 38, 76, 108, 43];Max(arr); // 108Min(arr); // 12</code></pre><h2 id="数组成员独立拆解"><a href="#数组成员独立拆解" class="headerlink" title="数组成员独立拆解"></a>数组成员独立拆解</h2><pre><code class="js">function Unzip(arr = []) {    return arr.reduce(        (t, v) =&gt; (v.forEach((w, i) =&gt; t[i].push(w)), t),        Array.from({ length: Math.max(...arr.map(v =&gt; v.length)) }).map(v =&gt; [])    );}</code></pre><pre><code class="js">const arr = [[&quot;a&quot;, 1, true], [&quot;b&quot;, 2, false]];Unzip(arr); // [[&quot;a&quot;, &quot;b&quot;], [1, 2], [true, false]]</code></pre><h2 id="数组成员个数统计"><a href="#数组成员个数统计" class="headerlink" title="数组成员个数统计"></a>数组成员个数统计</h2><pre><code class="js">function Count(arr = []) {    return arr.reduce((t, v) =&gt; (t[v] = (t[v] || 0) + 1, t), {});}</code></pre><pre><code class="js">const arr = [0, 1, 1, 2, 2, 2];Count(arr); // { 0: 1, 1: 2, 2: 3 }</code></pre><pre><code class="js">此方法是字符统计和单词统计的原理，入参时把字符串处理成数组即可</code></pre><h2 id="数组成员位置记录"><a href="#数组成员位置记录" class="headerlink" title="数组成员位置记录"></a>数组成员位置记录</h2><pre><code class="js">function Position(arr = [], val) {    return arr.reduce((t, v, i) =&gt; (v === val &amp;&amp; t.push(i), t), []);}</code></pre><pre><code class="js">const arr = [2, 1, 5, 4, 2, 1, 6, 6, 7];Position(arr, 2); // [0, 4]</code></pre><h2 id="数组成员特性分组"><a href="#数组成员特性分组" class="headerlink" title="数组成员特性分组"></a>数组成员特性分组</h2><pre><code class="js">function Group(arr = [], key) {    return key ? arr.reduce((t, v) =&gt; (!t[v[key]] &amp;&amp; (t[v[key]] = []), t[v[key]].push(v), t), {}) : {};}</code></pre><pre><code class="js">const arr = [    { area: &quot;GZ&quot;, name: &quot;YZW&quot;, age: 27 },    { area: &quot;GZ&quot;, name: &quot;TYJ&quot;, age: 25 },    { area: &quot;SZ&quot;, name: &quot;AAA&quot;, age: 23 },    { area: &quot;FS&quot;, name: &quot;BBB&quot;, age: 21 },    { area: &quot;SZ&quot;, name: &quot;CCC&quot;, age: 19 }]; // 以地区area作为分组依据Group(arr, &quot;area&quot;); // { GZ: Array(2), SZ: Array(2), FS: Array(1) }</code></pre><h2 id="数组成员所含关键字统计"><a href="#数组成员所含关键字统计" class="headerlink" title="数组成员所含关键字统计"></a>数组成员所含关键字统计</h2><pre><code class="js">function Keyword(arr = [], keys = []) {    return keys.reduce((t, v) =&gt; (arr.some(w =&gt; w.includes(v)) &amp;&amp; t.push(v), t), []);}</code></pre><pre><code class="js">const text = [    &quot;今天天气真好，我想出去钓鱼&quot;,    &quot;我一边看电视，一边写作业&quot;,    &quot;小明喜欢同桌的小红，又喜欢后桌的小君，真TM花心&quot;,    &quot;最近上班喜欢摸鱼的人实在太多了，代码不好好写，在想入非非&quot;];const keyword = [&quot;偷懒&quot;, &quot;喜欢&quot;, &quot;睡觉&quot;, &quot;摸鱼&quot;, &quot;真好&quot;, &quot;一边&quot;, &quot;明天&quot;];Keyword(text, keyword); // [&quot;喜欢&quot;, &quot;摸鱼&quot;, &quot;真好&quot;, &quot;一边&quot;]</code></pre><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><pre><code class="js">function ReverseStr(str = &quot;&quot;) {    return str.split(&quot;&quot;).reduceRight((t, v) =&gt; t + v);}</code></pre><pre><code class="js">const str = &quot;reduce最牛逼&quot;;ReverseStr(str); // &quot;逼牛最ecuder&quot;</code></pre><h2 id="数字千分化"><a href="#数字千分化" class="headerlink" title="数字千分化"></a>数字千分化</h2><pre><code class="js">function ThousandNum(num = 0) {    const str = (+num).toString().split(&quot;.&quot;);    const int = nums =&gt; nums.split(&quot;&quot;).reverse().reduceRight((t, v, i) =&gt; t + (i % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;);    const dec = nums =&gt; nums.split(&quot;&quot;).reduce((t, v, i) =&gt; t + ((i + 1) % 3 ? v : `${v},`), &quot;&quot;).replace(/^,|,$/g, &quot;&quot;);    return str.length &gt; 1 ? `${int(str[0])}.${dec(str[1])}` : int(str[0]);}</code></pre><pre><code class="js">ThousandNum(1234); // &quot;1,234&quot;ThousandNum(1234.00); // &quot;1,234&quot;ThousandNum(0.1234); // &quot;0.123,4&quot;ThousandNum(1234.5678); // &quot;1,234.567,8&quot;</code></pre><h2 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h2><pre><code class="js">async function AsyncTotal(arr = []) {    return arr.reduce(async(t, v) =&gt; {        const at = await t;        const todo = await Todo(v);        at[v] = todo;        return at;    }, Promise.resolve({}));}</code></pre><pre><code class="js">const result = await AsyncTotal(); // 需要在async包围下使用</code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code class="js">function Fibonacci(len = 2) {    const arr = [...new Array(len).keys()];    return arr.reduce((t, v, i) =&gt; (i &gt; 1 &amp;&amp; t.push(t[i - 1] + t[i - 2]), t), [0, 1]);}</code></pre><pre><code class="js">Fibonacci(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre><h2 id="URL参数反序列化"><a href="#URL参数反序列化" class="headerlink" title="URL参数反序列化"></a>URL参数反序列化</h2><pre><code class="js">function ParseUrlSearch() {    return location.search.replace(/(^\?)|(&amp;$)/g, &quot;&quot;).split(&quot;&amp;&quot;).reduce((t, v) =&gt; {        const [key, val] = v.split(&quot;=&quot;);        t[key] = decodeURIComponent(val);        return t;    }, {});}</code></pre><pre><code class="js">// 假设URL为：https://www.baidu.com?age=25&amp;name=TYJParseUrlSearch(); // { age: &quot;25&quot;, name: &quot;TYJ&quot; }</code></pre><h2 id="URL参数序列化"><a href="#URL参数序列化" class="headerlink" title="URL参数序列化"></a>URL参数序列化</h2><pre><code class="js">function StringifyUrlSearch(search = {}) {    return Object.entries(search).reduce(        (t, v) =&gt; `${t}${v[0]}=${encodeURIComponent(v[1])}&amp;`,        Object.keys(search).length ? &quot;?&quot; : &quot;&quot;    ).replace(/&amp;$/, &quot;&quot;);}</code></pre><pre><code class="js">StringifyUrlSearch({ age: 27, name: &quot;YZW&quot; }); // &quot;?age=27&amp;name=YZW&quot;</code></pre><h2 id="返回对象指定键值"><a href="#返回对象指定键值" class="headerlink" title="返回对象指定键值"></a>返回对象指定键值</h2><pre><code class="js">function GetKeys(obj = {}, keys = []) {    return Object.keys(obj).reduce((t, v) =&gt; (keys.includes(v) &amp;&amp; (t[v] = obj[v]), t), {});}</code></pre><pre><code class="js">const target = { a: 1, b: 2, c: 3, d: 4 };const keyword = [&quot;a&quot;, &quot;d&quot;];GetKeys(target, keyword); // { a: 1, d: 4 }</code></pre><h2 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h2><pre><code class="js">const people = [    { area: &quot;GZ&quot;, name: &quot;YZW&quot;, age: 27 },    { area: &quot;SZ&quot;, name: &quot;TYJ&quot;, age: 25 }];const map = people.reduce((t, v) =&gt; {    const { name, ...rest } = v;    t[name] = rest;    return t;}, {}); // { YZW: {…}, TYJ: {…} }</code></pre><h2 id="Redux-Compose函数原理"><a href="#Redux-Compose函数原理" class="headerlink" title="Redux Compose函数原理"></a>Redux Compose函数原理</h2><pre><code class="js">function Compose(...funs) {    if (funs.length === 0) {        return arg =&gt; arg;    }    if (funs.length === 1) {        return funs[0];    }    return funs.reduce((t, v) =&gt; (...arg) =&gt; t(v(...arg)));}</code></pre><h1 id="兼容和性能"><a href="#兼容和性能" class="headerlink" title="兼容和性能"></a>兼容和性能</h1><p> 好用是挺好用的，但是兼容性如何呢？在<a href="https://caniuse.com/#search=reduce" target="_blank" rel="noopener">Caniuse</a>上搜索一番，兼容性绝对的好，可大胆在任何项目上使用。不要吝啬你的想象力，尽情发挥<code>reduce</code>的<code>compose</code>技能啦。对于时常做一些累计的功能，<code>reduce</code>绝对是首选方法。 </p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZS5wbmc?x-oss-process=image/format,png" alt="caniuse-reduce">  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZVJpZ2h0LnBuZw?x-oss-process=image/format,png" alt="caniuse-reduceRight"></p><p> 另外，有些同学可能会问，<code>reduce</code>的性能又如何呢？下面我们通过对<code>for</code>、<code>forEach</code>、<code>map</code>和<code>reduce</code>四个方法同时做<code>1~100000</code>的累加操作，看看四个方法各自的执行时间。 </p><pre><code class="js">// 创建一个长度为100000的数组const list = [...new Array(100000).keys()];// forconsole.time(&quot;for&quot;);let result1 = 0;for (let i = 0; i &lt; list.length; i++) {    result1 += i + 1;}console.log(result1);console.timeEnd(&quot;for&quot;);// forEachconsole.time(&quot;forEach&quot;);let result2 = 0;list.forEach(v =&gt; (result2 += v + 1));console.log(result2);console.timeEnd(&quot;forEach&quot;);// mapconsole.time(&quot;map&quot;);let result3 = 0;list.map(v =&gt; (result3 += v + 1, v));console.log(result3);console.timeEnd(&quot;map&quot;);// reduceconsole.time(&quot;reduce&quot;);const result4 = list.reduce((t, v) =&gt; t + v + 1, 0);console.log(result4);console.timeEnd(&quot;reduce&quot;);</code></pre><table><thead><tr><th>累加操作</th><th>执行时间</th></tr></thead><tbody><tr><td><strong>for</strong></td><td><code>6.719970703125ms</code></td></tr><tr><td><strong>forEach</strong></td><td><code>3.696044921875ms</code></td></tr><tr><td><strong>map</strong></td><td><code>3.554931640625ms</code></td></tr><tr><td><strong>reduce</strong></td><td><code>2.806884765625ms</code></td></tr></tbody></table><p>以上代码在MacBook Pro 2019 15寸 16G内存 512G闪存的Chrome 79下执行，不同的机器不同的环境下执行以上代码都有可能存在差异。</p><p>我已同时测试过多台机器和多个浏览器，连续做了10次以上操作，发现reduce总体的平均执行时间还是会比其他三个方法稍微快一点，所以大家还是放心使用啦！本文更多是探讨reduce的使用技巧，如对reduce的兼容和性能存在疑问，可自行参考相关资料进行验证。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UteC5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UtMS5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://blog.csdn.net/JowayYoung/article/details/104293122&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;25个你不得不知道的数组reduce高级用法&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt;作为ES5新增的常规数组方法之一，对比&lt;code&gt;forEach&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面对reduce的语法进行简单说明，详情可查看MDN的reduce()的相关说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;形式：array.reduce((t, v, i, a) =&amp;gt; {}, initValue)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callback：回调函数(必选)&lt;/li&gt;
&lt;li&gt;initValue：初始值(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回调函数的参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;total(t)：累计器完成计算的返回值(必选)&lt;/li&gt;
&lt;li&gt;value(v)：当前元素(必选)&lt;/li&gt;
&lt;li&gt;index(i)：当前元素的索引(可选)&lt;/li&gt;
&lt;li&gt;array(a)：当前元素所属的数组对象(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值&lt;/li&gt;
&lt;li&gt;开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t&lt;/li&gt;
&lt;li&gt;进入下一次循环，重复上述操作，直至数组最后一个元素&lt;/li&gt;
&lt;li&gt;结束遍历，返回最终的t&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt;的精华所在是将累计器逐个作用于数组成员上，&lt;strong&gt;把上一次输出的值作为下一次输入的值&lt;/strong&gt;。下面举个简单的栗子，看看&lt;code&gt;reduce&lt;/code&gt;的计算结果。 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const arr = [3, 5, 1, 4, 2];
const a = arr.reduce((t, v) =&amp;gt; t + v);
// 等同于
const b = arr.reduce((t, v) =&amp;gt; t + v, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 代码不太明白没关系，贴一个&lt;code&gt;reduce&lt;/code&gt;的作用动图应该就会明白了。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码  技巧 reduce" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E6%8A%80%E5%B7%A7-reduce/"/>
    
  </entry>
  
  <entry>
    <title>如何使用JavaScript访问设备摄像头（前后）</title>
    <link href="http://www.icrazyman.cn/2020/06/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JavaScript%E8%AE%BF%E9%97%AE%E8%AE%BE%E5%A4%87%E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%88%E5%89%8D%E5%90%8E%EF%BC%89/"/>
    <id>http://www.icrazyman.cn/2020/06/09/如何使用JavaScript访问设备摄像头（前后）/</id>
    <published>2020-06-09T01:08:20.000Z</published>
    <updated>2020-06-09T01:21:14.563Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将向您展示如何通过JavaScript在网页上访问设备的摄像头，并支持多种浏览器，而无需外部库。</p><a id="more"></a><h1 id="如何使用相机API"><a href="#如何使用相机API" class="headerlink" title="如何使用相机API"></a>如何使用相机API</h1><p>要访问用户的相机（或麦克风），我们使用JavaScript <strong>MediaStream API</strong>。该API允许通过流访问这些设备捕获的视频和音频。</p><p>第一步是检查浏览器是否支持此API：</p><pre><code class="js">if (  &quot;mediaDevices&quot; in navigator &amp;&amp;  &quot;getUserMedia&quot; in navigator.mediaDevices) {  // ok, 浏览器支持它}</code></pre><p>在现代浏览器中，支持是不错的（当然没有Internet Explorer）。</p><h2 id="捕获视频流"><a href="#捕获视频流" class="headerlink" title="捕获视频流"></a>捕获视频流</h2><p>要捕获由摄像机生成的视频流，我们使用 <code>mediaDevices</code> 对象的 <code>getUserMedia</code> 方法。这个方法接收一个对象，其中包含我们要请求的媒体类型（视频或音频）和一些要求。首先，我们可以通过 <code>{video: true}</code> 来获取摄像机的视频。</p><pre><code class="js">const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });</code></pre><p>此调用将询问用户是否允许访问摄像机。如果用户拒绝，它将引发异常并且不返回流。因此，必须在 <code>try/catch</code> 块内完成处理这种情况。</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/2.png" alt=""></p><p>请注意，它返回一个Promise，因此您必须使用 <code>async/await</code> 或 <code>then</code> 块。在Mac OS系统上还会弹出授权</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/3.png" alt=""></p><p>点击“好”，就可以访问电脑摄像头了，控制台输出的 <code>videoStream</code> 对象如下</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/4.png" alt=""></p><h2 id="视频规格（requirements）"><a href="#视频规格（requirements）" class="headerlink" title="视频规格（requirements）"></a>视频规格（requirements）</h2><p>我们可以通过传递有关所需分辨率以及最小和最大限制的信息来改善视频的要求：</p><pre><code class="js">const constraints = {  video: {    width: {      min: 1280,      ideal: 1920,      max: 2560,    },    height: {      min: 720,      ideal: 1080,      max: 1440,    },  },};const videoStream = await navigator.mediaDevices.getUserMedia(constraints);</code></pre><p>这样，流以正确的宽度和高度比例进入，如果它是处于纵向模式的手机，则需要进行尺寸反转。</p><h2 id="在页面上显示视频"><a href="#在页面上显示视频" class="headerlink" title="在页面上显示视频"></a>在页面上显示视频</h2><p>既然有了流，我们该如何处理？</p><p>我们可以在页面上的 <code>video</code> 元素中显示视频：</p><pre><code class="js">// 页面中有一个 &lt;video autoplay id=&quot;video&quot;&gt;&lt;/video&gt; 标签const video = document.querySelector(&quot;#video&quot;);const videoStream = await navigator.mediaDevices.getUserMedia(constraints);video.srcObject = videoStream;</code></pre><p>请注意 <code>video</code> 标签中的自动播放属性 <code>autoplay</code>，没有它，你需要调用 <code>video.play()</code> 才能真正开始显示图像。</p><p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/5.png" alt=""></p><h2 id="访问手机的前后摄像头"><a href="#访问手机的前后摄像头" class="headerlink" title="访问手机的前后摄像头"></a>访问手机的前后摄像头</h2><p>默认情况下，<code>getUserMedia</code> 将使用系统默认的视频录制设备。如果是有两个摄像头的手机，它使用前置摄像头。</p><p>要访问后置摄像头，我们必须在视频规格中包括 <code>faceModeMode:&quot;environment&quot;</code>：</p><pre><code class="js">const constraints = {  video: {    width: { ... },    height: { ... },    facingMode: &quot;environment&quot;  },};</code></pre><p>默认值为 <code>faceingMode:&quot;user&quot;</code>，即前置摄像头。</p><p>需要注意的是，如果你想在已经播放视频的情况下更换摄像机，你需要先停止当前的视频流，然后再将其替换成另一台摄像机的视频流。</p><pre><code class="js">videoStream.getTracks().forEach((track) =&gt; {  track.stop();});</code></pre><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><p>你可以做的另一件很酷的事情是捕获视频的图像（屏幕快照）。</p><p>你可以在canvas上绘制当前视频帧，例如：</p><pre><code class="js">// 页面中有一个 &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 标签const canvas = document.querySelector(&quot;#canvas&quot;);canvas.width = video.videoWidth;canvas.height = video.videoHeight;canvas.getContext(&quot;2d&quot;).drawImage(video, 0, 0);</code></pre><p>你还可以在 <code>img</code> 元素中显示画布内容。</p><p>在本教程创建的示例中，我添加了一个按钮，该按钮可从画布动态创建图像并将其添加到页面：</p><pre><code class="js">const img = document.createElement(&quot;img&quot;);img.src = canvas.toDataURL(&quot;image/png&quot;);screenshotsContainer.prepend(img);</code></pre><h2 id="完整示例和代码"><a href="#完整示例和代码" class="headerlink" title="完整示例和代码"></a>完整示例和代码</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;摄像头&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        #video {          width: 100%;        }        .is-hidden {          display: none;        }        .btns {          margin-bottom: 10px;        }        button {          font-size: 22px;          padding: 8px 10px;          border: 2px solid #ccc;          border-radius: 10px;        }        .video-screenshot {          display: grid;          grid-template-columns: 1fr 1fr;          grid-column-gap: 10px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;如何使用JavaScript访问设备摄像头（前后）&lt;/h1&gt;&lt;div class=&quot;btns&quot;&gt;  &lt;button class=&quot;button is-hidden&quot; id=&quot;btnPlay&quot;&gt;    播放  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnPause&quot;&gt;    暂停  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnScreenshot&quot;&gt;    截屏  &lt;/button&gt;  &lt;button class=&quot;button&quot; id=&quot;btnChangeCamera&quot; style=&quot;padding: 6px 10px;&quot;&gt;    切换摄像头  &lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;video-screenshot&quot;&gt;  &lt;video autoplay id=&quot;video&quot;&gt;&lt;/video&gt;  &lt;div&gt;    &lt;div id=&quot;screenshotsContainer&quot;&gt;      &lt;canvas id=&quot;canvas&quot; class=&quot;is-hidden&quot;&gt;&lt;/canvas&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// https://segmentfault.com/a/1190000022867561window.onload = async function () {  if (    !&quot;mediaDevices&quot; in navigator ||    !&quot;getUserMedia&quot; in navigator.mediaDevices  ) {    document.write(&#39;当前浏览器不支持Camera API，请更新浏览器。&#39;)    return;  }  const video = document.querySelector(&quot;#video&quot;);  const canvas = document.querySelector(&quot;#canvas&quot;);  const screenshotsContainer = document.querySelector(&quot;#screenshotsContainer&quot;);  let videoStream = null  let useFrontCamera = true; // 前置摄像头  const constraints = {    video: {      width: {        min: 1280,        ideal: 1920,        max: 2560,      },      height: {        min: 720,        ideal: 1080,        max: 1440,      }    },  };  // play  btnPlay.addEventListener(&quot;click&quot;, function () {    video.play();    btnPlay.classList.add(&quot;is-hidden&quot;);    btnPause.classList.remove(&quot;is-hidden&quot;);  });  // pause  btnPause.addEventListener(&quot;click&quot;, function () {    video.pause();    btnPause.classList.add(&quot;is-hidden&quot;);    btnPlay.classList.remove(&quot;is-hidden&quot;);  });  // 切换摄像头  btnChangeCamera.addEventListener(&quot;click&quot;, function () {    useFrontCamera = !useFrontCamera;    init();  });  // 停止视频流  function stopVideoStream() {    if (videoStream) {      videoStream.getTracks().forEach((track) =&gt; {        track.stop();      });    }  }  // 截图  btnScreenshot.addEventListener(&quot;click&quot;, function () {    let img = document.getElementById(&#39;screenshot&#39;);    if (!img) {      img = document.createElement(&quot;img&quot;);      img.id = &#39;screenshot&#39;;      img.style.width = &#39;100%&#39;;    }    canvas.width = video.videoWidth;    canvas.height = video.videoHeight;    canvas.getContext(&quot;2d&quot;).drawImage(video, 0, 0);    img.src = canvas.toDataURL(&quot;image/png&quot;);    screenshotsContainer.prepend(img);  });  async function init() {    stopVideoStream();    constraints.video.facingMode = useFrontCamera ? &quot;user&quot; : &quot;environment&quot;;    try {      videoStream = await navigator.mediaDevices.getUserMedia(constraints);      video.srcObject = videoStream;    } catch (error) {      console.log(error)    }  }  init();}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将向您展示如何通过JavaScript在网页上访问设备的摄像头，并支持多种浏览器，而无需外部库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端 javascript" scheme="http://www.icrazyman.cn/tags/%E5%89%8D%E7%AB%AF-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发标准规范</title>
    <link href="http://www.icrazyman.cn/2020/04/08/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/"/>
    <id>http://www.icrazyman.cn/2020/04/08/Web前端开发标准规范/</id>
    <published>2020-04-08T06:28:20.000Z</published>
    <updated>2020-04-09T12:19:40.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2></li><li><h2 id="HTML代码规范"><a href="#HTML代码规范" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h2></li><li><h2 id="CSS和SCSS代码规范"><a href="#CSS和SCSS代码规范" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h2></li><li><h2 id="JavaScript代码规范"><a href="#JavaScript代码规范" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h2></li><li><h2 id="jQuery代码规范"><a href="#jQuery代码规范" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h2></li><li><h2 id="vue代码规范"><a href="#vue代码规范" class="headerlink" title="vue代码规范"></a>vue代码规范</h2></li></ul><a id="more"></a><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://tgideas.qq.com/doc/frontend/" target="_blank" rel="noopener">腾讯前端开发规范</a></li><li><a href="http://alloyteam.github.io/CodeGuide/#project-naming" target="_blank" rel="noopener">通过分析github代码库总结出来的工程师代码书写习惯</a></li><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">JavaScript Standard Style</a>。</li><li><a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue官网风格指南</a></li></ol><h1 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h2><ul><li>全部采用小写方式， 以下划线分隔；</li><li>有明显分类的，使用语义化的命名，无明确意义的，可用page01.html；</li><li>禁止使用特殊字符。</li></ul><pre><code class="js">例：my_project_name</code></pre><h2 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h2><ul><li>参照项目命名规则；</li><li>有复数结构时，要采用复数命名法；</li><li>图片文件夹：img；</li><li>css文件夹：css；</li><li>js文件夹：js；</li><li>include页面片段文件夹：inc。</li></ul><pre><code class="js">例：scripts, styles, images, data_models</code></pre><h2 id="JS文件命名"><a href="#JS文件命名" class="headerlink" title="JS文件命名"></a>JS文件命名</h2><ul><li>参照项目命名规则 。</li></ul><pre><code class="js">例：account_model.js</code></pre><h2 id="CSS-SCSS文件命名"><a href="#CSS-SCSS文件命名" class="headerlink" title="CSS, SCSS文件命名"></a>CSS, SCSS文件命名</h2><ul><li>参照项目命名规则。</li></ul><pre><code class="js">例：retina_sprites.scss</code></pre><h2 id="HTML文件命名"><a href="#HTML文件命名" class="headerlink" title="HTML文件命名"></a>HTML文件命名</h2><ul><li>参照项目命名规则。</li></ul><pre><code class="js">例：error_report.html</code></pre><hr><h1 id="HTML代码规范-1"><a href="#HTML代码规范-1" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h1><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul><li><code>doctype</code>声明使用<code>html5</code> ；</li><li>在html标签上加上lang属性，更多关于 <code>lang</code> 属性的说明<a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element" target="_blank" rel="noopener">在这里</a>，在sitepoint上可以查到<a href="http://reference.sitepoint.com/html/lang-codes" target="_blank" rel="noopener">语言列表</a>；</li><li>缩进使用soft tab（4个空格），嵌套的节点应该缩进；</li><li>清晰、简介的层级嵌套结构，保证嵌套层级最少；</li><li>在属性上，使用双引号，不要使用单引号；</li><li>标签、标签属性全部小写，用中划线做分隔符；</li><li>在无法用标签表明语义的场景下增加适当的注释；</li><li>所有html标签必须有结束符，<code>&lt;img /&gt;</code>, <code>&lt;col /&gt;</code>, <code>&lt;base /&gt;</code>, <code>&lt;link /&gt;</code>, <code>&lt;meta /&gt;</code>,<code>&lt;input /&gt;</code> 除外；</li><li>标签语法无错误，需要符合语义化；</li><li>较长的HTML文件，请在板块之间加入注释，使得结构更清晰，也更利于后期维护；</li><li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式 ；</li><li>统一页面编码格式为<code>utf-8</code> , <code>meta</code>标签<code>charset</code>设置为<code>utf-8</code>;</li><li>给 <code>&lt;a&gt;</code> 标签加上title属性；</li><li><code>&lt;a&gt;</code>标签的href属性必须写上链接地址，暂无的加上<code>javascript:alert(&#39;敬请期待！&#39;)</code>；</li><li>非本专题的页面间跳转，采用打开新窗口模式：<code>target=&quot;_blank&quot;</code>，同时为了避免<a href="https://blog.csdn.net/chinashanzhang/article/details/88537581" target="_blank" rel="noopener">安全问题</a>加上<code>rel=&quot;noopener&quot;</code>；</li><li>标签自定义属性使用<code>data-name=&quot;value&quot;</code>的形式来写, 如果自定义属性特别多, 可以考虑使用标准 json 的方式去写:<code>data-json=&#39;{&quot;a&quot;:&quot;a&quot;, &quot;b&quot;:&quot;b&quot;}&#39;</code>；</li><li>css 引用置于头部<code>&lt;head&gt;</code>标签内；</li><li>js 引用置于底部<code>&lt;/body&gt;</code>标签前；</li><li><code>img</code>标签必须加<code>alt</code>，尤其是logo、商品图片等关键图片信息，对SEO友好 ；</li><li>不要忽略可选的关闭标签，例：</li> 和 。</ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;Page title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;img src=&quot;images/company_logo.png&quot; alt=&quot;Company&quot;&gt;        &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt;        &lt;!-- 活动板块 开始 --&gt;        &lt;div class=&quot;part-act&quot;&gt;            &lt;img/&gt;            ...        &lt;/div&gt;        &lt;!-- 活动板块 结束 --&gt;    &lt;/body&gt;&lt;/html&gt; </code></pre><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul><li>兼容IE11及以上、Firefox、chrome、QQ浏览器；</li><li>页面如无指定，不需要兼容IE6、7、8、9、10；</li><li>不兼容IE6、7、8、9、10的情况下，需要在页面顶部加入提示，并对.browser-tips使用醒目的颜色标识样式。</li></ul><h2 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h2><ul><li>class、id都需小写，首字符必须是字母，禁止数字或其他特殊字符。由以字母开头的小写 字母<code>（a-z）</code>、数字<code>（0-9）</code>、中划线 <code>（-）</code>组成；</li><li>可以是单个单词，也可以是组合单词，要求能够描述清楚模块和元素的含义，使其具有语义化；</li><li>双单词或多单词组合方式：<code>命名空间-模块-元素-修饰</code>，如：<code>wb-demo-header-title</code>；</li><li>样式名不能包含<code>ad</code>、ads、adv、banner、sponsor、guanggao<code>、</code>ads<code>、</code>gg`是广告含义的关键词，避免元素被网页拓展、插件屏蔽；</li><li>涉及数据、交互等需要联调的部分，禁止通过id选择器定义样式，以免开发过程中id名变化，引起页局错乱；</li><li>除非是样式reset需要，禁止对纯元素选择器设置特定样式，避免样式污染；</li><li>自己写的z-index的值不能超过100（通用组件除外），元素内容不能超过10，弹层提示在10-99之间，不允许直接使用1000-9999之类大值；</li><li>命名词穷了怎么办？试下这个工具：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">codelf</a>。</li></ul><h2 id="通用命名"><a href="#通用命名" class="headerlink" title="通用命名"></a>通用命名</h2><h3 id="页面框架命名，一般具有唯一性，推荐用ID命名"><a href="#页面框架命名，一般具有唯一性，推荐用ID命名" class="headerlink" title="页面框架命名，一般具有唯一性，推荐用ID命名"></a>页面框架命名，一般具有唯一性，推荐用ID命名</h3><table><thead><tr><th style="text-align:left">ID名称</th><th style="text-align:left">命名</th><th style="text-align:left">ID名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">头部</td><td style="text-align:left">header</td><td style="text-align:left">主体</td><td style="text-align:left">main</td></tr><tr><td style="text-align:left">脚部</td><td style="text-align:left">footer</td><td style="text-align:left">容器</td><td style="text-align:left">wrapper</td></tr><tr><td style="text-align:left">侧栏</td><td style="text-align:left">sidebar</td><td style="text-align:left">栏目</td><td style="text-align:left">column</td></tr><tr><td style="text-align:left">布局</td><td style="text-align:left">layout</td><td style="text-align:left"></td></tr></tbody></table><h3 id="模块结构命名"><a href="#模块结构命名" class="headerlink" title="模块结构命名"></a>模块结构命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">模块(如：新闻模块)</td><td style="text-align:left">mod (mod-news)</td><td style="text-align:left">标题栏</td><td style="text-align:left">title</td></tr><tr><td style="text-align:left">内容</td><td style="text-align:left">content</td><td style="text-align:left">次级内容</td><td style="text-align:left">sub-content</td></tr></tbody></table><h3 id="导航结构命名"><a href="#导航结构命名" class="headerlink" title="导航结构命名"></a>导航结构命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">导航</td><td style="text-align:left">nav</td><td style="text-align:left">主导航</td><td style="text-align:left">main-nav</td></tr><tr><td style="text-align:left">子导航</td><td style="text-align:left">sub-nav</td><td style="text-align:left">顶部导航</td><td style="text-align:left">top-nav</td></tr><tr><td style="text-align:left">菜单</td><td style="text-align:left">menu</td><td style="text-align:left">子菜单</td><td style="text-align:left">sub-menu</td></tr></tbody></table><h3 id="一般元素命名"><a href="#一般元素命名" class="headerlink" title="一般元素命名"></a>一般元素命名</h3><table><thead><tr><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th><th style="text-align:left">Class名称</th><th style="text-align:left">命名</th></tr></thead><tbody><tr><td style="text-align:left">二级</td><td style="text-align:left">sub</td><td style="text-align:left">面包屑</td><td style="text-align:left">breadcrumb</td></tr><tr><td style="text-align:left">标志</td><td style="text-align:left">logo</td><td style="text-align:left">广告</td><td style="text-align:left">bner(禁用banner或ad)</td></tr><tr><td style="text-align:left">登陆</td><td style="text-align:left">login</td><td style="text-align:left">注册</td><td style="text-align:left">register/reg</td></tr><tr><td style="text-align:left">搜索</td><td style="text-align:left">search</td><td style="text-align:left">加入</td><td style="text-align:left">join</td></tr><tr><td style="text-align:left">状态</td><td style="text-align:left">status</td><td style="text-align:left">按钮</td><td style="text-align:left">btn</td></tr><tr><td style="text-align:left">滚动</td><td style="text-align:left">scroll</td><td style="text-align:left">标签页</td><td style="text-align:left">tab</td></tr><tr><td style="text-align:left">文章列表</td><td style="text-align:left">list</td><td style="text-align:left">短消息</td><td style="text-align:left">msg/message</td></tr><tr><td style="text-align:left">当前的</td><td style="text-align:left">current</td><td style="text-align:left">提示小技巧</td><td style="text-align:left">tips</td></tr><tr><td style="text-align:left">图标</td><td style="text-align:left">icon</td><td style="text-align:left">注释</td><td style="text-align:left">note</td></tr><tr><td style="text-align:left">指南</td><td style="text-align:left">guide</td><td style="text-align:left">服务</td><td style="text-align:left">service</td></tr><tr><td style="text-align:left">热点</td><td style="text-align:left">hot</td><td style="text-align:left">新闻</td><td style="text-align:left">news</td></tr><tr><td style="text-align:left">下载</td><td style="text-align:left">download</td><td style="text-align:left">投票</td><td style="text-align:left">vote</td></tr><tr><td style="text-align:left">合作伙伴</td><td style="text-align:left">partner</td><td style="text-align:left">友情链接</td><td style="text-align:left">link</td></tr><tr><td style="text-align:left">版权</td><td style="text-align:left">copyright</td><td style="text-align:left">演示</td><td style="text-align:left">demo</td></tr><tr><td style="text-align:left">下拉框</td><td style="text-align:left">select</td><td style="text-align:left">摘要</td><td style="text-align:left">summary</td></tr><tr><td style="text-align:left">翻页</td><td style="text-align:left">pages</td><td style="text-align:left">主题风格</td><td style="text-align:left">themes</td></tr><tr><td style="text-align:left">设置</td><td style="text-align:left">set</td><td style="text-align:left">成功</td><td style="text-align:left">suc</td></tr><tr><td style="text-align:left">按钮</td><td style="text-align:left">btn</td><td style="text-align:left">文本</td><td style="text-align:left">txt</td></tr><tr><td style="text-align:left">颜色</td><td style="text-align:left">color/c</td><td style="text-align:left">背景</td><td style="text-align:left">bg</td></tr><tr><td style="text-align:left">边框</td><td style="text-align:left">border/bor</td><td style="text-align:left">居中</td><td style="text-align:left">center</td></tr><tr><td style="text-align:left">上</td><td style="text-align:left">top/t</td><td style="text-align:left">下</td><td style="text-align:left">bottom/b</td></tr><tr><td style="text-align:left">左</td><td style="text-align:left">left/l</td><td style="text-align:left">右</td><td style="text-align:left">right/r</td></tr><tr><td style="text-align:left">添加</td><td style="text-align:left">add</td><td style="text-align:left">删除</td><td style="text-align:left">del</td></tr><tr><td style="text-align:left">间隔</td><td style="text-align:left">sp</td><td style="text-align:left">段落</td><td style="text-align:left">p</td></tr><tr><td style="text-align:left">弹出层</td><td style="text-align:left">pop</td><td style="text-align:left">公共</td><td style="text-align:left">global/gb</td></tr><tr><td style="text-align:left">操作</td><td style="text-align:left">op</td><td style="text-align:left">密码</td><td style="text-align:left">pwd</td></tr><tr><td style="text-align:left">透明</td><td style="text-align:left">tran</td><td style="text-align:left">信息</td><td style="text-align:left">info</td></tr><tr><td style="text-align:left">重点</td><td style="text-align:left">hit</td><td style="text-align:left">预览</td><td style="text-align:left">pvw</td></tr><tr><td style="text-align:left">单行输入框</td><td style="text-align:left">input</td><td style="text-align:left">首页</td><td style="text-align:left">index</td></tr><tr><td style="text-align:left">日志</td><td style="text-align:left">blog</td><td style="text-align:left">相册</td><td style="text-align:left">photo</td></tr><tr><td style="text-align:left">留言板</td><td style="text-align:left">guestbook</td><td style="text-align:left">用户</td><td style="text-align:left">user</td></tr><tr><td style="text-align:left">确认</td><td style="text-align:left">confirm</td><td style="text-align:left">取消</td><td style="text-align:left">cancel</td></tr><tr><td style="text-align:left">报错</td><td style="text-align:left">error</td><td style="text-align:left"></td></tr></tbody></table><h2 id="引入CSS-JS"><a href="#引入CSS-JS" class="headerlink" title="引入CSS, JS"></a>引入CSS, JS</h2><blockquote><p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 <code>type</code>，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是他们的默认值。 </p></blockquote><h3 id="HTML5-规范链接"><a href="#HTML5-规范链接" class="headerlink" title="HTML5 规范链接"></a>HTML5 规范链接</h3><ul><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element" target="_blank" rel="noopener">使用link</a></li><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element" target="_blank" rel="noopener">使用style</a></li><li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element" target="_blank" rel="noopener">使用script</a></li></ul><pre><code class="javascript">&lt;!-- 外联样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;reset.css&quot;&gt;&lt;!-- 内联样式 --&gt;&lt;style&gt;    ...&lt;/style&gt;&lt;!-- 外部JS --&gt;&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;!-- 内部JS --&gt;&lt;script&gt;    ...&lt;/script&gt;</code></pre><h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><blockquote><p>属性应该按照特定的顺序出现以保证易读性。</p></blockquote><ul><li><code>id</code></li><li><code>class</code></li><li><code>name</code></li><li><code>data-*</code></li><li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code> , <code>max-length</code>, <code>max</code>, <code>min</code>, <code>pattern</code></li><li><code>placeholder</code>, <code>title</code>, <code>alt</code></li><li><code>aria-*</code>, <code>role</code></li><li><code>required</code></li></ul><blockquote><p>id更加具体且应该尽量少使用，它与JS代码息息相关，所以将它放在第一位；class是为高可复用组件设计的，所以将它放在id后面（第一/二位）。</p></blockquote><pre><code class="html">&lt;a id=&quot;...&quot; class=&quot;...&quot; data-modal=&quot;toggle&quot; href=&quot;#&quot;&gt;Example link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code></pre><h2 id="boolean属性"><a href="#boolean属性" class="headerlink" title="boolean属性"></a>boolean属性</h2><blockquote><p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p></blockquote><blockquote><p>更多内容可以参考 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes" target="_blank" rel="noopener">WhatWG section on boolean attributes</a>：</p></blockquote><blockquote><p><em>boolean属性的存在表示取值为true，不存在则表示取值为false。</em></p></blockquote><pre><code class="html">&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt;    &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="JS生成标签"><a href="#JS生成标签" class="headerlink" title="JS生成标签"></a>JS生成标签</h2><blockquote><p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免在javascript中生成DOM。</p></blockquote><h2 id="减少标签数量"><a href="#减少标签数量" class="headerlink" title="减少标签数量"></a>减少标签数量</h2><blockquote><p>在编写HTML代码时，需要尽量避免多余的父节点；很多时候，需要通过迭代和重构来使HTML变得更少。</p></blockquote><pre><code class="html">&lt;!-- bad --&gt;&lt;span class=&quot;avatar&quot;&gt;    &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- good --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt;</code></pre><h2 id="实用高于完美"><a href="#实用高于完美" class="headerlink" title="实用高于完美"></a>实用高于完美</h2><blockquote><p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p></blockquote><hr><h1 id="CSS和SCSS代码规范-1"><a href="#CSS和SCSS代码规范-1" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>CSS类名命名参考样式命名；</li><li>让规则越具体越好，尽量不要使用<strong><code>ul li a {}</code></strong>这样长的选择器，最好使用<strong><code>.wb-list-wrapper {}</code></strong>之类的选择器；</li><li>禁止使用层级过深的选择器，最多5级；</li><li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式；</li><li>除非是样式reset需要，禁止对标签选择器设置特定样式，避免样式污染；</li><li>样式文件中不要出现大写的标签定义, 不要对 JS 钩子进行样式定义；</li><li>避免使用*来选择元素；</li><li>避免使用float、position，优先使用flex和grid；</li><li>避免使用<code>!important</code>, 如果必须请加注释；</li></ul><pre><code class="css"> //会导致页面所有的a标签都被加上背景 a{background:url(xxx);} //后期修改可能会添加一些span标签，如果刚好在div里面，会被污染；不利于后期维护 div span{display:block}</code></pre><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p>使用soft tab（4个空格）。 </p></blockquote><pre><code class="scss">.element {    position: absolute;    top: 10px;    left: 10px;    border-radius: 10px;    width: 50px;    height: 50px;}</code></pre><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><blockquote><p>每个属性声明末尾都要加分号。</p></blockquote><pre><code class="scss">.element {    width: 20px;    height: 20px;    background-color: red;}</code></pre><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><blockquote><p>以下几种情况不需要空格：</p></blockquote><ul><li>属性名后</li><li>多个规则的分隔符’,’前</li><li><code>!important</code> ‘!’后</li><li>属性值中’(‘后和’)’前</li><li>行末不要有多余的空格</li></ul><blockquote><p>以下几种情况需要空格：</p></blockquote><ul><li>属性值前</li><li>选择器’&gt;’, ‘+’, ‘~’前后</li><li>‘{‘前</li><li><code>!important</code> ‘!’前</li><li><code>@else</code> 前后</li><li>属性值中的’,’后</li><li>注释’/*‘后和’*/‘前</li></ul><pre><code class="scss">/* not good */.element {    color :red! important;    background-color: rgba(0,0,0,.5);}/* good */.element {    color: red !important;    background-color: rgba(0, 0, 0, .5);}/* not good */.element ,.dialog{    ...}/* good */.element,.dialog {}/* not good */.element&gt;.dialog{    ...}/* good */.element &gt; .dialog{    ...}/* not good */.element{    ...}/* good */.element {    ...}/* not good */@if{    ...}@else{    ...}/* good */@if {    ...} @else {    ...}</code></pre><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><blockquote><p>以下几种情况需要空行：</p></blockquote><ul><li>文件最后保留一个空行；</li><li>‘}’后最好跟一个空行，包括scss中嵌套的规则；</li><li>属性之间需要适当的空行，具体见后面属性声明顺序。</li></ul><pre><code class="scss">/* not good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}/* good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}</code></pre><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><blockquote><p>以下几种情况不需要换行：</p></blockquote><ul><li>‘{‘前</li></ul><blockquote><p>以下几种情况需要换行：</p></blockquote><ul><li>‘{‘后和’}’前</li><li>每个属性独占一行</li><li>多个规则的分隔符’,’后</li></ul><pre><code class="scss">/* not good */.element{color: red; background-color: black;}/* good */.element {    color: red;    background-color: black;}/* not good */.element, .dialog {    ...}/* good */.element,.dialog {    ...}</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释统一用’/<em> </em>/‘（scss中也不要用’//‘），具体参照下面的写法；</li><li>缩进与下一行代码保持一致；</li><li>难于理解的代码添加注释；</li><li>可能被错误理解的代码添加注释；</li><li>工具类等公共方法添加文档注释；</li><li>浏览器特性hack添加注释；</li><li>修改别人的 CSS 请添加注释 ；</li><li><strong>可位于一个代码行的末尾，与代码间隔一个空格。</strong></li></ul><pre><code class="scss">/* Modal header */.modal-header {    ...}/* * Modal header */.modal-header {    ...}.modal-header {    /* 50px */    width: 50px;    color: red; /* color red */}</code></pre><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li>最外层统一使用双引号；</li><li>url的内容要用引号；</li><li>属性选择器中的属性值需要引号。</li></ul><pre><code class="scss">.element:after {    content: &quot;&quot;;    background-image: url(&quot;logo.png&quot;);}li[data-type=&quot;single&quot;] {    ...}</code></pre><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>类名使用小写字母，以中划线分隔。推荐BEM命名法</li><li>id采用驼峰式命名</li><li>scss中的变量、函数、混合、placeholder采用驼峰式命名</li></ul><pre><code class="scss">/* class */.block-element-modifier {    ...}/* id */#myDialog {    ...}/* 变量 */$colorBlack: #000;/* 函数 */@function pxToRem($px) {    ...}/* 混合 */@mixin centerBlock {    ...}/* placeholder */%myDialog {    ...}</code></pre><h2 id="属性声明顺序"><a href="#属性声明顺序" class="headerlink" title="属性声明顺序"></a>属性声明顺序</h2><blockquote><p>相关的属性声明按下面的顺序做分组处理，组之间需要有一个空行。</p><ul><li>位置属性（position，top。，right， z-index， display， float等）；</li><li>大小（width, height, padding, margin）；</li><li>文字系列（font，line-height， letter-spacing，color- text-align等）；</li><li>背景边框（background，border等）；</li><li>其他（animation，transition等）；</li></ul></blockquote><pre><code class="scss">.declaration-order {    display: block;    float: right;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 100;    border: 1px solid #e5e5e5;    border-radius: 3px;    width: 100px;    height: 100px;    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;    line-height: 1.5;    text-align: center;    color: #333;    background-color: #f5f5f5;    opacity: 1;}// 下面是推荐的属性的顺序[    [        &quot;display&quot;,        &quot;visibility&quot;,        &quot;float&quot;,        &quot;clear&quot;,        &quot;overflow&quot;,        &quot;overflow-x&quot;,        &quot;overflow-y&quot;,        &quot;clip&quot;,        &quot;zoom&quot;    ],    [        &quot;table-layout&quot;,        &quot;empty-cells&quot;,        &quot;caption-side&quot;,        &quot;border-spacing&quot;,        &quot;border-collapse&quot;,        &quot;list-style&quot;,        &quot;list-style-position&quot;,        &quot;list-style-type&quot;,        &quot;list-style-image&quot;    ],    [        &quot;-webkit-box-orient&quot;,        &quot;-webkit-box-direction&quot;,        &quot;-webkit-box-decoration-break&quot;,        &quot;-webkit-box-pack&quot;,        &quot;-webkit-box-align&quot;,        &quot;-webkit-box-flex&quot;    ],    [        &quot;position&quot;,        &quot;top&quot;,        &quot;right&quot;,        &quot;bottom&quot;,        &quot;left&quot;,        &quot;z-index&quot;    ],    [        &quot;margin&quot;,        &quot;margin-top&quot;,        &quot;margin-right&quot;,        &quot;margin-bottom&quot;,        &quot;margin-left&quot;,        &quot;-webkit-box-sizing&quot;,        &quot;-moz-box-sizing&quot;,        &quot;box-sizing&quot;,        &quot;border&quot;,        &quot;border-width&quot;,        &quot;border-style&quot;,        &quot;border-color&quot;,        &quot;border-top&quot;,        &quot;border-top-width&quot;,        &quot;border-top-style&quot;,        &quot;border-top-color&quot;,        &quot;border-right&quot;,        &quot;border-right-width&quot;,        &quot;border-right-style&quot;,        &quot;border-right-color&quot;,        &quot;border-bottom&quot;,        &quot;border-bottom-width&quot;,        &quot;border-bottom-style&quot;,        &quot;border-bottom-color&quot;,        &quot;border-left&quot;,        &quot;border-left-width&quot;,        &quot;border-left-style&quot;,        &quot;border-left-color&quot;,        &quot;-webkit-border-radius&quot;,        &quot;-moz-border-radius&quot;,        &quot;border-radius&quot;,        &quot;-webkit-border-top-left-radius&quot;,        &quot;-moz-border-radius-topleft&quot;,        &quot;border-top-left-radius&quot;,        &quot;-webkit-border-top-right-radius&quot;,        &quot;-moz-border-radius-topright&quot;,        &quot;border-top-right-radius&quot;,        &quot;-webkit-border-bottom-right-radius&quot;,        &quot;-moz-border-radius-bottomright&quot;,        &quot;border-bottom-right-radius&quot;,        &quot;-webkit-border-bottom-left-radius&quot;,        &quot;-moz-border-radius-bottomleft&quot;,        &quot;border-bottom-left-radius&quot;,        &quot;-webkit-border-image&quot;,        &quot;-moz-border-image&quot;,        &quot;-o-border-image&quot;,        &quot;border-image&quot;,        &quot;-webkit-border-image-source&quot;,        &quot;-moz-border-image-source&quot;,        &quot;-o-border-image-source&quot;,        &quot;border-image-source&quot;,        &quot;-webkit-border-image-slice&quot;,        &quot;-moz-border-image-slice&quot;,        &quot;-o-border-image-slice&quot;,        &quot;border-image-slice&quot;,        &quot;-webkit-border-image-width&quot;,        &quot;-moz-border-image-width&quot;,        &quot;-o-border-image-width&quot;,        &quot;border-image-width&quot;,        &quot;-webkit-border-image-outset&quot;,        &quot;-moz-border-image-outset&quot;,        &quot;-o-border-image-outset&quot;,        &quot;border-image-outset&quot;,        &quot;-webkit-border-image-repeat&quot;,        &quot;-moz-border-image-repeat&quot;,        &quot;-o-border-image-repeat&quot;,        &quot;border-image-repeat&quot;,        &quot;padding&quot;,        &quot;padding-top&quot;,        &quot;padding-right&quot;,        &quot;padding-bottom&quot;,        &quot;padding-left&quot;,        &quot;width&quot;,        &quot;min-width&quot;,        &quot;max-width&quot;,        &quot;height&quot;,        &quot;min-height&quot;,        &quot;max-height&quot;    ],    [        &quot;font&quot;,        &quot;font-family&quot;,        &quot;font-size&quot;,        &quot;font-weight&quot;,        &quot;font-style&quot;,        &quot;font-variant&quot;,        &quot;font-size-adjust&quot;,        &quot;font-stretch&quot;,        &quot;font-effect&quot;,        &quot;font-emphasize&quot;,        &quot;font-emphasize-position&quot;,        &quot;font-emphasize-style&quot;,        &quot;font-smooth&quot;,        &quot;line-height&quot;,        &quot;text-align&quot;,        &quot;-webkit-text-align-last&quot;,        &quot;-moz-text-align-last&quot;,        &quot;-ms-text-align-last&quot;,        &quot;text-align-last&quot;,        &quot;vertical-align&quot;,        &quot;white-space&quot;,        &quot;text-decoration&quot;,        &quot;text-emphasis&quot;,        &quot;text-emphasis-color&quot;,        &quot;text-emphasis-style&quot;,        &quot;text-emphasis-position&quot;,        &quot;text-indent&quot;,        &quot;-ms-text-justify&quot;,        &quot;text-justify&quot;,        &quot;letter-spacing&quot;,        &quot;word-spacing&quot;,        &quot;-ms-writing-mode&quot;,        &quot;text-outline&quot;,        &quot;text-transform&quot;,        &quot;text-wrap&quot;,        &quot;-ms-text-overflow&quot;,        &quot;text-overflow&quot;,        &quot;text-overflow-ellipsis&quot;,        &quot;text-overflow-mode&quot;,        &quot;-ms-word-wrap&quot;,        &quot;word-wrap&quot;,        &quot;-ms-word-break&quot;,        &quot;word-break&quot;    ],    [        &quot;color&quot;,        &quot;background&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;,        &quot;background-color&quot;,        &quot;background-image&quot;,        &quot;background-repeat&quot;,        &quot;background-attachment&quot;,        &quot;background-position&quot;,        &quot;-ms-background-position-x&quot;,        &quot;background-position-x&quot;,        &quot;-ms-background-position-y&quot;,        &quot;background-position-y&quot;,        &quot;-webkit-background-clip&quot;,        &quot;-moz-background-clip&quot;,        &quot;background-clip&quot;,        &quot;background-origin&quot;,        &quot;-webkit-background-size&quot;,        &quot;-moz-background-size&quot;,        &quot;-o-background-size&quot;,        &quot;background-size&quot;    ],    [        &quot;outline&quot;,        &quot;outline-width&quot;,        &quot;outline-style&quot;,        &quot;outline-color&quot;,        &quot;outline-offset&quot;,        &quot;opacity&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.Alpha(Opacity&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.Alpha&quot;,        &quot;-ms-interpolation-mode&quot;,        &quot;-webkit-box-shadow&quot;,        &quot;-moz-box-shadow&quot;,        &quot;box-shadow&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;text-shadow&quot;    ],    [        &quot;-webkit-transition&quot;,        &quot;-moz-transition&quot;,        &quot;-ms-transition&quot;,        &quot;-o-transition&quot;,        &quot;transition&quot;,        &quot;-webkit-transition-delay&quot;,        &quot;-moz-transition-delay&quot;,        &quot;-ms-transition-delay&quot;,        &quot;-o-transition-delay&quot;,        &quot;transition-delay&quot;,        &quot;-webkit-transition-timing-function&quot;,        &quot;-moz-transition-timing-function&quot;,        &quot;-ms-transition-timing-function&quot;,        &quot;-o-transition-timing-function&quot;,        &quot;transition-timing-function&quot;,        &quot;-webkit-transition-duration&quot;,        &quot;-moz-transition-duration&quot;,        &quot;-ms-transition-duration&quot;,        &quot;-o-transition-duration&quot;,        &quot;transition-duration&quot;,        &quot;-webkit-transition-property&quot;,        &quot;-moz-transition-property&quot;,        &quot;-ms-transition-property&quot;,        &quot;-o-transition-property&quot;,        &quot;transition-property&quot;,        &quot;-webkit-transform&quot;,        &quot;-moz-transform&quot;,        &quot;-ms-transform&quot;,        &quot;-o-transform&quot;,        &quot;transform&quot;,        &quot;-webkit-transform-origin&quot;,        &quot;-moz-transform-origin&quot;,        &quot;-ms-transform-origin&quot;,        &quot;-o-transform-origin&quot;,        &quot;transform-origin&quot;,        &quot;-webkit-animation&quot;,        &quot;-moz-animation&quot;,        &quot;-ms-animation&quot;,        &quot;-o-animation&quot;,        &quot;animation&quot;,        &quot;-webkit-animation-name&quot;,        &quot;-moz-animation-name&quot;,        &quot;-ms-animation-name&quot;,        &quot;-o-animation-name&quot;,        &quot;animation-name&quot;,        &quot;-webkit-animation-duration&quot;,        &quot;-moz-animation-duration&quot;,        &quot;-ms-animation-duration&quot;,        &quot;-o-animation-duration&quot;,        &quot;animation-duration&quot;,        &quot;-webkit-animation-play-state&quot;,        &quot;-moz-animation-play-state&quot;,        &quot;-ms-animation-play-state&quot;,        &quot;-o-animation-play-state&quot;,        &quot;animation-play-state&quot;,        &quot;-webkit-animation-timing-function&quot;,        &quot;-moz-animation-timing-function&quot;,        &quot;-ms-animation-timing-function&quot;,        &quot;-o-animation-timing-function&quot;,        &quot;animation-timing-function&quot;,        &quot;-webkit-animation-delay&quot;,        &quot;-moz-animation-delay&quot;,        &quot;-ms-animation-delay&quot;,        &quot;-o-animation-delay&quot;,        &quot;animation-delay&quot;,        &quot;-webkit-animation-iteration-count&quot;,        &quot;-moz-animation-iteration-count&quot;,        &quot;-ms-animation-iteration-count&quot;,        &quot;-o-animation-iteration-count&quot;,        &quot;animation-iteration-count&quot;,        &quot;-webkit-animation-direction&quot;,        &quot;-moz-animation-direction&quot;,        &quot;-ms-animation-direction&quot;,        &quot;-o-animation-direction&quot;,        &quot;animation-direction&quot;    ],    [        &quot;content&quot;,        &quot;quotes&quot;,        &quot;counter-reset&quot;,        &quot;counter-increment&quot;,        &quot;resize&quot;,        &quot;cursor&quot;,        &quot;-webkit-user-select&quot;,        &quot;-moz-user-select&quot;,        &quot;-ms-user-select&quot;,        &quot;user-select&quot;,        &quot;nav-index&quot;,        &quot;nav-up&quot;,        &quot;nav-right&quot;,        &quot;nav-down&quot;,        &quot;nav-left&quot;,        &quot;-moz-tab-size&quot;,        &quot;-o-tab-size&quot;,        &quot;tab-size&quot;,        &quot;-webkit-hyphens&quot;,        &quot;-moz-hyphens&quot;,        &quot;hyphens&quot;,        &quot;pointer-events&quot;    ]]</code></pre><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><blockquote><p>颜色16进制用小写字母；颜色16进制尽量用简写。</p></blockquote><pre><code class="scss">/* not good */.element {    color: #ABCDEF;    background-color: #001122;}/* good */.element {    color: #abcdef;    background-color: #012;}</code></pre><h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><blockquote><p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p></blockquote><blockquote><p><code>margin</code> 和 <code>padding</code> 相反，需要使用简写；</p></blockquote><blockquote><p>常见的属性简写包括：</p></blockquote><ul><li><code>font</code></li><li><code>background</code></li><li><code>transition</code></li><li><code>animation</code></li></ul><pre><code class="scss">/* not good */.element {    transition: opacity 1s linear 2s;}/* good */.element {    transition-delay: 2s;    transition-timing-function: linear;    transition-duration: 1s;    transition-property: opacity;}</code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p><pre><code class="scss">.element {    ...}.element-avatar{    ...}@media (min-width: 480px) {    .element {        ...    }    .element-avatar {        ...    }}</code></pre><h2 id="SCSS相关"><a href="#SCSS相关" class="headerlink" title="SCSS相关"></a>SCSS相关</h2><ul><li>声明顺序：<ul><li><code>@extend</code></li><li>不包含 <code>@content</code> 的 <code>@include</code></li><li>包含 <code>@content</code> 的 <code>@include</code></li><li>自身属性</li><li>嵌套规则</li></ul></li><li>提交的代码中不要有 <code>@debug</code>；</li><li><code>@import</code> 引入的文件不需要开头的’_’和结尾的’.scss’；</li><li>嵌套最多不能超过5层；</li><li><code>@extend</code> 中使用placeholder选择器；</li><li>去掉不必要的父级引用符号’&amp;’。</li></ul><pre><code class="scss">/* not good */@import &quot;_dialog.scss&quot;;/* good */@import &quot;dialog&quot;;/* not good */.fatal {    @extend .error;}/* good */.fatal {    @extend %error;}/* not good */.element {    &amp; &gt; .dialog {        ...    }}/* good */.element {    &gt; .dialog {        ...    }}</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>不允许有空的规则；</li><li>元素选择器用小写字母；</li><li>去掉小数点前面的0；</li><li>去掉数字中不必要的小数点和末尾的0；</li><li>属性值’0’后面不要加单位；</li><li>同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法；</li><li>无前缀的标准属性应该写在有前缀的属性后面；</li><li>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</li><li>不要在一个文件里出现两个相同的规则；</li><li>用 <code>border: 0;</code> 代替 <code>border: none;</code>；</li><li>选择器不要超过5层（在scss中如果超过5层应该考虑用嵌套的方式来写）；</li><li>发布的代码中不要有 <code>@import</code>；</li><li>尽量少用’*’选择器。</li></ul><pre><code class="scss">/* not good */.element {}/* not good */LI {    ...}/* good */li {    ...}/* not good */.element {    color: rgba(0, 0, 0, 0.5);}/* good */.element {    color: rgba(0, 0, 0, .5);}/* not good */.element {    width: 50.0px;}/* good */.element {    width: 50px;}/* not good */.element {    width: 0px;}/* good */.element {    width: 0;}/* not good */.element {    border-radius: 3px;    -webkit-border-radius: 3px;    -moz-border-radius: 3px;    background: linear-gradient(to bottom, #fff 0, #eee 100%);    background: -webkit-linear-gradient(top, #fff 0, #eee 100%);    background: -moz-linear-gradient(top, #fff 0, #eee 100%);}/* good */.element {    -webkit-border-radius: 3px;       -moz-border-radius: 3px;            border-radius: 3px;    background: -webkit-linear-gradient(top, #fff 0, #eee 100%);    background:    -moz-linear-gradient(top, #fff 0, #eee 100%);    background:         linear-gradient(to bottom, #fff 0, #eee 100%);}/* not good */.element {    color: rgb(0, 0, 0);    width: 50px;    color: rgba(0, 0, 0, .5);}/* good */.element {    color: rgb(0, 0, 0);    color: rgba(0, 0, 0, .5);}</code></pre><h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><h3 id="图片命名"><a href="#图片命名" class="headerlink" title="图片命名"></a>图片命名</h3><ul><li>图片名称必须小写，禁止使用特殊字符、中文；</li><li>使用英文或拼音缩写，禁止特殊字符；</li><li>名称间隔使用-符号；</li><li>命名需要能体现图片的大概用途；</li><li>禁止文件名和实际图片内容不符。反面例子：图片名为’weixin-qrcode’，图片内容却是头像。</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>图片体积不能超过300K；</li><li>JPG图片必须压缩，一般80%品质即可，保证文字清晰；</li><li>JPG图片必须使用渐进式图片：使用Photoshop的“存储为web所用格式”时候，勾选“连续”；</li><li>透明PNG图片必须使用<a href="https://tgideas.qq.com/doc/frontend/tool/imagecompress.html" target="_blank" rel="noopener">压缩工具</a>压缩后提供。</li></ul><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><ul><li>img图片必须填写width、height、alt属性；</li><li>移动端必须填写<code>alt</code>属性；</li><li><code>alt</code>不能为无意义字符，需要能表现出图片的含义，如图片为道具图，则应该为道具的名称。</li></ul><h3 id="合理切图"><a href="#合理切图" class="headerlink" title="合理切图"></a>合理切图</h3><ul><li>文字禁止切到图片中，如果不确定是否需要变动，请咨询接口人；</li><li>序后台动态生成的图片，如道具图片、头像、奖品，必须单独切割出来；</li><li>图片合并成精灵图或做成字体图标，减少页面请求。</li></ul><hr><h1 id="JavaScript代码规范-1"><a href="#JavaScript代码规范-1" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h1><h2 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p>使用soft tab（2个空格）。</p></blockquote><pre><code class="js">if (x &lt; y) {  x += 10;} else {  x += 1;}</code></pre><h2 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h2><blockquote><p>不要超过100，但如果编辑器开启word wrap可以不考虑单行长度。</p></blockquote><h2 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h2><blockquote><p>以下几种情况后需加分号：</p></blockquote><ul><li>变量声明</li><li>表达式</li><li>return</li><li>throw</li><li>break</li><li>continue</li><li>do-while</li></ul><blockquote><p>以下几种情况后无需分号</p></blockquote><ul><li>for</li><li>function</li><li>if</li><li>switch</li><li>try</li><li>while</li></ul><pre><code class="js">/* var declaration */var x = 1;/* expression statement */x++;/* do-while */do {    x++;} while (x &lt; 10);</code></pre><h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><blockquote><p>以下几种情况不需要空格：</p></blockquote><ul><li>对象的属性名后；</li><li>前缀一元运算符后；</li><li>后缀一元运算符前；</li><li>函数调用括号前；</li><li>无论是函数声明还是函数表达式，’(‘前不要空格；</li><li>数组的’[‘后和’]’前；</li><li>对象的’{‘后和’}’前；</li><li>运算符’(‘后和’)’前。</li></ul><blockquote><p>以下几种情况需要空格：</p></blockquote><ul><li>二元运算符前后；</li><li>三元运算符’?:’前后；</li><li>代码块’{‘前；</li><li>下列关键字前：<code>else</code>, <code>while</code>, <code>catch</code>, <code>finally；</code></li><li>下列关键字后：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>case</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>, <code>return</code>, <code>typeof；</code></li><li>单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后；</li><li>对象的属性值前；</li><li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格；</li><li>无论是函数声明还是函数表达式，’{‘前一定要有空格；</li><li>函数的参数之间。</li></ul><pre><code class="js">// not goodvar a = {    b :1};// goodvar a = {    b: 1};// not good++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2;// not goodvar a = [ 1, 2 ];// goodvar a = [1, 2];// not goodvar a = ( 1+2 )*3;// goodvar a = (1 + 2) * 3;// no space before &#39;(&#39;, one space before &#39;{&#39;, one space between function parametersvar doSomething = function(a, b, c) {    // do something};// no space before &#39;(&#39;doSomething(item);// not goodfor(i=0;i&lt;6;i++){    x++;}// goodfor (i = 0; i &lt; 6; i++) {    x++;}</code></pre><h2 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h2><blockquote><p>以下几种情况需要空行：</p></blockquote><ul><li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）；</li><li>连续空行数控制在 1 ~ 3 行（根据代码块层次来控制空行数）；</li><li>注释前（当注释在代码块的第一行时，则无需空行）；</li><li>代码块后（在函数调用、数组、对象中则无需空行）；</li><li>语法意义上相互独立的代码将用空行分隔；</li><li>文件最后保留一个空行。</li></ul><pre><code class="js">// need blank line after variable declarationvar x = 1;// not need blank line when variable declaration is last expression in the current blockif (x &gt;= 1) {    var y = x + 1;}var a = 2;// need blank line before line commenta++;function b() {    // not need blank line when comment is first line of block    return a;}// need blank line after blocksfor (var i = 0; i &lt; 2; i++) {    if (true) {        return false;    }    continue;}var obj = {    foo: function() {        return 1;    },    bar: function() {        return 2;    }};// not need blank line when in argument list, array, objectfunc(    2,    function() {        a++;    },    3);var foo = [    2,    function() {        a++;    },    3];var foo = {    a: 2,    b: function() {        a++;    },    c: 3};</code></pre><h2 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h2><ul><li>(建议)每行代码不要超过 80 字符。当一条语句一行写不下时, 折行；</li><li>“{}” (大括号)前面不需要换行, 例如函数定义、if 语句、while 语句、switch 等；</li><li>换行的地方，行末必须有’,’或者运算符；</li><li>以下几种情况不需要换行：<ul><li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li><li>代码块’{‘前</li></ul></li><li>以下几种情况需要换行：<ul><li>代码块’{‘后和’}’前</li><li>变量赋值后</li></ul></li></ul><pre><code class="js">// not goodvar a = {    b: 1    , c: 2};x = y    ? 1 : 2;// goodvar a = {    b: 1,    c: 2};x = y ? 1 : 2;x = y ?    1 : 2;// no need line break with &#39;else&#39;, &#39;catch&#39;, &#39;finally&#39;if (condition) {    ...} else {    ...}try {    ...} catch (e) {    ...} finally {    ...}// not goodfunction test(){    ...}// goodfunction test() {    ...}// not goodvar a, foo = 7, b,    c, bar = 8;// goodvar a,    foo = 7,    b, c, bar = 8;</code></pre><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><ul><li>双斜线后，必须跟一个空格；</li><li>缩进与下一行代码保持一致；</li><li>可位于一个代码行的末尾，与代码间隔一个空格。</li></ul><pre><code class="js">if (condition) {    // if you made it here, then all security checks passed    allowed();}var zhangsan = &#39;zhangsan&#39;; // one space after code</code></pre><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ul><li>最少三行, ‘*’后跟一个空格，具体参照右边的写法；</li><li>建议在以下情况下使用：<ul><li>难于理解的代码段</li><li>可能存在错误的代码段</li><li>浏览器特殊的HACK代码</li><li>业务逻辑强相关的代码</li></ul></li></ul><pre><code class="js">/* * one space after &#39;*&#39; */var x = 1;</code></pre><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><blockquote><p>各类标签@param, @method等请参考<a href="http://usejsdoc.org/" target="_blank" rel="noopener">usejsdoc</a>和<a href="http://yuri4ever.github.io/jsdoc/" target="_blank" rel="noopener">JSDoc Guide</a>；</p></blockquote><blockquote><p>建议在以下情况下使用：</p></blockquote><ul><li>所有常量</li><li>所有函数</li><li>所有类</li></ul><pre><code class="js">** * @func * @desc 一个带参数的函数 * @param {string} a - 参数a * @param {number} b=1 - 参数b默认值为1 * @param {string} c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx * @param {object} d - 参数d为一个对象 * @param {string} d.e - 参数d的e属性 * @param {string} d.f - 参数d的f属性 * @param {object[]} g - 参数g为一个对象数组 * @param {string} g.h - 参数g数组中一项的h属性 * @param {string} g.i - 参数g数组中一项的i属性 * @param {string} [j] - 参数j是一个可选参数 */function foo(a, b, c, d, g, j) {    ...}</code></pre><h2 id="引号-1"><a href="#引号-1" class="headerlink" title="引号"></a>引号</h2><blockquote><p>最外层统一使用单引号。</p></blockquote><pre><code class="js">// not goodvar x = &quot;test&quot;;// goodvar y = &#39;foo&#39;,    z = &#39;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#39;;</code></pre><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul><li>精简短小, 见名知意。 必须是有意义的文件名， 文件名中严禁出现中文 ， 多个英文单词请用大小驼峰命名法。尽量保持所有名称最短, 但是一定要保证名称具有描述性；</li><li>字符串变量值统一用单引号；</li><li>变量的命名, 不得使用 js 保留字；</li><li>请不要在文件名后加数字, 来实现相同功能的多个版本；</li><li>除非必要, 请不要使用全局变量, 避免出现全局变量污染。</li><li>函数内部的变量, 请在函数定义的头部声明。出于避免造成不必要消耗的考虑, 复杂类型的变量可以只声明不赋值。唯一特殊的情况, 是 for 循环的下标变量, 可以使用的时候实时声明；</li><li>函数内两次以上使用到的同一全局变量或者外部对象, 定义为一个局部变量, 以保证程序性能最优, 例如: var doc = document, win = window；</li><li>私有化变量和方法名应该以下划线 _ 开头；</li><li>变量不要先使用后声明；</li><li>不使用(汉语拼音/拼音英文数字组合/不规范的英文缩写)作为文件名；</li><li>尽量使用英文小写作为文件名, 免某些系统不区分文件名大小写；</li><li>常量全大写，用下划线连接，避免魔术常量，优先使用const，其次let，最后才是var；</li><li>变量名fetch或async代表异步，get代表获取，set或put代表修改，is、has、can代表布尔值，handle代表普通函数。</li></ul><pre><code class="js">var thisIsMyName;var MAX_COUNT = 10;function Person(name) {    this.name = name;}</code></pre><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><blockquote><p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。 </p></blockquote><pre><code class="js">function doSomethingWithItems(items) {    // use one var    var value = 10,        result = value + 10,        i,        len;    for (i = 0, len = items.length; i &lt; len; i++) {        result += 10;    }}</code></pre><h2 id="条件语句-循环"><a href="#条件语句-循环" class="headerlink" title="条件语句/循环"></a>条件语句/循环</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li>if语句, 即使只有单行, 也要用花括号括起来；</li><li>使用三元运算符, 替代单一的 if else 语句；</li><li>if/else/while/for 条件表达式必须有小括号, 且自占一行；</li><li>利用 &amp;&amp; 和 || 短路来简化代码；</li><li>使用严格的条件判断符。用 === 代替 ==, 用!== 代替 !=。</li></ul><pre><code class="js">if (val != 0) {     return foo();} else {    return bar();}// 可以写作:return val ? foo() : bar();function foo(opt_win) {    var win;    if (opt_win) {        win = opt_win;    } else {        win = window;    }    // ...}// 可以写作:function foo(opt_win) {    var win = opt_win || window;    // ...}</code></pre><h3 id="amp-amp-短路"><a href="#amp-amp-短路" class="headerlink" title="&amp;&amp; 短路:"></a>&amp;&amp; 短路:</h3><pre><code class="javascript">if (node) {    if (node.kids) {        if (node.kids[index]) {            foo(node.kids[index]);        }    }}// 可以写作:if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) {    foo(node.kids[index]);}// 或者var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) {    foo(kid);}</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>尽量避免 for-in 循环, 只用于 object/hash 的遍历, 数组的遍历使用 for 循环；</li><li>for-in 循环体中必须用 hasOwnProperty 方法检查成员是否为自身成员, 避免来自原型链上的污染；</li><li>避免在 if 和 while 语句的条件部分进行赋值。</li></ul><pre><code class="js">// (错误)var i = 10;while (i = i - 2) {    statement;}// 应该写作: (正确)var i = 10;while (i &gt; 0) {    statement;    i = i - 2;}</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>一个函数的内容不宜太长, 较复杂的逻辑, 需拆分成多个函数来实现, 使代码逻辑清晰；</li><li>对外暴露的 API 型函数, 尽量保持输入输出的稳定, 减小调用者修改代码的成本和风险；</li><li>无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格；</li><li>函数调用括号前不需要空格；</li><li>立即执行函数外必须包一层括号；</li><li>参数之间用’, ‘分隔，注意逗号后有一个空格；</li><li>拥抱函数式编程，遵循单一原则；</li><li>尽量减少参数数量，一般超过3个参数用对象代替；</li><li>可以嵌套函数, 用于减少重复代码, 隐藏一些局部函数等, 但不要在块内声明一个函数。因为 JS 并不支持块级作用域, 虽然很多 js 引擎都支持块内声明函数, 但它不属于 ECMAScript 规范 (见 ECMA-262, 第 13 和 14 条)。各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背。ECMAScript 只允 许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量。</li></ul><pre><code class="js">// (错误)if (x){    function foo () {}}// 应该写作: (正确)if (x) {    var foo = function () {};}// no space before &#39;(&#39;, but one space before&#39;{&#39;var doSomething = function(item) {    // do something};function doSomething(item) {    // do something}// not gooddoSomething (item);// gooddoSomething(item);// requires parentheses around immediately invoked function expressions(function() {    return 1;})();// not good[1, 2].forEach(function x() {    ...});// good[1, 2].forEach(function() {    ...});// not goodvar a = [1, 2, function a() {    ...}];// goodvar a = [1, 2, function() {    ...}];// use &#39;, &#39; between function parametersvar doSomething = function(a, b, c) {    // do something};</code></pre><h2 id="数组、对象"><a href="#数组、对象" class="headerlink" title="数组、对象"></a>数组、对象</h2><ul><li>对象属性名不需要加引号；</li><li>对象以缩进的形式书写，不要写在一行；</li></ul><pre><code class="js">// not goodvar a = {    &#39;b&#39;: 1};var a = {b: 1};var a = {    b: 1,    c: 2,};// goodvar a = {    b: 1,    c: 2,};</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>number to string的转换，建议使用<strong><code>1 + &#39;&#39;</code></strong> 或 <strong><code>Sring(1)</code></strong>，不使用<strong><code>new String(1)</code></strong> 或 <strong><code>1.tiString()</code></strong> 的方式；</li><li>string to number的转换，建议使用<strong><code>parseInt</code></strong>；</li><li>float to integer 的转换，建议使用<strong><code>Math.floor/Math.round/Math.ceil</code></strong>方法，不使用<strong><code>parseInt</code></strong>。</li></ul><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><blockquote><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p></blockquote><pre><code class="js">// not goodif (condition)    doSomething();// goodif (condition) {    doSomething();}</code></pre><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><blockquote><p>适用场景：</p></blockquote><ul><li>初始化一个将来可能被赋值为对象的变量</li><li>与已经初始化的变量做比较</li><li>作为一个参数为对象的函数的调用传参</li><li>作为一个返回对象的函数的返回值</li></ul><blockquote><p>不适用场景：</p></blockquote><ul><li>不要用null来判断函数调用时有无传参</li><li>不要与未初始化的变量做比较</li></ul><pre><code class="js">// not goodfunction test(a, b) {    if (b === null) {        // not mean b is not supply        ...    }}var a;if (a === null) {    ...}// goodvar a = null;if (a === null) {    ...}</code></pre><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><ul><li>永远不要直接使用undefined进行变量判断；</li><li>使用typeof和字符串’undefined’对变量进行判断。</li></ul><pre><code class="js">// not goodif (person === undefined) {    ...}// goodif (typeof person === &#39;undefined&#39;) {    ...}</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>不要使用 void、eval, with, 只在将 ajax 响应的文本解析为 json 时使用 eval()；</li><li>不要使用 function 构造器；</li><li>代码中调试用的 alert、console.log、console.dir、debugger 等代码, 在提交到 git 之前, 必须完全清理掉；</li><li>不要在内置对象的原型上添加方法，如Array, Date；</li><li>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</li><li>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</li><li>不要在同个作用域下声明同名变量；</li><li>不要在一些不需要的地方加括号，例：delete(a.b)；</li><li>不要使用未声明的变量；</li><li>不要声明了变量却不使用；</li><li>不要在应该做比较的地方做赋值；</li><li>数组中不要存在空元素；</li><li>不要在循环内部声明函数；</li><li>不要像这样使用构造函数，例：<code>new function () { ... }</code>, <code>new Object</code>；</li><li>不要混用tab和space；</li><li>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名；</li><li>行尾不要有空白字符；</li><li>switch的falling through和no default的情况一定要有注释特别说明；</li><li>避免硬编码；</li><li>关键的代码添加适当的异常处理；</li><li>自测要保证每一个方法、每一个变量的所有场景都覆盖到；</li><li>不允许有空的代码块。</li></ul><pre><code class="js">// not goodif (a == 1) {    a++;}// goodif (a === 1) {    a++;}// goodfor (key in obj) {    if (obj.hasOwnProperty(key)) {        // be sure that obj[key] belongs to the object and was not inherited        console.log(obj[key]);    }}// not goodArray.prototype.count = function(value) {    return 4;};// not goodvar x = 1;function test() {    if (true) {        var x = 0;    }    x += 1;}// not goodfunction test() {    console.log(x);    var x = 1;}// not goodnew Person();// goodvar person = new Person();// not gooddelete(obj.attr);// gooddelete obj.attr;// not goodif (a = 10) {    a++;}// not goodvar a = [1, , , 2, 3];// not goodvar nums = [];for (var i = 0; i &lt; 10; i++) {    (function(i) {        nums[i] = function(j) {            return i + j;        };    }(i));}// not goodvar singleton = new function() {    var privateVar;    this.publicMethod = function() {        privateVar = 1;    };    this.publicMethod2 = function() {        privateVar = 2;    };};// not goodvar a   = 1;function Person() {    // not good    var me = this;    // good    var _this = this;    // good    var that = this;    // good    var self = this;}// goodswitch (condition) {    case 1:    case 2:        ...        break;    case 3:        ...    // why fall through    case 4        ...        break;    // why no default}// not good with empty blockif (condition) {}</code></pre><hr><h1 id="jQuery代码规范-1"><a href="#jQuery代码规范-1" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h1><h2 id="jQuery变量"><a href="#jQuery变量" class="headerlink" title="jQuery变量"></a>jQuery变量</h2><ul><li>所有用于存储、缓存jQuery对象的变量应该以$前缀命名；</li><li>最好把使用选择器返回的jQuery对象缓存到变量里，以便复用；</li><li>使用<a href="http://en.wikipedia.org/wiki/CamelCase" target="_blank" rel="noopener">驼峰法</a>命名变量。</li></ul><pre><code class="js">const $userName = $(&#39;#userName&#39;);</code></pre><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><ul><li>尽可能的使用ID选择器；</li><li>使用类（class）选择器时，不要使用元素类型；</li><li>对于ID-&gt;child的方式，使用find比用嵌套选择器高效；</li><li>给选择器一个范围，如<strong><code>$(&#39;.class&#39;, &#39;.context&#39;)</code></strong>；</li><li>避免使用全局选择器，如<strong><code>$(&#39;div.class &gt; *&#39;)</code></strong>；</li></ul><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><ul><li>字符串拼接可用ES6的模版字符串；</li><li>使用字符串连接符或者array.join()，比append高效；</li><li>不要操作空对象。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>每个页面只使用一次document的ready事件；</li><li>尽量不要使用匿名函数绑定事件，因为匿名函数不利于调试、维护、测试、重用；</li><li>不要在html标签中写事件调用，始终使用jquery来绑定、删除事件；</li><li>如果有必要，使用自定义事件（即：给事件一个作用域），这样可以方便解除事件，而不影响其它事件；</li><li>当需要给多个对象绑定相同事件时，使用事件委托。</li></ul><pre><code class="js">$(&quot;#J_my-link&quot;).on(&quot;click.mySpecialClick&quot;, myEventHandler);</code></pre><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><ul><li>将链式操作看成变量缓存和多选择器请求的替代方式；</li><li>当链式操作超过三个或者因为事件绑定变得复杂时，使用换行和缩进提高链式操作可读性；</li><li>对于长的链式操作来说，也可以把中间对象缓存成一个变量。</li></ul><pre><code class="js">$(&#39;#userName&#39;).html(&#39;zhangsan&#39;)              .siblings(&#39;#userAge&#39;)              .html(&#39;20&#39;)              .siblings(&#39;#gender&#39;)              .html(&#39;男&#39;)</code></pre><h1 id="vue代码规范-1"><a href="#vue代码规范-1" class="headerlink" title="vue代码规范"></a>vue代码规范</h1><h2 id="必要的"><a href="#必要的" class="headerlink" title="必要的"></a>必要的</h2><ul><li>组件的<code>data</code>必须是一个函数；</li><li><code>Prop</code>定义应该尽量详细；</li><li>为<code>v-for</code>设置键值<code>key</code>；</li><li>避免<code>v-if</code>和<code>v-for</code>用在一起，<code>v-for</code>的优先级要高于<code>v-if</code>；</li><li>为组件样式设置作用域<strong>（注：scss有替代解决方案）</strong>；</li></ul><pre><code class="js">export default {  data() {    return {      foo: &#39;bar&#39;    }  },  props: {    status: {      type: String,      required: true,      validator: function (value) {        return [          &#39;syncing&#39;,          &#39;synced&#39;,          &#39;version-conflict&#39;,          &#39;error&#39;        ].indexOf(value) !== -1      }    }  }}</code></pre><pre><code class="html">&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;  &lt;li    v-for=&quot;user in users&quot;    :key=&quot;user.id&quot;  &gt;    {{ user.text }}  &lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="scss">&lt;style scoped&gt;.wrapper {}.title {}&lt;/style&gt;&lt;style lang=&quot;scss&quot;&gt;.wrapper {    .title {}}&lt;/style&gt;</code></pre><h2 id="强烈推荐"><a href="#强烈推荐" class="headerlink" title="强烈推荐"></a>强烈推荐</h2><ul><li>单文件组件的文件名应该要么始终是大驼峰命名，要么始终是中划线命名；</li><li>应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或无状态的组件）应该全部以一个特定的前缀开头；</li><li>只应该用有单个活跃实例的组件应该以<code>The</code>前缀命名，以示其唯一性；</li><li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名；</li><li>组件名应该以高级别的单词开头，以描述性的修饰词结尾；</li><li>对于绝大多数项目来说，在单文件组件和字符串模版中组件名应该总是大驼峰命名，但在DOM模版中总是中划线命名；</li><li>组件名应该倾向于完整单词而不是缩写；</li><li>在声明<code>prop</code>的时候，其命名应该始终使用大驼峰，而在模版中应该始终使用中划线；</li><li>多个属性的元素应该分多行，每个属性一行；</li><li>组件模版应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法；</li><li>应该把复杂计算属性分割为尽可能多的更 简单的属性；</li><li>非空的属性值应该始终带引号（单引号或双引号，选你JS里不用的那个）；</li><li>指令缩写；</li><li>其它参考Vue官网的风格指南。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;HTML代码规范&quot;&gt;&lt;a href=&quot;#HTML代码规范&quot; class=&quot;headerlink&quot; title=&quot;HTML代码规范&quot;&gt;&lt;/a&gt;HTML代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;CSS和SCSS代码规范&quot;&gt;&lt;a href=&quot;#CSS和SCSS代码规范&quot; class=&quot;headerlink&quot; title=&quot;CSS和SCSS代码规范&quot;&gt;&lt;/a&gt;CSS和SCSS代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;JavaScript代码规范&quot;&gt;&lt;a href=&quot;#JavaScript代码规范&quot; class=&quot;headerlink&quot; title=&quot;JavaScript代码规范&quot;&gt;&lt;/a&gt;JavaScript代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;jQuery代码规范&quot;&gt;&lt;a href=&quot;#jQuery代码规范&quot; class=&quot;headerlink&quot; title=&quot;jQuery代码规范&quot;&gt;&lt;/a&gt;jQuery代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;vue代码规范&quot;&gt;&lt;a href=&quot;#vue代码规范&quot; class=&quot;headerlink&quot; title=&quot;vue代码规范&quot;&gt;&lt;/a&gt;vue代码规范&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="代码 前端 开发 标准 规范 质量" scheme="http://www.icrazyman.cn/tags/%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF-%E5%BC%80%E5%8F%91-%E6%A0%87%E5%87%86-%E8%A7%84%E8%8C%83-%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端代码质量的思考与实践</title>
    <link href="http://www.icrazyman.cn/2020/03/16/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.icrazyman.cn/2020/03/16/代码质量提升的思考与实践/</id>
    <published>2020-03-16T06:28:20.000Z</published>
    <updated>2020-03-20T02:18:06.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端代码质量的思考与实践"><a href="#前端代码质量的思考与实践" class="headerlink" title="前端代码质量的思考与实践"></a>前端代码质量的思考与实践</h1><p>编写可读的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是能够被阅读，其次才是能够被正确执行。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结，除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p><p>JavaScript 是动态和弱类型的语言，使用起来比较轻松随意，在IE6那个刀耕火种的时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端工程化技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p><a id="more"></a><h1 id="分享与共勉"><a href="#分享与共勉" class="headerlink" title="分享与共勉"></a>分享与共勉</h1><blockquote><ol><li><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.      —— Martin Fowler</p></li><li><p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, “How can I improve the code so that this comment isn’t needed?”               ——Steve McConnell</p></li><li>Programs must be written for people to read, and only incidentally for machines to execute.   —— Harold Abelson</li></ol></blockquote><h2 id="HTML中的实践"><a href="#HTML中的实践" class="headerlink" title="HTML中的实践"></a>HTML中的实践</h2><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMOcYJhBQLaq05rZi5yu9lFKrXZnpijz2VeCefrbR0CyNNnP2pOfW4aK*x7lupyOOwQ!!/b&amp;bo=jAEjAYwBIwEDCSw!&amp;rf=viewer_4" alt=""></p><ul><li><p>使用语义化标签</p></li><li><p>清晰、简洁的层级嵌套结构</p></li><li><p>尽可能少地使用无意义的标签，如div和span</p></li><li><p>语义不明显，可以用p也可以用div，优先用p标签</p></li><li><p>在无法用标签表明语义的场景下增加适当的注释</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2yC28RF9x3naE7Gy8FpNQOfLxe5IVY16QJ1P64SI7Z2AwXvgsCMngyFR7y2Ptvp9RQ!!/b&amp;bo=vwX.Ab8F*gEDKQw!&amp;rf=viewer_4" alt=""></p></li></ul><h2 id="CSS中的实践"><a href="#CSS中的实践" class="headerlink" title="CSS中的实践"></a>CSS中的实践</h2><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xgnO5gqaLn54n17E2fw0O.DfbXw1lsknXg8xE7DW*c2tUyxue2W1ZUELC*H5X4R0Q!!/b&amp;bo=kAFkAZABZAEDGTw!&amp;rf=viewer_4" alt=""></p><ul><li>引入sass或其他css预处理器</li><li>命名可以参考借鉴BEM命名法和中划线命名法</li><li>根节点用id选择器，其它用类选择器，子代替代后代</li><li>css属性书写采用约定的顺序</li><li>类命名中划线分隔不超过4级，超过了从0开始</li><li>尽量避免使用float，position，采用flex布局和grid布局</li><li>如果只能直接编写css，也可以参考上述体现的思路</li><li>如果无法直接引入sass，可用IDE或终端进行手动转译</li></ul><h2 id="javascript和jQuery的实践"><a href="#javascript和jQuery的实践" class="headerlink" title="javascript和jQuery的实践"></a>javascript和jQuery的实践</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>　　变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p><p>　　命名必须传递足够的信息，形如 getData 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 fetchUserInfoAsync 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 Async 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p><ul><li>命名的基础。用名词命名对象，用动词命名函数，用复数表示集合，也可以加上List或Map后缀来显示地表示出来，使代码接近于自然语言。变量命名建议用小驼峰，类建议用大驼峰。</li><li>命名规范。时刻按照某种规则来命名变量和函数，不用担心变量污染和能够见名知意了。如：fetch或async代表异步，get代表获取，set代表设置，is、has、can代表一个布尔值，handle代表普通函数等。.</li><li>命名的上下文。变量都是处在上下文（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。</li><li>匈牙利命名法。基本原则：变量名=属性+类型+描述。其中每一个对象的名称都要求有明确含义，可以取对象全称或简写。例如：sUserName，代表用户姓名的字符串。拥有一定的学习成本，自行取舍。.</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xS7LHFisL2UuNcq9tyvnA57nsCHTVc9sf0RSFNj6gzQvwm6a1eiQLuMO3ynK9ylOQ!!/b&amp;bo=OQGWATkBlgEDGTw!&amp;rf=viewer_4" alt=""></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>　　在ECMAScript 6之前，JavaScript中并没有真正的常量的概念。然而，这并不能组织开发者将变量用作常量。为了区分普通的变量（变量的值是可变的）和常量（常量的值初始化之后就不能变了），一种通用的命名约定应运而生。这个约定源自于C语言，它使用大写字母和下划线来命名，下划线用以分隔单词。</p><ul><li>约定命名。变量名全部用大写字母，多个单词用下划线分隔</li><li>魔术常量。同一个常量（值）在不同的上下文中可能代表着不同的含义。引申到js中，就是要使用有意义的变量名代替魔术常量，以提高代码的维护性和可读性。</li><li>避免硬编码。对于代码中重复使用次数较多、未来可能会变动的数据，最好抽离成变量或配置项，实现代码逻辑和业务松耦合，增强维护性。</li><li>常量的声明。按关键字优先使用顺序：const =&gt; let =&gt; var。能用const和let的尽量不要用var，var声明有副作用。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M22WMg2mLZUCVABtDtZCdO1Z8.2*4usStHIQRfxhxl7FS5r3y0dk*CeLHBP11kxbOsA!!/b&amp;bo=iQISAokCEgIDKQw!&amp;rf=viewer_4" alt=""></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>　　何时添加注释是具有争议的一个话提。代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p><ul><li>难于理解的代码。逻辑比较复杂或特殊的业务逻辑时都应当加注释。关键是让其他人更容易读懂这段代码。</li><li>可能被错误理解的代码。在团队开发中，当自己写的代码可能会被其他同事认为有错误时，需要添加注释。</li><li>浏览器特性hack。兼容性代码会让人看不明白，此时应当添加适当的注释解释其用途。</li><li>文档注释。对于工具类等公共方法，添加文档注释，解释其用途、参数和返回值，让人看注释就能明白使用方法，而不用关心方法内部的实现。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2zi24H4VLsBBQoPLNB9S5tGFifc7*JQ42kvVMTRUMLv0sehXvdQy03ifIM9jOwPUHw!!/b&amp;bo=KQJUAikCVAIDKQw!&amp;rf=viewer_4" alt=""></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>　　JS是一种多范式编程语言。函数式编程是一种编程范式，一种构建计算机程序结构和元素的方式，将计算视为数学函数的评估并避免改变状态和可变数据。它使你能够构建无副作用的功能，而函数式编程的一些优点，也使得系统变得更加容易维护。</p><ul><li><p>纯函数。给出相同的参数，它返回相同的结果（确定性）；不会引起任何可观察到的副作用；容易测试。</p></li><li><p>闭包。通过闭包可以在函数外部能访问到函数内部的变量，过度地使用闭包会造成内存泄露。</p></li><li><p>单一原则。如果一个方法承担了过多的职责，在需求发生变化的过程中，需要改写这个方法的可能性就越大。</p></li><li><p>面向切面编程。非侵入性的改造函数。保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用现有功能模块。</p></li><li><p>健壮性。web开发安全守则：永远不要相信用户的输入。对数据最好做异常处理，增强其健壮性。例如XSS。</p></li><li><p>参数。形参越少越好，不超过3个，超过3的用对象代替，这样可以极大地减少该方法的UT自测场景。</p></li><li><p><a href="https://segmentfault.com/a/1190000014277519" target="_blank" rel="noopener">注：尾调用和尾递归</a></p></li></ul><h2 id="前端异常的处理"><a href="#前端异常的处理" class="headerlink" title="前端异常的处理"></a>前端异常的处理</h2><p>  　　前端异常的处理也属于代码健壮性的一部分。JavaScript不像Java一样，有专门的语法去定义和实现异常处理，前端代码是离用户最近的代码，异常的处理更多的是从用户体验和代码健壮性出发的，后端代码异常的处理更多的是从业务角度和数据安全性出发的。所以JavaScript的异常处理方法主要是对页面内容（用户输入和接口输入）的校验上，在异常的时候能给出用户能看懂的提示，另一方面，从代码角度来上来说，研发也能够从页面的提示上快速地定位问题、修复问题，提升解决问题的效率。</p><h2 id="使用全等-替代相等-（副作用）"><a href="#使用全等-替代相等-（副作用）" class="headerlink" title="使用全等===替代相等==（副作用）"></a>使用全等===替代相等==（副作用）</h2><p>　　javascript具有强制类型转换机制，判断相等的操作是很微妙的。对于某些运算来说，为了得到成功的结果，强制类型转换会驱使某种类型的变量自动转换成其他不同类型，这种情形往往会造成意想不到的结果。</p><p>　　发生强制类型转换最常见的场景就是，使用了判断相等运算符==和!=的时候。当要比较的两个值的类型不同时，这两个运算符都会有强制类型转换。但在很多实际情况中，代码并不按照我所期望的方式运行。Crockford的编程规范、jQuery核心风格指南、SproutCore编程风格指南推荐使用===和!==。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M29FFoZar4Ed9fGnZt3A95nhiT9tFTUbYFB0EejZvcl12atXNcTEHE7nRnNetrb0MiA!!/b&amp;bo=aQF.AWkBfgEDGTw!&amp;rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M22T6agWuiSJY4RsmAba0zLnCiaSPP8TQUPenfp.A0VxIOC*xaWkGAb*5zqitw0o*AA!!/b&amp;bo=UQHRAFEB0QADGTw!&amp;rf=viewer_4" alt=""></p><h2 id="jQuery效率提升建议"><a href="#jQuery效率提升建议" class="headerlink" title="jQuery效率提升建议"></a>jQuery效率提升建议</h2><ul><li><p>正确使用选择器。Id &gt; tag &gt; class &gt; 属性和伪类</p></li><li><p>层级选择器尽量使用find方法，效率较高</p></li><li><p>缓存 jQuery 对象</p></li><li><p>链式调用</p></li><li><p>事件委托</p></li><li><p>少改动DOM</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMPvKCeTos0jToyTqBi1rRBT6dOhVBeGRoVS.F3JWQeUZ2iHUvGs.yFs12V8SfdNVBQ!!/b&amp;bo=tgEtAbYBLQEDCSw!&amp;rf=viewer_4" alt=""></p></li></ul><h2 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h2><p>　　设计模式是在软件设计过程中针对特定问题的简洁而优雅的解决方案。《parctical common lisp》的作者曾说，如果你需要一种模式，那一定是哪里出了问题。他所说的问题是指因为语言的天生缺陷，不得不去寻求和总结一种通用的解决方案。不管是弱类型或强类型，静态或动态语言，命令式或说明式语言、每种语言都有天生的优缺点。</p><p>　　单例模式比较好理解，它是一个对象，我们创建这个对象的目地是为了系统管理代码中的一些公用的变量，对象，函数，避免出现变量污染，一般我们声明一些变量和函数的时候，我们是在封闭的函数中，一般不会造成变量污染情况，但是以防万一，原因是在js中，全局变量和局部变量的关系比较复杂（有时候还夹杂着一部分变量提升问题），不少coder经常会因为此问题出现bug老半天找不到原因，创建好这个对象以后我们只是对外暴露一个对象入口，使用里面的变量时我们可以以object.变量名的形式来调用变量，其实也是为了实现js代码块的划分命名空间来设计的。</p><p>　　我之前写了几年的php和jQuery，经过了项目中不断地摸索与总结，得出了一个结论：在jquery技术栈的实际项目开发中，近乎95%的需求都可以通过单例模式来满足实现。</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M23yoqG.R4bU9GAe2In3aKAmMOlYqZziNn0h5jrmD0bbwnadQl6LAL23g98wyqu8tzA!!/b&amp;bo=igFfAYoBXwEDGTw!&amp;rf=viewer_4" alt=""></p><h2 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h2><p>　　适配器模式是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。</p><p>　　适用场景：</p><ul><li><p>使用一个已经存在的对象，但其方法或属性接口不符合你的要求</p></li><li><p>你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作</p></li><li><p>想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性</p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2*plLxWLNIFHV2noL3MqPTwV6D4tjhYmKuX.7ktGSq55RDg*9RUVHZQXQoKn6Ei86w!!/b&amp;bo=NQGGATUBhgEDGTw!&amp;rf=viewer_4" alt=""></p></li></ul><h2 id="推荐ES6，其次ES5，最后ES3"><a href="#推荐ES6，其次ES5，最后ES3" class="headerlink" title="推荐ES6，其次ES5，最后ES3"></a>推荐ES6，其次ES5，最后ES3</h2><ul><li>使用const，let，不使用var</li><li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号</li><li>使用数组成员对变量赋值时，优先使用解构赋值</li><li>立即执行函数可以写成箭头函数的形式。</li><li>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</li><li>使用扩展运算符（…）拷贝数组。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M2xVHPGGJLk3W62UE6tyKSTJxIoiL1WNfqY2Z.4BwTFJ6ThQ*T6b1iW*JaqdLFMr96w!!/b&amp;bo=fgGDAX4BgwEDGTw!&amp;rf=viewer_4" alt=""></p><h1 id="VUE中的实践"><a href="#VUE中的实践" class="headerlink" title="VUE中的实践"></a><strong>VUE中的实践</strong></h1><h2 id="大道至简，通俗易懂"><a href="#大道至简，通俗易懂" class="headerlink" title="大道至简，通俗易懂"></a>大道至简，通俗易懂</h2><ul><li>语义化的标签，可以配合类名实现</li><li>层次结构清晰、简洁，用最少的嵌套实现最复杂的结构</li><li>充分利用sass的作用域，样式私有化，把css样式影响范围最小化</li><li>使用大众化的写法，减少学习的成本</li><li>尽量多使用类选择器，少用标签选择器，实现复用</li><li>CSS样式属性的顺序可以参考前面章节《CSS中的实践》</li><li>把视图展示的部分放在template中，视图层主要负责展示</li><li>把数据（entity）放在data和computed中，数据层主要负责声明（interface, abstract）</li><li>把逻辑放在methods和其他几个api里，控制层主要负责实现</li><li>单向数据流的思想。数据改变可记录、可跟踪，源头易追溯；数据只有唯一入口和出口，更直观更容易理解，提高可维护性。</li><li>注：95%的业务场景最多只需要使用到3-4个生命周期，如果超过了，检查一下自己的代码</li><li>代码风格可参考：<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/</a></li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M25XPE37S.PJb5R.TDgtTRx81Ish1w4ydp8aKx*nIGxP.IzzlF9s.fOfD0V4r*k8h9Q!!/b&amp;bo=OQGRATkBkQEDGTw!&amp;rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M24VY5agn5qVwBEh85A0PcopKQb2zs9c4RGnfmVDuvk5Lhk.nD8Ru1nVcKOG.DPISiQ!!/b&amp;bo=hwGiAYcBogEDGTw!&amp;rf=viewer_4" alt=""></p><h1 id="前端发展的各个阶段"><a href="#前端发展的各个阶段" class="headerlink" title="前端发展的各个阶段"></a>前端发展的各个阶段</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMEY8.2bYL3bj6kzhLfcGo0DOE.J6TQwslagnORkrmyOK8w*X5kLIqIvjaOyxocXvpg!!/b&amp;bo=eAV6AngFegIDCSw!&amp;rf=viewer_4" alt=""></p><h1 id="前端框架的对比"><a href="#前端框架的对比" class="headerlink" title="前端框架的对比"></a>前端框架的对比</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/l8V*4kN5EKtnl2fKnrChMFVfzlATmBYJhyyzdFoRAeC*aEdCjYFOTgf7ZRVGMNX0622SbM6Vk1r5zRYedAO1mQ!!/b&amp;bo=1ARPAtQETwIDCSw!&amp;rf=viewer_4" alt=""></p><h1 id="常用设计模式与代码的结合"><a href="#常用设计模式与代码的结合" class="headerlink" title="常用设计模式与代码的结合"></a>常用设计模式与代码的结合</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M24RthCo7qOxsNTQFCAzzN1QKessjCP2kiRLyTeaEiqTWmJ*9I3a9rcT6N3jvQkv58g!!/b&amp;bo=IgV.ASIFfgEDKQw!&amp;rf=viewer_4" alt=""></p><h1 id="JavaScript语言的特点"><a href="#JavaScript语言的特点" class="headerlink" title="JavaScript语言的特点"></a>JavaScript语言的特点</h1><ul><li>声明提升。代码在执行的时候，js解析器会先把funtion声明和var声明放在前面，然后顺序执行对应的语句。推荐用es6的const，其次let，不推荐用var。</li><li>私有变量。可以通过闭包来实现私有变量的声明，但闭包会让私有变量常驻内存，滥用闭包会造成内存泄露，所以要谨慎使用闭包。</li><li>for-in。对象可以采用传统for-in循环遍历，但该方式会遍历出原型链上的属性，产生意想不到的结果。推荐使用ES6的Object.keys和Object.values结合数组的api。</li><li>多态。JS没有多态，某种意义上说多态与函数的单一原则是对立的，所以建议多类型参数执行的是同一类逻辑的时候用多态。参考：jquery源码的Sizzle引擎。</li><li>单线程。通过异步解决单线程的弊端。但传统异步解决方案通过回调实现，大量嵌套的回调会造成回调地狱的现象，代码可读性很差，不利于维护。推荐使用ES6的Promise和async/await。</li><li>副作用。全面拥抱函数式编程，避免使用有副作用的代码，如ES3中var的声明提升，for-in的副作用，==的隐式转换， BOM中alert的阻塞效果等。</li></ul><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/VWIP8vqzgA*ec2OAYm8M299*8GeMdpjGTKCCRJriLP8pPZ3Cwl1Lg6EhtloA37OiaK73R8KGxyX4RREM4272Ow!!/b&amp;bo=ZwGWAWcBlgEDGTw!&amp;rf=viewer_4" alt=""></p><h1 id="书籍以及社区"><a href="#书籍以及社区" class="headerlink" title="书籍以及社区"></a>书籍以及社区</h1><ul><li><p>《JavaScript权威指南》：犀牛书可以先大致通读几遍，也可以把其当作工具书，时时翻阅。 </p></li><li><p>《JavaScript高级程序设计》：红宝书虽然号称高级，但其实是帮助入门的。小红书配合犀牛书，相互印证。 </p></li><li><p>《你不知道的JavaScript 上中下》：这本绝对是神书，让你了解JavaScript不为人知的另一面，把闭包、异步这些讲得很通透。 </p></li><li><p>《ES6 标准入门（第3版）》阮老师的书，ES6入门书籍。</p></li><li><p>《锋利的jQuery》循序渐进地对jQuery的各种API进行了介绍</p></li><li><p>《 JavaScript模式》陈新 译，系统地讲解了编写高质量代码的技巧和开发过程中最常用的几种设计模式。</p></li><li><p>《重构-改善既有代码的设计》一些写代码的思想层次的东西。</p></li><li><p>《编写可维护的JavaScript 》包括具体风格和原则的介绍，也包括示例和技巧说明</p></li><li><p><a href="http://www.segmentfault.com/" target="_blank" rel="noopener">思否社区</a>：中国版<a href="http://www.stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></p></li></ul><h1 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h1><p>　　软件bug的修改是需要成本的，并且这项成本总是在不断地增加，特别是对于已经广泛发布的产品代码而言，更是如此。最好的情况是当我们一发现bug，立刻就可以修改它，这种情况只发生在刚写完这些代码后不久。否则转移到新的任务上，忘记了这部分代码，就需要重新阅读这些代码。</p><p>　　对于大型项目而言，还存在着另一个问题，就是最终修改代码的人，往往并不是当初写代码的人，也不是发现bug的人。因此，减少理解自己以前写的代码的时间，或者减少理解团队中他人写的代码的时间，就变得非常关键。</p><p>　　另外一个事实在于，软件开发人员通常读代码比写代码更耗时间。通常的情形是，当我们专注于某个问题时，会坐下来花一下午的时间编写出大量的代码。这些代码可能当天就可运行，但要想成为一项成熟的应用，需要我们对代码进行重新检查、重新校正、重新调整。</p><p>　　编写高质量的代码是十分重要的，不仅对于成功地完成项目十分有利，而且有利于开发者与开发团队的其他人员进行交流。提高代码的质量，可能最初只是几小时工时写出来的代码，最终需要花费几周的工时来阅读。这就是为什么编写易维护的高质量的代码对项目具有举足轻重的作用。</p><p>　　代码的质量从某种意义上来说就是一个系统的生命线，任何上线的系统都是通过了测试的，但代码的质量决定了这个系统能走多远！我在新闻上听说过有人删库跑路的，也见过有人接手老项目后马上离职的，其中有一些就和老代码的质量问题有着必然的联系。</p><p>　　代码质量和效率之间有着天然的矛盾，怎么去平衡值得我们去思考，下面是我的一点心得与体会：1、代码风格；2、code review；3、抽离、封装、复用；4、持续学习和持续实践；5、开发周期与代码质量的平衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端代码质量的思考与实践&quot;&gt;&lt;a href=&quot;#前端代码质量的思考与实践&quot; class=&quot;headerlink&quot; title=&quot;前端代码质量的思考与实践&quot;&gt;&lt;/a&gt;前端代码质量的思考与实践&lt;/h1&gt;&lt;p&gt;编写可读的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是能够被阅读，其次才是能够被正确执行。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结，除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。&lt;/p&gt;
&lt;p&gt;JavaScript 是动态和弱类型的语言，使用起来比较轻松随意，在IE6那个刀耕火种的时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端工程化技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码 质量 实践 思考 可读性" scheme="http://www.icrazyman.cn/tags/%E4%BB%A3%E7%A0%81-%E8%B4%A8%E9%87%8F-%E5%AE%9E%E8%B7%B5-%E6%80%9D%E8%80%83-%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「译」编写更好的 JavaScript 条件式和匹配条件的技巧</title>
    <link href="http://www.icrazyman.cn/2019/06/26/%E3%80%8C%E8%AF%91%E3%80%8D%E7%BC%96%E5%86%99%E6%9B%B4%E5%A5%BD%E7%9A%84%20JavaScript%20%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.icrazyman.cn/2019/06/26/「译」编写更好的 JavaScript 条件式和匹配条件的技巧/</id>
    <published>2019-06-26T12:46:29.000Z</published>
    <updated>2019-06-26T12:48:09.691Z</updated>
    
    <content type="html"><![CDATA[<ol start="10"><li>原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria</li></ol><ul><li>原文作者：Milos Protic</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。</p><p>正如我在另一篇文章 <a href="https://devinduct.com/blogpost/22/javascript-clean-code-best-practices" target="_blank" rel="noopener">JavaScript 整洁代码的最佳实践</a>里提到的，你写的代码不单单是给机器看的，还是给“<b>未来的自己</b>”以及“<b>其他人</b>”看的。</p><p>从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。</p><a id="more"></a><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>以下是关于如何构造 <code>if...else</code> 语句以及如何用更少的代码实现更多功能的技巧。阅读愉快！</p><h2 id="1-要事第一。小细节，但很重要"><a href="#1-要事第一。小细节，但很重要" class="headerlink" title="1. 要事第一。小细节，但很重要"></a>1. 要事第一。小细节，但很重要</h2><p>不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 <code>boolean</code> 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。</p><p>不好的：</p><pre><code class="js">const isEmailNotVerified = (email) =&gt; {    // 实现}if (!isEmailNotVerified(email)) {    // 做一些事...}if (isVerified === true) {    // 做一些事...}</code></pre><p>好的：</p><pre><code class="js">const isEmailVerified = (email) =&gt; {    // 实现}if (isEmailVerified(email)) {    // 做一些事...}if (isVerified) {    // 做一些事...}</code></pre><p>现在，理清了上面的事情后，我们就可以开始了。</p><h2 id="2-对于多个条件，使用-Array-includes"><a href="#2-对于多个条件，使用-Array-includes" class="headerlink" title="2. 对于多个条件，使用 Array.includes"></a>2. 对于多个条件，使用 <code>Array.includes</code></h2><p>假设我们想要在函数中检查汽车模型是 <code>renault</code> 还是 <code>peugeot</code>。那么代码可能是这样的：</p><pre><code class="js">const checkCarModel = (model) =&gt; {    if(model === &#39;renault&#39; || model === &#39;peugeot&#39;) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 <code>or</code> 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数</p><pre><code class="js">const checkCarModel = (model) =&gt; {    if([&#39;peugeot&#39;, &#39;renault&#39;].includes(model)) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：</p><pre><code class="js">const checkCarModel = (model) =&gt; {    const models = [&#39;peugeot&#39;, &#39;renault&#39;];    if(models.includes(model)) {     console.log(&#39;model valid&#39;);    }}checkCarModel(&#39;renault&#39;); // 输出 &#39;model valid&#39;</code></pre><p>现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 <code>models</code> 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。</p><h2 id="3-匹配所有条件，使用-Array-every-或者-Array-find"><a href="#3-匹配所有条件，使用-Array-every-或者-Array-find" class="headerlink" title="3. 匹配所有条件，使用 Array.every 或者 Array.find"></a>3. 匹配所有条件，使用 <code>Array.every</code> 或者 <code>Array.find</code></h2><p>在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：</p><pre><code class="js">const cars = [  { model: &#39;renault&#39;, year: 1956 },  { model: &#39;peugeot&#39;, year: 1968 },  { model: &#39;ford&#39;, year: 1977 }];const checkEveryModel = (model) =&gt; {  let isValid = true;  for (let car of cars) {    if (!isValid) {      break;    }    isValid = car.model === model;  }  return isValid;}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><p>如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 <code>Array.every</code> 或者 <code>Array.find</code> 来达到相同的结果。</p><pre><code class="js">const checkEveryModel = (model) =&gt; {  return cars.every(car =&gt; car.model === model);}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><p>通过使用 <code>Array.find</code> 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 <code>falsy</code> 项时立即返回 <code>false</code>。</p><pre><code class="js">const checkEveryModel = (model) =&gt; {  return cars.find(car =&gt; car.model !== model) === undefined;}console.log(checkEveryModel(&#39;renault&#39;)); // 输出 false</code></pre><h2 id="4-匹配部分条件，使用-Array-some"><a href="#4-匹配部分条件，使用-Array-some" class="headerlink" title="4. 匹配部分条件，使用 Array.some"></a>4. 匹配部分条件，使用 <code>Array.some</code></h2><p><code>Array.every</code> 匹配所有条件，这个方法则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。</p><p>我们可以通过编写一个类似的 <code>for...loop</code> 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。</p><pre><code class="js">const cars = [  { model: &#39;renault&#39;, year: 1956 },  { model: &#39;peugeot&#39;, year: 1968 },  { model: &#39;ford&#39;, year: 1977 }];const checkForAnyModel = (model) =&gt; {  return cars.some(car =&gt; car.model === model);}console.log(checkForAnyModel(&#39;renault&#39;)); // 输出 true</code></pre><h2 id="5-提前返回而不是使用-if-else-分支"><a href="#5-提前返回而不是使用-if-else-分支" class="headerlink" title="5. 提前返回而不是使用 if...else 分支"></a>5. 提前返回而不是使用 <code>if...else</code> 分支</h2><p>当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 <code>if...else</code> 嵌套将会让我们感到很痛苦。</p><p>另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。</p><p>举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：</p><pre><code class="js">const checkModel = (car) =&gt; {  let result; // 首先，定义一个 result 变量  // 检查是否有车  if(car) {    // 检查是否有车的模型    if (car.model) {      // 检查是否有车的年份      if(car.year) {        result = `Car model: ${car.model}; Manufacturing year: ${car.year};`;      } else {        result = &#39;No car year&#39;;      }    } else {      result = &#39;No car model&#39;    }     } else {    result = &#39;No car&#39;;  }  return result; // 我们的单独的返回语句}console.log(checkModel()); // 输出 &#39;No car&#39;console.log(checkModel({ year: 1988 })); // 输出 &#39;No car model&#39;console.log(checkModel({ model: &#39;ford&#39; })); // 输出 &#39;No car year&#39;console.log(checkModel({ model: &#39;ford&#39;, year: 1988 })); // 输出 &#39;Car model: ford; Manufacturing year: 1988;&#39;</code></pre><p>正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 <code>if...else</code> 语句。</p><p>我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 <code>&amp;&amp;</code> 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。</p><pre><code class="js">const checkModel = ({model, year} = {}) =&gt; {  if(!model &amp;&amp; !year) return &#39;No car&#39;;  if(!model) return &#39;No car model&#39;;  if(!year) return &#39;No car year&#39;;  // 这里可以任意操作模型或年份  // 确保它们存在  // 无需更多检查  // doSomething(model);  // doSomethingElse(year);  return `Car model: ${model}; Manufacturing year: ${year};`;}console.log(checkModel()); // 输出 &#39;No car&#39;console.log(checkModel({ year: 1988 })); // 输出 &#39;No car model&#39;console.log(checkModel({ model: &#39;ford&#39; })); // 输出 &#39;No car year&#39;console.log(checkModel({ model: &#39;ford&#39;, year: 1988 })); // 输出 &#39;Car model: ford; Manufacturing year: 1988;&#39;</code></pre><p>在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 <code>undefined</code> 时有可用于解构的值。注意，如果传入 <code>null</code> ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 null 的时候会输出 <code>&#39;No car&#39;</code>。</p><p>对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。</p><p>根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 <code>if...else</code> 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。</p><h2 id="6-使用索引或者映射，而不是-switch-语句"><a href="#6-使用索引或者映射，而不是-switch-语句" class="headerlink" title="6. 使用索引或者映射，而不是 switch 语句"></a>6. 使用索引或者映射，而不是 <code>switch</code> 语句</h2><p>假设我们想要基于给定的国家获取汽车模型。</p><pre><code class="js">const getCarsByState = (state) =&gt; {  switch (state) {    case &#39;usa&#39;:      return [&#39;Ford&#39;, &#39;Dodge&#39;];    case &#39;france&#39;:      return [&#39;Renault&#39;, &#39;Peugeot&#39;];    case &#39;italy&#39;:      return [&#39;Fiat&#39;];    default:      return [];  }}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); // 输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;italy&#39;)); // 输出 [&#39;Fiat&#39;]</code></pre><p>上诉代码可以重构，完全去除 <code>switch</code> 语句。</p><pre><code class="js">const cars = new Map()  .set(&#39;usa&#39;, [&#39;Ford&#39;, &#39;Dodge&#39;])  .set(&#39;france&#39;, [&#39;Renault&#39;, &#39;Peugeot&#39;])  .set(&#39;italy&#39;, [&#39;Fiat&#39;]);const getCarsByState = (state) =&gt; {  return cars.get(state) || [];}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); //输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;italy&#39;)); // 输出 [&#39;Fiat&#39;]</code></pre><p>或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。</p><pre><code class="js">const carState = {  usa: [&#39;Ford&#39;, &#39;Dodge&#39;],  france: [&#39;Renault&#39;, &#39;Peugeot&#39;],  italy: [&#39;Fiat&#39;]};const getCarsByState = (state) =&gt; {  return carState[state] || [];}console.log(getCarsByState()); // 输出 []console.log(getCarsByState(&#39;usa&#39;)); // 输出 [&#39;Ford&#39;, &#39;Dodge&#39;]console.log(getCarsByState(&#39;france&#39;)); // 输出 [&#39;Renault&#39;, &#39;Peugeot&#39;]</code></pre><h2 id="7-使用自判断链接和空合并"><a href="#7-使用自判断链接和空合并" class="headerlink" title="7. 使用自判断链接和空合并"></a>7. 使用自判断链接和空合并</h2><p>到了这一小节，我终于可以说“最后”了。在我看来，这两个功能对于 JavaScript 语言来说是非常有用的。作为一个来自 C# 世界的人，可以说我经常使用它们。</p><p>在写这篇文章的时候，这些还没有得到完全的支持。因此，对于以这种方式编写的代码，你需要使用 Babel 进行编译。你可以在自判断链接这里以及在空合并这里查阅。</p><p>自判断链接允许我们在没有显式检查中间节点是否存在的时候处理树形结构，空合并可以确保节点不存在时会有一个默认值，配合自判断链接使用会有不错的效果。</p><p>让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：</p><pre><code class="js">const car = {  model: &#39;Fiesta&#39;,  manufacturer: {    name: &#39;Ford&#39;,    address: {      street: &#39;Some Street Name&#39;,      number: &#39;5555&#39;,      state: &#39;USA&#39;    }  }}// 获取汽车模型const model = car &amp;&amp; car.model || &#39;default model&#39;;// 获取厂商地址const street = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.street || &#39;default street&#39;;// 请求一个不存在的属性const phoneNumber = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.phoneNumber;console.log(model) // 输出 &#39;Fiesta&#39;console.log(street) // 输出 &#39;Some Street Name&#39;console.log(phoneNumber) // 输出 undefined</code></pre><p>因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：</p><pre><code class="js">const checkCarManufacturerState = () =&gt; {  if(car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.state === &#39;USA&#39;) {    console.log(&#39;Is from USA&#39;);  }}checkCarManufacturerState() // 输出 &#39;Is from USA&#39;</code></pre><p>我无需再赘述如果对象结构更加复杂的话，代码会多么混乱了。许多库，例如 lodash，有自己的函数作为替代方案。不过这不是我们想要的，我们想要的是在原生 js 中也能做同样的事。我们来看一下新的方法：</p><pre><code class="js">// 获取汽车模型const model = car?.model ?? &#39;default model&#39;;// 获取厂商地址const street = car?.manufacturer?.address?.street ?? &#39;default street&#39;;// 检查汽车厂商是否来自 USAconst checkCarManufacturerState = () =&gt; {  if(car?.manufacturer?.address?.state === &#39;USA&#39;) {    console.log(&#39;Is from USA&#39;);  }}</code></pre><p>这看起来更加漂亮和简洁，对我来说，非常符合逻辑。如果你想知道为什么应该使用 <code>??</code> 而不是 <code>||</code> ，只需想一想什么值可以当做 <code>true</code> 或者 <code>false</code>，你将可能有意想不到的输出。</p><p>顺便说句题外话。自判断链接同样支持 DOM API，这非常酷，意味着你可以这么做：</p><pre><code class="js">const value = document.querySelector(&#39;input#user-name&#39;)?.value;</code></pre><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><blockquote><p>对于编码过程中的面条式代码和嵌套式的if/else判断深恶痛绝，但又无可奈何，最近看了一些技术文章，专门提到过javascript复杂判断的优雅写法，深入地学习了一下，现在总算知道一些复杂场景导致复杂的判断如何优雅地编码了，以后尽量不要再写if/else了，都是有更好的解决方案的。以下是自己学习中写的demo，记录一下：</p></blockquote><pre><code class="js">// 一般写法 var status = 1 if(status === 1) {   console.log(status) } else if(status === 2) {   console.log(status) } else if(status === 3) {   console.log(status) } else if(status === 4) {   console.log(status) } else {   console.log(status) }// switch写法 var status = 1 console.log(typeof status); switch(status - 0) {   case 1:     console.log(1);     break;   case 2:   case 3:     console.log(3);     break;   case 4:     console.log(4);     break;   default:     console.log(5);     break; }// 用对象实现多分支判断 var status = 3 const actions1 = {   1: () =&gt; { console.log(1) },   2: () =&gt; { console.log(2) },   3: () =&gt; { console.log(3) },   4: () =&gt; { console.log(4) },   &#39;default&#39;: () =&gt; { console.log(5) }, } actions1[status] ? actions1[status]() : actions1[&#39;default&#39;]() // 3//用es6的Map对象封装逻辑 var status = 2 const actions = new Map([   [1, () =&gt; console.log(1)],   [2, () =&gt; console.log(2)],   [3, () =&gt; console.log(3)],   [4, () =&gt; console.log(4)],   [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)], ]) actions.get(status - 0) ? actions.get(status - 0)() : actions.get(&#39;default&#39;)() // 2// 二元判断 var identify = &#39;guest3&#39; var status = 2 var actions = new Map([     [&#39;guest1_1&#39;, () =&gt; console.log(&#39;guest_1&#39;)],     [&#39;guest2_2&#39;, () =&gt; console.log(&#39;guest_2&#39;)],     [&#39;guest3_3&#39;, () =&gt; console.log(&#39;guest_3&#39;)],     [&#39;guest4_4&#39;, () =&gt; console.log(&#39;guest_4&#39;)],     [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)] ]) actions.get(`${identify}_${status}`) ? actions.get(`${identify}_${status}`)() : actions.get(&#39;default&#39;)() // default// 用对象也可以作二元判断 var identify = &#39;guest2&#39; var status = 3 var actions = {     &#39;guest1_1&#39;: () =&gt; console.log(&#39;guest1_1&#39;),     &#39;guest2_2&#39;: () =&gt; console.log(&#39;guest2_2&#39;),     &#39;guest3_3&#39;: () =&gt; console.log(&#39;guest3_3&#39;),     &#39;guest4_4&#39;: () =&gt; console.log(&#39;guest4_4&#39;),     &#39;default&#39;: () =&gt; console.log(&#39;default&#39;), } actions[`${identify}_${status}`] ? actions[`${identify}_${status}`]() : actions[&#39;default&#39;]() //  default</code></pre><h2 id="关于多元判断的解决方案如下："><a href="#关于多元判断的解决方案如下：" class="headerlink" title="关于多元判断的解决方案如下："></a>关于多元判断的解决方案如下：</h2><pre><code class="js">const status1 = 3;const status2 = 2;const actions = new Map([  [&#39;11&#39;, () =&gt; console.log(&#39;11&#39;)],  [&#39;12&#39;, () =&gt; console.log(&#39;12&#39;)],  [&#39;13&#39;, () =&gt; console.log(&#39;13&#39;)],  [&#39;21&#39;, () =&gt; console.log(&#39;21&#39;)],  [&#39;22&#39;, () =&gt; console.log(&#39;22&#39;)],  [&#39;23&#39;, () =&gt; console.log(&#39;23&#39;)],  [&#39;31&#39;, () =&gt; console.log(&#39;31&#39;)],  [&#39;32&#39;, () =&gt; console.log(&#39;32&#39;)],  [&#39;33&#39;, () =&gt; console.log(&#39;33&#39;)],  [&#39;default&#39;, () =&gt; console.log(&#39;default&#39;)]])actions.get(`${status1}${status2}`) ? actions.get(`${status1}${status2}`)() : actions.get(&#39;default&#39;)() // 23</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;原文作者：Milos Protic&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。&lt;/p&gt;
&lt;p&gt;正如我在另一篇文章 &lt;a href=&quot;https://devinduct.com/blogpost/22/javascript-clean-code-best-practices&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 整洁代码的最佳实践&lt;/a&gt;里提到的，你写的代码不单单是给机器看的，还是给“&lt;b&gt;未来的自己&lt;/b&gt;”以及“&lt;b&gt;其他人&lt;/b&gt;”看的。&lt;/p&gt;
&lt;p&gt;从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 风格 编码 技巧" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E9%A3%8E%E6%A0%BC-%E7%BC%96%E7%A0%81-%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>新手使用vue-router传参时注意事项</title>
    <link href="http://www.icrazyman.cn/2019/06/12/%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8vue-router%E4%BC%A0%E5%8F%82%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://www.icrazyman.cn/2019/06/12/新手使用vue-router传参时注意事项/</id>
    <published>2019-06-12T14:03:27.000Z</published>
    <updated>2019-06-18T11:22:41.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新手使用vue-router传参时注意事项"><a href="#新手使用vue-router传参时注意事项" class="headerlink" title="新手使用vue-router传参时注意事项"></a>新手使用vue-router传参时注意事项</h1><p>vue-router里路由传参推荐用path和query的组合，或者是name和params的组合。其中name+params传参在刷新页面后路由参数会丢失，可以在路由配置时把参数配在url上，path+query的传参刷新页面后不会丢失，但是传参会拼接到url后，有长度的限制。具体用哪一种传参方式取决于业务的需要和实际的应用场景。</p><a id="more"></a><h1 id="使用name和params组合传参"><a href="#使用name和params组合传参" class="headerlink" title="使用name和params组合传参"></a>使用name和params组合传参</h1><blockquote><pre><code class="javascript">this.$router.push({name: &#39;details&#39;, params: {&#39;id&#39;: 233}})    </code></pre></blockquote><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><pre><code class="javascript">import Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;Vue.use(Router)export default new Router({    mode: &#39;history&#39;,    routes: [        {            path: &#39;/details&#39;,            name: &#39;details&#39;,            component: resolve =&gt; require([&#39;../components/details&#39;], resolve)        }    ]})</code></pre><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><pre><code class="javascript">this.$route.params.id // 233</code></pre><p><img src="C:\Users\Administrator\Desktop\1.png" alt="1"></p><h2 id="刷新参数丢失-显示-undefined"><a href="#刷新参数丢失-显示-undefined" class="headerlink" title="刷新参数丢失 显示 undefined"></a>刷新参数丢失 显示 undefined</h2><pre><code class="javascript">this.$route.params.id // undefined</code></pre><p><img src="https://segmentfault.com/img/bVbtyj2?w=1414&amp;h=1022" alt="图片"></p><p>注意：此方法第一次跳转是没有问题的，参数也可以传过去，但是刷新页面后，参数就没了 (ps: 这个地方其实还有一个问题，当你传递的参数是number类型，第一次是没有问题的，获取的时候也是number类型，但是当你刷新页面后，number变成string类型，如果涉及计算的建议先类型转换一下)</p><p>第一次是预期结果 // 234</p><pre><code class="javascript">console.log(this.$route.params.id + 1)</code></pre><p><img src="https://segmentfault.com/img/bVbtyon?w=1290&amp;h=1016" alt=""></p><p>刷新页面后直接字符串拼接了 // 2331</p><p><img src="https://segmentfault.com/img/bVbtyoo?w=1006&amp;h=1050" alt=""></p><h2 id="参数丢失解决方案"><a href="#参数丢失解决方案" class="headerlink" title="参数丢失解决方案"></a>参数丢失解决方案</h2><pre><code class="javascript">routes: [    {        path: &#39;/details/:id&#39;, // 这里配置的要和你传递的参数名保持一致        name: &#39;details&#39;,        component: resolve =&gt; require([&#39;../components/details&#39;], resolve)    }]</code></pre><h1 id="path和query组合传参"><a href="#path和query组合传参" class="headerlink" title="path和query组合传参"></a>path和query组合传参</h1><pre><code class="javascript">this.$router.push({path: &#39;/details&#39;, query: {id: 666}})this.$route.query.id // 666</code></pre><p><img src="https://segmentfault.com/img/bVbtyqO?w=1150&amp;h=1046" alt=""></p><p>此方法参数会跟在问号后面 例如：/details?id=666，该方法刷新页面不会丢失参数</p><p>最后：根据自己的项目选择合适的传参方式</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新手使用vue-router传参时注意事项&quot;&gt;&lt;a href=&quot;#新手使用vue-router传参时注意事项&quot; class=&quot;headerlink&quot; title=&quot;新手使用vue-router传参时注意事项&quot;&gt;&lt;/a&gt;新手使用vue-router传参时注意事项&lt;/h1&gt;&lt;p&gt;vue-router里路由传参推荐用path和query的组合，或者是name和params的组合。其中name+params传参在刷新页面后路由参数会丢失，可以在路由配置时把参数配在url上，path+query的传参刷新页面后不会丢失，但是传参会拼接到url后，有长度的限制。具体用哪一种传参方式取决于业务的需要和实际的应用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue vue-router 框架" scheme="http://www.icrazyman.cn/tags/vue-vue-router-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://www.icrazyman.cn/2019/04/18/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.icrazyman.cn/2019/04/18/vue学习笔记/</id>
    <published>2019-04-18T07:21:44.816Z</published>
    <updated>2019-04-18T07:51:55.683Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为换工作，忙着找下家的缘故，好久没做一些学习总结了，趁着新东家的项目都做完的比较空闲的缘故，把最近新学习的技术归纳整理一下吧！之前在学习react的时候就对比了解过vue和react的优势和区别了，虽然react在大型项目上比vue有优势，社区也更强大，但在武汉这个市场绝大部分还是已vue为主，之前工作中用的是react，所以一直都在学的react，同时vue比较简单，学习曲线比较平缓，所以当时也没急着去研究vue了。这次换了新东家，项目是用的vue+vuex+axios+vux框架+webpack搭的项目，正好也跟着项目仔细地研究了vue技术栈，确实没有react那么复杂，现把一些学习和工作中的学习笔记记录下来，以便以后可以复习。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>直接引入链接：建议初学者使用；</li><li>通过node.js的NPM安装Vue；</li><li>通过node.js的NPM安装Vue-cli脚手架（推荐安装方式）；</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>字符串：title: ‘hello world’；</li><li>数字：num:123；</li><li>数组：arrow: [‘apple’, ‘banana’,’orange’]；</li><li>对象：name: {firstName:’ming’,lastName:’Li’}；</li><li>布尔值：true/false；</li></ul><h3 id="模版数据绑定"><a href="#模版数据绑定" class="headerlink" title="模版数据绑定"></a>模版数据绑定</h3><ul><li>：模版解析；</li><li>v-text：文本绑定；</li><li>v-model：数据双向绑定；v-model.lazy：延迟对数据进行更新；<ul><li>v-model.number：对输入的数据字符串转为数字；</li><li>v-model.trim：对数据进行裁剪，去除空格等</li></ul></li></ul><h3 id="表单数据绑定"><a href="#表单数据绑定" class="headerlink" title="表单数据绑定"></a>表单数据绑定</h3><ul><li>checkbox：储存的数据类型是数组；</li><li>radio：储存的数据类型是字符串；</li><li>select：存储的数据类型是字符串；</li></ul><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ul><li>v-bind：标签属性绑定，属于动态绑定，可以简写为：。绑定后的属性为变量，可以是字符串，数组或者是对象；</li><li>v-if/v-if-else-if/v-else：条件渲染，如果成立则执行，不成立则注销；</li><li>v-show：同样是条件渲染，不同的是不成立是隐藏而不是注销；</li></ul><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li>通过v-on:event=”eventName”进行绑定，可简写为@:event=”eventName”;方法通过在methods里进行方法定义；</li><li>在v-on:event.midiflyer添加修改器；</li><li>自定义事件：v-on:diyEvent=”eventName”，通过$emit来触发自定义事件。<code>methods: {my-function () {this.$emit(&#39;diyEvent&#39;), 参数}}</code>；</li></ul><h3 id="计算属性和数据监听"><a href="#计算属性和数据监听" class="headerlink" title="计算属性和数据监听"></a>计算属性和数据监听</h3><ul><li>传值属性：props: [‘xx’,’xx’]。父子组件如果需要传值，必须要在props里进行定义；</li><li>事件属性：methods: {}。所有事件都在这里进行定义；很多情况下在执行事件时需要取消默认事件。function(e){e.preventDefault();}；</li><li>计算属性：computed: {方法 () { return 方法 }}；计算属性的优点：可以直接根据data的属性动态的更改（data中myValue的值变化会同步反映到计算属性里）（计算属性会缓存所依赖的那个值，直到那个值发生变化，否则不会重新取值）与方法调用的缺点：调用方法的时候才会更新，即使data中myValue的值没有变化，调用时依然会去重新取值。使用场景：在耗时、大量搜索的情况下使用，减少dom重复渲染的性能支出。</li><li>创建属性：created:function(){}。方法不需要手动调用，直接执行。</li><li>数据监听：watch: { 方法 () {}}；</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="动态绑定class"><a href="#动态绑定class" class="headerlink" title="动态绑定class"></a>动态绑定class</h4><ul><li>v-bind:class=”{red:true}”；</li><li>v-bind:class={changeClass:changeClass}；</li><li>v-bind:class={active ? true : false}</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>不强制要求按照W3C规则进行命名，但最好遵循。例如：<code>my-template</code>;</li><li>不管组件是大驼峰还是小驼峰，在模版引用的时候一律要转为中横线的命名方式。例如：组件为<code>comName</code>，引用时为：<code>&lt;com-name&gt;&lt;/com-name&gt;</code>；在传递属性时名称也同样。</li></ul><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>全局注册：<code>Vue.component(&#39;my-template&#39;, {template: &#39;...&#39;});</code>  html：<code>&lt;my-template&gt;&lt;/my-template&gt;</code></li><li>局部注册：只在使用的场景进行注册。<code>var myTemplate = {template: &#39;...&#39;};  new Vue({..., components: {&#39;my-template: myTemplate&#39;}})</code></li></ul><h3 id="模版解析"><a href="#模版解析" class="headerlink" title="模版解析"></a>模版解析</h3><ul><li>特殊标签下的模版需要注意，比如table、ol、ul、select等标签，使用<code>is</code>进行挂载。例如:<code>&lt;table&gt;&lt;tr is=&quot;my-tr&quot;&gt;&lt;/tr&gt;&lt;/table&gt;</code>;</li><li><p>推荐使用字符串模版：</p></li><li><p><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>；</p></li><li>javascript内联模版字符串；</li><li><p>vue组件；</p></li><li><p>组件中的data必须是函数。</p></li></ul><h3 id="组件组合"><a href="#组件组合" class="headerlink" title="组件组合"></a>组件组合</h3><ul><li>父组件通过prop进行向下传递；</li><li>子组件通过事件进行发送信息，子组件触发事件，父组件进行监听；</li><li>传值时要主要命名的选择和使用，使用props使用的驼峰式明显需要转变为对应的中横线式。<code>Vue.component(&#39;my-template&#39;, {props: [&#39;myMessage&#39;],template: &#39;...&#39;}); &lt;my-template   my-message=&quot;hello&quot;&gt;&lt;/my-template&gt;</code></li><li>字面量语法和动态语法；</li><li>slot插槽：父组件向子组件插入template模板，父子之间通过slot属性和name属性进行对应<code>&lt;p slot=&quot;header&quot;&gt;我是header&lt;/p&gt;&lt;span slot=&quot;footer&quot;&gt;我是footer&lt;/span&gt;</code>；</li><li>动态组件：利用 <code>:is = &quot;&quot;</code> 进行组件的动态绑定，外层可以用内置组件keep-alive 来进行缓存；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用组件树设计项目，配置文件链接各个组件-命名转换，动态组件；</li><li>父组件向内传递属性-动态属性；</li><li>子组件向外发布事件；</li><li>slot插槽传递模版 - 具名slot；</li></ul><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="动画：使用transition-内置组件，有css过渡和js过渡两种方式。"><a href="#动画：使用transition-内置组件，有css过渡和js过渡两种方式。" class="headerlink" title="动画：使用transition 内置组件，有css过渡和js过渡两种方式。"></a>动画：使用transition 内置组件，有css过渡和js过渡两种方式。</h3><h4 id="css过渡实现原理：给动画的不同阶段加上不同的class名称。"><a href="#css过渡实现原理：给动画的不同阶段加上不同的class名称。" class="headerlink" title="css过渡实现原理：给动画的不同阶段加上不同的class名称。"></a>css过渡实现原理：给动画的不同阶段加上不同的class名称。</h4><ul><li>四个阶段：v-enter/v-enter-active/v-leave/v-leave-active；使用：<code>&lt;transition name=&quot;fade&quot;&gt;&lt;/transition&gt;</code>  .fade-enter/.fade-enter-active/.fade-leave/.fade-leave-active；</li><li>能够接受动画的元素有：v-show/v-if/动态组件加载；</li><li>通过mode=”out-in”/“in-out”实现动画顺序；</li><li>对于多元素模版，如果使用的是同标签名，需要使用key来进行区分；</li></ul><h4 id="js过渡实现原理：通过定义不同的方法来实现动画。"><a href="#js过渡实现原理：通过定义不同的方法来实现动画。" class="headerlink" title="js过渡实现原理：通过定义不同的方法来实现动画。"></a>js过渡实现原理：通过定义不同的方法来实现动画。</h4><p>不同方法名：</p><p><code>&lt;transition      v-on:before-enter=&quot;beforeEnter&quot;      v-on:enter=&quot;enter&quot;      v-on:after-enter=&quot;afterEnter&quot;      v-on:enter-cancelled=&quot;enterCancelled&quot;      v-on:before-leave=&quot;beforeLeave&quot;      v-on:leave=&quot;leave&quot;      v-on:after-leave=&quot;afterLeave&quot;      v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;    ...    &lt;/transition&gt;</code></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><ul><li>方法：主要有两种：局部定义和全局定义。</li><li>使用：inserted和bind是指令的两个配置属性，属性值是一个函数，所以用es6语法。讲inserted函数，，然后然后回到组件，处理el表示使用了指令的元素对象，还有一个binding对象，其中binding.value表示的是使用了指令元素的指令的值，可以是json，然后借这个json（里面放着css相关信息）所包含的数据来修改dom的样式。</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>vue-resource： 发送http请求</li><li>vue-router：   前端路由</li><li>引入步骤：<ul><li>入口js文件 import  from  插件 </li><li>Vue.use(插件)  不过在模块环境中应当始终显式调用 Vue.use() :</li></ul></li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><ul><li>Node.js</li><li>NPM</li><li>Mustache</li><li>ECMAscript</li><li>Javascript</li><li>Ajax</li></ul><h2 id="Vue全家桶"><a href="#Vue全家桶" class="headerlink" title="Vue全家桶"></a>Vue全家桶</h2><ul><li>vue.js</li><li>vue-cli</li><li>vue-router</li><li>vue-axios</li><li>vue-lazyload</li></ul><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><ul><li>Webpack</li><li>Gulp</li><li>Parcel</li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul><li>Css-loader</li><li>Sass-loader</li><li>Vue-style-loader</li><li>Superagent</li></ul><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul><li>在开发过程中，如果修改了配置文件，需要重新启动，否则报错；</li><li>手写输入的拼写错误问题，一般会提示出来；</li><li>样式文件中的拼写错误，包括属性、值、图片名称，如果找不到也会报错，一般很难找到，所以出现报错的时候一定先要解决！！</li><li>使用webpack要进行loader依赖的安装；</li><li>proxyTable 反向代理设置；</li><li>在组件中template节点下必须只有一个子节点；</li><li>如果采用webpack进行打包管理，如果数据中有需要在js里引用图片地址，需要使用<code>require()</code>的方式进行引用，否则不会被打包到静态文件目录里；</li><li>在组件使用时候先进行数据绑定；</li><li>在使用属性的时候一定记得要添加作用域，比如this；</li><li>在组件或者模版中使用sass或less文件，一定要在style标签上声明lang，否则报错没商量；</li><li>在组件开发过程中，如果需要传参一定记得定义并且在引用的地方调用；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为换工作，忙着找下家的缘故，好久没做一些学习总结了，趁着新东家的项目都做完的比较空闲的缘故，把最近新学习的技术归纳整理一下吧！之前在学习react的时候就对比了解过vue和react的优势和区别了，虽然react在大型项目上比vue有优势，社区也更强大，但在武汉这个市场绝大部分还是已vue为主，之前工作中用的是react，所以一直都在学的react，同时vue比较简单，学习曲线比较平缓，所以当时也没急着去研究vue了。这次换了新东家，项目是用的vue+vuex+axios+vux框架+webpack搭的项目，正好也跟着项目仔细地研究了vue技术栈，确实没有react那么复杂，现把一些学习和工作中的学习笔记记录下来，以便以后可以复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue 框架 学习 笔记" scheme="http://www.icrazyman.cn/tags/vue-%E6%A1%86%E6%9E%B6-%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>手写一个简单版本的Promise</title>
    <link href="http://www.icrazyman.cn/2019/02/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E7%9A%84Promise/"/>
    <id>http://www.icrazyman.cn/2019/02/14/手写一个简单版本的Promise/</id>
    <published>2019-02-14T12:59:11.000Z</published>
    <updated>2019-02-14T13:08:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h1><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p></blockquote><blockquote><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、resolved（已成功）和rejected（已失败）。一旦成功就不允许失败，一旦失败就不允许成功。</p></blockquote><a id="more"></a><h1 id="先把一个空架子搭出来"><a href="#先把一个空架子搭出来" class="headerlink" title="先把一个空架子搭出来"></a>先把一个空架子搭出来</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 失败回调列表    function resolve() {}; // 成功的方法    function rejecte() {}; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then(function(onFulfilled, onRejected) {})</code></pre><h1 id="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"><a href="#因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法" class="headerlink" title="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"></a>因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 拒绝回调列表    function resolve(value) {        self.status = RESOLVED; // 把状态改为resolved        self.value = value;        self.resolvedCallbacks.map(cb =&gt; cb(self.value)); // 分别执行成功回调列表里的方法，并传入value    }; // 成功的方法    function reject(value) {        self.status = REJECTED; // 把状态改为rejected        self.value = value;        self.rejectedCallbacks.map(cb =&gt; cb(self.value)); //分别执行拒绝回调列表里的方法，并传入value    }; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then(function(onFulfilled, onRejected) {})</code></pre><h1 id="返回的promise具有then方法，并能获取到初始化数据"><a href="#返回的promise具有then方法，并能获取到初始化数据" class="headerlink" title="返回的promise具有then方法，并能获取到初始化数据"></a>返回的promise具有then方法，并能获取到初始化数据</h1><pre><code class="js">MyPromise.prototype.then = function(onFulfilled, onRejected) {    const self = this;    if(self.status === PENDING) { // 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里        self.resolvedCallbacks.push(onFulfilled);        self.rejectedCallbacks.push(onRejected);    }    // 初始化后再调用then方法根据初始化的状态分别执行对应的方法    if(self.status === RESOLVED) {        onFulfilled(self.value);    }    if(self.status === REJECTED) {        onRejected(self.value);    }    return self; // 链式调用}</code></pre><h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><pre><code class="js">new MyPromise(function(resolve, reject) {    setTimeout(function(){        resolve(&#39; test &#39;)    }, 2000);}).then(function(value) {    console.log(&#39;resolve&#39; + value);}, function(value) {    console.log(&#39;reject&#39; + value);})// 结果: resolve test </code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="js">const PENDING = &#39;pending&#39;; const RESOLVED = &#39;resolved&#39;;const REJECTED = &#39;rejected&#39;;function MyPromise(fn){    /* 初始化 */    const self = this; // 实例对象    self.value = null; // 默认值为null    self.status = PENDING; // 初始状态为pending等待状态    self.resolvedCallbacks = []; // 成功回调列表    self.rejectedCallbacks = []; // 拒绝回调列表    function resolve(value) {        self.status = RESOLVED; // 把状态改为resolved        self.value = value;        self.resolvedCallbacks.map(cb =&gt; cb(self.value)); // 分别执行成功回调列表里的方法，并传入value    }; // 成功的方法    function reject(value) {        self.status = REJECTED; // 把状态改为rejected        self.value = value;        self.rejectedCallbacks.map(cb =&gt; cb(self.value)); //分别执行拒绝回调列表里的方法，并传入value    }; // 拒绝的方法    /* 初始化 */    try {        fn(resolve, reject); // 调用传入的函数，并传入resolve和reject方法为入参    } catch(e) {        reject(self.value); // 异常场景直接调用reject拒绝方法    }}MyPromise.prototype.then = function(onFulfilled, onRejected) {    const self = this;    if(self.status === PENDING) { // 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里        self.resolvedCallbacks.push(onFulfilled);        self.rejectedCallbacks.push(onRejected);    }    // 初始化后再调用then方法根据初始化的状态分别执行对应的方法    if(self.status === RESOLVED) {        onFulfilled(self.value);    }    if(self.status === REJECTED) {        onRejected(self.value);    }    return self; // 链式调用}new MyPromise(function(resolve, reject) {    setTimeout(function(){        resolve(&#39; test &#39;)    }, 2000);}).then(function(value) {    console.log(&#39;resolve&#39; + value);}, function(value) {    console.log(&#39;reject&#39; + value);})</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>首先是利用构造函数模式初始化一个promise对象，在原型上绑定实例方法，注意初始化调用then方法的时候此时状态为pending，在执行传入的方法改变状态后再调用then方法会根据修改后的状态执行不同的逻辑</p></blockquote><blockquote><p>我觉得promise对象利用了构造函数设计模式解决了js异步回调嵌套的问题，完美解决了返回数据嵌套依赖的问题，也就是俗称的回调地狱。现在算是把长久以来关于promise的疑惑搞明白了，over！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是promise&quot;&gt;&lt;a href=&quot;#什么是promise&quot; class=&quot;headerlink&quot; title=&quot;什么是promise&quot;&gt;&lt;/a&gt;什么是promise&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise对象代表一个异步操作，有三种状态：pending（进行中）、resolved（已成功）和rejected（已失败）。一旦成功就不允许失败，一旦失败就不允许成功。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="promise 异步 es6" scheme="http://www.icrazyman.cn/tags/promise-%E5%BC%82%E6%AD%A5-es6/"/>
    
  </entry>
  
  <entry>
    <title>react优化总结</title>
    <link href="http://www.icrazyman.cn/2019/01/31/react%E4%BC%98%E5%8C%96/"/>
    <id>http://www.icrazyman.cn/2019/01/31/react优化/</id>
    <published>2019-01-31T12:43:32.000Z</published>
    <updated>2019-01-31T12:43:41.090Z</updated>
    
    <content type="html"><![CDATA[<p>写了一段时间的react之后，渐渐的喜欢上了使用react来写应用。</p><p>我们知道，Facebook在推出react时打出的旗号之一就是高性能。</p><p>今天我们还一起来聊一聊react的性能优化，思考还能通过哪些手段来提升React的性能，使我们的react更快，性能更好。</p><a id="more"></a><h1 id="请慎用setState，因其容易导致重新渲染"><a href="#请慎用setState，因其容易导致重新渲染" class="headerlink" title="请慎用setState，因其容易导致重新渲染"></a>请慎用setState，因其容易导致重新渲染</h1><blockquote><p>既然将数据主要交给了Redux来管理，那就尽量使用Redux管理你的数据和状态state，除了少数情况外，别忘了shouldComponentUpdate也需要比较state。</p></blockquote><h1 id="请将方法的bind一律置于constructor"><a href="#请将方法的bind一律置于constructor" class="headerlink" title="请将方法的bind一律置于constructor"></a>请将方法的bind一律置于constructor</h1><blockquote><p>Component的render里不动态bind方法，方法都在constructor里bind好，如果要动态传参，方法可使用闭包返回一个最终可执行函数。如：showDelBtn(item) { return (e) =&gt; {}; }。如果每次都在render里面的jsx去bind这个方法，每次都要绑定会消耗性能。</p></blockquote><h1 id="请只传递component需要的props"><a href="#请只传递component需要的props" class="headerlink" title="请只传递component需要的props"></a>请只传递component需要的props</h1><blockquote><p>传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（）。</p></blockquote><h1 id="请尽量使用const-element"><a href="#请尽量使用const-element" class="headerlink" title="请尽量使用const element"></a>请尽量使用const element</h1><blockquote><p>我们可以将不怎么变动，或者不需要传入状态的component写成const element的形式，这样能加快这个element的初始渲染速度。</p></blockquote><h1 id="保证key值唯一"><a href="#保证key值唯一" class="headerlink" title="保证key值唯一"></a>保证key值唯一</h1><blockquote><p>保证key值唯一方便diff算法比较，注意不要用数组的index作为key，原因非唯一性</p></blockquote><h1 id="合理使用shouldComponentUpdate"><a href="#合理使用shouldComponentUpdate" class="headerlink" title="合理使用shouldComponentUpdate"></a>合理使用shouldComponentUpdate</h1><blockquote><p>子组件更新时候对props作出新老数据比对，如果改变了，才render子组件</p></blockquote><h1 id="使用pureComponent"><a href="#使用pureComponent" class="headerlink" title="使用pureComponent"></a>使用pureComponent</h1><blockquote><p>使用pureComponent会默认添加shouldComponentUpdate并进行浅比较</p></blockquote><h1 id="使用Immutablejs"><a href="#使用Immutablejs" class="headerlink" title="使用Immutablejs"></a>使用Immutablejs</h1><blockquote><p>使用不可变的数据来解决数据状态的变化比对，提高性能</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了一段时间的react之后，渐渐的喜欢上了使用react来写应用。&lt;/p&gt;
&lt;p&gt;我们知道，Facebook在推出react时打出的旗号之一就是高性能。&lt;/p&gt;
&lt;p&gt;今天我们还一起来聊一聊react的性能优化，思考还能通过哪些手段来提升React的性能，使我们的react更快，性能更好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react 规范 优化" scheme="http://www.icrazyman.cn/tags/react-%E8%A7%84%E8%8C%83-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://www.icrazyman.cn/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.icrazyman.cn/2019/01/20/数据结构/</id>
    <published>2019-01-20T14:47:32.000Z</published>
    <updated>2019-01-21T14:55:11.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。</p></blockquote><a id="more"></a><h1 id="为什么需要学习数据结构？"><a href="#为什么需要学习数据结构？" class="headerlink" title="为什么需要学习数据结构？"></a>为什么需要学习数据结构？</h1><h2 id="语言是相通的"><a href="#语言是相通的" class="headerlink" title="语言是相通的?"></a>语言是相通的?</h2><p>人们常说，编程语言是相通的，掌握了一门，其他语言很容易就能掌握，个人认为这是一个似是而非的观点。</p><p>每门编程语言都离不开变量，数组，循环，条件判断这些概念，这似乎能够支持上面的观点，但是，每门编程语言都有自己的适用范围。都有自己擅长的事情，即便是有了node.js这种能够一统前后端的语言，也总有它不能胜任的工作，比如机器学习。像python这样的近乎万能的语言，也总有无能为力的时候，比如面对高性能计算，许多python库的底层实现可都是C语言哦。</p><p>多年的工作经验告诉我，真正相通的不是语言，而是数据结构和算法。</p><p>数据结构和算法是脱离编程语言而存在的，不同的语言有不同的实现版本，但内在的逻辑却不会有变化，所体现的编程思想不会有变化。</p><h2 id="一段亲身经历"><a href="#一段亲身经历" class="headerlink" title="一段亲身经历"></a>一段亲身经历</h2><p>我曾经在工作有过这样一次经历，我在后端通过websockt向前端发送数据，数据是一个具体的坐标，前端的同学得到坐标后，要在前端的中国地图上根据坐标显示一个光圈。这是一个非常简单的事情，但却遇到了麻烦，后端向前端推送数据是一个不定时的行为，有时1秒钟推了3条数据，有时3秒钟才推1条数据，当我推送数据频繁的时候，如果这些坐标都在地图上显示，地图会非常乱。长时间不推送数据时，前端页面不应该一直显示之前推送过的坐标，因为每一个坐标代表一个用户刚刚在我们的网站上做了一项操作。</p><p>于是，我们对前端显示做了限制，前端同一个时刻最多显示10个坐标，如果已经有10个，新来的坐标要把之前最早到来的坐标挤掉，每个坐标最多显示5秒钟。就是这样一个简单的要求，前端同学却迟迟不能实现该功能，因为他无法兼顾最多显示10个坐标和每个坐标最多显示5秒钟的要求。</p><p>后来，我让他用队列来实现。前端在收到坐标后，将坐标和收到时间构造成一个新的对象，一同放入到队列中，如果列队元素已经有10个，则把队列头部的元素删除，于此同时，每隔1秒钟就对队列里的元素检查一次，队列头部的元素都是最早到来的，如果当前时间距离到来时间超过5秒，则删除队列头部元素。</p><p>就这样，前端同学使用队列，非常快的实现了这个功能，而且对数据结构产生了浓厚的兴趣。</p><p>每当你怀疑学习数据结构的必要性和作用时，请提醒自己，如果你手里只有锤子，那么目光所及之处都是钉子。</p><h2 id="学习数据结构的目标"><a href="#学习数据结构的目标" class="headerlink" title="学习数据结构的目标"></a>学习数据结构的目标</h2><ul><li><p>提高程序设计能力</p></li><li><p>提高算法能力</p></li><li><p>找工作面试的时候hold住面试官</p></li></ul><p>数据结构的精髓在于总结提炼了许多存储管理和使用数据的模式，这些模式的背后是最精华的编程思想，这些思想的领悟需要时间，不要想当然的认为学会了几种数据结构就可以在工作中大显身手，但学会了数据结构，对自身能力的提升是不言而喻的。</p><p>当然，在没有参悟这些数据管理方式和编程思想之前，我们先学习具体的工具和方法。</p><h2 id="学习数据结构需要准备哪些知识"><a href="#学习数据结构需要准备哪些知识" class="headerlink" title="学习数据结构需要准备哪些知识"></a>学习数据结构需要准备哪些知识</h2><p>你需要熟练地使用数组这种数据类型，我想这没什么困难，再有就是知道如何在javascript中定义类，这里推荐一篇文章<a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="noopener">Javascript定义类（class）的三种方法</a>本系列课程主要使用构造函数法定义类。</p><h1 id="数据结构之—-栈"><a href="#数据结构之—-栈" class="headerlink" title="数据结构之—-栈"></a>数据结构之—-栈</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈是一种特殊的线性表，仅能够在栈顶进行操作，有着先进后出(后进先出)的特性，下面这张图展示了栈的工作特点：</p><p><img src="https://i.imgur.com/k0yBPn0.png" alt=""></p><p>对于栈的理解，你必须牢牢抓住一点，那便是你只能在栈顶进行操作，生活中有一个非常贴切的例子，玩羽毛球的同学都会买一桶羽毛球，羽毛球桶就是典型的栈结构。</p><p><img src="https://i.imgur.com/lNPG23S.jpg" alt=""></p><p>每次取羽毛球时，都只能从顶部取，最底下的羽毛球，你是取不到的，用完了羽毛球后，也只能从顶部放回去。</p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>上一小节，我们对栈这种数据结构有了视觉上的接触和理解，接下来，我们要对栈进行定义，毕竟，我们写一个栈，为的是使用它，那么就必须先定义数据存储在哪里，提供什么样的方法。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>从数据存储的角度看，实现栈有两种方式，一种是以数组做基础，一种是以链表做基础，数组是最简单的实现方式，链表在后面会作为单独的一种数据结构来讲解。本次课程将使用数组来实现栈和队列，数组是大家平时用的最频繁的，也是最了解熟悉的数据类型。</p><p>我们先定义一个简单的Stack类</p><pre><code>function Stack() {    var items = [];  // 使用数组存储数据};</code></pre><p>数据将存储在items数组之中，现在，这个类没有任何方法。</p><h3 id="栈的方法"><a href="#栈的方法" class="headerlink" title="栈的方法"></a>栈的方法</h3><p>栈有以下几个方法：</p><ul><li>push 添加一个元素到栈顶（向桶里放入一个羽毛球）</li></ul><pre><code>// push方法向栈里压入一个元素this.push = function(item){    items.push(item);};</code></pre><ul><li>pop 弹出栈顶元素（从桶里拿出一个羽毛球）</li></ul><pre><code>// pop方法把栈顶的元素弹出this.pop = function(){    return items.pop();};</code></pre><p>数组的pop方法会删除最靠后的那个元素，同时return该元素</p><ul><li>top 返回栈顶元素，注意，不是弹出（看一眼桶里最顶端的羽毛球，但是不拿）</li></ul><pre><code>// top 方法返回栈顶元素this.top = function(){    return items[items.length - 1];};</code></pre><p>top方法只是想查看一下最顶端的元素</p><ul><li>isEmpty 判断栈是否为空（看看羽毛球是不是都用完了）</li></ul><pre><code>// isEmpty返回栈是否为空this.isEmpty = function(){    return items.length == 0;};</code></pre><ul><li>size 返回栈里元素的个数（数一下桶里还有多少羽毛球）</li></ul><pre><code>// size方法返回栈的大小this.size = function(){    return items.length;};</code></pre><ul><li>clear 清空栈（把桶里的羽毛球都倒出来扔掉）</li></ul><pre><code>// clear 清空栈this.clear = function(){    items = []}</code></pre><p>最终完成版的代码如下</p><pre><code>function Stack() {    var items = [];  // 使用数组存储数据    // push方法向栈里压入一个元素    this.push = function(item){        items.push(item);    };    // 获取数组    this.get = function() {        return items;    }    // pop方法把栈顶的元素弹出    this.pop = function(){        return items.pop();    };    // top 方法返回栈顶元素    this.top = function(){        return items[items.length - 1];    };    // isEmpty返回栈是否为空    this.isEmpty = function(){        return items.length == 0;    };    // size方法返回栈的大小    this.size = function(){        return items.length;    };    // clear 清空栈    this.clear = function(){        items = []    }}</code></pre><h3 id="被欺骗的错觉"><a href="#被欺骗的错觉" class="headerlink" title="被欺骗的错觉"></a>被欺骗的错觉</h3><p>看完上面的实现，难道你没有一种被欺骗的感觉么？传的那么神乎其神的数据结构，这里实现的栈，竟然就只是对数组做了一层封装而已啊！！！</p><p>只是做了一层封装么？请思考下面几个问题：</p><ul><li><p>给你一个数组，你可以通过索引操作任意一个元素，但是给你一个栈，你能操作任意元素么？栈提供的方法只允许你操作栈顶的元素，也就是数组的最后一个元素，这种限制其实提供给我们一种思考问题的方式，这个方式也就是栈的特性，后进先出。</p></li><li><p>既然栈的底层实现其实就是数组，栈能做的事情，数组一样可以做啊，为什么弄出一个栈来，是不是多此一举？封装是为了隐藏实现细节，站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便，后面的练习题你将有所体会。</p></li><li><p>既然栈的底层就是对数组的操作，而你平时对数组的使用已经到了非常熟练的程度了，那么请问问自己，为什么就从来都没有自己实现过一个栈呢？是你此前不知道栈的这个概念，还是知道栈的概念但是不知道它有哪些具体方法？不论是哪一种情况，都表明栈对你来说是一个全新的知识，尽管底层的实现是那么的简单，可是越简单就越能说明问题，为啥，你自己就没想出栈这个东西？</p></li></ul><h2 id="栈的应用练习"><a href="#栈的应用练习" class="headerlink" title="栈的应用练习"></a>栈的应用练习</h2><p>通过两个练习题，你或许能够明白我前面所说的站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便。</p><h3 id="合法括号"><a href="#合法括号" class="headerlink" title="合法括号"></a>合法括号</h3><ul><li>题目要求</li></ul><p>下面的字符串中包含小括号，请编写一个函数判断字符串中的括号是否合法，所谓合法，就是括号成对出现</p><pre><code>sdf(ds(ew(we)rw)rwqq)qwewe   合法(sd(qwqw)sd(sd))             合法()()sd()(sd()fw))(           不合法</code></pre><ul><li>思路分析</li></ul><p>括号存在嵌套关系，也存在并列关系，如果是用数组存储这些括号，然后再想办法一对一对的抵消掉，似乎是一个可行的办法，可是如何判断一个左括号对应的是哪个右括号呢？站在数组的肩膀上思考这个问题，就陷入到一种无从下手的绝望之中。</p><p>现在，我们站在栈的肩膀上思考这个问题，解题的步骤就非常简单，我们可以使用for循环遍历字符串的每一个字符，对每个字符做如下的操作：</p><ul><li><p>遇到左括号，就把左括号压如栈中</p></li><li><p>遇到右括号，判断栈是否为空，为空说明没有左括号与之对应，缺少左括号，字符串括号不合法，如果栈不为空，则把栈顶元素移除，这对括号抵消掉了</p></li></ul><p>当for循环结束之后，如果栈是空的，就说明所有的左右括号都抵消掉了，如果栈里还有元素，则说明缺少右括号，字符串括号不合法。</p><ul><li>示例代码</li></ul><pre><code>function is_leagl_brackets(string){    var stack = new Stack();    for(var i=0; i&lt;string.length; i++ ){        var item = string[i];        if(item == &quot;(&quot;){            // 将左括号压入栈            stack.push(item);        }else if (item==&quot;)&quot;){            // 如果为空,就说明没有左括号与之抵消            if(stack.isEmpty()){                return false;            }else{                // 将栈顶的元素弹出                stack.pop();            }        }    }    return stack.size() == 0;};console.log(is_leagl_brackets(&quot;()()))&quot;));console.log(is_leagl_brackets(&quot;sdf(ds(ew(we)rw)rwqq)qwewe&quot;));console.log(is_leagl_brackets(&quot;()()sd()(sd()fw))(&quot;));</code></pre><ul><li>小结</li></ul><p>栈的底层是不是使用了数组这不重要，重要的是栈的这种后进先出的特性，重要的是你只能操作栈顶元素的的限制，一定要忽略掉栈的底层如何实现，而只去关心栈的特性。</p><p>我们在编辑文档时，包括写代码，经常进行回退的操作，control+z就可以了，那么你有没有想过，这其实就可以用栈来实现，每一步操作都放入到栈中，当你想回退的时候，就使用pop方法把栈顶元素弹出，于是得到了你之前的一步操作。</p><hr><h3 id="计算逆波兰表达式"><a href="#计算逆波兰表达式" class="headerlink" title="计算逆波兰表达式"></a>计算逆波兰表达式</h3><ul><li>题目要求</li></ul><p>逆波兰表达式，也叫后序表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式，例如 (a+b)<em>(c+d)转换为ab+cd+</em>。</p><pre><code>[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] 等价于(4 + (13 / 5)) = 6[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;] 等价于((10 * (6 / ((9 + 3) * -11))) + 17) + 5</code></pre><p>请编写函数calc_exp(exp) 实现逆波兰表达式计算，exp的类型是数组。</p><ul><li>思路分析</li></ul><p>[“4”, “13”, “5”, “/“, “+”] 就是一个数组，在数组层面上思考这个问题，遇到 / 时，把13 和 5 拿出来计算，然后把13 和 5 删除并把结果放入到4的后面，天哪，太复杂了，太笨拙了，我已经无法继续思考了。</p><p>如果是使用栈来解决这个问题，一切就那么的自然而简单，使用for循环遍历数组，对每一个元素做如下操作：</p><ol><li><p>如果元素不是 + - * / 中的某一个，就压入栈中</p></li><li><p>如果元素是 + - * / 中的某一个，则从栈里连续弹出两个元素，并对这两个元素进行计算，将计算结果压入栈中</p></li></ol><p>for循环结束之后，栈里只有一个元素，这个元素就是整个表达式的计算结果</p><ul><li>示例代码</li></ul><pre><code>function calc_exp(arr) {    var stack = new Stack();    for(var i = 0, len = arr.length; i &lt; len; i ++) {        var item = arr[i];        if (~[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;].indexOf(item)) {            // 注意这里需要用到后序表达式或中序表达式转换一下            var v1 = stack.pop();            var v2 = stack.pop();            var exp_res = parseInt(eval(v2 + item + v1));            stack.push(exp_res);        } else {            stack.push(item);        }    }    return stack.pop();}console.log(&quot;-----------------------------------------&quot;);console.log(calc_exp([&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;])); // 6</code></pre><h3 id="课后练习题"><a href="#课后练习题" class="headerlink" title="课后练习题"></a>课后练习题</h3><ul><li>实现一个有min方法的栈</li></ul><p>实现一个栈，除了常见的push，pop方法以外，提供一个min方法，返回栈里最小的元素，且时间复杂度为o(1)</p><ul><li>思路分析</li></ul><p>使用两个栈来存储数据，其中一个命名为data_stack,专门用来存储数据，另一个命名为min_stack，专门用来存储栈里最小的数据。</p><p>注意了，我接下来的分析过程非常重要，我希望你能多阅读几遍。</p><ol><li><p>我们要实现的是一个栈，除了常规的方法，还要有一个min方法，data_stack就是专门为常规方法而存在的，min_stack就是为了这个min方法而存在的。</p></li><li><p>编程思想里有一个分而治之的思想，简单来说，就是分开想，分开处理。那么我们现在考虑data_stack，这个时候别管min方法，你就只关心data_stack，它就是一个普通的栈啊，没什么特别的，一个简单的栈你还不会么，就是push，pop那些方法，正常实现就可以了。</p></li><li><p>data_stack处理完了以后，再考虑min_stack，这个时候，你就别想data_stack了，只关心min_stack，它要存储栈里的最小值，我们先考虑边界情况，如果min_stack为空，这个时候，如果push进来一个数据，那这个数据一定是最小的，所以此时，直接放入min_stack即可。如果min_stack不为空，这个时候它的栈顶不正是栈的最小元素么，如果push进来的元素比栈顶元素还小，放入min_stack就好了，这样，min_stack的栈顶始终都是栈里的最小值。</p></li></ol><ul><li>示例代码:</li></ul><pre><code>function MinStack() {    var data_stack = new Stack();    var min_stack = new Stack();    this.push = function(item) {        data_stack.push(item);        if (min_stack.isEmpty() || min_stack.top &gt; item) {            min_stack.push(item);        } else {            min_stack.push(min_stack.top());        }    }    this.pop = function() {        min_stack.pop();        return data_stack.pop();    }    this.get = function() {        return data_stack.get();    }    this.min = function() {        return min_stack.top();    }}var minstack = new MinStack();minstack.push(3);minstack.push(6);minstack.push(8);console.log(minstack.get()); // [3, 6, 8]console.log(minstack.min()); // 3minstack.push(2);console.log(minstack.min()); // 3</code></pre><h3 id="使用栈，完成中序表达式转后序表达式"><a href="#使用栈，完成中序表达式转后序表达式" class="headerlink" title="使用栈，完成中序表达式转后序表达式"></a>使用栈，完成中序表达式转后序表达式</h3><pre><code>输入:[&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]输出:[&quot;12&quot;,&quot;3&quot;,&quot;+&quot;]输入:[&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;]输出:[ &#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;9&#39;, &#39;8&#39;, &#39;+&#39;, &#39;+&#39; ]输入:[&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;,&#39;)&#39;, &#39;/&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]输出:[&#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;4&#39;,&#39;/&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;6&#39;, &#39;8&#39;, &#39;+&#39;, &#39;3&#39;, &#39;*&#39;, &#39;+&#39;]</code></pre><ul><li>思路分析</li></ul><p>定义数组postfix_lst，用于存储后序表达式，遍历中序表达式，对每一个遍历到的元素做如处理:</p><ol><li><p>如果是数字,直接放入到postfix_lst中</p></li><li><p>遇到左括号入栈</p></li><li><p>遇到右括号,把栈顶元素弹出并放入到postfix_lst中,直到遇到左括号，最后弹出左括号</p></li><li><p>遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符， 把弹出的运算符加入到postfix_lst，当前的运算符入栈</p></li><li><p>for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中</p></li></ol><pre><code>// 定义运算符的优先级var priority_map = {    &quot;+&quot;: 1,    &quot;-&quot;: 1,    &quot;*&quot;: 2,    &quot;/&quot;: 2};function infix_exp_2_postfix_exp(exp){    var stack = new Stack();    var postfix_lst = [];    for(var i = 0;i&lt;exp.length;i++){        var item = exp[i];        // 如果是数字,直接放入到postfix_lst中        if(!isNaN(item)){            postfix_lst.push(item);        }else if (item == &quot;(&quot;){            // 遇到左括号入栈            stack.push(item);        }else if (item == &quot;)&quot;){            // 遇到右括号,把栈顶元素弹出,直到遇到左括号            while(stack.top() != &quot;(&quot;){                postfix_lst.push(stack.pop());            }            stack.pop();   // 左括号出栈        }else{            // 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符            while(!stack.isEmpty() &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(stack.top()) &gt;= 0 &amp;&amp; priority_map[stack.top()] &gt;= priority_map[item]){                // 把弹出的运算符加入到postfix_lst                postfix_lst.push(stack.pop());            }            // 当前的运算符入栈            stack.push(item);        }    }    // for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中    while(!stack.isEmpty()) {        postfix_lst.push(stack.pop())    }    return postfix_lst};// 12+3console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]))// 2-3+2console.log(infix_exp_2_postfix_exp([&quot;2&quot;,&quot;-&quot;, &quot;3&quot;, &quot;+&quot;, &quot;2&quot;]))// (1+(4+5+3)-3)+(9+8)var exp = [&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;];console.log(infix_exp_2_postfix_exp(exp))// (1+(4+5+3)/4-3)+(6+8)*3var exp = [&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;)&#39;, &#39;/&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]console.log(infix_exp_2_postfix_exp(exp))console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;,&quot;*&quot;, &quot;5&quot;]))console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;*&quot;, &quot;3&quot;,&quot;+&quot;, &quot;5&quot;]))</code></pre><ul><li>算法思路推理过程</li></ul><p>推理的过程要从简入繁，先考虑最简单的情况</p><ul><li>只有一个运算符</li></ul><pre><code>中序: 1 + 2后序: 1 2 +</code></pre><p>后序表达式，数值在前，操作符在后，因此，遇到数值时直接放入到后序表达式中。将操作符放入栈中，等到中序表达式遍历结束后，将栈里的操作符弹出放入到后序表达式中</p><ul><li>多个运算符，栈顶操作符优先级和当前运算符相同</li></ul><p>多个运算符，似乎也可以像第一步推理中那样操作，但实际不行</p><pre><code>中序: 1 + 2 - 3后序: 1 2 + 3 -</code></pre><p>每次遇到操作符时，如果栈里有操作符，说明前面有需要计算的数值，且计算的操作符就在栈顶，应该弹出放入到后缀表达式中，如果都等到中缀表达式结束再弹出，就会变成 1 2 3 + -</p><p>就本示例而言，遇到减号时，后缀表达式里是 1 2 ，栈里是+，1和2需要计算，进行计算的操作符就在栈顶，因此需要弹出，放入到后缀表达式，之后减号入栈，中缀表达式遍历结束后，后缀表达式是 1 2 + 3， 栈里是-，将栈里的操作符去全部弹出，放入到后缀表达式，最终结果为 1 2 + 3 -。</p><pre><code>中序: 1 * 2 + 3后序: 1 2 * 3 +</code></pre><p>栈顶运算符优先级高，和第2步的分析一致，前面有需要计算的数值，应该弹出放入到后缀表达式中</p><ul><li>多个运算符，栈顶操作符优先级大于当前运算符相同</li></ul><pre><code>中序: 1 + 2 * 3后序: 1 2 3 * +</code></pre><p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p><ul><li>多个运算符，栈顶操作符优先级小于当前运算符相同</li></ul><pre><code>中序: 1 + 2 * 3后序: 1 2 3 * +</code></pre><p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p><ul><li>有括号的情况</li></ul><p>括号里的的表达式可以视为一个独立的中缀表达式，因此，前面4步的分析都适用，但是括号里的中缀表达式在一个更大的表达式中，因此需要与其他部分分隔，分隔的方法就是遇到小括号后压栈，此后的操作遵循前面的推理逻辑，当遇到右括号时，说明括号内的表达式结束了，根据第一步的分析，应该把所有属于这个括号内表达式的操作符都弹出来放入到后缀表达式，最后一步弹出左括号。</p><p><strong>还在学习ing…，学习后再补充</strong></p><h1 id="数据结构之—-队列"><a href="#数据结构之—-队列" class="headerlink" title="数据结构之—-队列"></a>数据结构之—-队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><h3 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a>数据存储</h3><h3 id="队列的方法"><a href="#队列的方法" class="headerlink" title="队列的方法"></a>队列的方法</h3><ul><li>enqueue方法</li><li>dequeue方法</li><li>head方法</li><li>size方法</li><li>clear方法</li><li>isEmpty方法</li><li>tail方法<h2 id="队列的应用练习"><a href="#队列的应用练习" class="headerlink" title="队列的应用练习"></a>队列的应用练习</h2><h3 id="约瑟夫环（普通模式）"><a href="#约瑟夫环（普通模式）" class="headerlink" title="约瑟夫环（普通模式）"></a>约瑟夫环（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h3 id="斐波那契数列（普通模式）"><a href="#斐波那契数列（普通模式）" class="headerlink" title="斐波那契数列（普通模式）"></a>斐波那契数列（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码</li><li>小结<h3 id="用队列实现栈（困难模式）"><a href="#用队列实现栈（困难模式）" class="headerlink" title="用队列实现栈（困难模式）"></a>用队列实现栈（困难模式）</h3></li><li>题目要求</li><li>思路分析</li><li>代码示例<h3 id="打印杨辉三角（困难模式）"><a href="#打印杨辉三角（困难模式）" class="headerlink" title="打印杨辉三角（困难模式）"></a>打印杨辉三角（困难模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="用两个栈实现一个队列（普通模式）"><a href="#用两个栈实现一个队列（普通模式）" class="headerlink" title="用两个栈实现一个队列（普通模式）"></a>用两个栈实现一个队列（普通模式）</h3></li><li>思路分析</li><li>思路分析<h3 id="迷宫问题（地狱模式）"><a href="#迷宫问题（地狱模式）" class="headerlink" title="迷宫问题（地狱模式）"></a>迷宫问题（地狱模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h1 id="数据结构之—-链表"><a href="#数据结构之—-链表" class="headerlink" title="数据结构之—-链表"></a>数据结构之—-链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h3 id="首尾节点"><a href="#首尾节点" class="headerlink" title="首尾节点"></a>首尾节点</h3><h3 id="有头链表和无头链表"><a href="#有头链表和无头链表" class="headerlink" title="有头链表和无头链表"></a>有头链表和无头链表</h3><h3 id="猴子捞月"><a href="#猴子捞月" class="headerlink" title="猴子捞月"></a>猴子捞月</h3><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="定义链表类"><a href="#定义链表类" class="headerlink" title="定义链表类"></a>定义链表类</h3><h3 id="链表的方法"><a href="#链表的方法" class="headerlink" title="链表的方法"></a>链表的方法</h3></li><li>append方法</li><li>print方法</li><li>insert方法</li><li>remove方法</li><li>get方法</li><li>indexOf方法<h2 id="基于链表实现的Stack-和-Queue"><a href="#基于链表实现的Stack-和-Queue" class="headerlink" title="基于链表实现的Stack 和 Queue"></a>基于链表实现的Stack 和 Queue</h2><h2 id="链表常见面试题"><a href="#链表常见面试题" class="headerlink" title="链表常见面试题"></a>链表常见面试题</h2><h3 id="翻转链表（困难模式）"><a href="#翻转链表（困难模式）" class="headerlink" title="翻转链表（困难模式）"></a>翻转链表（困难模式）</h3></li><li>题目要求</li><li>迭代翻转思路分析</li><li>递归翻转链表思路分析<h3 id="从尾到头打印链表（普通模式）"><a href="#从尾到头打印链表（普通模式）" class="headerlink" title="从尾到头打印链表（普通模式）"></a>从尾到头打印链表（普通模式）</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h3 id="合并两个两个有序链表-困难模式"><a href="#合并两个两个有序链表-困难模式" class="headerlink" title="合并两个两个有序链表(困难模式)"></a>合并两个两个有序链表(困难模式)</h3></li><li>题目要求</li><li>思路分析</li><li>示例代码<h2 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="查找单链表中的倒数第K个节点（k-gt-0）（普通模式）"><a href="#查找单链表中的倒数第K个节点（k-gt-0）（普通模式）" class="headerlink" title="查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）"></a>查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）</h3><h3 id="查找单链表的中间结点（普通模式）"><a href="#查找单链表的中间结点（普通模式）" class="headerlink" title="查找单链表的中间结点（普通模式）"></a>查找单链表的中间结点（普通模式）</h3><h3 id="实现双向链表（地狱模式）"><a href="#实现双向链表（地狱模式）" class="headerlink" title="实现双向链表（地狱模式）"></a>实现双向链表（地狱模式）</h3><h1 id="数据结构之—-BitMap"><a href="#数据结构之—-BitMap" class="headerlink" title="数据结构之—-BitMap"></a>数据结构之—-BitMap</h1><h2 id="一个简单的问题"><a href="#一个简单的问题" class="headerlink" title="一个简单的问题"></a>一个简单的问题</h2><h3 id="毫无难度的实现"><a href="#毫无难度的实现" class="headerlink" title="毫无难度的实现"></a>毫无难度的实现</h3><h3 id="更快的方法"><a href="#更快的方法" class="headerlink" title="更快的方法"></a>更快的方法</h3><h3 id="更节省空间的算法"><a href="#更节省空间的算法" class="headerlink" title="更节省空间的算法"></a>更节省空间的算法</h3><h2 id="街边的路灯"><a href="#街边的路灯" class="headerlink" title="街边的路灯"></a>街边的路灯</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><h3 id="新的实现方式"><a href="#新的实现方式" class="headerlink" title="新的实现方式"></a>新的实现方式</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="大数据排序"><a href="#大数据排序" class="headerlink" title="大数据排序"></a>大数据排序</h3><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><h3 id="BoolmFilter-类"><a href="#BoolmFilter-类" class="headerlink" title="BoolmFilter 类"></a>BoolmFilter 类</h3></li><li>操作二进制位</li><li>add方法</li><li>isExist方法<h2 id="课后练习题-1"><a href="#课后练习题-1" class="headerlink" title="课后练习题"></a>课后练习题</h2><h3 id="两个集合取交集（普通模式）"><a href="#两个集合取交集（普通模式）" class="headerlink" title="两个集合取交集（普通模式）"></a>两个集合取交集（普通模式）</h3></li><li>示例代码<h3 id="支持负数（困难模式）"><a href="#支持负数（困难模式）" class="headerlink" title="支持负数（困难模式）"></a>支持负数（困难模式）</h3></li><li>思路分析</li><li>示例代码<h3 id="查找不重复的数（地狱模式）"><a href="#查找不重复的数（地狱模式）" class="headerlink" title="查找不重复的数（地狱模式）"></a>查找不重复的数（地狱模式）</h3></li><li>思路分析</li><li>示例代码<h1 id="数据结构之—-树"><a href="#数据结构之—-树" class="headerlink" title="数据结构之—-树"></a>数据结构之—-树</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2>###结构<br>###节点<br>###节点的度<br>###叶节点<br>###分支节点<br>###子女节点<h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h3 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h3><h3 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h3><h3 id="节点所在层次"><a href="#节点所在层次" class="headerlink" title="节点所在层次"></a>节点所在层次</h3><h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><h3 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h3><h3 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h3><h3 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h3><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3></li><li>满二叉树</li><li>完全二叉树<h3 id="二叉树的类定义"><a href="#二叉树的类定义" class="headerlink" title="二叉树的类定义"></a>二叉树的类定义</h3></li><li>定义节点</li><li>定义二叉树类</li><li>init_tree</li><li>in_order 中序遍历算法</li><li>pre_order 前序遍历算法</li><li>post_order 后序遍历算法</li><li>size 返回节点数量</li><li>height 返回树的高度</li><li>查找节点<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3></li><li>求一棵树的镜像(普通模式)<ul><li>思路分析</li><li>示例代码</li></ul></li><li>使用非递归方式实现前序遍历<ul><li>思路分析</li><li>示例代码<h3 id="课后练习题-2"><a href="#课后练习题-2" class="headerlink" title="课后练习题"></a>课后练习题</h3></li></ul></li><li>使用非递归方式实现中，后两种遍历方法（普通模式+）</li><li>寻找两个节点的最近公共祖先（困难模式）</li><li>分层打印二叉树（困难模式+）</li><li>输出指定层的节点个数（困难模式+）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript 数据结构" scheme="http://www.icrazyman.cn/tags/JavaScript-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>你需要了解的几种JavaScript设计模式</title>
    <link href="http://www.icrazyman.cn/2019/01/15/%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A7%8DJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.icrazyman.cn/2019/01/15/你需要了解的几种种JavaScript设计模式/</id>
    <published>2019-01-15T13:54:57.000Z</published>
    <updated>2019-01-20T11:07:39.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p><h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><ul><li><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p></li><li><p>设计模式主要是为了解决对象的生成和整合问题。</p></li><li><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p></li></ul><p><strong>读万卷书，不如行万里路。接下来要贴代码了，从代码中就可以理解常用设计模式的主要概念。</strong></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>单例模式</li><li>观察者模式（发布\订阅模式）</li><li>中介者模式</li><li>策略模式/状态模式</li><li>命令模式</li><li>迭代器模式</li><li>参与者模式</li><li>数据访问对象模式</li><li>等待者模式</li><li>同步模块模式</li><li>异步模块模式</li><li>链模式</li><li>构造函数模式</li><li>职责链模式</li><li>MVC模式</li><li>MVP模式</li><li>MVVM模式</li><li>享元模式</li><li>状态模式</li><li>模板方法模式</li></ol><a id="more"></a><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><pre><code>var Singleton = function() {    var midseason = getMidseason();    return {        midseason: midseason, // 单例模式私有变量         sendAjax: function(api, formData, callback) {             // 代码...        },        submitForm: function(dlg){             // 代码...        },        cancelForm: function(dlg){            // 代码...        },        initChosen: function(selector, options){            // 代码...        },        initDataTable: function(selector, options) {            // 代码...        },        editInventoryType: function(data){            // 代码...            Singleton.initChosen($(&#39;.check-goods-type&#39;));        },        changePriceCardStatus: function(data) {            Singleton.sendAjax(&#39;api&#39;, {&#39;data&#39;: data}, function(data) {                // 代码...            })        }    }}()</code></pre><h1 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布\订阅模式）"></a>观察者模式（发布\订阅模式）</h1><pre><code>var Observer = (function() {    var _message = {};    return {        regist: function(type, fn) {            if (typeof _message[type] === &#39;undefined&#39;) {                _message[type] = [fn];            } else {                _message[type].push(fn);            }        },        fire: function(type, args) {            if (!_message[type]) return;            var events = {                type: type,                args: args || {}            }            for ( var i = _message[type].length -1 ; i &gt;= 0; i --) {                _message[type][i].call(this, events);            }        },        remove: function(type, fn) {            if (_message[type] instanceof Array) {                for( var i = _message[type]; i&gt;= 0; i -- ) {                    _message[type][i] === fn &amp;&amp; _message[type].splice(i ,1);                }            };        }    }})()Observer.regist(&#39;test&#39;, function(e) {    console.log(e.type, e.args.msg);})Observer.fire(&#39;test&#39;, {msg: &#39;传递参数&#39;});</code></pre><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><pre><code>var Mediator = function() {    var _msg = {};    return {        register: function(type, action) {            if (_msg[type]) {                _msg[type].push(action);            } else {                _msg[type] = [];                _msg[type].push(action);            }            return this;        },        send: function(type) {            if (_msg[type]) {                for (var i = 0, len = _msg[type].length; i &lt; len; i++) {                    _msg[type][i] &amp;&amp; _msg[type][i]();                };            };            return this;        }    }}();Mediator.register(&#39;demo&#39;, function() {    console.log(&quot;first&quot;);}).register(&#39;demo&#39;, function() {    console.log(&quot;second&quot;);}).send(&#39;demo&#39;);</code></pre><h1 id="策略模式与状态模式类似，区别是调用指定的方法传参"><a href="#策略模式与状态模式类似，区别是调用指定的方法传参" class="headerlink" title="策略模式与状态模式类似，区别是调用指定的方法传参"></a>策略模式与状态模式类似，区别是调用指定的方法传参</h1><pre><code>var Pattern = function() {    var status = {        return30: function(price) {            console.log(price+&#39;折扣&#39;);        },        return50: function(price) {            console.log(price+&#39;折扣&#39;);        }    }    return function(item, price) {        return status[item] &amp;&amp; status[item](price);    }}()Pattern(&#39;return30&#39;, 300)</code></pre><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;     var CanvasCommand = function() {         var canvas = document.getElementById(&#39;canvas&#39;),             ctx = canvas.getContext(&#39;2d&#39;);         var Action = {             fillStyle: function(c) {                 ctx.fillStyle = c;             },             fillRect: function(x, y, width, height) {                 ctx.fillRect(x, y, width, height);             }         }         return {             excute: function(msg) {                 if (!msg) return;                 if (msg.length) {                     for(var i = 0, len = msg.length; i &lt; len; i ++) {                         arguments.callee(msg[i]);                     }                 } else {                     msg.param = Object.prototype.toString.call(msg.param) === &#39;[object Array]&#39; ? msg.param : [msg.param];                     Action[msg.command].apply(Action, msg.param);                 }             }         }     }()     CanvasCommand.excute([         {command: &#39;fillStyle&#39;, param: &#39;red&#39;},         {command: &#39;fillRect&#39;, param: [20, 20, 100, 100]}     ])&lt;/script&gt;</code></pre><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><pre><code>&lt;ul id=&quot;container&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    var Iterator = function(items, container) {        var container = container &amp;&amp; document.getElementById(&#39;container&#39;) || document,            items = container.getElementsByTagName(items),            length = items.length,            index = 0;        var splice = [].splice;        return {            // 获取第一个元素            first: function() {                index = 0;                return items[index];            },            // 获取最后一个元素            last: function() {                index = length - 1;                return items[index];            },            // 获取前一个元素            pre: function() {                if (--index &gt; 0) {                    return items[index];                } else {                    index = 0;                    return null;                }            },            // 获取后一个元素            next: function() {                if (++index &lt; length) {                    return items[index];                } else {                    index = length - 1;                    return null;                }            },            // 获取某一个元素            get: function(num) {                index = num &gt;= 0 ? num % length : num % length + length;                return items[index];            },            // 对每一个元素执行某一个方法            dealEach: function(fn) {                var args = splice.call(arguments, 1);                for (var i = 0; i &lt; length; i++) {                    fn.apply(items[i], args);                };            },            // 对某一个元素执行某一个方法            dealItem: function(num, fn) {                fn.apply(this.get(num), splice.call(arguments, 2));            },            // 排他方式处理某一个元素            exclusive: function(num, allFn, numFn) {                this.dealEach(allFn);                if (Object.prototype.toString.call(num) === &#39;[object Array]&#39;) {                    for (var i = 0, len = num.length; i &lt; len; i++) {                        this.dealItem(num[i], numFn);                    };                } else {                    this.dealItem(num, numFn);                }            },        }    }    var demo = new Iterator(&#39;li&#39;, &#39;container&#39;);    console.log(demo.first());    console.log(demo.last());    console.log(demo.pre());    console.log(demo.next());    console.log(demo.get(1));    demo.dealEach(function(text, color) {        this.innerHTML = text;        this.style.background = color;    }, &#39;test&#39;, &#39;pink&#39;);    demo.exclusive([2, 3], function() {        this.innerHTML = &#39;被排除的&#39;;        this.style.background = &#39;green&#39;;    }, function() {        this.innerHTML = &#39;被选中的&#39;;        this.style.background = &#39;red&#39;;    })&lt;/script&gt;</code></pre><h1 id="参与者模式"><a href="#参与者模式" class="headerlink" title="参与者模式"></a>参与者模式</h1><p>其实就是把函数绑定和函数柯里化结合起来的设计模式</p><pre><code>if (Function.prototype.bind === undefined) {    Function.prototype.bind = function(context) {        var slice = Array.prototype.slice,            args = slice.call(arguments, 1),            that = this;        return function() {            var addArgs = slice.call(arguments),                allArgs = args.concat(addArgs);            return that.apply(context, allArgs);        }        }};</code></pre><h1 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h1><pre><code>&lt;script&gt;    // 数据访问对象模式可以方便我们对前端存储的管理，并且使用时更方便    var BaseLocalStorage = function(preId, timeSign) {        this.preId = preId; // 定义本地存储数据前缀        this.timeSign = timeSign || &#39;|-|&#39;; // 定义时间戳与存储数据之间的拼接符    }    BaseLocalStorage.prototype = {        status: {            SUCCESS: 0, // 成功            FAILURE: 1, // 失败            OVERFLOW: 2, // 溢出            TIMEOUT: 3, // 过期        }, // 操作状态        storage: localStorage || window.localStorage, // 保存本地存储链接        getKey: function(key) {            return this.preId + key;        }, // 获取本地存储数据库数据真实字段        /**         * 添加修改数据         * @param {string}   key      数据字段标识         * @param {string}   value    数据值         * @param {Function} callback 回调函数         * @param {time}     time     添加时间         */        set: function(key, value, callback, time) {            var status = this.status.SUCCESS,                key = this.getKey[key];            try {                time = new Date(time).getTime() || time.getTime();            } catch(e) {                time = Date.now() + 1000 * 60 * 60 * 24 * 31;            }            try {                this.storage.setItem[key, time + this.timeSign + value];            } catch(e) {                status = this.status.OVERFLOW;            }            callback &amp;&amp; callback.call(this, status, key, value);        },        /**         * 获取数据         * @param  {string}   key      数据字段标识         * @param  {Function} callback 回调函数         * @return {[object]}          值和状态         */        get: function(key, callback) {            var status = this.status.SUCCESS,                key = this.getKey[key],                value = null,                timeSignLen = this.timeSign.length,                that = this,                index,                time,                result;            try {                value = that.storage.getItem(key);            } catch(e) {                result = {                    status: that.status.FAILURE,                    value: null,                }                callback &amp;&amp; callback.call(this, result.status, result.value);                return result;            }            if (value) {                index = value.indexOf(that.timeSign);                time = +value.slice(0, index);                if (new Date(time).getTime() &gt; Date.now() || time == 0) {                    value = value.slice(index + timeSignLen);                } else {                    value = null,                    status = that.status.TIMEOUT;                    that.remove(key);                }            } else {                status = that.status.FAILURE;            }            result = {                status: status,                value: value            };            callback &amp;&amp; callback.call(this, result.status, result.value);            return result;        },        /**         * 删除数据         * @param  {string}   key      数据字段标识         * @param  {Function} callback 回调函数         */        remove: function(key, callback) {            var status = this.status.FAILURE,                key = this.getKey[key],                value = null;            try {                value = this.storage.getItem(key);            } catch(e) {}            if (value) {                try {                    this.storage.removeItem(key);                    status = this.status.SUCCESS;                } catch(e) {}            };            callback &amp;&amp; callback.call(this, status, status &gt; 0 ? null : value.slice(value.indexOf(this.timeSign) + this.timeSign.length))        }    }    var LS = new BaseLocalStorage(&#39;LS__&#39;);    LS.set(&#39;a&#39;, &#39;xiao ming&#39;, function() {console.log(arguments);})    LS.remove(&#39;a&#39;, function() {console.log(arguments);})    LS.remove(&#39;a&#39;, function() {console.log(arguments);})    LS.get(&#39;a&#39;, function() {console.log(arguments);})&lt;/script&gt;</code></pre><h1 id="等待者模式"><a href="#等待者模式" class="headerlink" title="等待者模式"></a>等待者模式</h1><pre><code>&lt;script&gt;var Waiter = function() {    var dfd = [], // 注册等待对象容器        doneArr = [], // 成功回调方法容器        failArr = [], // 失败回调方法容器        slice = Array.prototype.slice,        that = this;    // 监控对象类    var Primise = function() {        this.resolved = false;        this.rejected = false;    }    // 监控对象类原型方法    Primise.prototype = {        resolve: function() {            this.resolved = true;            if (!dfd.length) return;            for(var i = dfd.length - 1; i &gt;= 0; i--) {                // 如果有任意一个监控对象没有被解决或者解决失败则返回                if (dfd[i] &amp;&amp; !dfd[i].resolved || dfd[i].rejected) {                    return;                };                // 清除监控对象                dfd.splice(i, 1);            }            // 执行解决成功回调方法            _exec(doneArr);        },        reject: function() {            this.rejected = true;            if (!dfd.length) return;            // 清除所有监控对象            dfd.splice(0);            // 执行解决成功回调方法            _exec(failArr);        }    }    // 创建监控对象    that.Deferred = function() {        return new Primise();    }    // 回调执行方法    function _exec(arr) {        var i = 0,            len = arr.length;        for(; i &lt; len; i ++) {            try {                arr[i] &amp;&amp; arr[i]();            } catch(e) {}        }    };    // 监控异步方法 参数 监控对象    that.when = function() {        dfd = slice.call(arguments);        var i = dfd.length;        for( --i; i &gt;= 0; i --) {            // 如果不存在监控对象，或者监控对象已经解决，或者不是监控对象            if(!dfd || dfd[i].resolved || dfd[i].rejected || !dfd[i] instanceof Primise) {                dfd.splice(i, 1);            }        }        return that;    };    // 解决成功回调函数添加方法    that.done = function() {        doneArr = doneArr.concat(slice.call(arguments));        return that;    };    // 解决失败回调函数添加方法    that.fail = function() {        failArr = failArr.concat(slice.call(arguments));        return that;    };}var waiter = new Waiter();var first = function() {    var dtd = waiter.Deferred();    setTimeout(function(){        console.log(&quot;first finish&quot;);        // 发布解决成功消息        dtd.resolve();    }, 500)    return dtd;}();var second = function() {    var dtd = waiter.Deferred();    setTimeout(function(){        console.log(&quot;second finish&quot;);        // 发布解决成功消息        dtd.resolve();    }, 500)    return dtd;}();waiter    .when(first, second)    .done(function() {        console.log(&quot;success&quot;);    }, function() {        console.log(&quot;success again&quot;);    })    .fail(function() {        console.log(&quot;fail&quot;);    })// first finish// second finish// success// success again&lt;/script&gt;</code></pre><h1 id="同步模块模式"><a href="#同步模块模式" class="headerlink" title="同步模块模式"></a>同步模块模式</h1><pre><code>&lt;div id=&quot;test&quot;&gt;                fsadas         &lt;/div&gt;&lt;script&gt;(function() {    var F = F || {};    /**     * 定义模块方法     * @param  {string}   str 模块路由     * @param  {Function} fn  模块方法     */    F.define = function(str, fn) {        var parts = str.split(&#39;.&#39;),            old = parent = this,            i = len = 0;        // 如果第一个模式是模块管理器单体对象，则移除        if (parts[0] === &#39;F&#39;) {            parts = parts.slice(1);        };        // 屏蔽对define与module模块方法的重写        if (parts[0] === &#39;define&#39; || parts[0] === &#39;module&#39;) {            return;        };        for(len = parts.length; i &lt; len; i ++) {            if (typeof parent[parts[i]] === &#39;undefined&#39;) {                // 生命当前模块                parent[parts[i]] = {};            };        }        // 缓存下一层的祖父模块        old = parent;        // 缓存下一层级父模块        parent = parent[parts[i]];        if (fn) {            old[parts[-- i]] = fn();        };    }    F.module = function() {        var args = [].slice.call(arguments),            // 获取回调执行函数            fn = args.pop(),            // 获取依赖模块，如果args[0]是数组，则依赖模块为args[0]，否则依赖模块为arg            parts = args[0] &amp;&amp; args[0] instanceof Array ? args[0] : args,            // 依赖模块列表            modules = [],            // 模块路由            modIds = &#39;&#39;,            // 依赖模块索引            i = 0,            // 依赖模块长度            ilen = parts.length,            // 父模块，模块路由层级索引，模块路由层级长度            parent, j, jlen;        // 遍历依赖模块        while(i &lt; ilen) {            // 如果是路由模块            if (typeof parts[i] === &#39;string&#39;) {                // 设置当前模块父对象F                parent = this;                // 解析模块路由，并屏蔽掉模块父对象                modIds = parts[i].replace(/^F\./, &#39;&#39;).split(&#39;.&#39;)                // 遍历模块路由层级                for(j = 0, jlen = modIds.length; j &lt; jlen; j ++) {                    // 重置父模块                    parent = parent[modIds[j]] || false;                }                // 将模块添加到依赖模块列表中                modules.push(parent);            } else { // 如果是模块对象                // 直接加入依赖模块列表中                modules.push(parts[i]);            }            i ++;        }        fn.apply(null, modules);    }    F.define(&#39;string&#39;, function() {        return {            trim: function(str) {                return str.replace(/^\s+|\s+$/g, &#39;&#39;);            }        }    })    F.define(&#39;dom&#39;, function() {        var $ = function(id) {            $.dom = document.getElementById(id);            return $;        }        $.html = function(html) {            if (html) {                this.dom.innerHTML = html;                return this;            } else {                return this.dom.innerHTML;            }        }        return $;    });    console.log(F.dom(&#39;test&#39;).html());    console.log(F.string.trim(&#39;    范德萨更大噶  &#39;));    F.module(&#39;dom&#39;, &#39;string.trim&#39;, function(dom, trim) {        var html = dom(&#39;test&#39;).html();        var str = trim(html);        console.log(&#39;***&#39; + html + &#39;***&#39; + str + &#39;***&#39;);    })})()&lt;/script&gt;</code></pre><h1 id="异步模块模式"><a href="#异步模块模式" class="headerlink" title="异步模块模式"></a>异步模块模式</h1><pre><code>&lt;script&gt;// 向闭包中传入模块管理器对象F，~屏蔽压缩文件时，前面漏写;报错~(function(F) {    // 模块缓存器。存储已创建模块    var moduleCache = {        /**         * 设置模块并执行模块构造函数         * @param {[type]}   moduleName 模块id名称         * @param {[type]}   params     依赖模块         * @param {Function} callback   模块构造函数         */        setModule: function(moduleName, params, callback) {            // 模块容器，模块文件加载完成回调函数            var _module, fn;            // 如果模块被调用过            if (moduleCach[moduleName]) {                // 获取模块                _module = moduleCache[moduleName];                // 设置模块已经加载完成                _module.status = &#39;loaded&#39;;                // 矫正模块接口                _module.exports = callback ? callback.apply(_module, params) : null;                // 执行模块文件加载完成回调函数                while(fn = _module.onload.shift()) {                    fn(_module.exports);                }            } else {                // 模块不存在，则直接执行构造函数                callback &amp;&amp; callback.apply(null, params)            }        },        /**         * 异步加载依赖模块所在文件         * @param  {[type]} moduleName 模块路径         * @param  {[Function]} callback  模块加载完成回调函数         * @return {[type]}            [description]         */        loadModule: function(moduleName, callback) {            // 依赖模块            var _module;            // 如果依赖模块被要求加载过            if (moduleCache[moduleName]) {                // 获取该模块信息                _module = moduleCache[moduleName];                // 如果模块加载完成                if (_module.status === &#39;loaded&#39;) {                    // 执行模块加载完成回调函数                    setTimeout(callback(_module.exports), 0);                } else {                    // 缓存该模块所处文件加载完成回调函数                    _module.onload.push(callback);                }            } else { // 模块第一次被依赖引用                // 缓存该模块初始化信息                moduleCache[moduleName] = {                    moduleName: moduleName,                    status: &#39;loading&#39;, // 模块对应文件加载状态，默认加载中                    exports: null, // 模块接口                    onload: [callback] // 模块对应文件加载完成回调函数缓冲器                }            };            // 加载模块对应文件            loadScript(getUrl[moduleName]);        }    };    // 获取文件路径    getUrl: function(moduleName) {        return String(moduleName).replace(/\.js$/g, &#39;&#39;) + &#39;.js&#39;;    },    // 加载脚本文件    loadScript: function(src) {        var _script = document.createElement(&#39;script&#39;);        _script.type = &#39;text/JavaScript&#39;;        _script.charset = &#39;UTF-8&#39;;        _script.async = true;        _script.src = src;        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(_script);    }})((function() {    // 创建模块管理对象F,并保存在全局作用域中    return window.F = {        /**         * 创建或调用模块方法         * @param  {string} url         参数为模块url         * @param  {[type]} modDeps     参数为依赖模块         * @param  {[type]} modCallback 参数为模块主函数         */        module: function(url, modDeps, modCallback) {                // 将参数转化为数组            var args = [].slice.call(arguments),                // 获取模块构造函数（参数数组中最后一个参数成员）                callback = args.pop(),                // 获取依赖模块（紧邻回调函数参数，且数据类型为数组）                deps = (args.length &amp;&amp; args[args.length - 1] instanceof Array) ? args.pop() : [];                // 该模块url                url = args.length ? args.pop() : null,                // 依赖模块序列                params = [],                // 未加载的依赖模块数量统计                depsCount = 0,                // 依赖模块序列中索引值                i = 0,                // 依赖模块序列长度                len;            // 获取依赖模块长度            if (len = deps.length) {                // 遍历依赖模块                while(i &lt; len) {                    // 闭包保存i                    (function(i) {                        // 增加未加载依赖模块数量统计                        depsCount ++;                        // 异步加载依赖模块                        loadModule(deps[i], function(mod) {                            // 依赖模块序列中添加依赖模块接口引用                            params[i] = mod;                            // 依赖模块加载完成，依赖模块数量统计减一                            depsCount --;                            // 如果依赖模块全部加载                            if (depsCount === 0) {                                // 在模块缓存器中矫正该模块，并执行构造函数                                setModule(url, param, callback);                            };                        })                    })(i)                    i ++;                }            } else { // 无依赖模块，直接执行回调函数                // 在模块缓存器中矫正该模块，并执行构造函数                setModule(url, [], callback);            }        }    };})());&lt;/script&gt;</code></pre><h1 id="链模式（仿jquery）"><a href="#链模式（仿jquery）" class="headerlink" title="链模式（仿jquery）"></a>链模式（仿jquery）</h1><pre><code>&lt;div id=&quot;demo&quot;&gt;123&lt;/div&gt;&lt;script&gt;    var A = function(selector, context) {        return new A.fn.init(selector, context);    }    A.fn = A.prototype = {        constructor: A,        init: function(selector, context) {            this.length = 0,            context = context || document;            if(~selector.indexOf(&#39;#&#39;)) {                this[0] = document.getElementById(selector.slice(1));            } else {                var domes = context.getElementsByTagName(selector),                    i = 0,                    len = doms.length;                for(; i &lt; len; i ++) {                    this[i] = doms[i];                }                this.lenth = len;            }            this.context = context;            this.selector = selector;            return this;        }    }    console.log(A(&#39;#demo&#39;));&lt;/script&gt;</code></pre><h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><pre><code>&lt;script&gt;    var obj = {        &#39;name&#39;: &#39;zs&#39;,        &#39;age&#39;: 11,        &#39;say&#39;: function(){            console.log(this.name);        }    }console.log(&#39;-----------------------------------------------------------------------&#39;);    var Singletom = function(name, age){        this.name = name;        this.age = age;        this.instance = null;        this.say = function(){            console.log(this.name);        }    }    function getInstance(name, age){        return this.instance || (this.instance = new Singletom(name, age));     }    var a = getInstance(&#39;zs&#39;, 11);    var b = getInstance(&#39;ls&#39;, 12);    a.say();    b.say();    console.log(a);    console.log(b);    console.log(a.name);    console.log(a.age);console.log(&#39;-----------------------------------------------------------------------&#39;);    var getInstance2 = function(fn){        var result;        return function(){            return result || (result = fn.call(this, arguments));        }    }    // 创建div    var createWindow = function(){        var div = document.createElement(&quot;div&quot;);        div.innerHTML = &quot;我是弹窗内容&quot;;        div.style.display = &#39;none&#39;;        document.body.appendChild(div);        return div;    };    var divs = getInstance2(createWindow);    console.log(divs());&lt;/script&gt;</code></pre><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><pre><code>职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个对象分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，他都可能是请求的发起者也可能是请求的接收者。通过这样的方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与元请求的接收者之间的耦合。当然也方便对每个阶段对象进行单元测试。同时对于中途插入的请求，此模式依然使用，并可顺利对请求执行并产出结果。对于职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费，并且多个对象参与请求的传递，这在代码调试时增加了调试成本。有感：职责链模式就是把一个复杂的逻辑处理分解成更细粒度的单元，结合项目中，就是把请求，弹框等功能分解封装好，职责链这种设计模式有利于实现那种某些需求点不确定的需求，把不确定的需求单独抽离出来并且单独封装，其他的功能点或需求点不影响，有利于分别对各个功能点做测试。</code></pre><h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><pre><code>&lt;script&gt;// MVC架构模式很好地解决了页面中数据层、视图层、业务逻辑层（控制器）之间的耦合关系，使它们得到显性的区分，这也使得层次之间的耦合度降低。我们在开发中可以不用顾忌所有需求而专注于某一层次开发，降低了开发与维护成本，提升了开发效率。如果页面系统足够复杂，某些视图要共享同一组数据，或者某些需求的实现引用类似视图，此时MVC模式便可提高某些视图与数据的复用率。$(function() {    var MVC = MVC || {};    MVC.model = function() {        // 内部数据对象        var M = {};        // 服务器端获取的数据，通常通过ajax获取并存储        M.data = {};        // 配置数据，页面加载时即提供        M.conf = {};        // 返回数据模型层对象操作方法        return {            // 获取服务器端数据            getData: function(m) {                return M.data[m];            },            // 获取配置数据            getConf: function(c) {                return M.conf[c];            },            // 设置服务器端数据            setData: function(m, v) {                M.data[m] = v;                return this;            },            // 设置配置数据            setConf: function(c, v) {                M.conf[c] = v;                return this;            }        }    }();    MVC.view = function() {        // 模型数据层对象操作方法引用        var M = MVC.model;        // 内部视图创建方法对象        var V = {};        // 获取视图接口方法        return function(v) {            // 根据视图名称返回视图            V[v]();        }    }();    MVC.controller = function() {        // 模型数据层对象操作方法引用        var M = MVC.model;        // 视图数据层对象操作方法引用        var V = MVC.view;        // 控制器创建方法对象        var C = {};    }();})&lt;/script&gt;</code></pre><h1 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h1><pre><code>&lt;script&gt;~(function(window) {    var MVP = function() {};    MVP.model = function() {        var M = {};        M.data = [            {                text: &#39;新闻头条&#39;,                mode: &#39;news&#39;,                url: &#39;http://www.example.com/01&#39;            },            {                text: &#39;最新电影&#39;,                mode: &#39;movie&#39;,                url: &#39;http://www.example.com/02&#39;            }        ];        M.conf = {};        return {            getData: function(m) {                return M.data(m);            },            /**             * 设置数据             * @param {[type]} m 模块名称             * @param {[type]} v 模块数据             */            setData: function(m, v) {                M.data[m] = v;                return v;            },            getConf: function(c) {                return M.conf[c]            },            /**             * 设置配置             * @param {[type]} c 配置项名称             * @param {[type]} v 配置项值             */            setConf: function(c, v) {                M.conf[c] = v;                return v;            }        }    }();    MVP.view = function() {        // 子元素或者兄弟元素替换模板        var REPLACEKEY = &#39;__REPLACEKEY__&#39;;        // 获取完整元素模板        function getHTML(str, type) {            return str                    .replace(/^(\w+)()[^\{\}*]?(\{([@\w]+)\})?(.*?)$/, function(match, $1, $2, $3, $4, $5) {                        $2 = $2 || &#39;&#39;;                        $3 = $3 || &#39;&#39;;                        $4 = $4 || &#39;&#39;;                        $5 = $5.replace(/\{([@\w]+)\}/g, &#39;&#39;);                        return type === &#39;in&#39; ?                        &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + REPLACEKEY + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39;:                            type === &#39;add&#39; ?                            &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39; + REPLACEKEY                            :                            &#39;&lt;&#39; + $1 + $2 + $5 + &#39;&gt;&#39; + $4 + &#39;&lt;/&#39; + $1 + &#39;&gt;&#39;                    })                    .replace(/#([@\-\w]+)/g, &#39; id=&quot;$1&quot;&#39;)                    .replace(/\.([@\-\s\w]+/g, &#39; class=&quot;$1&quot;&#39;)                    .replace(/\[(.+)\]/g, function(match, key) {                        var a = key                                .replace(/&#39;|&quot;/g, &#39;&#39;)                                .split(&#39; &#39;),                            h = &#39;&#39;;                        for(var j = 0, len = a.length; j &lt; len; j ++) {                            h += &#39; &#39; + a[j].replace(/=(.*)/g, &#39;=&quot;$1&quot;&#39;);                        }                        return h;                    })                    .replace(/@(\w+)/g, &#39;&#39;);        }        function eachArray(arr, fn) {            for(var i = 0, len = arr.length; i &lt; len; i ++) {                // 将索引值、索引对应值、数组长度传入回调函数中并执行                fn(i, arr[i], len);            }        }        /**         * 替换兄弟元素模板或者子元素模板         * @param  {[type]} str 原始字符串         * @param  {[type]} rep 兄弟元素模板或者子元素模板         */        function formateItem(str, rep) {            // 用对应元素字符串替换兄弟元素模板或者子元素模板            return str.replace(new RegExp(REPLACEKEY, &#39;g&#39;), rep);        }        return function(str) {            var part = str                .replace(/^\s+|\s+$/g, &#39;&#39;)                .replace(/^\s+(&gt;)\s+/g, &#39;$1&#39;)                .split(&#39;&gt;&#39;),                html = REPLACEKEY,                item,                nodeTpl;            eachArray(part, function(partIndex, partValue, partLen) {                item = partValue.split(&#39;+&#39;);                nodeTpl = REPLACEKEY;                eachArray(item, function(itemIndex, itemValue, itemLen) {                    nodeTpl = formateItem(nodeTpl, getHTML(itemValue, itemIndex === itemLen - 1 ? (partIndex === partLen - 1 ? &#39;&#39; : &#39;in&#39;) : &#39;add&#39;));                })                html = formateItem(html, nodeTpl);            })            return html;        }    }()    MVP.presenter = function() {        var V = MVP.view;        var M = MVP.model;        var C = {};        return {            init: function() {                for(var i in C) {                    C[i] &amp;&amp; C[i](M, V, i);                }            },            add: function(modName, pst) {                C[modName] = pst;                return this;            }        }    }();    MVP.init = function() {};    window.MVP = MVP;})(window)var C = {    nav: function(M, V) {        var data = M.getData(&#39;nav&#39;);        data[0].choose = &#39;choose&#39;;        data[data.length - 1].last = &#39;last&#39;;        var tpl = V(&#39;li.@mode @choose @last[data-mode=@mode]&gt;a#nax_@mode.nav-@mode[href=@url title=@text]&gt;i.nav-icon-@mode-@mode+span{@text}&#39;);        $        .create(&#39;ul&#39;, {            &#39;class&#39;: &#39;navigator&#39;,            &#39;id&#39;: &#39;nav&#39;        })        .html(            A.formateString(tpl, data)        )        .appendTo(&#39;#container&#39;);    }}window.onload = function() {    MVP.init();}&lt;/script&gt;</code></pre><h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><pre><code>&lt;div class=&quot;first&quot; data-bind=&quot;type: &#39;slider&#39;, data: demo1&quot;&gt;test1&lt;/div&gt;&lt;div class=&quot;second&quot; data-bind=&quot;type: &#39;slider&#39;, data: demo2&quot;&gt;test2&lt;/div&gt;&lt;div class=&quot;third&quot; data-bind=&quot;type: &#39;progressbar&#39;, data: demo3&quot;&gt;test3&lt;/div&gt;&lt;script&gt;~(function() {    var window = this || (0, eval)(&#39;this&#39;);    // 获取页面字体大小，作为创建页面UI尺寸参照物    var FONTSIZE = function() {        // 获取页面body元素字体大小并转化成整数。        return parseInt(document.body.currentStyle ? document.body.currentStyle[&#39;fontSize&#39;] : getComputedStyle(document.body, false)[&#39;fontSize&#39;]);    }();    // 视图模型对象（策略对象）    var VM = function() {        var Method = {            progressbar: function(dom, data) {                // 进度条进度完成容器                var progress = document.createElement(&#39;div&#39;),                    param = data.data;                // 设置进度完成容器尺寸                progress.style.width = (param.position || 100) + &#39;%&#39;;                // 为进度条组件添加UI样式                dom.className += &#39; ui-progressbar&#39;;                // 进度完成容器元素插入进度条容器中                dom.appendChild(progress);            },            slider: function(dom, data) {                // 滚动条拨片                var bar = document.createElement(&#39;span&#39;),                    // 滑动条进度容器                    progress = document.createElement(&#39;div&#39;),                    // 滑动条容量提示信息                    totleText = null,                    // 滑动条拨片提示信息                    progressText = null,                    // 数据模型数据，结构{position: 60, totle: 200}                    param = data.data,                    // 容器元素宽度                    width = dom.clientWidth,                    // 容器元素横坐标值                    left = dom.offsetLeft,                    // 拨片位置                    realWidth = (param.position || 100) * width / 100;                // 清空滑动条容器，为创建滑动条作准备                dom.innerHTML = &#39;&#39;;                // 如果模型数据中提供容器总量信息，则创建滚动条提示文案                if (param.totle) {                    // 容器总量提示文案                    text = document.createElement(&#39;b&#39;);                    // 拨片位置提示文案                    progressText = document.createElement(&#39;em&#39;);                    // 设置容器总量提示文案                    text.innerHTML = param.totle;                    // 将容器总量提示文案元素添加到滑动条组件中                    dom.appendChild(text);                    // 将拨片位置提示文案元素添加到滑动条组件中                    dom.appendChild(progressText);                };                // 设置滑动条                setStyle(realWidth);                // 为滑动条组件添加UI样式                dom.className += &#39; ui-slider&#39;;                // 将进度容器添加到滑动条组件中                dom.appendChild(progress);                // 将拨片添加到滑动条组件中                dom.appendChild(bar);                // 设置滑动条                function setStyle(w) {                    // 设置进度容器宽度                    progress.style.width = w + &#39;px&#39;;                    // 设置拨片横坐标                    bar.style.left = w - FONTSIZE / 2 + &#39;px&#39;;                    // 如果有拨片提示文案                    if (progressText) {                        // 设置拨片提示文案横坐标                        progressText.style.left = w - FONTSIZE / 2 * 2.4 + &#39;px&#39;;                        // 设置拨片提示文案内容                        progressText.innerHTML = parseFloat(w / width * 100).toFixed(2) + &#39;%&#39;;                    };                }                //创建组件逻辑 按下鼠标拨片                bar.onmousedown = function() {                    // 移动拨片（鼠标光标在页面中滑动，事件绑定给document是为了优化交互体验，使鼠标光标可以在页面中自由滑动）                    document.onmousemove = function(event) {                        var e = event || window.event;                        var w = e.clientX - left;                        // 设置滑动条                        setStyle(w &lt; width ? ( w &gt; 0 ? w : 0) : width);                    }                    // 阻止页面滑动选取事件                    document.onselectstart = function() {                        return false;                    }                    // 停止滑动交互                    document.onmouseup = function() {                        // 取消文档鼠标光标移动事件                        document.onmousemove = null;                        // 取消文档滑动选取事件                        document.onselectstart = null;                    }                }            }        }        /**         * 获取视图层组件渲染数据的映射信息         * @param  {[type]} dom 组件元素         */        function getBindData(dom) {            // 获取组件自定义属性data-bind值            var data = dom.getAttribute(&#39;data-bind&#39;);            // 将自定义属性data-bind值转化为对象            return !!data &amp;&amp; (new Function(&quot;return ({&quot;+ data +&quot;})&quot;))();        }        // 组件实例化方法        return function() {            var doms = document.body.getElementsByTagName(&#39;*&#39;),            // 元素自定义数据句柄                ctx = null;            // ui处理是会向页面中插入元素，此时doms.length会改变，此时动态获取dom.length            for(var i = 0; i &lt; doms.length; i ++) {                // 获取元素自定义数据                ctx = getBindData(doms[i]);                // 如果元素是ui组件，则根据自定义属性中组件类型，渲染该组件                ctx.type &amp;&amp; Method[ctx.type] &amp;&amp; Method[ctx.type](doms[i], ctx);            }        }    }();    // 将视图模型对象绑定在Window上，供外部获取    window.VM = VM;})()var demo1 = {        position: 60,        totle: 200    },    demo2 = {        position: 20    },    demo3 = {position: 50};window.onload = function() {    VM();}&lt;/script&gt;</code></pre><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><pre><code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;script&gt;// 其实就是js里组合继承，构造函数绑定属性，原型绑定方法// 每页显示5条数据，不够5条从最前面取var FlyWeight = function() {    var created = [];    function create() {        var dom = document.createElement(&#39;div&#39;);        document.getElementById(&#39;container&#39;).appendChild(dom);        created.push(dom);        return dom;    }    return {        getDiv: function() {            if (created.length &lt; 5) {                return create();            } else {                var div = created.shift();                created.push(div);                return div;            }        }    }}()console.log(FlyWeight.getDiv());for(var i = 0; i &lt; 5; i ++) {    FlyWeight.getDiv().innerHTML = i;}&lt;/script&gt;</code></pre><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><pre><code>var MarrySate = function() {    var _currentState = {},        status = {            jump: function() { console.log(&quot;jump&quot;); },            move: function() { console.log(&quot;move&quot;); },            shoot: function() { console.log(&quot;shoot&quot;); },            squat: function() { console.log(&quot;squat&quot;); }        };    var Action = {        changeState: function() {            var arg = arguments;            _currentState = {};            for(var i = 0, len = arg.length; i &lt; len; i ++) {                _currentState[arg[i]] = true;            }            return this;        },        goes: function() {            console.log(&quot;触发了&quot;);            for(var k in _currentState) {                _currentState[k] &amp;&amp; status[k]();            }        }    }    return {        change: Action.changeState,        goes: Action.goes    }}MarrySate()        .change(&#39;jump&#39;, &#39;move&#39;)        .goes()// 触发了// jump// move</code></pre><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>可以利用该模式封装弹层插件<br><code>`</code></p></blockquote><p><script><br>var Alert = function(data) {<br>    if (!data) return;<br>    // 设置内容<br>    this.content = data.content;<br>    // 创建提示框面板<br>    this.panel = document.createElement(‘div’);<br>    // 创建提示内容组件<br>    this.contentNode = document.createElement(‘p’);<br>    // 创建确定按钮组件<br>    this.confirmBtn = document.createElement(‘span’);<br>    // 创建关闭按钮组件<br>    this.closeBtn = document.createElement(‘b’);<br>    // 为提示框面板增加类<br>    this.panel.className = ‘alert’;<br>    // 为关闭按钮增加类<br>    this.closeBtn.className = ‘a-close’;<br>    // 为确定按钮增加类<br>    this.confirmBtn.className = ‘a-confirm’;<br>    // 为关闭按钮增加文案<br>    this.closeBtn.innerHTML = data.close || ‘关闭’;<br>    // 为确定按钮增加文案<br>    this.confirmBtn.innerHTML = data.confirm || ‘确定’;<br>    // 为提示内容增加文本<br>    this.contentNode.innerHTML = this.content;<br>    // 点击确定按钮执行方法 如果data中有succuess方法则为success方法，否则为空函数<br>    this.success = data.success || function() {};<br>    // 点击关闭按钮执行方法<br>    this.fail = data.fail || function() {};<br>}<br>// 提示框原型方法<br>Alert.prototype = {<br>    init: function() {<br>        this.panel.appendChild(this.closeBtn);<br>        this.panel.appendChild(this.contentNode);<br>        this.panel.appendChild(this.confirmBtn);<br>        document.body.appendChild(this.panel);<br>        this.bindEvent();<br>        this.show();<br>    },<br>    bindEvent: function() {<br>        var self = this;<br>        this.closeBtn.onclick = function() {<br>            self.fail();<br>            self.hide();<br>        }<br>        this.confirmBtn.onclick = function() {<br>            self.success();<br>            self.hide();<br>        }<br>    },<br>    hide: function() {<br>        this.panel.style.display = ‘none’;<br>    },<br>    show: function() {<br>        this.panel.style.display = ‘block’;<br>    }<br>}<br>new Alert({<br>    ‘content’: ‘test’,<br>    ‘close’: ‘close test’<br>}).init()</p><p>var RightAlert = function(data) {<br>    Alert.call(this, data);<br>    this.confirmBtn.className = this.confirmBtn.className + ‘ right’;<br>}<br>RightAlert.prototype = new Alert();<br>new RightAlert({<br>    ‘content’: ‘test’,<br>    ‘close’: ‘right close test’<br>}).init()<br></script><br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要学习设计模式？&quot;&gt;&lt;a href=&quot;#为什么要学习设计模式？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习设计模式？&quot;&gt;&lt;/a&gt;为什么要学习设计模式？&lt;/h1&gt;&lt;p&gt;为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。&lt;/p&gt;
&lt;h2 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计模式是我们每天编程遇到的问题的可重用解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设计模式主要是为了解决对象的生成和整合问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;换句话说，设计模式可以作为可应用于现实世界编程问题的模板。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读万卷书，不如行万里路。接下来要贴代码了，从代码中就可以理解常用设计模式的主要概念。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;观察者模式（发布\订阅模式）&lt;/li&gt;
&lt;li&gt;中介者模式&lt;/li&gt;
&lt;li&gt;策略模式/状态模式&lt;/li&gt;
&lt;li&gt;命令模式&lt;/li&gt;
&lt;li&gt;迭代器模式&lt;/li&gt;
&lt;li&gt;参与者模式&lt;/li&gt;
&lt;li&gt;数据访问对象模式&lt;/li&gt;
&lt;li&gt;等待者模式&lt;/li&gt;
&lt;li&gt;同步模块模式&lt;/li&gt;
&lt;li&gt;异步模块模式&lt;/li&gt;
&lt;li&gt;链模式&lt;/li&gt;
&lt;li&gt;构造函数模式&lt;/li&gt;
&lt;li&gt;职责链模式&lt;/li&gt;
&lt;li&gt;MVC模式&lt;/li&gt;
&lt;li&gt;MVP模式&lt;/li&gt;
&lt;li&gt;MVVM模式&lt;/li&gt;
&lt;li&gt;享元模式&lt;/li&gt;
&lt;li&gt;状态模式&lt;/li&gt;
&lt;li&gt;模板方法模式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 设计模式" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码简洁之道</title>
    <link href="http://www.icrazyman.cn/2019/01/08/JavaScript%20%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://www.icrazyman.cn/2019/01/08/JavaScript 代码简洁之道/</id>
    <published>2019-01-08T13:54:29.000Z</published>
    <updated>2019-01-08T14:58:59.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。"><a href="#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。" class="headerlink" title="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。"></a>测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</h1><p>代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。</p><p>本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。</p><p>我们将从几个方面展开讨论：</p><ol><li><p>变量</p></li><li><p>函数</p></li><li><p>对象和数据结构</p></li><li><p>类</p></li><li><p>SOLID</p></li><li><p>测试</p></li><li><p>异步</p></li><li><p>错误处理</p></li><li><p>代码风格</p></li><li><p>注释</p></li></ol><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="用有意义且常用的单词命名变量"><a href="#用有意义且常用的单词命名变量" class="headerlink" title="用有意义且常用的单词命名变量"></a>用有意义且常用的单词命名变量</h2><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad:"></a>Bad:</h3><p><code>const yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;);</code></p><h3 id="Good"><a href="#Good" class="headerlink" title="Good:"></a>Good:</h3><p><code>const currentDate = moment().format(&#39;YYYY/MM/DD&#39;);</code></p><h2 id="保持统一"><a href="#保持统一" class="headerlink" title="保持统一"></a>保持统一</h2><p>可能同一个项目对于获取用户信息，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 codelf 搜索，看别人是怎么取名的。</p><h3 id="Bad-1"><a href="#Bad-1" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  getUserInfo();  getClientData();  getCustomerRecord();</code></pre><h3 id="Good-1"><a href="#Good-1" class="headerlink" title="Good:"></a>Good:</h3><p><code>getUser()</code></p><h2 id="每个常量都该命名"><a href="#每个常量都该命名" class="headerlink" title="每个常量都该命名"></a>每个常量都该命名</h2><p>可以用 buddy.js 或者 ESLint 检测代码中未命名的常量。</p><h3 id="Bad-2"><a href="#Bad-2" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 三个月之后你还能知道 86400000 是什么吗?setTimeout(blastOff, 86400000);</code></pre><h3 id="Good-2"><a href="#Good-2" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const MILLISECOND_IN_A_DAY = 86400000;setTimeout(blastOff, MILLISECOND_IN_A_DAY);</code></pre><h2 id="可描述"><a href="#可描述" class="headerlink" title="可描述"></a>可描述</h2><p>通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。</p><h3 id="Bad-3"><a href="#Bad-3" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;saveCityZipCode(ADDRESS.match(CITY_ZIP_CODE_REGEX)[1],                ADDRESS.match(CITY_ZIP_CODE_REGEX)[2]);</code></pre><h3 id="Good-3"><a href="#Good-3" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;const [, city, zipCode] = ADDRESS.match(CITY_ZIP_CODE_REGEX) || [];saveCityZipCode(city, zipCode);</code></pre><h2 id="直接了当"><a href="#直接了当" class="headerlink" title="直接了当"></a>直接了当</h2><h3 id="Bad-4"><a href="#Bad-4" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];locations.forEach((l) =&gt; {  doStuff();  doSomeOtherStuff();  // ...  // ...  // ...  // 需要看其他代码才能确定 &#39;l&#39; 是干什么的。  dispatch(l);});</code></pre><h3 id="Good-4"><a href="#Good-4" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];locations.forEach((location) =&gt; {  doStuff();  doSomeOtherStuff();  // ...  // ...  // ...  dispatch(location);});</code></pre><h2 id="避免无意义的前缀"><a href="#避免无意义的前缀" class="headerlink" title="避免无意义的前缀"></a>避免无意义的前缀</h2><p>如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</p><h3 id="Bad-5"><a href="#Bad-5" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  const car = {    carMake: &#39;Honda&#39;,    carModel: &#39;Accord&#39;,    carColor: &#39;Blue&#39;  };  function paintCar(car) {    car.carColor = &#39;Red&#39;;  }</code></pre><h3 id="Good-5"><a href="#Good-5" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const car = {  make: &#39;Honda&#39;,  model: &#39;Accord&#39;,  color: &#39;Blue&#39;};function paintCar(car) {  car.color = &#39;Red&#39;;}</code></pre><h2 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h2><h3 id="Bad-6"><a href="#Bad-6" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMicrobrewery(name) {  const breweryName = name || &#39;Hipster Brew Co.&#39;;  // ...}</code></pre><h3 id="Good-6"><a href="#Good-6" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMicrobrewery(name = &#39;Hipster Brew Co.&#39;) {  // ...}</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数越少越好"><a href="#参数越少越好" class="headerlink" title="参数越少越好"></a>参数越少越好</h2><p>如果参数超过两个，使用 ES2015/ES6 的解构语法，不用考虑参数的顺序。（注：不要超过3个参数，如果确实需要3个以上的参数，用对象包起来）</p><h3 id="Bad-7"><a href="#Bad-7" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMenu(title, body, buttonText, cancellable) {  // ...}</code></pre><h3 id="Good-7"><a href="#Good-7" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#39;Foo&#39;,  body: &#39;Bar&#39;,  buttonText: &#39;Baz&#39;,  cancellable: true});</code></pre><h2 id="只做一件事情"><a href="#只做一件事情" class="headerlink" title="只做一件事情"></a>只做一件事情</h2><p>这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。</p><h3 id="Bad-8"><a href="#Bad-8" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function emailClients(clients) {  clients.forEach((client) =&gt; {    const clientRecord = database.lookup(client);    if (clientRecord.isActive()) {      email(client);    }  });}</code></pre><h3 id="Good-8"><a href="#Good-8" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function emailActiveClients(clients) {  clients    .filter(isActiveClient)    .forEach(email);}function isActiveClient(client) {  const clientRecord = database.lookup(client);      return clientRecord.isActive();}</code></pre><h2 id="顾名思义"><a href="#顾名思义" class="headerlink" title="顾名思义"></a>顾名思义</h2><p>看函数名就应该知道它是干啥的。(注：其实就是语义化命名，代码是给人看的)</p><h3 id="Bad-9"><a href="#Bad-9" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function addToDate(date, month) {  // ...}const date = new Date();// 很难知道是把什么加到日期中addToDate(date, 1);</code></pre><h3 id="Good-9"><a href="#Good-9" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function addMonthToDate(month, date) {  // ...}const date = new Date();addMonthToDate(1, date);</code></pre><h2 id="只需要一层抽象层"><a href="#只需要一层抽象层" class="headerlink" title="只需要一层抽象层"></a>只需要一层抽象层</h2><p>如果函数嵌套过多会导致很难复用以及测试。</p><h3 id="Bad-10"><a href="#Bad-10" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function parseBetterJSAlternative(code) {  const REGEXES = [    // ...  ];  const statements = code.split(&#39; &#39;);  const tokens = [];  REGEXES.forEach((REGEX) =&gt; {    statements.forEach((statement) =&gt; {      // ...    });  });  const ast = [];  tokens.forEach((token) =&gt; {    // lex...  });  ast.forEach((node) =&gt; {    // parse...  });}</code></pre><h3 id="Good-10"><a href="#Good-10" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function parseBetterJSAlternative(code) {  const tokens = tokenize(code);  const ast = lexer(tokens);  ast.forEach((node) =&gt; {    // parse...  });}function tokenize(code) {  const REGEXES = [    // ...  ];  const statements = code.split(&#39; &#39;);  const tokens = [];  REGEXES.forEach((REGEX) =&gt; {    statements.forEach((statement) =&gt; {      tokens.push( /* ... */ );    });  });  return tokens;}function lexer(tokens) {  const ast = [];  tokens.forEach((token) =&gt; {    ast.push( /* ... */ );  });  return ast;}</code></pre><h2 id="删除重复代码"><a href="#删除重复代码" class="headerlink" title="删除重复代码"></a>删除重复代码</h2><p>很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。</p><p>要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 SOLID 原则（SOLID 是什么？稍后会详细介绍）。</p><h3 id="Bad-11"><a href="#Bad-11" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function showDeveloperList(developers) {  developers.forEach((developer) =&gt; {    const expectedSalary = developer.calculateExpectedSalary();    const experience = developer.getExperience();    const githubLink = developer.getGithubLink();    const data = {      expectedSalary,      experience,      githubLink    };    render(data);  });}function showManagerList(managers) {  managers.forEach((manager) =&gt; {    const expectedSalary = manager.calculateExpectedSalary();    const experience = manager.getExperience();    const portfolio = manager.getMBAProjects();    const data = {      expectedSalary,      experience,      portfolio    };    render(data);  });}</code></pre><h3 id="Good-11"><a href="#Good-11" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function showEmployeeList(employees) {  employees.forEach(employee =&gt; {    const expectedSalary = employee.calculateExpectedSalary();    const experience = employee.getExperience();    const data = {      expectedSalary,      experience,    };    switch(employee.type) {      case &#39;develop&#39;:        data.githubLink = employee.getGithubLink();        break      case &#39;manager&#39;:        data.portfolio = employee.getMBAProjects();        break    }    render(data);  })}</code></pre><h2 id="对象设置默认属性"><a href="#对象设置默认属性" class="headerlink" title="对象设置默认属性"></a>对象设置默认属性</h2><h3 id="Bad-12"><a href="#Bad-12" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const menuConfig = {  title: null,  body: &#39;Bar&#39;,  buttonText: null,  cancellable: true};function createMenu(config) {  config.title = config.title || &#39;Foo&#39;;  config.body = config.body || &#39;Bar&#39;;  config.buttonText = config.buttonText || &#39;Baz&#39;;  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;}createMenu(menuConfig);</code></pre><h3 id="Good-12"><a href="#Good-12" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const menuConfig = {  title: &#39;Order&#39;,  // &#39;body&#39; key 缺失  buttonText: &#39;Send&#39;,  cancellable: true};function createMenu(config) {  config = Object.assign({    title: &#39;Foo&#39;,    body: &#39;Bar&#39;,    buttonText: &#39;Baz&#39;,    cancellable: true  }, config);  // config 就变成了: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}  // ...}createMenu(menuConfig);</code></pre><h2 id="不要传-flag-参数"><a href="#不要传-flag-参数" class="headerlink" title="不要传 flag 参数"></a>不要传 flag 参数</h2><p>通过 flag 的 true 或 false，来判断执行逻辑，违反了一个函数干一件事的原则。(这个持保留意见，只能说尽量不要把分支判断放在函数里面)</p><h3 id="Bad-13"><a href="#Bad-13" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createFile(name, temp) {  if (temp) {    fs.create(`./temp/${name}`);  } else {    fs.create(name);  }}</code></pre><h3 id="Good-13"><a href="#Good-13" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createFile(name) {  fs.create(name);}function createFileTemplate(name) {  createFile(`./temp/${name}`)}</code></pre><h2 id="避免副作用（第一部分）"><a href="#避免副作用（第一部分）" class="headerlink" title="避免副作用（第一部分）"></a>避免副作用（第一部分）</h2><p>函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。</p><p>当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。</p><p>副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。</p><p>（注：这就是纯函数的作用，同样的输入，返回的一定是同样的输入，这样对于结果是可预料的，不会出现意料之外甚至很难修复的问题）</p><h3 id="Bad-14"><a href="#Bad-14" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 全局变量被一个函数引用// 现在这个变量从字符串变成了数组，如果有其他的函数引用，会发生无法预见的错误。var name = &#39;Ryan McDermott&#39;;function splitIntoFirstAndLastName() {  name = name.split(&#39; &#39;);}splitIntoFirstAndLastName();console.log(name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h3 id="Good-14"><a href="#Good-14" class="headerlink" title="Good:"></a>Good:</h3><pre><code>var name = &#39;Ryan McDermott&#39;;var newName = splitIntoFirstAndLastName(name)function splitIntoFirstAndLastName(name) {  return name.split(&#39; &#39;);}console.log(name); // &#39;Ryan McDermott&#39;;console.log(newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];</code></pre><h2 id="避免副作用（第二部分）"><a href="#避免副作用（第二部分）" class="headerlink" title="避免副作用（第二部分）"></a>避免副作用（第二部分）</h2><p>在 JavaScript 中，基本类型通过赋值传递，对象和数组通过引用传递。以引用传递为例：</p><p>假如我们写一个购物车，通过 addItemToCart() 方法添加商品到购物车，修改 购物车数组。此时调用 purchase() 方法购买，由于引用传递，获取的 购物车数组 正好是最新的数据。</p><p>看起来没问题对不对？</p><p>如果当用户点击购买时，网络出现故障， purchase() 方法一直在重复调用，与此同时用户又添加了新的商品，这时网络又恢复了。那么 purchase() 方法获取到 购物车数组 就是错误的。</p><p>为了避免这种问题，我们需要在每次新增商品时，克隆 购物车数组 并返回新的数组。</p><h3 id="Bad-15"><a href="#Bad-15" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {  cart.push({ item, date: Date.now() });};</code></pre><h3 id="Good-15"><a href="#Good-15" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {  return [...cart, {item, date: Date.now()}]};</code></pre><h2 id="不要写全局方法"><a href="#不要写全局方法" class="headerlink" title="不要写全局方法"></a>不要写全局方法</h2><p>在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 Array.prototype 上新增一个 diff 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 diff 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 Array 进行扩展。</p><h3 id="Bad-16"><a href="#Bad-16" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>Array.prototype.diff = function diff(comparisonArray) {  const hash = new Set(comparisonArray);  return this.filter(elem =&gt; !hash.has(elem));};</code></pre><h3 id="Good-16"><a href="#Good-16" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class SuperArray extends Array {  diff(comparisonArray) {    const hash = new Set(comparisonArray);    return this.filter(elem =&gt; !hash.has(elem));          }}</code></pre><h2 id="比起命令式我更喜欢函数式编程"><a href="#比起命令式我更喜欢函数式编程" class="headerlink" title="比起命令式我更喜欢函数式编程"></a>比起命令式我更喜欢函数式编程</h2><p>函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。</p><h3 id="Bad-17"><a href="#Bad-17" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const programmerOutput = [  {    name: &#39;Uncle Bobby&#39;,    linesOfCode: 500  }, {    name: &#39;Suzie Q&#39;,    linesOfCode: 1500  }, {    name: &#39;Jimmy Gosling&#39;,    linesOfCode: 150  }, {    name: &#39;Gracie Hopper&#39;,    linesOfCode: 1000  }];let totalOutput = 0;for (let i = 0; i &lt; programmerOutput.length; i++) {  totalOutput += programmerOutput[i].linesOfCode;</code></pre><h3 id="Good-17"><a href="#Good-17" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const programmerOutput = [  {    name: &#39;Uncle Bobby&#39;,    linesOfCode: 500  }, {    name: &#39;Suzie Q&#39;,    linesOfCode: 1500  }, {    name: &#39;Jimmy Gosling&#39;,    linesOfCode: 150  }, {    name: &#39;Gracie Hopper&#39;,    linesOfCode: 1000  }];let totalOutput = programmerOutput  .map(output =&gt; output.linesOfCode)  .reduce((totalLines, lines) =&gt; totalLines + lines, 0)</code></pre><h2 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h2><h2 id="Bad-18"><a href="#Bad-18" class="headerlink" title="Bad:"></a>Bad:</h2><pre><code>if (fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) {  // ...}</code></pre><h2 id="Good-18"><a href="#Good-18" class="headerlink" title="Good:"></a>Good:</h2><pre><code>// 持保留意见function shouldShowSpinner(fsm, listNode) {  return fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode);}if (shouldShowSpinner(fsmInstance, listNodeInstance)) {  // ...}</code></pre><h2 id="尽量别用“非”条件句"><a href="#尽量别用“非”条件句" class="headerlink" title="尽量别用“非”条件句"></a>尽量别用“非”条件句</h2><h3 id="Bad-19"><a href="#Bad-19" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function isDOMNodeNotPresent(node) {  // ...}if (!isDOMNodeNotPresent(node)) {  // ...}</code></pre><h3 id="Good-19"><a href="#Good-19" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function isDOMNodePresent(node) {  // ...}if (isDOMNodePresent(node)) {  // ...}</code></pre><h2 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h2><p>Q：不用条件语句写代码是不可能的。</p><p>A：绝大多数场景可以用多态替代。</p><p>Q：用多态可行，但为什么就不能用条件语句了呢？</p><p>A：为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则。</p><h3 id="Bad-20"><a href="#Bad-20" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Airplane {  // ...  // 获取巡航高度  getCruisingAltitude() {    switch (this.type) {      case &#39;777&#39;:        return this.getMaxAltitude() - this.getPassengerCount();      case &#39;Air Force One&#39;:        return this.getMaxAltitude();      case &#39;Cessna&#39;:        return this.getMaxAltitude() - this.getFuelExpenditure();    }  }}</code></pre><h3 id="Good-20"><a href="#Good-20" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Airplane {  // ...}// 波音777class Boeing777 extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude() - this.getPassengerCount();  }}// 空军一号class AirForceOne extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude();  }}// 赛纳斯飞机class Cessna extends Airplane {  // ...  getCruisingAltitude() {    return this.getMaxAltitude() - this.getFuelExpenditure();  }}// 利用对象使用分支判断var Airplane = {    &#39;777&#39;: function() {        return this.getMaxAltitude() - this.getPassengerCount();    },    &#39;Air Force One&#39;: function() {        return this.getMaxAltitude();    },    &#39;Cessna&#39;: function() {        return this.getMaxAltitude() - this.getFuelExpenditure();    },}</code></pre><h2 id="避免类型检查（第一部分）"><a href="#避免类型检查（第一部分）" class="headerlink" title="避免类型检查（第一部分）"></a>避免类型检查（第一部分）</h2><p>JavaScript 是无类型的，意味着你可以传任意类型参数，这种自由度很容易让人困扰，不自觉的就会去检查类型。仔细想想是你真的需要检查类型还是你的 API 设计有问题？（注：持保留意见）</p><h3 id="Bad-21"><a href="#Bad-21" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function travelToTexas(vehicle) {  if (vehicle instanceof Bicycle) {    vehicle.pedal(this.currentLocation, new Location(&#39;texas&#39;));  } else if (vehicle instanceof Car) {    vehicle.drive(this.currentLocation, new Location(&#39;texas&#39;));  }}</code></pre><h3 id="Good-21"><a href="#Good-21" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function travelToTexas(vehicle) {  vehicle.move(this.currentLocation, new Location(&#39;texas&#39;));}</code></pre><h2 id="避免类型检查（第二部分）"><a href="#避免类型检查（第二部分）" class="headerlink" title="避免类型检查（第二部分）"></a>避免类型检查（第二部分）</h2><p>如果你需要做静态类型检查，比如字符串、整数等，推荐使用 TypeScript，不然你的代码会变得又臭又长。</p><pre><code class="Bad:">function combine(val1, val2) {  if (typeof val1 === &#39;number&#39; &amp;&amp; typeof val2 === &#39;number&#39; ||      typeof val1 === &#39;string&#39; &amp;&amp; typeof val2 === &#39;string&#39;) {    return val1 + val2;  }  throw new Error(&#39;Must be of type String or Number&#39;);}</code></pre><h3 id="Good-22"><a href="#Good-22" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(val1, val2) {  return val1 + val2;}</code></pre><h2 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h2><p>现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间，想知道现代浏览器优化了哪些内容，请点这里。（注：持保留意见，低版本的浏览器没有做该优化，虽然性能提升不大，但这是一个好的编码习惯）</p><h3 id="Bad-22"><a href="#Bad-22" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 在老的浏览器中，由于 `list.length` 没有做缓存，每次迭代都会去计算，造成不必要开销。// 现代浏览器已对此做了优化。for (let i = 0, len = list.length; i &lt; len; i++) {  // ...}</code></pre><h3 id="Good-23"><a href="#Good-23" class="headerlink" title="Good:"></a>Good:</h3><pre><code>for (let i = 0; i &lt; list.length; i++) {  // ...}</code></pre><h2 id="删除弃用代码"><a href="#删除弃用代码" class="headerlink" title="删除弃用代码"></a>删除弃用代码</h2><p>很多时候有些代码已经没有用了，但担心以后会用，舍不得删。</p><p>如果你忘了这件事，这些代码就永远存在那里了。</p><p>放心删吧，你可以在代码库历史版本中找他它。</p><p>（持保留意见，因为保留部分注释的重要代码是以防出现问题可以直接线上恢复代码而不用上紧急版本）</p><h3 id="Bad-23"><a href="#Bad-23" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function oldRequestModule(url) {  // ...}function newRequestModule(url) {  // ...}const req = newRequestModule;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);</code></pre><h3 id="Good-24"><a href="#Good-24" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function newRequestModule(url) {  // ...}const req = newRequestModule;inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);</code></pre><h1 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h1><h2 id="用-get、set-方法操作数据"><a href="#用-get、set-方法操作数据" class="headerlink" title="用 get、set 方法操作数据"></a>用 get、set 方法操作数据</h2><p>这样做可以带来很多好处，比如在操作数据时打日志，方便跟踪错误；在 set 的时候很容易对数据进行校验…</p><h3 id="Bad-24"><a href="#Bad-24" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function makeBankAccount() {  // ...  return {    balance: 0,    // ...  };}const account = makeBankAccount();account.balance = 100;</code></pre><h3 id="Good-25"><a href="#Good-25" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeBankAccount() {  // 私有变量  let balance = 0;  function getBalance() {    return balance;  }  function setBalance(amount) {    // ... 在更新 balance 前，对 amount 进行校验    balance = amount;  }  return {    // ...    getBalance,    setBalance,  };}const account = makeBankAccount();account.setBalance(100);</code></pre><h2 id="使用私有变量"><a href="#使用私有变量" class="headerlink" title="使用私有变量"></a>使用私有变量</h2><p>可以用闭包来创建私有变量</p><h3 id="Bad-25"><a href="#Bad-25" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const Employee = function(name) {  this.name = name;};Employee.prototype.getName = function getName() {  return this.name;};const employee = new Employee(&#39;John Doe&#39;);console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: undefined</code></pre><h3 id="Good-26"><a href="#Good-26" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeEmployee(name) {  return {    getName() {      return name;    },  };}const employee = makeEmployee(&#39;John Doe&#39;);console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doedelete employee.name;console.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe</code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="使用-class"><a href="#使用-class" class="headerlink" title="使用 class"></a>使用 class</h2><p>在 ES2015/ES6 之前，没有类的语法，只能用构造函数的方式模拟类，可读性非常差。</p><h3 id="Bad-26"><a href="#Bad-26" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 动物const Animal = function(age) {  if (!(this instanceof Animal)) {    throw new Error(&#39;Instantiate Animal with `new`&#39;);  }  this.age = age;};Animal.prototype.move = function move() {};// 哺乳动物const Mammal = function(age, furColor) {  if (!(this instanceof Mammal)) {    throw new Error(&#39;Instantiate Mammal with `new`&#39;);  }  Animal.call(this, age);  this.furColor = furColor;};Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function liveBirth() {};// 人类const Human = function(age, furColor, languageSpoken) {  if (!(this instanceof Human)) {    throw new Error(&#39;Instantiate Human with `new`&#39;);  }  Mammal.call(this, age, furColor);  this.languageSpoken = languageSpoken;};Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function speak() {};</code></pre><h3 id="Good-27"><a href="#Good-27" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 动物class Animal {  constructor(age) {    this.age = age  };  move() {};}// 哺乳动物class Mammal extends Animal{  constructor(age, furColor) {    super(age);    this.furColor = furColor;  };  liveBirth() {};}// 人类class Human extends Mammal{  constructor(age, furColor, languageSpoken) {    super(age, furColor);    this.languageSpoken = languageSpoken;  };  speak() {};</code></pre><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>这种模式相当有用，可以在很多库中发现它的身影，比如 jQuery、Lodash 等。它让你的代码简洁优雅。实现起来也非常简单，在类的方法最后返回 this 可以了。</p><h3 id="Bad-27"><a href="#Bad-27" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;  }  setModel(model) {    this.model = model;  }  setColor(color) {    this.color = color;  }  save() {    console.log(this.make, this.model, this.color);  }}const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;);car.setColor(&#39;pink&#39;);car.save();</code></pre><h3 id="Good-28"><a href="#Good-28" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Car {  constructor(make, model, color) {    this.make = make;    this.model = model;    this.color = color;  }  setMake(make) {    this.make = make;    return this;  }  setModel(model) {    this.model = model;    return this;  }  setColor(color) {    this.color = color;    return this;  }  save() {    console.log(this.make, this.model, this.color);    return this;  }}const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;)  .setColor(&#39;pink&#39;);  .save();</code></pre><h2 id="不要滥用继承"><a href="#不要滥用继承" class="headerlink" title="不要滥用继承"></a>不要滥用继承</h2><p>很多时候继承被滥用，导致可读性很差，要搞清楚两个类之间的关系，继承表达的一个属于关系，而不是包含关系，比如 Human-&gt;Animal vs. User-&gt;UserDetails</p><h3 id="Bad-28"><a href="#Bad-28" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Employee {  constructor(name, email) {    this.name = name;    this.email = email;  }  // ...}// TaxData（税收信息）并不是属于 Employee（雇员），而是包含关系。class EmployeeTaxData extends Employee {  constructor(ssn, salary) {    super();    this.ssn = ssn;    this.salary = salary;  }  // ...}</code></pre><h3 id="Good-29"><a href="#Good-29" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class EmployeeTaxData {  constructor(ssn, salary) {    this.ssn = ssn;    this.salary = salary;  }  // ...}class Employee {  constructor(name, email) {    this.name = name;    this.email = email;  }  setTaxData(ssn, salary) {    this.taxData = new EmployeeTaxData(ssn, salary);  }  // ...}</code></pre><h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。</p><h2 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 The Single Responsibility Principle"></a>单一功能原则 The Single Responsibility Principle</h2><p>如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p><h3 id="Bad-29"><a href="#Bad-29" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class UserSettings {  constructor(user) {    this.user = user;  }  changeSettings(settings) {    if (this.verifyCredentials()) {      // ...    }  }  verifyCredentials() {    // ...  }}</code></pre><h3 id="Good-30"><a href="#Good-30" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class UserAuth {  constructor(user) {    this.user = user;  }  verifyCredentials() {    // ...  }}class UserSetting {  constructor(user) {    this.user = user;    this.auth = new UserAuth(this.user);  }  changeSettings(settings) {    if (this.auth.verifyCredentials()) {      // ...    }  }}</code></pre><h2 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 The Open Closed Principle"></a>开闭原则 The Open Closed Principle</h2><p>“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。</p><h3 id="Bad-30"><a href="#Bad-30" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = &#39;ajaxAdapter&#39;;  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = &#39;nodeAdapter&#39;;  }}class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    if (this.adapter.name === &#39;ajaxAdapter&#39;) {      return makeAjaxCall(url).then((response) =&gt; {        // 传递 response 并 return      });    } else if (this.adapter.name === &#39;httpNodeAdapter&#39;) {      return makeHttpCall(url).then((response) =&gt; {        // 传递 response 并 return      });    }  }}function makeAjaxCall(url) {  // 处理 request 并 return promise}function makeHttpCall(url) {  // 处理 request 并 return promise}</code></pre><h3 id="Good-31"><a href="#Good-31" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class AjaxAdapter extends Adapter {  constructor() {    super();    this.name = &#39;ajaxAdapter&#39;;  }  request(url) {    // 处理 request 并 return promise  }}class NodeAdapter extends Adapter {  constructor() {    super();    this.name = &#39;nodeAdapter&#39;;  }  request(url) {    // 处理 request 并 return promise  }}class HttpRequester {  constructor(adapter) {    this.adapter = adapter;  }  fetch(url) {    return this.adapter.request(url).then((response) =&gt; {      // 传递 response 并 return    });  }}</code></pre><h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 Liskov Substitution Principle"></a>里氏替换原则 Liskov Substitution Principle</h2><p>名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。</p><h3 id="Bad-31"><a href="#Bad-31" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 长方形class Rectangle {  constructor() {    this.width = 0;    this.height = 0;  }  setColor(color) {    // ...  }  render(area) {    // ...  }  setWidth(width) {    this.width = width;  }  setHeight(height) {    this.height = height;  }  getArea() {    return this.width * this.height;  }}// 正方形class Square extends Rectangle {  setWidth(width) {    this.width = width;    this.height = width;  }  setHeight(height) {    this.width = height;    this.height = height;  }}function renderLargeRectangles(rectangles) {  rectangles.forEach((rectangle) =&gt; {    rectangle.setWidth(4);    rectangle.setHeight(5);    const area = rectangle.getArea();     rectangle.render(area);  });}const rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);</code></pre><h3 id="Good-32"><a href="#Good-32" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Shape {  setColor(color) {    // ...  }  render(area) {    // ...  }}class Rectangle extends Shape {  constructor(width, height) {    super();    this.width = width;    this.height = height;  }  getArea() {    return this.width * this.height;  }}class Square extends Shape {  constructor(length) {    super();    this.length = length;  }  getArea() {    return this.length * this.length;  }}function renderLargeShapes(shapes) {  shapes.forEach((shape) =&gt; {    const area = shape.getArea();    shape.render(area);  });}const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes);</code></pre><h2 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 The Interface Segregation Principle"></a>接口隔离原则 The Interface Segregation Principle</h2><p>JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。</p><h3 id="Bad-32"><a href="#Bad-32" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.animationModule.setup();  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName(&#39;body&#39;),  animationModule() {} // Most of the time, we won&#39;t need to animate when traversing.  // ...});</code></pre><h3 id="Good-33"><a href="#Good-33" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class DOMTraverser {  constructor(settings) {    this.settings = settings;    this.options = settings.options;    this.setup();  }  setup() {    this.rootNode = this.settings.rootNode;    this.setupOptions();  }  setupOptions() {    if (this.options.animationModule) {      // ...    }  }  traverse() {    // ...  }}const $ = new DOMTraverser({  rootNode: document.getElementsByTagName(&#39;body&#39;),  options: {    animationModule() {}  }});</code></pre><h2 id="依赖倒置原则-The-Dependency-Inversion-Principle"><a href="#依赖倒置原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则 The Dependency Inversion Principle"></a>依赖倒置原则 The Dependency Inversion Principle</h2><p>说就两点：</p><ul><li><p>高层次模块不能依赖低层次模块，它们依赖于抽象接口。</p></li><li><p>抽象接口不能依赖具体实现，具体实现依赖抽象接口。</p></li></ul><p>总结下来就两个字，解耦。</p><h3 id="Bad-33"><a href="#Bad-33" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 库存查询class InventoryRequester {  constructor() {    this.REQ_METHODS = [&#39;HTTP&#39;];  }  requestItem(item) {    // ...  }}// 库存跟踪class InventoryTracker {  constructor(items) {    this.items = items;    // 这里依赖一个特殊的请求类，其实我们只是需要一个请求方法。    this.requester = new InventoryRequester();  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;]);inventoryTracker.requestItems();</code></pre><h3 id="Good-34"><a href="#Good-34" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 库存跟踪class InventoryTracker {  constructor(items, requester) {    this.items = items;    this.requester = requester;  }  requestItems() {    this.items.forEach((item) =&gt; {      this.requester.requestItem(item);    });  }}// HTTP 请求class InventoryRequesterHTTP {  constructor() {    this.REQ_METHODS = [&#39;HTTP&#39;];  }  requestItem(item) {    // ...  }}// webSocket 请求class InventoryRequesterWS {  constructor() {    this.REQ_METHODS = [&#39;WS&#39;];  }  requestItem(item) {    // ...  }}// 通过依赖注入的方式将请求模块解耦，这样我们就可以很轻易的替换成 webSocket 请求。const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;], new InventoryRequesterHTTP());inventoryTracker.requestItems();</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>随着项目变得越来越庞大，时间线拉长，有的老代码可能半年都没碰过，如果此时上线，你有信心这部分代码能正常工作吗？测试的覆盖率和你的信心是成正比的。</p><p>PS: 如果你发现你的代码很难被测试，那么你应该优化你的代码了。</p><h2 id="单一化"><a href="#单一化" class="headerlink" title="单一化"></a>单一化</h2><h3 id="Bad-34"><a href="#Bad-34" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import assert from &#39;assert&#39;;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {  it(&#39;handles date boundaries&#39;, () =&gt; {    let date;    date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);    date.addDays(30);    assert.equal(&#39;1/31/2015&#39;, date);    date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);    date.addDays(28);    assert.equal(&#39;02/29/2016&#39;, date);    date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);    date.addDays(28);    assert.equal(&#39;03/01/2015&#39;, date);  });});</code></pre><h3 id="Good-35"><a href="#Good-35" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import assert from &#39;assert&#39;;describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {  it(&#39;handles 30-day months&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);    date.addDays(30);    assert.equal(&#39;1/31/2015&#39;, date);  });  it(&#39;handles leap year&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);    date.addDays(28);    assert.equal(&#39;02/29/2016&#39;, date);  });  it(&#39;handles non-leap year&#39;, () =&gt; {    const date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);    date.addDays(28);    assert.equal(&#39;03/01/2015&#39;, date);  });});</code></pre><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="不再使用回调"><a href="#不再使用回调" class="headerlink" title="不再使用回调"></a>不再使用回调</h2><p>不会有人愿意去看嵌套回调的代码，用 Promises 替代回调吧。</p><h3 id="Bad-35"><a href="#Bad-35" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request&#39;;import { writeFile } from &#39;fs&#39;;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;, (requestErr, response) =&gt; {  if (requestErr) {    console.error(requestErr);  } else {    writeFile(&#39;article.html&#39;, response.body, (writeErr) =&gt; {      if (writeErr) {        console.error(writeErr);      } else {        console.log(&#39;File written&#39;);      }    });  }});</code></pre><h3 id="Good-36"><a href="#Good-36" class="headerlink" title="Good:"></a>Good:</h3><pre><code>get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)  .then((response) =&gt; {    return writeFile(&#39;article.html&#39;, response);  })  .then(() =&gt; {    console.log(&#39;File written&#39;);  })  .catch((err) =&gt; {    console.error(err);  });</code></pre><h2 id="Async-Await-比起-Promises-更简洁"><a href="#Async-Await-比起-Promises-更简洁" class="headerlink" title="Async/Await 比起 Promises 更简洁"></a>Async/Await 比起 Promises 更简洁</h2><h3 id="Bad-36"><a href="#Bad-36" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request-promise&#39;;import { writeFile } from &#39;fs-promise&#39;;get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)  .then((response) =&gt; {    return writeFile(&#39;article.html&#39;, response);  })  .then(() =&gt; {    console.log(&#39;File written&#39;);  })  .catch((err) =&gt; {    console.error(err);  });</code></pre><h3 id="Good-37"><a href="#Good-37" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import { get } from &#39;request-promise&#39;;import { writeFile } from &#39;fs-promise&#39;;async function getCleanCodeArticle() {  try {    const response = await get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;);    await writeFile(&#39;article.html&#39;, response);    console.log(&#39;File written&#39;);  } catch(err) {    console.error(err);  }}</code></pre><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要忽略抛异常"><a href="#不要忽略抛异常" class="headerlink" title="不要忽略抛异常"></a>不要忽略抛异常</h2><h3 id="Bad-37"><a href="#Bad-37" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>try {  functionThatMightThrow();} catch (error) {  console.log(error);}</code></pre><h3 id="Good-38"><a href="#Good-38" class="headerlink" title="Good:"></a>Good:</h3><pre><code>try {  functionThatMightThrow();} catch (error) {  // 这一种选择，比起 console.log 更直观  console.error(error);  // 也可以在界面上提醒用户  notifyUserOfError(error);  // 也可以把异常传回服务器  reportErrorToService(error);  // 其他的自定义方法}</code></pre><h2 id="不要忘了在-Promises-抛异常"><a href="#不要忘了在-Promises-抛异常" class="headerlink" title="不要忘了在 Promises 抛异常"></a>不要忘了在 Promises 抛异常</h2><h3 id="Bad-38"><a href="#Bad-38" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>getdata()  .then((data) =&gt; {    functionThatMightThrow(data);  })  .catch((error) =&gt; {    console.log(error);  });</code></pre><h3 id="Good-39"><a href="#Good-39" class="headerlink" title="Good:"></a>Good:</h3><pre><code>getdata()  .then((data) =&gt; {    functionThatMightThrow(data);  })  .catch((error) =&gt; {    // 这一种选择，比起 console.log 更直观    console.error(error);    // 也可以在界面上提醒用户    notifyUserOfError(error);    // 也可以把异常传回服务器    reportErrorToService(error);    // 其他的自定义方法  });</code></pre><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。</p><h2 id="常量大写"><a href="#常量大写" class="headerlink" title="常量大写"></a>常量大写</h2><h3 id="Bad-39"><a href="#Bad-39" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const DAYS_IN_WEEK = 7;const daysInMonth = 30;const songs = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];const Artists = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];function eraseDatabase() {}function restore_database() {}class animal {}class Alpaca {}</code></pre><h3 id="Good-40"><a href="#Good-40" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const DAYS_IN_WEEK = 7;const DAYS_IN_MONTH = 30;const SONGS = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];const ARTISTS = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];function eraseDatabase() {}function restoreDatabase() {}class Animal {}class Alpaca {}</code></pre><h2 id="先声明后调用"><a href="#先声明后调用" class="headerlink" title="先声明后调用"></a>先声明后调用</h2><p>就像我们看报纸文章一样，从上到下看，所以为了方便阅读把函数声明写在函数调用前面。</p><h3 id="Bad-40"><a href="#Bad-40" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class PerformanceReview {  constructor(employee) {    this.employee = employee;  }  lookupPeers() {    return db.lookup(this.employee, &#39;peers&#39;);  }  lookupManager() {    return db.lookup(this.employee, &#39;manager&#39;);  }  getPeerReviews() {    const peers = this.lookupPeers();    // ...  }  perfReview() {    this.getPeerReviews();    this.getManagerReview();    this.getSelfReview();  }  getManagerReview() {    const manager = this.lookupManager();  }  getSelfReview() {    // ...  }}const review = new PerformanceReview(employee);review.perfReview();</code></pre><h3 id="Good-41"><a href="#Good-41" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class PerformanceReview {  constructor(employee) {    this.employee = employee;  }  perfReview() {    this.getPeerReviews();    this.getManagerReview();    this.getSelfReview();  }  getPeerReviews() {    const peers = this.lookupPeers();    // ...  }  lookupPeers() {    return db.lookup(this.employee, &#39;peers&#39;);  }  getManagerReview() {    const manager = this.lookupManager();  }  lookupManager() {    return db.lookup(this.employee, &#39;manager&#39;);  }  getSelfReview() {    // ...  }}const review = new PerformanceReview(employee);review.perfReview();</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="只有业务逻辑需要注释"><a href="#只有业务逻辑需要注释" class="headerlink" title="只有业务逻辑需要注释"></a>只有业务逻辑需要注释</h2><p>代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p><h3 id="Bad-41"><a href="#Bad-41" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function hashIt(data) {  // 这是初始值  let hash = 0;  // 数组的长度  const length = data.length;  // 循环数组  for (let i = 0; i &lt; length; i++) {    // 获取字符代码    const char = data.charCodeAt(i);    // 修改 hash    hash = ((hash &lt;&lt; 5) - hash) + char;    // 转换为32位整数    hash &amp;= hash;  }}</code></pre><h3 id="Good-42"><a href="#Good-42" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function hashIt(data) {  let hash = 0;  const length = data.length;  for (let i = 0; i &lt; length; i++) {    const char = data.charCodeAt(i);    hash = ((hash &lt;&lt; 5) - hash) + char;    // 转换为32位整数    hash &amp;= hash;  }}</code></pre><h2 id="删掉注释的代码"><a href="#删掉注释的代码" class="headerlink" title="删掉注释的代码"></a>删掉注释的代码</h2><p>git 存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧。</p><h3 id="Bad-42"><a href="#Bad-42" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff();</code></pre><h3 id="Good-43"><a href="#Good-43" class="headerlink" title="Good:"></a>Good:</h3><pre><code>doStuff();</code></pre><p>javascript</p><p>不要记日记<br>记住你有 git！，git log 可以帮你干这事。</p><h3 id="Bad-43"><a href="#Bad-43" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>/** * 2016-12-20: 删除了 xxx * 2016-10-01: 改进了 xxx * 2016-02-03: 删除了第12行的类型检查 * 2015-03-14: 增加了一个合并的方法 */function combine(a, b) {  return a + b;}</code></pre><h3 id="Good-44"><a href="#Good-44" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(a, b) {  return a + b;}</code></pre><h2 id="注释不需要高亮"><a href="#注释不需要高亮" class="headerlink" title="注释不需要高亮"></a>注释不需要高亮</h2><p>注释高亮，并不能起到提示的作用，反而会干扰你阅读代码。（注：在联调或临时修改代码调试的时候可以用此方法引起自己的注意，保证在提交代码的时候可以注意到此处，不会造成调试代码的提交）</p><h3 id="Bad-44"><a href="#Bad-44" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////$scope.model = {  menu: &#39;foo&#39;,  nav: &#39;bar&#39;};////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////const actions = function() {  // ...};</code></pre><h3 id="Good-45"><a href="#Good-45" class="headerlink" title="Good:"></a>Good:</h3><pre><code>$scope.model = {  menu: &#39;foo&#39;,  nav: &#39;bar&#39;};const actions = function() {  // ...};</code></pre><p>文末推荐一篇很好的讲述前端代码规范的文章，包含前端各种代码的规范，我觉得可以根据自己公司项目的实际情况借鉴一二。<a href="https://guide.aotu.io/docs/index.html" target="_blank" rel="noopener">前端代码规范</a></p><blockquote><p>翻译自 ryanmcdermott 的 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a>，本文对原文进行了一些修改。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。&quot;&gt;&lt;a href=&quot;#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。&quot; class=&quot;headerlink&quot; title=&quot;测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。&quot;&gt;&lt;/a&gt;测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。&lt;/h1&gt;&lt;p&gt;代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。&lt;/p&gt;
&lt;p&gt;本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。&lt;/p&gt;
&lt;p&gt;我们将从几个方面展开讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象和数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SOLID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码风格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript 代码 风格 编码" scheme="http://www.icrazyman.cn/tags/JavaScript-%E4%BB%A3%E7%A0%81-%E9%A3%8E%E6%A0%BC-%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript运算符优先级和隐式转换</title>
    <link href="http://www.icrazyman.cn/2018/12/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.icrazyman.cn/2018/12/26/JavaScript运算符优先级和隐式转换/</id>
    <published>2018-12-26T12:40:51.000Z</published>
    <updated>2018-12-26T15:28:19.783Z</updated>
    
    <content type="html"><![CDATA[<p>昨天圣诞节，本应该是一个开心的日子，但对有些程序猿来说，是非常糟糕的一天。在很多技术开发群里，在技术论坛以及github社区都炸天了。我想说的是，使用开源的人，得有感激之心，但是贡献开源的人更应该要有敬畏之心。我们要感谢每一个开源的人，他们为这个世界贡献了自己的力量，为这个社会提高了效率，而开源的人也应该怀有敬畏之心，尊重每一个使用者，更好地回馈使用者，使用者和开源这相互成就。</p><p>好了，话说回来，今天看了一篇文章，其中有一个题目感觉非常有趣，我也给大家送一个彩蛋吧，其中也引发了我对JavaScript运算符和隐式转换的思考了，所以还是坐下来静下心把JavaScript的运算符和隐式转换学习总结了一下，但其中难免会有些错误，不喜勿喷啊！</p><p>先贴个彩蛋：</p><p><code>({}+[])[[~!+[]]*~+[]]+(!(~+[])+{})[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]</code></p><p>各位童鞋，你算出来了吗？点击后将揭晓答案哦！当然，等不及的童鞋肯定自己在控制台复制粘贴得出结果了吧，呵呵！</p><a id="more"></a><p>答案就是：</p><p><img src="https://i.imgur.com/8IpzJoy.png" alt=""></p><p>哈哈，是不是被骂了还在问人这段代码是什么意思呢？</p><p>我来告诉你：</p><p>这段代码为什么会输出sb呢？其实这段代码考的是js的类型转化的一些基本原理。</p><p>首先要运用到的第一个知识就是js运算符的优先级，因为这么长一段运算看的人眼花，我们必须得先根据优先级分成n小段，然后再各个击破。</p><h1 id="js运算符的优先级"><a href="#js运算符的优先级" class="headerlink" title="js运算符的优先级"></a>js运算符的优先级</h1><p>优先级的排列如下表，优先级从高到低：</p><p><img src="https://i.imgur.com/b834A7c.jpg" alt=""></p><p>根据此规则，我们把这一串运算分为以下表达式：</p><p><img src="https://i.imgur.com/cdDv5jr.png" alt=""></p><p>其实中括号[]也是一个运算符，用来通过索引访问数组项，另外也可以访问字符串的子字符，有点类似charAt方法，如：’abcd’[1] // 返回’b’。而且中括号的优先级还是最高的哦。</p><p>接下来需要运用的就是JavaScript的类型转化知识了，我们先说说什么情况下需要进行类型转化。当操作符两边的操作数类型不一致或者不是基本类型（也叫原始类型）时，需要进行类型转化。</p><p>让我们快速的复习一下，在JavaScript中，一共有两种类型的值：原始值(primitives)和对象值(objects)。</p><p>原始值有：undefined、null、布尔值(booleans)、数字(numbers)、还有字符串(strings)。</p><p>其他的所有值都是对象类型的值，包括数组(arrays)和函数(functions)。</p><h1 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h1><p>先按运算符来分一下类：</p><p>减号-，乘号*，肯定是进行数学运算，所以操作数需转化为number类型。</p><p>加号+，可能是字符串拼接，也可能是数学运算，所以可能会转化为number或string。</p><p>一元运算，如+[]，只有一个操作数的，转化为number类型。</p><p>下面来看一下转化规则。</p><h2 id="对于非原始类型的，通过ToPrimitive-将值转换成原始类型"><a href="#对于非原始类型的，通过ToPrimitive-将值转换成原始类型" class="headerlink" title="对于非原始类型的，通过ToPrimitive()将值转换成原始类型"></a>对于非原始类型的，通过ToPrimitive()将值转换成原始类型</h2><p><code>ToPrimitive(input, PreferredType?)</code></p><p>可选参数PreferredType是Number或者是String。返回值为任何原始值。</p><p>如果PreferredType是Number，执行顺序如下：</p><ol><li><p>如果input为primitive，返回；</p></li><li><p>如果input为Object。调用obj.valueOf()，如果结果是primitive，返回；</p></li><li><p>否则，调用obj.toString()，如果结果是primitive，返回；</p></li><li><p>否则，抛出TypeError。</p></li></ol><p>如果 PreferredType是String，步骤2跟3互换，如果PreferredType没有，Date实例被设置成String，其他都是Number。</p><h2 id="通过ToNumber-将值转换为数字"><a href="#通过ToNumber-将值转换为数字" class="headerlink" title="通过ToNumber()将值转换为数字"></a>通过ToNumber()将值转换为数字</h2><p>通过ToNumber()把值转换成Number，直接看ECMA 9.3的表格：</p><p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,Number)将该对象转换为原始值，然后在调用ToNumber()将这个原始值转换为数字。</p><h2 id="通过ToString-将值转换为字符串"><a href="#通过ToString-将值转换为字符串" class="headerlink" title="通过ToString()将值转换为字符串"></a>通过ToString()将值转换为字符串</h2><p>通过ToString()把值转化成字符串， 直接看ECMA 9.8的表格</p><p><img src="https://i.imgur.com/9hKHPCu.jpg" alt=""></p><p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,String)将该对象转换为原始值，然后再调用ToString()将这个原始值转换为字符串.规则就这么多，接下来实践一下，根据我们上面划分出的子表达式，一步一步将这个神奇的代码给执行出来。开工~</p><p>先看最简单的子表达式：</p><p><code>+[]</code></p><p>只有一个操作数[]，肯定是转化为number了，根据上面的规则2，[]是个数组，object类型，即对象。所以得先调用toPrimitive转化为原始类型，并且PreferredType为number，这个参数表示更“倾向于”转化的类型，这里肯定是number了。然后首先调用数组的valueOf方法，数组调用valueOf会返回自身，</p><p>这个时候，我们得到一个空串“”，还没有结束，看上面的规则2描述，继续调用toNumber，转化为number类型，大功告成！子表达式16转化完毕，+[]，最终得到0。</p><p>来看子表达式：</p><p><code>[~+&quot;&quot;]</code></p><p>空串””前面有两个一元操作符，但是操作数还是只有一个，所以，最终要转化为的类型是number。看规则2吧，空串调用toNumber得到0。接下来是~，这是个什么东东呢？它是位运算符，作用可以记为把数字取负然后减一，所以~0就是-1 。</p><p>别忘了，这个子表达式外头还包着中括号，所以最终的值为[-1]，即一个数组，里面只有一个元素-1.</p><p>接下来看子表达式就简单了</p><p>把以上求出来的填进去，就变成了这样：–[-1][0]，取数组的第0个元素，然后自减，结果为-2，是不so easy!</p><p>继续往后走，子表达式：</p><p><code>[~+[]]</code></p><p>其实把上面的原理用上就非常明显了，答案[-1]。</p><p>继续，此刻它已变成：-2<em>[-1]，有稍许不一样，不过没关系，我们还是按照规则来，运算符是乘号</em>，当然是做数学运算，那后面的[-1]就得转化为number，过程如下：</p><ol><li><p>调用toPrimitive，发现是object类型</p></li><li><p>调用valueOf，返回自身[-1]</p></li><li><p>因为不是原始类型，继续调用toString，返回”-1”</p></li><li><p>“-1”是原始类型了，然后调用toNumber，返回-1</p></li><li><p>与-2相乘，返回2</p></li></ol><p>子表达式：</p><p><code>~~!+[]</code></p><p>不多说了，答案1。就是从右往左依次一元计算。</p><p>此刻它已经长这样了：2+1， 好，我不多说了。</p><p>继续看表达式：</p><p><code>!(~+[])，~+[]=-1</code></p><p>这个根据上面已经知道了，那!-1是什么呢？这里要说一下这个感叹号，它是逻辑取非的意思，会把表达式转化为布尔类型，转化规则和js的Truthy和Falsy原则是一样的，后面跟数字的，除0以外都为false，后面跟字符串的，除空串以外都为false。这里的!-1当然就是false了。</p><p>接下来这个表达式3：false+{}有点关键</p><p>一个布尔加一个对象，那这个{}应该先转化为原始类型，流程如下：</p><ol><li><p>调用toPrimitive，发现是object类型</p></li><li><p>调用valueOf，返回自身{}，</p></li><li><p>不是原始类型，调用toString，返回</p></li><li><p>[objectObject]</p></li><li><p>false与[objectObject]相加，false先转化为字符串”false”</p></li></ol><p>相加得结果false[objectObject] 此时它是这样的：false[objectObject][3]，因为这个[]可以取字符串的子字符，像charAt一样，所以得到了结果”s”</p><p>经过上面艰难的流程，我们拿到了字符”s”，也就是那张图的左半边，剩下的那个”b”，相同的原理可以搞出来，我这里就不一一演示了，留给你练练吧~</p><p>回顾一下这个过程其实也不复杂，只是有一些需要重复劳动的，只要你掌握了运算的优先级，能把大串分解成一个个小串，然后运用类型转化的知识挨个处理就搞定了。怎么样，看到这里你还觉得神奇吗？</p><p>同样的，中文字符也是由这样组成的，跟英文同样的道理。</p><h1 id="操作符也会影响数据的类型转换"><a href="#操作符也会影响数据的类型转换" class="headerlink" title="操作符也会影响数据的类型转换"></a>操作符也会影响数据的类型转换</h1><ol><li><p>当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为数字类型</p></li><li><p>当+号作为二元操作符时，如果两个操作数中存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串</p></li><li><p>当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作</p></li><li><p>当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。</p></li></ol><h1 id="引用对象如何转换为简单值"><a href="#引用对象如何转换为简单值" class="headerlink" title="引用对象如何转换为简单值"></a>引用对象如何转换为简单值</h1><ol><li><p>一个复杂对象在转为基础类型的时候会调用ToPrimitive(hint)方法来指定其目标类型</p></li><li><p>如果传入的hint值为number,那么就先调用对象的valueOf()方法，调用完valueOf()方法后，如果返回的是原始值，则结束ToPrimitive操作</p></li><li><p>如果返回的不是原始值，则继续调用对象的toString()方法，调用完toString()方法之后如果返回的是一个原始值，则结束ToPrimitive操作</p></li><li><p>如果返回的还是复杂值，则抛出异常。如果传入的hint值为string，则先调用toString()方法，再调用valueOf()方法，其余的过程一样。</p></li></ol><h1 id="那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？"><a href="#那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？" class="headerlink" title="那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？"></a>那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？</h1><ol><li><p>如果运行环境非常明确的需要将一个复杂对象转换为数字则传入number如 Number(value) 和 +value 则传入number</p></li><li><p>如果运行环境非常明确的需要将一个复杂对象转换为字符串则传入string如String(value) 和 alert(value) 则传入string</p></li><li><p>如果是用+号连接两个操作数，操作数在确定确定其中只要有一个为字符串的时候另外一个操作数会转为字符串，ToPrimitive()会传入string，但是如果两个操作数都不能确定是字符串的时候则默认传入number(Date对象是一个例外，它会默认传入string)进行数据类型转换。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天圣诞节，本应该是一个开心的日子，但对有些程序猿来说，是非常糟糕的一天。在很多技术开发群里，在技术论坛以及github社区都炸天了。我想说的是，使用开源的人，得有感激之心，但是贡献开源的人更应该要有敬畏之心。我们要感谢每一个开源的人，他们为这个世界贡献了自己的力量，为这个社会提高了效率，而开源的人也应该怀有敬畏之心，尊重每一个使用者，更好地回馈使用者，使用者和开源这相互成就。&lt;/p&gt;
&lt;p&gt;好了，话说回来，今天看了一篇文章，其中有一个题目感觉非常有趣，我也给大家送一个彩蛋吧，其中也引发了我对JavaScript运算符和隐式转换的思考了，所以还是坐下来静下心把JavaScript的运算符和隐式转换学习总结了一下，但其中难免会有些错误，不喜勿喷啊！&lt;/p&gt;
&lt;p&gt;先贴个彩蛋：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;({}+[])[[~!+[]]*~+[]]+(!(~+[])+{})[--[~+&amp;quot;&amp;quot;][+[]]*[~+[]] + ~~!+[]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;各位童鞋，你算出来了吗？点击后将揭晓答案哦！当然，等不及的童鞋肯定自己在控制台复制粘贴得出结果了吧，呵呵！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript 运算符 优先级 隐式转换" scheme="http://www.icrazyman.cn/tags/JavaScript-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%BC%98%E5%85%88%E7%BA%A7-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>js 事件循环（Event Loop）机制</title>
    <link href="http://www.icrazyman.cn/2018/12/22/js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event%20Loop%EF%BC%89%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.icrazyman.cn/2018/12/22/js 事件循环（Event Loop）机制/</id>
    <published>2018-12-22T01:56:26.000Z</published>
    <updated>2019-02-14T13:53:14.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先放个测试题，压压惊</p></blockquote><pre><code>const interval = setInterval(()=&gt;{  console.log(&#39;setInterval&#39;);},0);setTimeout(()=&gt;{  console.log(&#39;setTimeout 1&#39;);  Promise.resolve()    .then(()=&gt;{      console.log(&#39;promise1&#39;);      })    .then(()=&gt;{      setTimeout(()=&gt;{        console.log(&#39;setTimeout 2&#39;);        clearInterval(interval);      },0);    })},0);Promise.resolve()  .then(()=&gt;{     console.log(&#39;promise2&#39;);})</code></pre><p><strong>末尾揭晓答案</strong></p><a id="more"></a><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p><p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p><p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p><p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p><p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p><p>可以预见，未来的javascript也会一直是一门单线程的语言。</p><h1 id="单线程的优劣势"><a href="#单线程的优劣势" class="headerlink" title="单线程的优劣势"></a>单线程的优劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li><p>降低处理复杂性，简化开发，例如不用考虑竞争机制等。</p></li><li><p>作为用于预处理与用户互动的脚本语言，可以更加容易地处理状态同步的问题。</p></li><li><p>JS核心维护人员自身的理解与设计。</p></li><li><p>越简单越容易推广，快速上手。</p></li></ol><h2 id="明显的劣势"><a href="#明显的劣势" class="headerlink" title="明显的劣势"></a>明显的劣势</h2><ol><li><p>并发处理能力，任务处于 I/O 等待状态，导致CPU处理资源的浪费。</p></li><li><p>于是JavaScript语言将任务的执行模分成两种：同步任务和异步任务。通过事件循环处理任务。</p></li><li><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p></li><li><p>异步任务：不进入主线程、而进入任务队列（Task queue），只有任务通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p></li></ol><h1 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h1><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p><p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p><p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并吧这个执行环境销毁。接着继续执行队列里的下一段代码。</p><h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><p>先看一段伪代码</p><pre><code>// eventLoop是一个用作队列的数组，（先进，先出）var eventLoop = [ ];var event;// “永远”执行while (true){  if (eventLoop.length &gt; 0){    // 拿到队列中的下一个事件    event = eventLoop.shift();    // 现在，执行下一个事件    try {      event();    }catch (err){      reportError(err);    }  }</code></pre><p>这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。</p><p>再贴张流程图</p><p><img src="https://i.imgur.com/Vvg8kzp.png" alt="流程图"></p><p>事件循环的具体步骤</p><ol><li><p>同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。</p></li><li><p>系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。</p></li><li><p>执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。</p></li></ol><p>请看下面一段代码</p><pre><code>console.log(&#39;A&#39;+ new Date());setTimeout(function(){ console.log(&#39;B&#39;+new Date());},1000);var end = Date.now()+3000;while(Date.now()&lt;end){}console.log(&#39;C&#39;+new Date());</code></pre><p>A,B,C输出的顺序，以及输出的时间 ?</p><p>A会被立即输出，执行到setTimeout(…)时，将会等待1秒后在任务队列添加一个打印B的任务，然后继续往下执行。JS主线程会在while循环通过后继续往下执行，在等待3秒后C被打印，此时任务队列中还有个定时任务回调函数。JS执行栈执行完一个任务之后会再去任务队列取任务，所以C输出后。直接输出B。</p><p>PS：一定要清楚， setTimeout(..) 并 没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。</p><h1 id="macro-task-宏任务-与micro-task-微任务"><a href="#macro-task-宏任务-与micro-task-微任务" class="headerlink" title="macro task(宏任务)与micro task(微任务)"></a>macro task(宏任务)与micro task(微任务)</h1><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p><p>以下事件属于宏任务：</p><ul><li>script</li><li>setInterval()</li><li>setTimeout()</li><li>setImmediate</li><li>用户交互操作</li><li>UI渲染</li></ul><p>以下事件属于微任务</p><ul><li>new Promise()</li><li>process.nextTick</li><li>new MutaionObserver()</li><li>Object.observe</li></ul><p>事件循环做的事情如下：</p><ol><li><p>检查Macrotask 队列是否为空（同步代码），若不为空，则进行下一步，若为空，则跳到3；</p></li><li><p>从Macrotask队列中取首个任务推入执行栈执行，执行完后进入下一步；</p></li><li><p>检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）；</p></li><li><p>从Microtask队列取首个任务执行，执行完后，跳到3；</p></li><li><p>然后开始下一轮 Event loop，执行宏任务中的异步代码；</p></li></ol><p><strong>简单来讲，整体的js代码这个macrotask先执行，同步代码执行完后有microtask执行microtask，没有microtask执行下一个macrotask，如此往复循环；</strong></p><hr><p>文首测试题的答案为：</p><p>promise2</p><p>setInterval</p><p>setTimeout 1</p><p>promise1</p><p>setInterval</p><p>setTimeout2</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先放个测试题，压压惊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;
const interval = setInterval(()=&amp;gt;{
  console.log(&amp;#39;setInterval&amp;#39;);
},0);

setTimeout(()=&amp;gt;{
  console.log(&amp;#39;setTimeout 1&amp;#39;);
  Promise.resolve()
    .then(()=&amp;gt;{
      console.log(&amp;#39;promise1&amp;#39;);  
    })
    .then(()=&amp;gt;{
      setTimeout(()=&amp;gt;{
        console.log(&amp;#39;setTimeout 2&amp;#39;);
        clearInterval(interval);
      },0);
    })
},0);

Promise.resolve()
  .then(()=&amp;gt;{
     console.log(&amp;#39;promise2&amp;#39;);
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;末尾揭晓答案&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript　js　事件循环 eventloop" scheme="http://www.icrazyman.cn/tags/javascript-js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-eventloop/"/>
    
  </entry>
  
  <entry>
    <title>不破不立的哲学与个人成长</title>
    <link href="http://www.icrazyman.cn/2018/12/02/%E4%B8%8D%E7%A0%B4%E4%B8%8D%E7%AB%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    <id>http://www.icrazyman.cn/2018/12/02/不破不立的哲学与个人成长/</id>
    <published>2018-12-02T01:23:40.000Z</published>
    <updated>2018-12-02T01:35:51.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从团建狼人杀说起"><a href="#从团建狼人杀说起" class="headerlink" title="从团建狼人杀说起"></a>从团建狼人杀说起</h1><p>一切要从上周五团队团建中的狼人杀游戏说起。第一局我是狼人，韬光养晦，不鸣不飞，胜；后两局不起眼神职，点兵点将，“瞎指一通”，侃侃而谈，结果都是大胜。</p><p>这种看似有些破坏正常套路的行为站在宏观层面来看，实际上可以大大增加好人获胜的概率。</p><p>对于狼人，取胜之匙可以简单归结为“避免身份被暴露”，对于好人，取胜之匙则是“让狼人身份暴露”。</p><p>要知道狼在在暗处，如果按部就班，要想让狼人暴露，就比较考验直觉和运气了，如果一开始不能灭掉几个狼人，越拖则越不利。如何让狼人暴露呢？我的策略就是破坏平衡，不怕犯错，让狼人露出马脚，从而提高获胜的概率。</p><p>一开始狼人对彼此身份是互相知道的，胡乱指两个人，其中有狼人概率相当高，此时狼人的表现就很容易暴露一些重要信息；就算指的都是好人，狼人表现也会不一样，可能指认的人数会稍稍多一些，此时，人已经开始分组，同时也透露出你指的人好人概率更大之类的判断信息，所有这些加起来都会提高获胜的概率，也就是一开始想办法让狼人也参与进来，狼人是知道彼此的身份，说得越多做的越多透出信息越多。但是，如果一开始大家就巴拉巴拉说些有的没的话，第一局基本上就靠运气，狼人已经占得先机了。</p><p>我们工作中很多事情与之都是类似的道理。例如软件开发中的bug测试，软件中的bug我们可以看出是狼人杀中的狼人，要让这些bug出现，我们平时正常的操作套路是远远不够的。必须要进行破坏性的极端测试边界测试来让这些bug暴露，例如没有数据情况，网络异常情况，网络访问突然峰值10倍情况等。</p><p>可以看到，要想让潜在的问题，潜在的坏蛋出现，破坏平衡，故意出错，引蛇出洞是一个非常行之有效的方法。这种策略也是自己工作与学习成长的策略。</p><a id="more"></a><h1 id="不破不立的哲学"><a href="#不破不立的哲学" class="headerlink" title="不破不立的哲学"></a>不破不立的哲学</h1><p>如果把我们的人生发展看成是一局狼人杀，则停滞、重复、局限以及安逸就可以看成是狼人，我们需要把它们找出来扼杀掉，但是，人总是习惯呆在舒适区，轻松省力，往往就看不到背后的狼人其实每晚都在杀害你内心的那些好人，久而久之，你的人生可能就会被狼人给弄失败。</p><p>举个例子，很多开发人员进入互联网圈子后，头1~2年成长会非常快，每天接触很多新鲜的东西，总有很多不会的东西，然而，等工作个2~3年，等业务驾轻就熟之后，就会发现每天的工作好像没有什么挑战，工作内容也重复，每天好像没有明显成长，此时，显然就已经进入舒适区了，也可以看成是成长的瓶颈。很多人的做法是换个换个工作，不同业务不同团队不同文化重新刺激自己，确实很很有效，但这并不是长久之计，当换来换去后你会发现大同小异，通常10年左右，你就会发现又陷入了瓶颈，一切并没有本质变化，而且年龄越大，换工作成本越高，不得不呆在一个地方舒适下去，然后眼睁睁看着后辈超越自己，所谓中年危机就是这么来的。</p><p>所以，要想人生有所成，尤其新兴且竞争激烈的互联网行业，关键还是要练自己的内功远离舒适区，而不是依赖于环境，通过自身的行为和策略把藏在暗处的狼人揪出来，灭之，则你就能取得人生的胜利。</p><p>如何揪出这些狼人呢？我的做法和上面狼人杀是一致的，进行破坏，所谓不破不立，具体做法包括下面几点：破坏平衡，主动犯错，广度刺激，自造难度。</p><h2 id="破坏平衡"><a href="#破坏平衡" class="headerlink" title="破坏平衡"></a>破坏平衡</h2><p><img src="https://image.zhangxinxu.com/image/blog/201808/niuniu-car.jpg" alt="破坏平衡"></p><p>上图这个叫做“扭扭车”，家里小朋友很喜欢玩，玩得还很溜。扭扭车的动力很有意思，其要前进，必须要扭来扭去，通过不平衡来制造前进的动力。这其实很技术的成长，或者人生的前进类似，你需要一些不平衡在获得前进的东西。</p><p>如果说远点，这个其实跟阶级差异贫富差异内在是类似的。会想以前吃大锅饭，人人均等的时代，社会经济的发展是很慢的，看上去的平衡却造成了前进停滞；而估计能者居上，产生不平衡后，国家40年来的经济发展就非常迅速，不平衡可以产生动力，只要掌握好这个平衡度，不翻车，就能持续前进。</p><p>人生也是如此，如果满于现状，觉得都挺好的，无欲无求；或者迷茫，不知道未来路在哪里，自己想要什么，则发展就会停滞，对于互联网行业，如果停滞意味就会被赶超，是非常危险的。</p><p>如果你是这种状态，则需要打破这种平衡，来获得前进动力。方法很多，比方说斗破苍穹里面萧炎被悔婚，算是一种平衡的打破；或者谈一场轰轰烈烈但失败的恋爱，让我想起了董明珠如果不是丈夫去世，怕没有今天的成就；或者让老大给你打个1星激励下。</p><p>我以前是通过刺激打破迷茫的状态，而现在则是通过设立目标来获得前进动力。</p><p>比方说我想要改变世界，发现现在离这个目标还很远，必须要加油，然后每天就很努力，因为当前状态和目标状态相比是一种不平衡的状态，这种不平衡就产生了前进的动力。</p><p><img src="https://image.zhangxinxu.com/image/blog/201808/change-wrold.png" alt=""></p><p>当然，你的目标可以不是改变世界这么虚这么远的，可以是短期的，例如这个季度我要在团队完成10个分享，我1个月时间翻译某某文档。也不一定工作上的，也可以连续一个月每天中午和女朋友打个电话，你们关系一定会变得更好，每周至少去健身一次等等。</p><p>制作不平衡，远离当下状态，获得成长动力。</p><h2 id="主动犯错"><a href="#主动犯错" class="headerlink" title="主动犯错"></a>主动犯错</h2><p>不怕犯错，甚至主动犯错。</p><p>可以举举我开车识路的例子。</p><p><img src="https://image.zhangxinxu.com/image/blog/201808/car-drive.jpg" alt=""></p><p>对于经常走的路线，例如回老家，或者上班，在前期，我几乎病态地每次都开不一样的路，比方说回老家，先不说沪常高速，京沪高速，沈海高速这几个高速主干道开了个遍，我多次直接不走高速从下面慢慢溜达，走过全程不走高速，走过一半省道一半高速，市区内各条小道也是走了个遍。结果这些偏门道路80%都是糟糕的选择，比方说高速2小时，下面屁颠屁颠开了4小时，一路上大货车一堆，红绿灯一堆，拍照一堆，有一次还擦擦碰碰，那些省道也不是免费的，芝麻点路还收10块钱，比高速还贵。看起来这些决策是错误的，费时有费力，带来的是痛苦，但是，这种主动犯错带来的经验与学习却是宝贵的，令人印象深刻的，不同道路的不同特色就了然于心，识路的技能成长就很快，在日后会带来巨大的价值。果然，节假日来了，高速堵车堵成了狗屎，而我，则和老婆大人在车里，吃着火锅，哼着小曲，沿着下面道路，完美避开拥堵，一路畅通回到了家，比堵车的这些家伙快了1倍时间。</p><p>成为道路达人的的秘诀就是主动尝试，不怕犯错，失败才能快速成长，只要发现一条曲径通幽的道路就是赚到，就是赚不到，沿途的风景也是不错的收获。</p><p>我在技能学习的时候，也会各种尝试，不怕犯错，人生有些错误是不能挽回的，但是，代码和技能不是这样的，不要怕，勇敢的上。</p><p>例如我在学习padStart()和padEnd()这两个ES6 API的时候，后面的补全参数按照道理应该是字符串，但是自己就主动犯错，各种数据类型都试一遍，结果发现了以外的收获，同样是一个API的学习，所get到的知识点，知识细节就比按部就班浅尝辄止学习的同学多很多，当你有无数多个这样的积累的时候，你就可以甩别人一条长安街了。</p><h2 id="广度刺激"><a href="#广度刺激" class="headerlink" title="广度刺激"></a>广度刺激</h2><p>通过换工作寻求新的刺激成本是比较高的，通常而言，大多数企业是不喜欢频繁的换工作的员工的。但是，我们通过广度刺激自己远离安逸和惰性则是百益无一害的。</p><p>广度刺激一方面是关注新技术，不一定要深知，至少要了解，可以扩展自己的技术选型的广度。有些技术如果对团队非常有帮助，则可以推动在团队落地，容易出好的绩效，升职加薪那就自然而然就来了。</p><p>另外一方面是关注新的模式，新的业务。例如去年直播很多，还有抖音，拼多多的崛起，对这些新模式新业务的了解有助于开阔自己的眼界，不至于坐井观天。否则一直呆在公司这点弹丸之地，不对外部事物保持关注，很容易淹没在滚滚潮流中，被时代淘汰。</p><p>以前很多在IBM这类公司工作人，被这个传统IT公司所累，很多认知都落后于时代，在新兴的互联网企业完全玩不开，掌握的理论都过时，是很危险的，大家可以引以为鉴，有效避之。</p><h2 id="自造难度"><a href="#自造难度" class="headerlink" title="自造难度"></a>自造难度</h2><p>人在江湖，身不由己。难免会接到没有技术含量的枯燥工作，对于前端而言，做一些简单的运营活动就是件很无趣的事情。你是按部就班完成工作把生命无形中浪费掉，还是有点追求在工作中给自己自增难度找点乐子呢？</p><p>所谓找点乐子，就是不要老是把自己掌握的那丁点技术重复来重复去使用，抓住每一次机会给自己来一个有意思的挑战，实现快速成长。</p><p>举一些我自己给自己下挑战的例子：</p><ul><li>这个图标我纯CSS绘制；</li><li>这个效果纯CSS实现；</li><li>这个效果我用SVG实现试试；</li><li>这个页面所有资源加载尺寸我要控制100K以内；</li><li>重复工作好无聊，写个自动化工具，这个页面我正好让我测一测工具跑起来怎么样；</li><li>最近学了点新技术，用在大项目中风险比较高，这个也就内部同事看看的运营页面正好可以用来试试手；</li><li>……</li></ul><p>等等等等。<strong>为什么觉得工作无聊，因为重复，那就想办法不重复，给自己增加点挑战不就好了，越折腾越成长，虽然说多花了点时间，但是，你让原本半天没有意义浪费生命的时光也变得有意义了，自己也成长了，然后再和同事分享分享，那不得了，影响力也有了，自然更容易取得人生上的成功了。</strong></p><h1 id="没有掉馅饼的事"><a href="#没有掉馅饼的事" class="headerlink" title="没有掉馅饼的事"></a>没有掉馅饼的事</h1><p>在互联网这个新兴行业，你想指望每天划划水，呆在自己舒适的小天地，同时升职加薪走上人生巅峰，那是不可能的。</p><p>互联网行业是目前而言相对比较公平的行业，你努力付出，积极进度，能力出众，技术优秀，自然会得到符合的报酬和地位，因为行业里这样的人稀缺无比。同样的，那些守着前几年学的点东西指望在公司养老一辈子的，也一定会被淘汰，被边缘，消失在滚滚红尘中。这就是公平，这也是为什么中国互联网的发展在全球处于领先的原因之一。</p><p>本文转载自【<a href="http://www.zhangxinxu.com/life/?p=801" title="不破不立的哲学与个人成长" target="_blank" rel="noopener">不破不立的哲学与个人成长</a>】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从团建狼人杀说起&quot;&gt;&lt;a href=&quot;#从团建狼人杀说起&quot; class=&quot;headerlink&quot; title=&quot;从团建狼人杀说起&quot;&gt;&lt;/a&gt;从团建狼人杀说起&lt;/h1&gt;&lt;p&gt;一切要从上周五团队团建中的狼人杀游戏说起。第一局我是狼人，韬光养晦，不鸣不飞，胜；后两局不起眼神职，点兵点将，“瞎指一通”，侃侃而谈，结果都是大胜。&lt;/p&gt;
&lt;p&gt;这种看似有些破坏正常套路的行为站在宏观层面来看，实际上可以大大增加好人获胜的概率。&lt;/p&gt;
&lt;p&gt;对于狼人，取胜之匙可以简单归结为“避免身份被暴露”，对于好人，取胜之匙则是“让狼人身份暴露”。&lt;/p&gt;
&lt;p&gt;要知道狼在在暗处，如果按部就班，要想让狼人暴露，就比较考验直觉和运气了，如果一开始不能灭掉几个狼人，越拖则越不利。如何让狼人暴露呢？我的策略就是破坏平衡，不怕犯错，让狼人露出马脚，从而提高获胜的概率。&lt;/p&gt;
&lt;p&gt;一开始狼人对彼此身份是互相知道的，胡乱指两个人，其中有狼人概率相当高，此时狼人的表现就很容易暴露一些重要信息；就算指的都是好人，狼人表现也会不一样，可能指认的人数会稍稍多一些，此时，人已经开始分组，同时也透露出你指的人好人概率更大之类的判断信息，所有这些加起来都会提高获胜的概率，也就是一开始想办法让狼人也参与进来，狼人是知道彼此的身份，说得越多做的越多透出信息越多。但是，如果一开始大家就巴拉巴拉说些有的没的话，第一局基本上就靠运气，狼人已经占得先机了。&lt;/p&gt;
&lt;p&gt;我们工作中很多事情与之都是类似的道理。例如软件开发中的bug测试，软件中的bug我们可以看出是狼人杀中的狼人，要让这些bug出现，我们平时正常的操作套路是远远不够的。必须要进行破坏性的极端测试边界测试来让这些bug暴露，例如没有数据情况，网络异常情况，网络访问突然峰值10倍情况等。&lt;/p&gt;
&lt;p&gt;可以看到，要想让潜在的问题，潜在的坏蛋出现，破坏平衡，故意出错，引蛇出洞是一个非常行之有效的方法。这种策略也是自己工作与学习成长的策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编码 成长" scheme="http://www.icrazyman.cn/tags/%E7%BC%96%E7%A0%81-%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>基于github和工作中总结出来的工程师代码书写习惯</title>
    <link href="http://www.icrazyman.cn/2018/11/28/%E5%9F%BA%E4%BA%8Egithub%E5%92%8C%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93%E5%87%BA%E6%9D%A5%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E4%B9%A0%E6%83%AF/"/>
    <id>http://www.icrazyman.cn/2018/11/28/基于github和工作中总结出来的工程师代码书写习惯/</id>
    <published>2018-11-28T14:35:50.000Z</published>
    <updated>2018-12-02T01:25:16.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最佳原则"><a href="#最佳原则" class="headerlink" title="最佳原则"></a>最佳原则</h1><p>虽然这些细节是小事，不会有体验或者性能上的优化，但是却体现了一个coder和团队的专业程度 团队的愿景：成为业界卓越的Web团队！</p><p>坚持制定好的代码规范。</p><p>所以不管团队有多少人，代码风格都应该师出同门！</p><a id="more"></a><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h2><p>全部采用小写方式， 以下划线分隔。</p><p>例：my_project_name</p><h2 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h2><p>参照项目命名规则；</p><p>有复数结构时，要采用复数命名法。</p><p>例：scripts, styles, images, data_models</p><h2 id="JS文件命名"><a href="#JS文件命名" class="headerlink" title="JS文件命名"></a>JS文件命名</h2><p>参照项目命名规则。</p><p>例：account_model.js</p><h2 id="CSS-SCSS文件命名"><a href="#CSS-SCSS文件命名" class="headerlink" title="CSS, SCSS文件命名"></a>CSS, SCSS文件命名</h2><p>参照项目命名规则；</p><p>例：retina_sprites.css</p><h2 id="HTML文件命名"><a href="#HTML文件命名" class="headerlink" title="HTML文件命名"></a>HTML文件命名</h2><p>参照项目命名规则。</p><p>例：error_report.html</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>缩进使用soft tab（4个空格）；</li><li>嵌套的节点应该缩进；</li><li>在属性上，使用双引号，不要使用单引号；</li><li>属性名全小写，用中划线做分隔符；</li><li>不要在自动闭合标签结尾处使用斜线（HTML5 规范 指出他们是可选的）；（<a href="https://www.oschina.net/news/49775/html-tag-to-close-or-not-to-close" title="作者注：有待考证" target="_blank" rel="noopener">作者注：有待考证</a>）</li><li>不要忽略可选的关闭标签，例：<code>&lt;/li&gt;</code> 和 <code>&lt;/body&gt;</code>。</li></ul><h2 id="HTML5-doctype"><a href="#HTML5-doctype" class="headerlink" title="HTML5 doctype"></a>HTML5 doctype</h2><p>在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现；</p><p>虽然doctype不区分大小写，但是按照惯例，doctype大写 （<a href="https://stackoverflow.com/questions/15594877/is-there-any-benefits-to-use-uppercase-or-lowercase-letters-with-html5-tagname" title="关于html属性，大写还是小写" target="_blank" rel="noopener">关于html属性，大写还是小写</a>）。</p><h2 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h2><p>根据HTML5规范：</p><p><em>应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。</em></p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为’UTF-8’。</p><h2 id="IE兼容模式"><a href="#IE兼容模式" class="headerlink" title="IE兼容模式"></a>IE兼容模式</h2><p>用 ·<meta>· 标签可以指定页面应该用什么版本的IE来渲染；</p><h2 id="引入CSS-JS"><a href="#引入CSS-JS" class="headerlink" title="引入CSS, JS"></a>引入CSS, JS</h2><p>根据HTML5规范, 通常在引入CSS和JS时不需要指明<code>type</code>，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是他们的默认值。</p><h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><p>属性应该按照特定的顺序出现以保证易读性；</p><ul><li>class</li><li>id</li><li>name</li><li>data-*</li><li>src, for, type, href, value , max-length, max, min, pattern</li><li>placeholder, title, alt</li><li>aria-*, role</li><li>required, readonly, disabled</li></ul><p>class是为高可复用组件设计的，所以应处在第一位；</p><p>id更加具体且应该尽量少使用，所以将它放在第二位。</p><h2 id="boolean属性"><a href="#boolean属性" class="headerlink" title="boolean属性"></a>boolean属性</h2><p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p><pre><code>&lt;input type=&quot;text&quot; disabled&gt;&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt;&lt;select&gt;    &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt;&lt;/select&gt;</code></pre><h2 id="JS生成标签"><a href="#JS生成标签" class="headerlink" title="JS生成标签"></a>JS生成标签</h2><p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。</p><h2 id="减少标签数量"><a href="#减少标签数量" class="headerlink" title="减少标签数量"></a>减少标签数量</h2><p>在编写HTML代码时，需要尽量避免多余的父节点；</p><p>很多时候，需要通过迭代和重构来使HTML变得更少。</p><h2 id="实用高于完美"><a href="#实用高于完美" class="headerlink" title="实用高于完美"></a>实用高于完美</h2><p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；</p><p>任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p><h1 id="CSS-SCSS"><a href="#CSS-SCSS" class="headerlink" title="CSS, SCSS"></a>CSS, SCSS</h1><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>使用soft tab（4个空格）。</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>每个属性声明末尾都要加分号。</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>以下几种情况不需要空格：</p><ul><li>属性名后</li><li>多个规则的分隔符’,’前</li><li>!important ‘!’后</li><li>属性值中’(‘后和’)’前</li><li>行末不要有多余的空格</li></ul><p>以下几种情况需要空格：</p><ul><li>属性值前</li><li>选择器’&gt;’, ‘+’, ‘~’前后</li><li>‘{‘前</li><li>!important ‘!’前</li><li>@else 前后</li><li>属性值中的’,’后</li><li>注释’/<em>‘后和’</em>/‘前</li></ul><pre><code>/* not good */.element {    color :red! important;    background-color: rgba(0,0,0,.5);}/* good */.element {    color: red !important;    background-color: rgba(0, 0, 0, .5);}/* not good */.element ,.dialog{    ...}/* good */.element,.dialog {}/* not good */.element&gt;.dialog{    ...}/* good */.element &gt; .dialog{    ...}/* not good */.element{    ...}/* good */.element {    ...}/* not good */@if{    ...}@else{    ...}/* good */@if {    ...} @else {    ...}</code></pre><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>以下几种情况需要空行：</p><ul><li>文件最后保留一个空行</li><li>‘}’后最好跟一个空行，包括scss中嵌套的规则</li><li>属性之间需要适当的空行</li></ul><pre><code>/* not good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}/* good */.element {    ...}.dialog {    color: red;    &amp;:after {        ...    }}</code></pre><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>以下几种情况不需要换行：</p><ul><li>‘{‘前</li></ul><p>以下几种情况需要换行：</p><ul><li>‘{‘后和’}’前</li><li>每个属性独占一行</li><li>多个规则的分隔符’,’后</li></ul><pre><code>/* not good */.element{color: red; background-color: black;}/* good */.element {    color: red;    background-color: black;}/* not good */.element, .dialog {    ...}/* good */.element,.dialog {    ...}</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释统一用’/<em> </em>/‘（scss中也不要用’//‘），具体参照下边的写法；</p><p>缩进与下一行代码保持一致；</p><p>可位于一个代码行的末尾，与代码间隔一个空格。</p><pre><code>/* Modal header */.modal-header {    ...}/* * Modal header */.modal-header {    ...}.modal-header {    /* 50px */    width: 50px;    color: red; /* color red */}</code></pre><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>最外层统一使用双引号；</p><p>url的内容要用引号；</p><p>属性选择器中的属性值需要引号。</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>类名使用小写字母，以中划线分隔</li><li>id采用驼峰式命名</li><li>scss中的变量、函数、混合、placeholder采用驼峰式命名</li></ul><pre><code>/* class */.element-content {    ...}/* id */#myDialog {    ...}/* 变量 */$colorBlack: #000;/* 函数 */@function pxToRem($px) {    ...}/* 混合 */@mixin centerBlock {    ...}/* placeholder */%myDialog {    ...}</code></pre><h2 id="属性声明顺序"><a href="#属性声明顺序" class="headerlink" title="属性声明顺序"></a>属性声明顺序</h2><p>相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。</p><pre><code>.declaration-order {    display: block;    float: right;    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 100;    border: 1px solid #e5e5e5;    border-radius: 3px;    width: 100px;    height: 100px;    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;    line-height: 1.5;    text-align: center;    color: #333;    background-color: #f5f5f5;    opacity: 1;}// 下面是推荐的属性的顺序[    [        &quot;display&quot;,        &quot;visibility&quot;,        &quot;float&quot;,        &quot;clear&quot;,        &quot;overflow&quot;,        &quot;overflow-x&quot;,        &quot;overflow-y&quot;,        &quot;clip&quot;,        &quot;zoom&quot;    ],    [        &quot;table-layout&quot;,        &quot;empty-cells&quot;,        &quot;caption-side&quot;,        &quot;border-spacing&quot;,        &quot;border-collapse&quot;,        &quot;list-style&quot;,        &quot;list-style-position&quot;,        &quot;list-style-type&quot;,        &quot;list-style-image&quot;    ],    [        &quot;-webkit-box-orient&quot;,        &quot;-webkit-box-direction&quot;,        &quot;-webkit-box-decoration-break&quot;,        &quot;-webkit-box-pack&quot;,        &quot;-webkit-box-align&quot;,        &quot;-webkit-box-flex&quot;    ],    [        &quot;position&quot;,        &quot;top&quot;,        &quot;right&quot;,        &quot;bottom&quot;,        &quot;left&quot;,        &quot;z-index&quot;    ],    [        &quot;margin&quot;,        &quot;margin-top&quot;,        &quot;margin-right&quot;,        &quot;margin-bottom&quot;,        &quot;margin-left&quot;,        &quot;-webkit-box-sizing&quot;,        &quot;-moz-box-sizing&quot;,        &quot;box-sizing&quot;,        &quot;border&quot;,        &quot;border-width&quot;,        &quot;border-style&quot;,        &quot;border-color&quot;,        &quot;border-top&quot;,        &quot;border-top-width&quot;,        &quot;border-top-style&quot;,        &quot;border-top-color&quot;,        &quot;border-right&quot;,        &quot;border-right-width&quot;,        &quot;border-right-style&quot;,        &quot;border-right-color&quot;,        &quot;border-bottom&quot;,        &quot;border-bottom-width&quot;,        &quot;border-bottom-style&quot;,        &quot;border-bottom-color&quot;,        &quot;border-left&quot;,        &quot;border-left-width&quot;,        &quot;border-left-style&quot;,        &quot;border-left-color&quot;,        &quot;-webkit-border-radius&quot;,        &quot;-moz-border-radius&quot;,        &quot;border-radius&quot;,        &quot;-webkit-border-top-left-radius&quot;,        &quot;-moz-border-radius-topleft&quot;,        &quot;border-top-left-radius&quot;,        &quot;-webkit-border-top-right-radius&quot;,        &quot;-moz-border-radius-topright&quot;,        &quot;border-top-right-radius&quot;,        &quot;-webkit-border-bottom-right-radius&quot;,        &quot;-moz-border-radius-bottomright&quot;,        &quot;border-bottom-right-radius&quot;,        &quot;-webkit-border-bottom-left-radius&quot;,        &quot;-moz-border-radius-bottomleft&quot;,        &quot;border-bottom-left-radius&quot;,        &quot;-webkit-border-image&quot;,        &quot;-moz-border-image&quot;,        &quot;-o-border-image&quot;,        &quot;border-image&quot;,        &quot;-webkit-border-image-source&quot;,        &quot;-moz-border-image-source&quot;,        &quot;-o-border-image-source&quot;,        &quot;border-image-source&quot;,        &quot;-webkit-border-image-slice&quot;,        &quot;-moz-border-image-slice&quot;,        &quot;-o-border-image-slice&quot;,        &quot;border-image-slice&quot;,        &quot;-webkit-border-image-width&quot;,        &quot;-moz-border-image-width&quot;,        &quot;-o-border-image-width&quot;,        &quot;border-image-width&quot;,        &quot;-webkit-border-image-outset&quot;,        &quot;-moz-border-image-outset&quot;,        &quot;-o-border-image-outset&quot;,        &quot;border-image-outset&quot;,        &quot;-webkit-border-image-repeat&quot;,        &quot;-moz-border-image-repeat&quot;,        &quot;-o-border-image-repeat&quot;,        &quot;border-image-repeat&quot;,        &quot;padding&quot;,        &quot;padding-top&quot;,        &quot;padding-right&quot;,        &quot;padding-bottom&quot;,        &quot;padding-left&quot;,        &quot;width&quot;,        &quot;min-width&quot;,        &quot;max-width&quot;,        &quot;height&quot;,        &quot;min-height&quot;,        &quot;max-height&quot;    ],    [        &quot;font&quot;,        &quot;font-family&quot;,        &quot;font-size&quot;,        &quot;font-weight&quot;,        &quot;font-style&quot;,        &quot;font-variant&quot;,        &quot;font-size-adjust&quot;,        &quot;font-stretch&quot;,        &quot;font-effect&quot;,        &quot;font-emphasize&quot;,        &quot;font-emphasize-position&quot;,        &quot;font-emphasize-style&quot;,        &quot;font-smooth&quot;,        &quot;line-height&quot;,        &quot;text-align&quot;,        &quot;-webkit-text-align-last&quot;,        &quot;-moz-text-align-last&quot;,        &quot;-ms-text-align-last&quot;,        &quot;text-align-last&quot;,        &quot;vertical-align&quot;,        &quot;white-space&quot;,        &quot;text-decoration&quot;,        &quot;text-emphasis&quot;,        &quot;text-emphasis-color&quot;,        &quot;text-emphasis-style&quot;,        &quot;text-emphasis-position&quot;,        &quot;text-indent&quot;,        &quot;-ms-text-justify&quot;,        &quot;text-justify&quot;,        &quot;letter-spacing&quot;,        &quot;word-spacing&quot;,        &quot;-ms-writing-mode&quot;,        &quot;text-outline&quot;,        &quot;text-transform&quot;,        &quot;text-wrap&quot;,        &quot;-ms-text-overflow&quot;,        &quot;text-overflow&quot;,        &quot;text-overflow-ellipsis&quot;,        &quot;text-overflow-mode&quot;,        &quot;-ms-word-wrap&quot;,        &quot;word-wrap&quot;,        &quot;-ms-word-break&quot;,        &quot;word-break&quot;    ],    [        &quot;color&quot;,        &quot;background&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;,        &quot;background-color&quot;,        &quot;background-image&quot;,        &quot;background-repeat&quot;,        &quot;background-attachment&quot;,        &quot;background-position&quot;,        &quot;-ms-background-position-x&quot;,        &quot;background-position-x&quot;,        &quot;-ms-background-position-y&quot;,        &quot;background-position-y&quot;,        &quot;-webkit-background-clip&quot;,        &quot;-moz-background-clip&quot;,        &quot;background-clip&quot;,        &quot;background-origin&quot;,        &quot;-webkit-background-size&quot;,        &quot;-moz-background-size&quot;,        &quot;-o-background-size&quot;,        &quot;background-size&quot;    ],    [        &quot;outline&quot;,        &quot;outline-width&quot;,        &quot;outline-style&quot;,        &quot;outline-color&quot;,        &quot;outline-offset&quot;,        &quot;opacity&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.Alpha(Opacity&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.Alpha&quot;,        &quot;-ms-interpolation-mode&quot;,        &quot;-webkit-box-shadow&quot;,        &quot;-moz-box-shadow&quot;,        &quot;box-shadow&quot;,        &quot;filter:progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.gradient&quot;,        &quot;text-shadow&quot;    ],    [        &quot;-webkit-transition&quot;,        &quot;-moz-transition&quot;,        &quot;-ms-transition&quot;,        &quot;-o-transition&quot;,        &quot;transition&quot;,        &quot;-webkit-transition-delay&quot;,        &quot;-moz-transition-delay&quot;,        &quot;-ms-transition-delay&quot;,        &quot;-o-transition-delay&quot;,        &quot;transition-delay&quot;,        &quot;-webkit-transition-timing-function&quot;,        &quot;-moz-transition-timing-function&quot;,        &quot;-ms-transition-timing-function&quot;,        &quot;-o-transition-timing-function&quot;,        &quot;transition-timing-function&quot;,        &quot;-webkit-transition-duration&quot;,        &quot;-moz-transition-duration&quot;,        &quot;-ms-transition-duration&quot;,        &quot;-o-transition-duration&quot;,        &quot;transition-duration&quot;,        &quot;-webkit-transition-property&quot;,        &quot;-moz-transition-property&quot;,        &quot;-ms-transition-property&quot;,        &quot;-o-transition-property&quot;,        &quot;transition-property&quot;,        &quot;-webkit-transform&quot;,        &quot;-moz-transform&quot;,        &quot;-ms-transform&quot;,        &quot;-o-transform&quot;,        &quot;transform&quot;,        &quot;-webkit-transform-origin&quot;,        &quot;-moz-transform-origin&quot;,        &quot;-ms-transform-origin&quot;,        &quot;-o-transform-origin&quot;,        &quot;transform-origin&quot;,        &quot;-webkit-animation&quot;,        &quot;-moz-animation&quot;,        &quot;-ms-animation&quot;,        &quot;-o-animation&quot;,        &quot;animation&quot;,        &quot;-webkit-animation-name&quot;,        &quot;-moz-animation-name&quot;,        &quot;-ms-animation-name&quot;,        &quot;-o-animation-name&quot;,        &quot;animation-name&quot;,        &quot;-webkit-animation-duration&quot;,        &quot;-moz-animation-duration&quot;,        &quot;-ms-animation-duration&quot;,        &quot;-o-animation-duration&quot;,        &quot;animation-duration&quot;,        &quot;-webkit-animation-play-state&quot;,        &quot;-moz-animation-play-state&quot;,        &quot;-ms-animation-play-state&quot;,        &quot;-o-animation-play-state&quot;,        &quot;animation-play-state&quot;,        &quot;-webkit-animation-timing-function&quot;,        &quot;-moz-animation-timing-function&quot;,        &quot;-ms-animation-timing-function&quot;,        &quot;-o-animation-timing-function&quot;,        &quot;animation-timing-function&quot;,        &quot;-webkit-animation-delay&quot;,        &quot;-moz-animation-delay&quot;,        &quot;-ms-animation-delay&quot;,        &quot;-o-animation-delay&quot;,        &quot;animation-delay&quot;,        &quot;-webkit-animation-iteration-count&quot;,        &quot;-moz-animation-iteration-count&quot;,        &quot;-ms-animation-iteration-count&quot;,        &quot;-o-animation-iteration-count&quot;,        &quot;animation-iteration-count&quot;,        &quot;-webkit-animation-direction&quot;,        &quot;-moz-animation-direction&quot;,        &quot;-ms-animation-direction&quot;,        &quot;-o-animation-direction&quot;,        &quot;animation-direction&quot;    ],    [        &quot;content&quot;,        &quot;quotes&quot;,        &quot;counter-reset&quot;,        &quot;counter-increment&quot;,        &quot;resize&quot;,        &quot;cursor&quot;,        &quot;-webkit-user-select&quot;,        &quot;-moz-user-select&quot;,        &quot;-ms-user-select&quot;,        &quot;user-select&quot;,        &quot;nav-index&quot;,        &quot;nav-up&quot;,        &quot;nav-right&quot;,        &quot;nav-down&quot;,        &quot;nav-left&quot;,        &quot;-moz-tab-size&quot;,        &quot;-o-tab-size&quot;,        &quot;tab-size&quot;,        &quot;-webkit-hyphens&quot;,        &quot;-moz-hyphens&quot;,        &quot;hyphens&quot;,        &quot;pointer-events&quot;    ]]</code></pre><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>颜色16进制用小写字母；</p><p>颜色16进制尽量用简写。</p><pre><code>/* not good */.element {    color: #ABCDEF;    background-color: #001122;}/* good */.element {    color: #abcdef;    background-color: #012;}</code></pre><h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p><p>margin 和 padding 相反，需要使用简写；</p><p>常见的属性简写包括：</p><ul><li>font</li><li>background</li><li>transition</li><li>animation</li></ul><pre><code>/* not good */.element {    transition: opacity 1s linear 2s;}/* good */.element {    transition-delay: 2s;    transition-timing-function: linear;    transition-duration: 1s;    transition-property: opacity;}</code></pre><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p><h2 id="SCSS相关"><a href="#SCSS相关" class="headerlink" title="SCSS相关"></a>SCSS相关</h2><p>提交的代码中不要有 @debug；</p><p>声明顺序：</p><ul><li>@extend</li><li>不包含 @content 的 @include</li><li>包含 @content 的 @include</li><li>自身属性</li><li>嵌套规则</li></ul><p><code>@import</code> 引入的文件不需要开头的’_’和结尾的’.scss’；</p><p>嵌套最多不能超过5层；</p><p><code>@extend</code> 中使用placeholder选择器；</p><p>去掉不必要的父级引用符号’&amp;’。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>不允许有空的规则；</p><p>元素选择器用小写字母；</p><p>去掉小数点前面的0；</p><p>去掉数字中不必要的小数点和末尾的0；</p><p>属性值’0’后面不要加单位；</p><p>同个属性不同前缀的写法需要在垂直方向保持对齐；</p><p>无前缀的标准属性应该写在有前缀的属性后面；</p><p>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</p><p>不要在一个文件里出现两个相同的规则；</p><p>用 border: 0; 代替 border: none;；</p><p>选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）；</p><p>发布的代码中不要有 @import；</p><p>尽量少用’*’选择器。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h2><p>使用soft tab（4个空格）。</p><h2 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h2><p>不要超过80，但如果编辑器开启word wrap可以不考虑单行长度。</p><h2 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h2><p>以下几种情况后需加分号：</p><ul><li>变量声明</li><li>表达式</li><li>return</li><li>throw</li><li>break</li><li>continue</li><li>do-while</li></ul><h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><p>以下几种情况不需要空格：</p><ul><li>对象的属性名后</li><li>前缀一元运算符后</li><li>后缀一元运算符前</li><li>函数调用括号前</li><li>无论是函数声明还是函数表达式，’(‘前不要空格</li><li>数组的’[‘后和’]’前</li><li>对象的’{‘后和’}’前（有待考证）</li><li>运算符’(‘后和’)’前</li></ul><p>以下几种情况需要空格：</p><ul><li>二元运算符前后</li><li>三元运算符’?:’前后</li><li>代码块’{‘前</li><li>下列关键字前：else, while, catch, finally</li><li>下列关键字后：if, else, for, while, do, switch, case, try, catch, finally, with, return, typeof</li><li>单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后</li><li>对象的属性值前</li><li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格</li><li>无论是函数声明还是函数表达式，’{‘前一定要有空格</li><li>函数的参数之间</li></ul><pre><code>// not goodvar a = {    b :1};// goodvar a = {    b: 1};// not good++ x;y ++;z = x?1:2;// good++x;y++;z = x ? 1 : 2;// not goodvar a = [ 1, 2 ];// goodvar a = [1, 2];// not goodvar a = ( 1+2 )*3;// goodvar a = (1 + 2) * 3;// no space before &#39;(&#39;, one space before &#39;{&#39;, one space between function parametersvar doSomething = function(a, b, c) {    // do something};// no space before &#39;(&#39;doSomething(item);// not goodfor(i=0;i&lt;6;i++){    x++;}// goodfor (i = 0; i &lt; 6; i++) {    x++;}</code></pre><h2 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h2><p>以下几种情况需要空行：</p><ul><li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）</li><li>注释前（当注释在代码块的第一行时，则无需空行）</li><li>代码块后（在函数调用、数组、对象中则无需空行）(有待考证)</li><li>文件最后保留一个空行</li></ul><h2 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h2><p>换行的地方，行末必须有’,’或者运算符；</p><p>以下几种情况不需要换行：</p><ul><li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li><li>代码块’{‘前</li></ul><p>以下几种情况需要换行：</p><ul><li>代码块’{‘后和’}’前</li><li>变量赋值后</li></ul><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>双斜线后，必须跟一个空格；</p><p>缩进与下一行代码保持一致；</p><p>可位于一个代码行的末尾，与代码间隔一个空格。</p><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>最少三行, ‘*’后跟一个空格；</p><p>建议在以下情况下使用：</p><ul><li>难于理解的代码段</li><li>可能存在错误的代码段</li><li>浏览器特殊的HACK代码</li><li>业务逻辑强相关的代码</li></ul><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>各类标签@param, @method等请参考<a href="http://usejsdoc.org/" title="usejsdoc" target="_blank" rel="noopener">usejsdoc</a>和<a href="http://yuri4ever.github.io/jsdoc/" title="JSDoc Guide" target="_blank" rel="noopener">JSDoc Guide</a>；</p><p>建议在以下情况下使用：</p><ul><li>所有常量</li><li>所有函数</li><li>所有类</li></ul><pre><code>/** * @func * @desc 一个带参数的函数 * @param {string} a - 参数a * @param {number} b=1 - 参数b默认值为1 * @param {string} c=1 - 参数c有两种支持的取值&lt;/br&gt;1—表示x&lt;/br&gt;2—表示xx * @param {object} d - 参数d为一个对象 * @param {string} d.e - 参数d的e属性 * @param {string} d.f - 参数d的f属性 * @param {object[]} g - 参数g为一个对象数组 * @param {string} g.h - 参数g数组中一项的h属性 * @param {string} g.i - 参数g数组中一项的i属性 * @param {string} [j] - 参数j是一个可选参数 */function foo(a, b, c, d, g, j) {    ...}</code></pre><h2 id="引号-1"><a href="#引号-1" class="headerlink" title="引号"></a>引号</h2><p>最外层统一使用单引号。</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul><li>标准变量采用小驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据）</li><li>‘ID’在变量名中全大写</li><li>‘URL’在变量名中全大写</li><li>‘Android’在变量名中大写第一个字母</li><li>‘iOS’在变量名中小写第一个，大写后两个字母</li><li>常量全大写，用下划线连接</li><li>构造函数，大写第一个字母（大驼峰式命名）</li><li>jquery对象必须以’$’开头命名</li></ul><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格；</p><p>函数调用括号前不需要空格；</p><p>立即执行函数外必须包一层括号；</p><p>不要给inline function命名；</p><p>参数之间用’, ‘分隔，注意逗号后有一个空格。</p><h2 id="数组、对象"><a href="#数组、对象" class="headerlink" title="数组、对象"></a>数组、对象</h2><p>对象属性名不需要加引号；</p><p>对象以缩进的形式书写，不要写在一行；</p><p>数组、对象最后不要有逗号。（作者注：最新ES6语法允许最后加逗号）</p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>适用场景：</p><ul><li>初始化一个将来可能被赋值为对象的变量</li><li>与已经初始化的变量做比较</li><li>作为一个参数为对象的函数的调用传参</li><li>作为一个返回对象的函数的返回值</li></ul><p>不适用场景：</p><ul><li>不要用null来判断函数调用时有无传参</li><li>不要与未初始化的变量做比较</li></ul><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>永远不要直接使用undefined进行变量判断；</p><p>使用typeof和字符串’undefined’对变量进行判断。</p><h2 id="jshint"><a href="#jshint" class="headerlink" title="jshint"></a>jshint</h2><p>用’===’, ‘!==’代替’==’, ‘!=’；（作者注：具体场景具体分析）</p><p>for-in里一定要有hasOwnProperty的判断；</p><p>不要在内置对象的原型上添加方法，如Array, Date；</p><p>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</p><p>变量不要先使用后声明；</p><p>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</p><p>不要在同个作用域下声明同名变量；</p><p>不要在一些不需要的地方加括号，例：delete(a.b)；</p><p>不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）；</p><p>不要声明了变量却不使用；</p><p>不要在应该做比较的地方做赋值；</p><p>debugger不要出现在提交的代码里；</p><p>数组中不要存在空元素；</p><p>不要在循环内部声明函数；</p><p>不要像这样使用构造函数，例：<code>new function () { ... }</code>, <code>new Object</code>；</p><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>不要混用tab和space；</p><p>不要在一处使用多个tab或space；</p><p>换行符统一用’LF’；</p><p>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名；</p><p>行尾不要有空白字符；</p><p>switch的falling through和no default的情况一定要有注释特别说明；</p><p>不允许有空的代码块。</p><pre><code>// not goodvar a   = 1;function Person() {    // not good    var me = this;    // good    var _this = this;    // good    var that = this;    // good    var self = this;}// goodswitch (condition) {    case 1:    case 2:        ...        break;    case 3:        ...    // why fall through    case 4        ...        break;    // why no default}// not good with empty blockif (condition) {}</code></pre><h1 id="编辑器配置和构建检查"><a href="#编辑器配置和构建检查" class="headerlink" title="编辑器配置和构建检查"></a>编辑器配置和构建检查</h1><h1 id="sublime3插件"><a href="#sublime3插件" class="headerlink" title="sublime3插件"></a>sublime3插件</h1><h3 id="安装node包"><a href="#安装node包" class="headerlink" title="安装node包"></a>安装node包</h3><ul><li>jscs npm install jscs -g</li><li>jshint npm install jshint -g</li><li>csscomb npm install csscomb -g</li><li>csslint npm install csslint -g</li></ul><h3 id="安装gem包"><a href="#安装gem包" class="headerlink" title="安装gem包"></a>安装gem包</h3><ul><li>scss-lint gem install scss_lint</li></ul><h3 id="安装sublime3-Package-Control"><a href="#安装sublime3-Package-Control" class="headerlink" title="安装sublime3 Package Control"></a>安装sublime3 Package Control</h3><ul><li>按下 ctrl+`</li><li>复制粘贴以下代码 <pre><code>import urllib.request,os,hashlib; h = &#39;eb2297e1a458f27d836c04bb0cbaf282&#39; + &#39;d0e7a3098092775ccb37ca9d6b2e4b7d&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http://packagecontrol.io/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</code></pre></li></ul><h3 id="安装sublime3插件"><a href="#安装sublime3插件" class="headerlink" title="安装sublime3插件"></a>安装sublime3插件</h3><ul><li>按下 <code>ctrl+shift+p</code>，输入’ip’（Install Package）</li><li><p>输入以下插件的名字，按顺序逐个进行安装：</p><ul><li>EditorConfig</li><li>Sass</li><li>SublimeLinter</li><li>SublimeLinter-jscs</li><li>SublimeLinter-jshint</li><li>SublimeLinter-csslint</li><li>SublimeLinter-contrib-scss-lint</li><li>JSFormat</li><li>CSScomb</li></ul></li></ul><p>本文参考【<a href="http://alloyteam.github.io/CodeGuide/" title="通过分析github代码库总结出来的工程师代码书写习惯" target="_blank" rel="noopener">通过分析github代码库总结出来的工程师代码书写习惯</a>】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最佳原则&quot;&gt;&lt;a href=&quot;#最佳原则&quot; class=&quot;headerlink&quot; title=&quot;最佳原则&quot;&gt;&lt;/a&gt;最佳原则&lt;/h1&gt;&lt;p&gt;虽然这些细节是小事，不会有体验或者性能上的优化，但是却体现了一个coder和团队的专业程度 团队的愿景：成为业界卓越的Web团队！&lt;/p&gt;
&lt;p&gt;坚持制定好的代码规范。&lt;/p&gt;
&lt;p&gt;所以不管团队有多少人，代码风格都应该师出同门！&lt;/p&gt;
    
    </summary>
    
    
      <category term="github 代码 规范 编码 习惯 前端 开发" scheme="http://www.icrazyman.cn/tags/github-%E4%BB%A3%E7%A0%81-%E8%A7%84%E8%8C%83-%E7%BC%96%E7%A0%81-%E4%B9%A0%E6%83%AF-%E5%89%8D%E7%AB%AF-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>React 组件间通讯</title>
    <link href="http://www.icrazyman.cn/2018/10/22/React%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>http://www.icrazyman.cn/2018/10/22/React 组件间通讯/</id>
    <published>2018-10-22T14:40:50.000Z</published>
    <updated>2018-10-22T14:46:52.470Z</updated>
    
    <content type="html"><![CDATA[<p>作者： From 淘宝前端团队</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p><p><img src="http://img.alicdn.com/tfs/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png" alt=""></p><a id="more"></a><p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p><p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p><p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p><p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p><h1 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h1><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p><pre><code>class Parent extends Component{  state = {    msg: &#39;start&#39;  };  componentDidMount() {    setTimeout(() =&gt; {      this.setState({        msg: &#39;end&#39;      });    }, 1000);  }  render() {    return &lt;Child_1 msg={this.state.msg} /&gt;;  }}class Child_1 extends Component{  render() {    return &lt;p&gt;{this.props.msg}&lt;/p&gt;  }}</code></pre><p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 … 运算符（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 … 运算符 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p><pre><code>// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息class Child_1 extends Component{  render() {    return &lt;div&gt;      &lt;p&gt;{this.props.msg}&lt;/p&gt;      &lt;Child_1_1 {...this.props}/&gt;    &lt;/div&gt;  }}class Child_1_1 extends Component{  render() {    return &lt;p&gt;{this.props.msg}&lt;/p&gt;  }}</code></pre><h1 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h1><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p><pre><code>class Parent extends Component{  state = {    msg: &#39;start&#39;  };  transferMsg(msg) {    this.setState({      msg    });  }  render() {    return &lt;div&gt;        &lt;p&gt;child msg: {this.state.msg}&lt;/p&gt;        &lt;Child_1 transferMsg = {msg =&gt; this.transferMsg(msg)} /&gt;      &lt;/div&gt;;  }}class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      this.props.transferMsg(&#39;end&#39;)    }, 1000);  }  render() {    return &lt;div&gt;      &lt;p&gt;child_1 component&lt;/p&gt;    &lt;/div&gt;  }}</code></pre><p>在上面的例子中，我们使用了 箭头函数，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 this 仍指向父组件。</p><p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 … 运算符，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p><h1 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h1><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p><pre><code>class Parent extends Component{  state = {    msg: &#39;start&#39;  };  transferMsg(msg) {    this.setState({      msg    });  }  componentDidUpdate() {    console.log(&#39;Parent update&#39;);  }  render() {    return (      &lt;div&gt;        &lt;Child_1 transferMsg = {msg =&gt; this.transferMsg(msg)} /&gt;        &lt;Child_2 msg = {this.state.msg} /&gt;      &lt;/div&gt;    );  }}class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      this.props.transferMsg(&#39;end&#39;)    }, 1000);  }  componentDidUpdate() {    console.log(&#39;Child_1 update&#39;);  }  render() {    return &lt;div&gt;      &lt;p&gt;child_1 component&lt;/p&gt;    &lt;/div&gt;  }}class Child_2 extends Component{  componentDidUpdate() {    console.log(&#39;Child_2 update&#39;);  }  render() {    return &lt;div&gt;      &lt;p&gt;child_2 component: {this.props.msg}&lt;/p&gt;      &lt;Child_2_1 /&gt;    &lt;/div&gt;  }}class Child_2_1 extends Component{  componentDidUpdate() {    console.log(&#39;Child_2_1 update&#39;);  }  render() {    return &lt;div&gt;      &lt;p&gt;child_2_1 component&lt;/p&gt;    &lt;/div&gt;  }}</code></pre><p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p><p><img src="https://img.alicdn.com/tfs/TB1VjpZNVXXXXcIXXXXXXXXXXXX-268-152.png" alt=""></p><p>有没有更好的解决方式来进行兄弟组件间的通讯，甚至是父子组件层级较深的通讯的呢？</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>在传统的前端解耦方面，观察者模式作为比较常见一种设计模式，大量使用在各种框架类库的设计当中。即使我们在写 React，在写 JSX，我们核心的部分还是 JavaScript。</p><p>观察者模式也叫 发布者-订阅者模式，发布者发布事件，订阅者监听事件并做出反应，对于上面的代码，我们引入一个小模块，使用观察者模式进行改造。</p><pre><code>import eventProxy from &#39;../eventProxy&#39;class Parent extends Component{  render() {    return (      &lt;div&gt;        &lt;Child_1/&gt;        &lt;Child_2/&gt;      &lt;/div&gt;    );  }}// componentDidUpdate 与 render 方法与上例一致class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      // 发布 msg 事件      eventProxy.trigger(&#39;msg&#39;, &#39;end&#39;);    }, 1000);  }}// componentDidUpdate 方法与上例一致class Child_2 extends Component{  state = {    msg: &#39;start&#39;  };  componentDidMount() {      // 监听 msg 事件    eventProxy.on(&#39;msg&#39;, (msg) =&gt; {      this.setState({        msg      });    });  }  render() {    return &lt;div&gt;      &lt;p&gt;child_2 component: {this.state.msg}&lt;/p&gt;      &lt;Child_2_1 /&gt;    &lt;/div&gt;  }}</code></pre><p>我们在 child_2 组件的 componentDidMount 中订阅了 msg 事件，并在 child_1 componentDidMount 中，在 1s 后发布了 msg 事件，child_2 组件对 msg 事件做出相应，更新了自身的 state，我们可以看到，由于在整个通讯过程中，只改变了 child_2 的 state，因而只有 child_2 和 child_2_1 出发了一次更新的生命周期。</p><p><img src="https://img.alicdn.com/tfs/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png" alt=""></p><p>而上面代码中，神奇的 eventProxy.js 究竟是怎样的一回事呢？</p><pre><code>// eventProxy.js&#39;use strict&#39;;const eventProxy = {  onObj: {},  oneObj: {},  on: function(key, fn) {    if(this.onObj[key] === undefined) {      this.onObj[key] = [];    }    this.onObj[key].push(fn);  },  one: function(key, fn) {    if(this.oneObj[key] === undefined) {      this.oneObj[key] = [];    }    this.oneObj[key].push(fn);  },  off: function(key) {    this.onObj[key] = [];    this.oneObj[key] = [];  },  trigger: function() {    let key, args;    if(arguments.length == 0) {      return false;    }    key = arguments[0];    args = [].concat(Array.prototype.slice.call(arguments, 1));    if(this.onObj[key] !== undefined      &amp;&amp; this.onObj[key].length &gt; 0) {      for(let i in this.onObj[key]) {        this.onObj[key][i].apply(null, args);      }    }    if(this.oneObj[key] !== undefined      &amp;&amp; this.oneObj[key].length &gt; 0) {      for(let i in this.oneObj[key]) {        this.oneObj[key][i].apply(null, args);        this.oneObj[key][i] = undefined;      }      this.oneObj[key] = [];    }  }};export default eventProxy;</code></pre><p>eventProxy 中，总共有 on、one、off、trigger 这 4 个函数：</p><ul><li><p>on、one：on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</p></li><li><p>trigger：trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</p></li><li><p>off：用于解除所有订阅了某个事件的所有函数。</p></li></ul><h1 id="Flux-与-Redux"><a href="#Flux-与-Redux" class="headerlink" title="Flux 与 Redux"></a>Flux 与 Redux</h1><p>Flux 作为 Facebook 发布的一种应用架构，他本身是一种模式，而不是一种框架，基于这个应用架构模式，在开源社区上产生了众多框架，其中最受欢迎的就是我们即将要说的 Redux。更多关于 Flux 和 Redux 的介绍这里就不一一展开，有兴趣的同学可以好好看看 Flux 官方介绍、Flux 架构入门教程–阮一峰等相关资料。<br>下面将来好好聊聊 Redux 在组件间通讯的方式。</p><p>Flux 需要四大部分组成：Dispatcher、Stores、Views/Controller-Views、Actions，其中的 Views/Controller-Views 可以理解为我们上面所说的 Parent 组件，其作用是从 state 当中获取到相应的数据，并将其传递给他的子组件（descendants）。而另外 3 个部分，则是由 Redux 来提供了。</p><pre><code>// 该例子主要对各组件的 componentDidMount 进行改造，其余部分一致import {createStore} from &#39;redux&#39;function reducer(state = {}, action) {  return action;}let store = createStore(reducer);class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      store.dispatch({        type: &#39;child_2&#39;,        data: &#39;hello&#39;      })    }, 1000);    setTimeout(() =&gt; {      store.dispatch({        type: &#39;child_2_1&#39;,        data: &#39;bye&#39;      })    }, 2000);  }}class Child_2 extends Component{  state = {    msg: &#39;start&#39;  };  componentDidUpdate() {    console.log(&#39;Child_2 update&#39;, store.getState());  }  componentDidMount() {    store.subscribe(() =&gt; {      let state = store.getState();      if (state.type === &#39;child_2&#39;) {        this.setState({          msg: state.data        });      }    });  }}class Child_2_1 extends Component{  state = {    msg: &#39;start&#39;  };  componentDidUpdate() {    console.log(&#39;Child_2_1 update&#39;, store.getState());  }  componentDidMount() {    store.subscribe(() =&gt; {      let state = store.getState();      if (state.type === &#39;child_2_1&#39;) {        this.setState({          msg: state.data        });      }    });  }  render() {    return &lt;div&gt;      &lt;p&gt;child_2_1 component: {this.state.msg}&lt;/p&gt;    &lt;/div&gt;  }}</code></pre><p>在上面的例子中，我们将一个名为 reducer 的函数作为参数，生成我们所需要的 store，reducer 接受两个参数，一个是存储在 store 里面的 state，另一个是每一次调用 dispatch 所传进来的 action。reducer 的作用，就是对 dispatch 传进来的 action 进行处理，并将结果返回。而里面的 state 可以通过 store 里面的 getState 方法进行获得，其结果与最后一次通过 reducer 处理后的结果保持一致。</p><p>在 child_1 组件中，我们每隔 1s 通过 store 的 dispatch 方法，向 store 传入包含有 type 字段的 action，reducer 直接将 action 进行返回。</p><p>而在 child_2 与 child_2_1 组件中，通过 store 的 subscribe 方法，监听 store 的变化，触发 dispatch 后，所有通过 subscribe 进行监听的函数都会作出相应，根据当前通过 store.getState() 获取到的结果进行处理，对当前组件的 state 进行设置。所以我们可以在控制台上看到各个组件更新及存储在 store 中 state 的情况：</p><p><img src="https://img.alicdn.com/tfs/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png" alt=""></p><p>在 Redux 中，store 的作用，与 MVC 中的 Model 类似，可以将我们项目中的数据传递给 store，交给 store 进行处理，并可以实时通过 store.getState() 获取到存储在 store 中的数据。我们对上面例子的 reducer 及各个组件的 componentDidMount 做点小修改，看看 store 的这一个特性。</p><pre><code>import {createStore} from &#39;redux&#39;function reducer(state = {}, action) {  switch (action.type) {    case &#39;child_2&#39;:      state.child_2 = action.data + &#39; child_2&#39;;      return state;    case &#39;child_2_1&#39;:      state.child_2_1 = action.data + &#39; child_2_1&#39;;      return state;    default:      return state  }}let store = createStore(reducer);class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      store.dispatch({        type: &#39;child_2&#39;,        data: &#39;hello&#39;      })    }, 1000);    setTimeout(() =&gt; {      store.dispatch({        type: &#39;child_2_1&#39;,        data: &#39;bye&#39;      })    }, 2000);  }}class Child_2 extends Component{  componentDidMount() {    store.subscribe(() =&gt; {      let state = store.getState();      if (state.hasOwnProperty(&#39;child_2&#39;)) {        this.setState({          msg: state.child_2        });      }    });  }}class Child_2_1 extends Component{  componentDidMount() {    store.subscribe(() =&gt; {      let state = store.getState();      if (state.hasOwnProperty(&#39;child_2_1&#39;)) {        this.setState({          msg: state.child_2_1        });      }    });  }}</code></pre><p>我们对创建 store 时所传进去的 reducer 进行修改。reducer 中，其参数 state 为当前 store 的值，我们对不同的 action 进行处理，并将处理后的结果存储在 state 中并进行返回。此时，通过 store.getState() 获取到的，就是我们处理完成后的 state。</p><p><img src="https://img.alicdn.com/tfs/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png" alt=""></p><p>Redux 内部的实现，其实也是基于观察者模式的，reducer 的调用结果，存储在 store 内部的 state 中，并在每一次 reducer 的调用中并作为参数传入。所以在 child_1 组件第 2s 的 dispatch 后，child_2 与 child_2_1 组件通过 subscribe 监听的函数，其通过 getState 获得的值，都包含有 child_2 与 child_2_1 字段的，这就是为什么第 2s 后的响应，child_2 也进行了一次生命周期。所以在对 subscribe 响应后的处理，最好还是先校对通过 getState() 获取到的 state 与当前组件的 state 是否相同。</p><pre><code>// child_2 componentDidMount() {    store.subscribe(() =&gt; {      let state = store.getState();      if (state.hasOwnProperty(&#39;child_2&#39;)        &amp;&amp; state.child_2 !== this.state.msg) {        this.setState({          msg: state.child_2        });      }    });  }</code></pre><p>加上这样的校验，各个组件的生命周期的触发就符合我们的预期了。</p><p><img src="https://img.alicdn.com/tfs/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png" alt=""></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redux 对于组件间的解耦提供了很大的便利，如果你在考虑该不该使用 Redux 的时候，社区里有一句话说，“当你不知道该不该使用 Redux 的时候，那就是不需要的”。Redux 用起来一时爽，重构或者将项目留给后人的时候，就是个大坑，Redux 中的 dispatch 和 subscribe 方法遍布代码的每一个角落。刚刚的例子不是最好的，Flux 设计中的 Controller-Views 概念就是为了解决这个问题出发的，将所有的 subscribe 都置于 Parent 组件（Controller-Views），由最上层组件控制下层组件的表现，然而，这不就是我们所说的 子组件向父组件通讯 这种方式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者： From 淘宝前端团队&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.alicdn.com/tfs/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="react 组件 通讯" scheme="http://www.icrazyman.cn/tags/react-%E7%BB%84%E4%BB%B6-%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>编写「可读」代码的实践</title>
    <link href="http://www.icrazyman.cn/2018/09/27/%E7%BC%96%E5%86%99%E3%80%8C%E5%8F%AF%E8%AF%BB%E3%80%8D%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.icrazyman.cn/2018/09/27/编写「可读」代码的实践/</id>
    <published>2018-09-27T13:09:20.000Z</published>
    <updated>2018-09-27T13:22:46.668Z</updated>
    
    <content type="html"><![CDATA[<p>作者： From 淘宝前端团队</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>编写<strong>可读</strong>的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是<strong>能够被阅读</strong>，其次才是<strong>能够被正确执行</strong>。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p><p>在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。</p><blockquote><p>JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p></blockquote><blockquote><p>这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。</p></blockquote><a id="more"></a><h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><p>变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p><p>命名必须传递足够的信息，形如 getData 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 fetchUserInfoAsync 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 Async 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p><h2 id="命名的基础"><a href="#命名的基础" class="headerlink" title="命名的基础"></a>命名的基础</h2><p>通常，我们使用名词来命名对象，使用动词来命名函数。比如：</p><pre><code>monkey.eat(banana);  // the money eats a bananaconst apple = pick(tree);  // pick an apple from the tree</code></pre><p>这两句代码与自然语言（右侧的注释）很接近，即使完全不了解编程的人也能看懂大概。</p><p>有时候，我们需要表示某种集合概念，比如数组或哈希对象。这时可以通过名词的复数形式来表示，比如用 bananas 表示一个数组，这个数组的每一项都是一个 banana。如果需要特别强调这种集合的形式，也可以加上 List 或 Map 后缀来显式表示出来，比如用 bananaList 表示数组。</p><blockquote><p>有些单词的复数形式和单数形式相同，有些不可数的单词没有复数形式（比如 data，information），这时我也会使用 List 等后缀来表示集合概念。</p></blockquote><h2 id="命名的上下文"><a href="#命名的上下文" class="headerlink" title="命名的上下文"></a>命名的上下文</h2><p>变量都是处在<strong>上下文</strong>（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。举个例子，假设我们的程序需要管理一个动物园，程序的代码里有一个名为 feedAnimals 的函数来喂食动物园中的所有动物：</p><pre><code>function feedAnimals(food, animals) {  // ...  // 上下文中有 bananas, peaches, monkey 变量  const banana = bananas.pop();  if (banana) {    monkey.eat(banana);  } else {    const peach = peaches.pop();    monkey.eat(peach);  }  // ...}</code></pre><p>负责喂食动物的函数 feedAnimals 函数的主要逻辑就是：用各种食物把动物园里的各种动物喂饱。也许，每种动物能接受的食物种类不同，也许，我们需要根据各种食物的库存来决定每种动物最终分到的食物，总之在这个上下文中，我们需要关心食物的种类，所以传给 money.eat 方法的实参对象命名为 banana 或者 peach，代码很清楚地表达出了它的关键逻辑：「猴子要么吃香蕉，要么吃桃子（如果没有香蕉了）」。我们肯定不会这样写：</p><pre><code>// 我们不会这样写const food = bananas.pop();if(food) {  monkey.eat(food);} else {  const food = peaches.pop();  monkey.eat(food);}</code></pre><p>Monkey#eat 方法内部就不一样了，这个方法很可能是下面这样的（假设 eat 是 Monkey 的基类 Animal 的方法）：</p><pre><code>class Animal{  // ...  eat(food) {    this.hunger -= food.energy;  }  // ...}class Monkey extends Animal{   // ... }</code></pre><p>如代码所示，「吃」这个方法的核心逻辑就是根据食物的能量来减少动物（猴子）自身的饥饿度，至于究竟是吃了桃子还是香蕉，我们不关心，所以在这个方法的上下文中，我们直接将表示食物的函数形参命名为 food。</p><p>想象一下，假设我们正在编写某个函数，即将写一段公用逻辑，我们会选择去写一个新的功能函数来执行这段公用逻辑。在编写这个新的功能函数过程中，往往会受到之前那个函数的影响，变量的命名也是按照其在之前那个函数中的意义来的。虽然写的时候不感觉有什么阻碍，但是读者阅读的单元是函数（他并不了解之前哪个函数），会被深深地困扰。</p><h2 id="严格遵循一种命名规范的收益"><a href="#严格遵循一种命名规范的收益" class="headerlink" title="严格遵循一种命名规范的收益"></a>严格遵循一种命名规范的收益</h2><p>如果你能够时刻按照某种严格的规则来命名变量和函数，还能带来一个潜在的好处，那就是你再也不用记住哪些之前命名过（甚至其他人命名过）的变量或函数了。特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。比如，「获取用户信息」这个概念，就叫作 fetchUserInfomation，不管是在早晨还是傍晚，不管你是在公司还是家中，你都会将它命名为 fetchUserInfomation 而不是 getUserData。那么当你再次需要使用这个变量时，你根本不用翻阅之前的代码或依赖 IDE 的代码提示功能，你只需要再命名一下「获取用户信息」这个概念，就可以得到 fetchUserInfomation 了，是不是很酷？</p><h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><p>分支是代码里最常见的结构，一段结构清晰的代码单元应当是像二叉树一样，呈现下面的结构。</p><pre><code>if (condition1) {  if (condition2) {    ...  } else {    ...  }} else {  if (condition3) {    ...  } else {    ...  }}</code></pre><p>这种优美的结构能够帮助我们在大脑中迅速绘制一张图，便于我们在脑海中模拟代码的执行。但是，我们大多数人都不会遵循上面这样的结构来写分支代码。以下是一些常见的，在我看来可读性比较差的分支语句的写法：</p><h2 id="不好的做法：在分支中-return"><a href="#不好的做法：在分支中-return" class="headerlink" title="不好的做法：在分支中 return"></a>不好的做法：在分支中 return</h2><pre><code>function foo() {  if (condition) {    // 分支1的逻辑    return;  }  // 分支2的逻辑}</code></pre><p>这种分支代码很常见，而且往往分支 2 的逻辑是先写的，也是函数的主要逻辑，分支 1 是后来对函数进行修补的过程中产生的。这种分支代码有一个很致命的问题，那就是，如果读者没有注意到分支1中的 return（我敢保证，在使用 IDE 把代码折叠起来后，没人能第一时间注意到这个 return），就不会意识到后面一段代码（分支 2）是有可能不会执行的。我的建议是，把分支 2 放到一个 else 语句块中，代码就会清晰可读很多：</p><pre><code>function foo() {  if (condition) {    // 分支 1 的逻辑  } else {    // 分支 2 的逻辑  }}</code></pre><blockquote><p>如果某个分支是空的，我也倾向于留下一个空行，这个空行明确地告诉代码的读者，如果走到这个 else，我什么都不会做。如果你不告诉读者，读者就会产生怀疑，并尝试自己去弄明白。</p></blockquote><h2 id="不好的做法：多个条件复合"><a href="#不好的做法：多个条件复合" class="headerlink" title="不好的做法：多个条件复合"></a>不好的做法：多个条件复合</h2><pre><code>if (condition1 &amp;&amp; condition2 &amp;&amp; condition3) {  // 分支1：做一些事情} else {  // 分支2：其他的事情}</code></pre><p>这种代码也很常见：在若干条件同时满足（或有任一满足）的时候做一些主要的事情（分支1，也就是函数的主逻辑），否则就做一些次要的事情（分支2，比如抛异常，输出日志等）。虽然写代码的人知道什么是主要的事情，什么是次要的事情，但是代码的读者并不知道。读者遇到这种代码，就会产生困惑：分支2到底对应了什么条件？</p><p>在上面这段代码中，三种条件只要任意一个不成立就会执行到分支 2，但这其实本质上是多个分支：1)条件 1 不满足，2)条件 1 满足而条件 2 不满足，3)条件 1 和 2 都满足而条件 3 不满足。如果我们笼统地使用同一段代码来处理多个分支，那么就会增加阅读者阅读分支 2 时的负担（需要考虑多个情况）。更可怕的是，如果后面需要增加一些额外的逻辑（比如，在条件 1 成立且条件 2 不成立的时候多输出一条日志），整个 if-else 都可能需要重构。</p><p>对这种场景，我通常这样写：</p><pre><code>if (condition1) {  if (condition2) {    // 分支1：做一些事情  } else {    // 分支2：其他的事情  }} else {  // 分支3：其他的事情}</code></pre><p>即使分支 2 和分支 3 是完全一样的，我也认为有必要将其分开。虽然多了几行代码，收益却是很客观的。</p><blockquote><p>万事非绝对。对于一种情况，我不反对将多个条件复合起来，那就是当被复合的多个条件联系十分紧密的时候，比如 if(foo &amp;&amp; foo.bar)。</p></blockquote><h2 id="不好的做法：使用分支改变环境"><a href="#不好的做法：使用分支改变环境" class="headerlink" title="不好的做法：使用分支改变环境"></a>不好的做法：使用分支改变环境</h2><pre><code>let foo = someValue;if (condition) {  foo = doSomethingTofoo(foo);}// 继续使用 foo 做一些事情</code></pre><p>这种风格的代码很容易出现在那些屡经修补的代码文件中，很可能一开始是没有这个 if 代码块的，后来发现了一个 bug，于是加上了这个 if 代码块，在某些条件下对 foo 做一些特殊的处理。如果你希望项目在迭代过程中，风险越积越高，那么这个习惯绝对算得上「最佳实践」了。</p><p>事实上，这样的「补丁」积累起来，很快就会摧毁代码的可读性和可维护性。怎么说呢？当我们在写下上面这段代码中的 if 分支以试图修复 bug 的时候，我们内心存在这样一个假设：我们是知道程序在执行到这一行时，foo 什么样子的；但事实是，我们根本不知道，因为在这一行之前，foo 很可能已经被另一个人所写的尝试修复另一个 bug 的另一个 if 分支所篡改了。所以，当代码出现问题的时候，我们应当完整地审视一段独立的功能代码（通常是一个函数），并且多花一点时间来修复他，比如：</p><pre><code>const foo = condition ? doSomethingToFoo(someValue) : someValue;</code></pre><p>我们看到，很多风险都是在项目快速迭代的过程中积累下来的。为了「快速」迭代，在添加功能代码的时候，我们有时候连函数这个最小单元的都不去了解，仅仅着眼于自己插入的那几行，希望在那几行中解决/hack掉所有问题，这是十分不可取的。</p><p>我认为，项目的迭代再快，其代码质量和可读性都应当有一个底线。这个底线是，当我们在修改代码的时候，应当完整了解当前修改的这个函数的逻辑，然后修改这个函数，以达到添加功能的目的。注意，这里的「修改一个函数」和「在函数某个位置添加几行代码」是不同的，在「修改一个函数」的时候，为了保证函数功能独立，逻辑清晰，不应该畏惧在这个函数的任意位置增删代码。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数只做一件事情"><a href="#函数只做一件事情" class="headerlink" title="函数只做一件事情"></a>函数只做一件事情</h2><p>有时，我们会自作聪明地写出一些很「通用」的函数。比如，我们有可能写出下面这样一个获取用户信息的函数 fetchUserInfo：其逻辑是：</p><p>1) 当传入的参数是用户ID（字符串）时，返回单个用户数据；<br>2) 而传入的参数是用户ID的列表（数组）时，返回一个数组，其中的每一项是一个用户的数据。</p><pre><code>async function fetchUserInfo(id) {  const isSingle = typeof idList === &#39;string&#39;;  const idList = isSingle ? [id] : id;  const result = await request.post(&#39;/api/userInfo&#39;, {idList});  return isSingle ? result[0] : result;}// 可以这样调用const userList = await fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;]);// 也可以这样调用const user = await fetchUserInfo(&#39;1017&#39;);</code></pre><p>这个函数能够做两件事：1)获取多个用户的数据列表；2)获取单个用户的数据。在项目的其他地方调用 fetchUserInfo 函数时，也许我们确实能感到「方便」了一些。但是，代码的读者一定不会有相同的体会，当读者在某处读到 fetchUserInfo([‘1011’, ‘1013’]) 这句调用的代码时，他就会立刻对 fetchUserInfo 产生「第一印象」：这个函数需要传入用户ID数组；当他读到另外一种调用形式时，他一定会怀疑自己之前是不是眼睛花了。读者并不了解背后的「潜规则」，除非规则是预先设计好并且及时地更新到文档中。总之，我们绝不该一时兴起就写出上面这种函数。</p><p>遵循一个函数只做一件事的原则，我们可以将上述功能拆成两个函数fetchMultipleUser 和 fetchSingleUser 来实现。在需要获取用户数据时，只需要选择调用其中的一个函数。</p><pre><code>async function fetchMultipleUser(idList) {  return await request.post(&#39;/api/users/&#39;, {idList});}async function fetchSingleUser(id) {  return await fetchMultipleUser([id])[0];}</code></pre><p>上述改良不仅改善了代码的可读性，也改善了可维护性。举个例子，假设随着项目的迭代，获取单一用户信息的需求不再存在了。</p><ul><li><p>如果是改良前，我们会删掉那些「传入单个用户ID来调用 fetchUserInfo」的代码，同时保留剩下的那些「传入多个用户ID调用 fetchUserInfo」的代码， 但是 fetchUserInfo 函数几乎一定不会被更改。这样，函数内部 isSingle 为 true 的分支，就留在了代码中，成了永远都不会执行的「脏代码」，谁愿意看到自己的项目中充斥着永远不会执行的代码呢？</p></li><li><p>对于改良后的代码，我们（也许借助IDE）能够轻松检测到 fetchSingleUser 已经不会被调用了，然后放心大胆地直接删掉这个函数。</p></li></ul><p>那么，如何界定某个函数做的是不是一件事情？我的经验是这样：<strong>如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。</strong>比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。</p><h2 id="函数应适当地处理异常"><a href="#函数应适当地处理异常" class="headerlink" title="函数应适当地处理异常"></a>函数应适当地处理异常</h2><p>有时候，我们会陷入一种很不好的习惯中，那就是，总是去尝试写出永远不会报错的函数。我们会给参数配上默认值，在很多地方使用 || 或者 &amp;&amp; 来避免代码运行出错，仿佛如果你的函数报错会成为某种耻辱似的。而且，当我们尝试去修复一个运行时报错的函数时，我们往往倾向于在报错的那一行添加一些兼容逻辑来避免报错。</p><p>举个例子，假设我们需要编写一个获取用户详情的函数，它要返回一个完整的用户信息对象：不仅包含ID，名字等基本信息，也包含诸如「收藏的书籍」等通过额外接口返回的信息。这些额外的接口也许不太稳定：</p><pre><code>async function getUserDetail(id) {  const user = await fetchSingleUser(id);  user.favoriteBooks = (await fetchUserFavorits(id)).books;  // 上面这一行报错了：Can not read property &#39;books&#39; of undefined.  // ...}</code></pre><p>假设 fetchUserFavorites 会时不时地返回 undefined，那么读取其 books 属性自然就会报错。为了修复该问题，我们很可能会这样做：</p><pre><code>const favorites = await fetchUserFavorits(id);user.favoriteBooks = favorites &amp;&amp; favorites.books;// 这下不会报错了</code></pre><p>这样做看似解决了问题：的确，getUserDetail 不会再报错了，但同时埋下了更深的隐患。</p><p>当 fetchUserFavorites 返回 undefined 时，程序已经处于一种异常状态了，我们没有任何理由放任程序继续运行下去。试想，如果后面的某个时刻（比如用户点击「我收藏的书」选项卡），程序试图遍历 user.favoriteBooks 属性（它被赋值成了undefined），那时也会报错，而且那时排查起来会更加困难。</p><p>如何处理上述的情况呢？我认为，如果被我们依赖的 fetchUserFavorits 属于当前的项目，那么 getUserDetail 对此报错真的没什么责任，因为 fetchUserFavorits 就不应该返回 undefined，我们应该去修复 fetchUserFavorits，任务失败时显式地告知出来，或者直接抛出异常。同时，getUserDetail 稍作修改：</p><pre><code>// 情况1：显式告知，此时应认为获取不到收藏数据不算致命的错误const result = await fetchUserFavorits(id);if(result.success) {  user.favoriteBooks = result.data.books;} else {  user.favoriteBooks = []}// 情况2：直接抛出异常user.favoriteBooks = (await fetchUserFavorits(id)).books;// 这时 `getUserDetail` 不需要改动，任由异常沿着调用栈向上冒泡</code></pre><p>那么如果 fetchUserFavorits 不在当前项目中，而是依赖的外部模块呢？我认为，这时你就该为选择了这样一个不可靠的模块负责，在 getUserDetail 中增加一些「擦屁股」代码，来避免你的项目的其他部分受到侵害。</p><pre><code>const favorites = await fetchUserFavorits(id);if(favorites) {  user.favoriteBooks = favorites.books;} else {  throw new Error(&#39;获取用户收藏失败&#39;);}</code></pre><h2 id="控制函数的副作用"><a href="#控制函数的副作用" class="headerlink" title="控制函数的副作用"></a>控制函数的副作用</h2><p>无副作用的函数，是<strong>不依赖上下文，也不改变上下文</strong>的函数。长久依赖，我们已经习惯了去写「有副作用的函数」，毕竟 JavaScript 需要通过副作用去操作环境的 API 完成任务。这就导致了，很多原本可以用纯粹的、无副作用的函数完成任务的场合，我们也会不自觉地采取有副作用的方式。</p><p>虽然看上去有点可笑，但我们有时候就是会写出下面这样的代码！</p><pre><code>async function getUserDetail(id) {  const user = await fetchSingleUserInfo(id);  await addFavoritesToUser(user);  ...}async function addFavoritesToUser(user) {  const result = await fetchUserFavorits(user.id);  user.favoriteBooks = result.books;  user.favoriteSongs = result.songs;  user.isMusicFan = result.songs.length &gt; 100;}</code></pre><p>上面，addFavoritesToUser 函数就是一个「有副作用」的函数，它改变了 users，给它新增了几个个字段。问题在于，仅仅阅读 getUserData 函数的代码完全无法知道，user 会发生怎样的改变。</p><p>一个无副作用的函数应该是这样的：</p><pre><code>async function getUserDetail(id) {  const user = await fetchSingleUserInfo(id);  const {books, songs, isMusicFan} = await getUserFavorites(id);  return Object.assign(user, {books, songs, isMusicFan})}async function getUserFavorites(id) {  const {books, songs} = await fetchUserFavorits(user.id);  return {    books, songs, isMusicFan: result.songs.length &gt; 100  }}</code></pre><p>难道这不是理所当然的形式吗？</p><h2 id="非侵入性地改造函数"><a href="#非侵入性地改造函数" class="headerlink" title="非侵入性地改造函数"></a>非侵入性地改造函数</h2><p>函数是一段独立和内聚的逻辑。在产品迭代的过程中，我们有时候不得不去修改函数的逻辑，为其添加一些新特性。之前我们也说过，一个函数只应做一件事，如果我们需要添加的新特性，与原先函数中的逻辑没有什么联系，那么决定是否通过改造这个函数来添加新功能，应当格外谨慎。</p><p>仍然用「向服务器查询用户数据」为例，假设我们有如下这样一个函数（为了让它看上去复杂一些，假设我们使用了一个更基本的 request 库）：</p><pre><code>const fetchUserInfo = (userId, callback) =&gt; {  const param = {    url: &#39;/api/user&#39;,    method: &#39;post&#39;,    payload: {id: userId}  };  request(param, callback);}</code></pre><p>现在有了一个新需求：为 fetchUserInfo 函数增加一道本地缓存，如果第二次请求同一个 userId 的用户信息，就不再重新向服务器发起请求，而直接以第一次请求得到的数据返回。</p><p>按照如下快捷简单的解决方案，改造这个函数只需要五分钟时间：</p><pre><code>const userInfoMap = {};const fetchUserInfo = (userId, callback) =&gt; {  if (userInfoMap[userId]) {            // 新增代码    callback(userInfoMap[userId]);    // 新增代码  } else {                              // 新增代码    const param = {      // ... 参数    };    request(param, (result) =&gt; {      userInfoMap[userId] = result;   // 新增代码      callback(result);    });  }}</code></pre><p>不知你有没有发现，经此改造，这个函数的可读性已经明显降低了。没有缓存机制前，函数很清晰，一眼就能明白，加上新增的几行代码，已经不能一眼就看明白了。</p><p>实际上，「缓存」和「获取用户数据」完全是独立的两件事。我提出的方案是，编写一个通用的缓存包装函数（类似装饰器）memorizeThunk，对 fetchUserInfo 进行包装，产出一个新的具有缓存功能的 fetchUserInfoCache，在不破坏原有函数可读性的基础上，提供缓存功能。</p><pre><code>const memorizeThunk = (func, reducer) =&gt; {  const cache = {};  return (...args, callback) =&gt; {    const key = reducer(...args);    if (cache[key]) {      callback(...cache[key]);    } else {      func(...args, (...result) =&gt; {        cache[key] = result;        callback(...result);      });    }  }}const fetchUserInfo = (userInfo, callback) =&gt; {  // 原来的逻辑}const fetchUserInfoCache = memorize(fetchUserInfo, (userId) =&gt; userId);</code></pre><p>也许实现这个方案需要十五分钟，但是试想一下，如果将来的某个时候，我们又不需要缓存功能了（或者需要提供一个开关来打开/关闭缓存功能），修改代码的负担是怎样的？第一种简单方案，我们需要精准（提心吊胆地）地删掉新增的若干行代码，而我提出的这种方案，是以函数为单位增删的，负担要轻很多，不是吗？</p><h1 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h1><h2 id="避免滥用成员函数"><a href="#避免滥用成员函数" class="headerlink" title="避免滥用成员函数"></a>避免滥用成员函数</h2><p>JavaScript 中的类，是 ES6 才有的概念，此前是通过函数和原型链来模拟的。在编写类的时候，我们常常忍不住地写很多没必要的成员函数：当类的某个成员函数的内部逻辑有点复杂了，行数有点多了之后，我们往往会将其中一部分「独立」逻辑拆分出来，实现为类的另一个成员函数。比如，假设我们编写某个 React 组件来显示用户列表，用户列表的形式是每两个用户为一行。</p><pre><code>class UserList extends React.Component{  // ...  chunk = (users) =&gt; {    // 将 [&#39;张三&#39;, &#39;李四&#39;, &#39;王二&#39;, &#39;麻子&#39;] 转化为 [[&#39;张三&#39;, &#39;李四&#39;], [&#39;王二&#39;, &#39;麻子&#39;]]  }  render(){    const chunks = this.chunk(this.props.users);    // 每两个用户为一行    return (      &lt;div&gt;        {chunks.map(users=&gt;          &lt;row&gt;            {users.map(user =&gt;               &lt;col&gt;&lt;UserItem user={user}&gt;&lt;/col&gt;            )}          &lt;/row&gt;        )}      &lt;/div&gt;    )  }}</code></pre><p>如上述代码所示，UserList 组件按照「两个一行」的方式来显示用户列表，所以需要先将用户列表进行组合。进行组合的工作这件事情看上去是比较独立的，所以我们往往会将 chunk 实现成 UserList 的一个成员函数，在 render 中调用它。</p><p>我认为这样做并不可取，因为 chunk 只会被 render 所调用，仅仅服务于 render。阅读这个类源码的时候，读者其实只需要在 render 中去了解 chunk 函数就够了。然而 chunk 以成员函数的形式出现，扩大了它的可用范围，提前把自己曝光给了读者，反而会造成干扰。读者阅读源码，首先就是将代码折叠起来，然后他看到的是这样的景象：</p><pre><code>class UserList extends React.Component {  componentDidMount() {...}  componentWillUnmount() {...}  chunk() {...}    // 读者的内心独白：这是什么鬼？  render() {...}}</code></pre><p>熟悉 React 的同学对组件中出现一个不熟悉的方法多半会感到困惑。不管怎么说，读者肯定会首先去浏览一遍这些成员函数，但是阅读 chunk 函数带给读者的信息基本是零，反而还会干扰读者的思路，因为读者现在还不知道用户列表需要以「每两个一行」的方式呈现。所以我认为，chunk 函数绝对应该定义在 render 中，如下所示：</p><pre><code>render(){  const chunk = (users) =&gt; ...  const chunks = this.chunk(this.props.users);  return (    &lt;div&gt;  ...}</code></pre><p>这样虽然函数的行数可能会比较多，但将代码折叠起来后，函数的逻辑则会非常清楚。而且，chunk 函数曝光在读者眼中的时机是非常正确的，那就是，在它即将被调用的地方。实际上，在「计算函数的代码行数」这个问题上，我会把内部定义的函数视为一行，因为函数对读者可以是黑盒，它的负担只有一行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者： From 淘宝前端团队&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;编写&lt;strong&gt;可读&lt;/strong&gt;的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是&lt;strong&gt;能够被阅读&lt;/strong&gt;，其次才是&lt;strong&gt;能够被正确执行&lt;/strong&gt;。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。&lt;/p&gt;
&lt;p&gt;在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="开发 学习 提升 编程 代码" scheme="http://www.icrazyman.cn/tags/%E5%BC%80%E5%8F%91-%E5%AD%A6%E4%B9%A0-%E6%8F%90%E5%8D%87-%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>写给工程师的十条精进原则</title>
    <link href="http://www.icrazyman.cn/2018/09/13/%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%8D%81%E6%9D%A1%E7%B2%BE%E8%BF%9B%E5%8E%9F%E5%88%99/"/>
    <id>http://www.icrazyman.cn/2018/09/13/写给工程师的十条精进原则/</id>
    <published>2018-09-13T15:11:30.000Z</published>
    <updated>2018-09-13T15:23:31.511Z</updated>
    
    <content type="html"><![CDATA[<p>作者： 云鹏 From 美团技术团队</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>时间回到8年前，我人生中的第一份实习工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。</p><p>这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。</p><p>8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。</p><p>“追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。</p><a id="more"></a><h1 id="原则一：Owner意识"><a href="#原则一：Owner意识" class="headerlink" title="原则一：Owner意识"></a>原则一：Owner意识</h1><p>“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。</p><p><strong>认真负责是工作的底线。</strong>首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD的工程交付质量，还会对协同工作的RD、QA、PM等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。</p><p><strong>积极主动是“Owner意识”更高一级的要求。</strong>RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。</p><p>积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。</p><h1 id="原则二：时间观念"><a href="#原则二：时间观念" class="headerlink" title="原则二：时间观念"></a>原则二：时间观念</h1><p>相信大家都有时间观念，但是真正能执行到位的可能并没有那么多。互联网是一个快速发展的行业，RD的研发效率是一个公司硬实力的重要体现。项目的按期交付是一项很重要的执行能力，在很大程度上决定着领导和同事对自己靠谱程度的评价。大家可能会问：难度几乎相同的项目，为什么有的同学经常Delay，而有的同学每次都能按时上线？一个很重要的原因，就是这些按时交付的同学往往具备如下两个特质：<strong>做事有计划，工作分主次。</strong></p><p><strong>工作安排要有计划性。</strong>通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。</p><p>此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。</p><p><strong>工作安排要分清楚主次。</strong>我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。</p><h1 id="原则三：以终为始"><a href="#原则三：以终为始" class="headerlink" title="原则三：以终为始"></a>原则三：以终为始</h1><p>“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：<strong>先想清楚目标，然后努力实现。</strong></p><p>在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现的尤为明显。</p><p>例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，<strong>所以要根据问题设定目标，再进行优化。</strong></p><p>“以终为始”，这一原则还可以作用于我们的学习中。很多同学看过很多技术文章，但是总是感觉自己依然一无所知。很重要的一个原因，就是没有<strong>带着目标去学习。</strong>在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把Redis的持久化原理搞清楚，还是把Redis的主从同步机制弄明白，亦或是想学习整个Redis Cluster的架构体系。如果我们能够带着问题与目标，再进行相关的资料搜集与学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好很多。</p><h1 id="原则四：闭环思维"><a href="#原则四：闭环思维" class="headerlink" title="原则四：闭环思维"></a>原则四：闭环思维</h1><p>你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。</p><p>之前看过一句话：<strong>一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，</strong>如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。</p><p>例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的To Do进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入“沟通-发现问题-再沟通-再发现问题”的恶性循环中。</p><p><strong>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。</strong></p><p><strong>“闭环思维”还要求能够定期主动进行阶段性的反馈。</strong>刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。</p><p>这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。</p><h1 id="原则五：保持敬畏"><a href="#原则五：保持敬畏" class="headerlink" title="原则五：保持敬畏"></a>原则五：保持敬畏</h1><p>“君子之心，常怀敬畏”，保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。</p><p><strong>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。</strong>以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。</p><p>类似的问题，还包括对上线流程的不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。</p><p>保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，<strong>让规范与约定与时俱进，也是另一种形式的敬畏。</strong></p><h1 id="原则六：事不过二"><a href="#原则六：事不过二" class="headerlink" title="原则六：事不过二"></a>原则六：事不过二</h1><p>“事不过二”，是我们团队一贯坚持的原则，它可以解读为两层含义。</p><p>一层含义是“<strong>所有的评审与问题讨论，不要超过两次</strong>”。之所以有这样的要求，是因为我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。</p><p>同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此我们团队规定：<strong>所有的评审最多两次</strong>。通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够大大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。</p><p>“事不过二”原则的另一层含义，是“<strong>同样的错误不能犯第二次</strong>”。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。</p><h1 id="原则七：设计优先"><a href="#原则七：设计优先" class="headerlink" title="原则七：设计优先"></a>原则七：设计优先</h1><p>“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。”</p><p><strong>架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。</strong>很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计的足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。<strong>无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。</strong>因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。</p><p><strong>“设计优先”这一原则，要求写别人看得懂的设计。</strong>我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。</p><h1 id="原则八：P-PC平衡"><a href="#原则八：P-PC平衡" class="headerlink" title="原则八：P/PC平衡"></a>原则八：P/PC平衡</h1><p>“P/PC平衡”原则，即产出与产能平衡原则。伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。<strong>产出与产能必须平衡，才能达到真正的高效能。</strong>为了让大家更清晰的了解这一原则，本文举两个例子。</p><p>从系统的角度看，每一个系统都是通过持续不断地叠加功能，来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。</p><p>再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P/PC不平衡的体现。<strong>如果能在做项目的过程中，通过学习总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。</strong></p><p>“P/PC平衡”原则还适用于很多其他的领域，例如团队、家庭等，我本人也非常推崇这一原则。希望大家也能将其作为自身的一项基本原则，努力寻找到产出与产能的平衡点。</p><h1 id="原则九：善于提问"><a href="#原则九：善于提问" class="headerlink" title="原则九：善于提问"></a>原则九：善于提问</h1><p>“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，<strong>只有在争辩中，才可能诞生最好的主意和最好的决定。</strong></p><p>在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。</p><p><strong>“善于提问”，还要懂得如何提问。</strong>为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：这就是批判性思维。</p><p>批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。</p><h1 id="原则十：空杯心态"><a href="#原则十：空杯心态" class="headerlink" title="原则十：空杯心态"></a>原则十：空杯心态</h1><p>“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。</p><p><strong>保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。</strong>在工作中，多去跟不同级别的同学聊一聊，或者做一个360度评估，这有助于我们更加客观地评价自己。在横向对比中，多向那些优秀的同学看齐，学习他人的优点。很多同学在设计评审或者代码Review过程中，针对别人提出的问题与建议，往往都采用一种对立的态度。错误地认为别人是在挑刺，是在针对自己。诚然，在某些方面，我们可能确实比其他人想得深入，但是这不代表在所有方面都能考虑周全。对于别人的建议，建议使用“善于提问”原则里提到的批判性思维仔细分析一下，虚心地吸取那些好的建议。</p><p>工作学习就像“练级打怪”，技能储备的越多，就越容易走到最后。保持空杯心态，可以让我们发现很多以前注意不到的新能力，我们要做的就是努力学习它，将它们转化为自己能力库的一部分。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，是我总结的工作与学习的十条基本原则。其中有的侧重于个人做事情的方法，如“Owner意识”、“时间观念”、“以终为始”、”闭环思维”；有的侧重于团队工作标准规范，如“保持敬畏”、“事不过二”、“设计优先”；有的侧重于团队或个人效能提升，如“P/PC平衡”、“善于提问”、“空杯心态”。这些原则是我多年在工作与学习中，不断总结得来的经验。希望在大家面临选择时，这些原则能够起到一定的帮助和指导作用。</p><p>以原则为中心地工作与生活，让自己与团队变得更加强大。</p><h1 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h1><p>云鹏，2014年加入美团，先后参与了美团酒店供应链体系、分布式调度系统的建设，现在负责美团旅行客户关系管理系统、基础信息服务的建设工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者： 云鹏 From 美团技术团队&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;时间回到8年前，我人生中的第一份实习工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。&lt;/p&gt;
&lt;p&gt;这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。&lt;/p&gt;
&lt;p&gt;8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。&lt;/p&gt;
&lt;p&gt;“追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发 原则 流程 编程 工程师" scheme="http://www.icrazyman.cn/tags/%E5%BC%80%E5%8F%91-%E5%8E%9F%E5%88%99-%E6%B5%81%E7%A8%8B-%E7%BC%96%E7%A8%8B-%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>工程师如何在工作中提升自己</title>
    <link href="http://www.icrazyman.cn/2018/09/12/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1/"/>
    <id>http://www.icrazyman.cn/2018/09/12/工程师如何在工作中提升自己/</id>
    <published>2018-09-12T14:24:53.000Z</published>
    <updated>2018-09-13T15:38:13.241Z</updated>
    
    <content type="html"><![CDATA[<p>作者： 刘丁 From 美团技术团队</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。</p><p>如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答：</p><ul><li><p>第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。</p></li><li><p>提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。</p></li><li><p>成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。</p></li></ul><a id="more"></a><h1 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h1><p>在繁忙的工作中，持之以恒、不断学习和进步是一件艰巨的任务，需要坚强的毅力和坚定的决心。如果方法不得当，更是事倍功半。幸好我们的古人和现在哲人已经总结了很多优秀的学习方法论，这里汇总了一些重要原则。遵循这些方法必会对大家的工作学习大有裨益。</p><h2 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h2><p>有报道指出，过去几十年的知识量超过之前人类几千年的知识量总和。而计算机领域绝对是当代知识更新最快的领域之一，因此，工程师必须要接受这样一个现实，现在所掌握的深厚知识体系很快就会被淘汰。要想在计算机领域持续做优秀架构师，就必须不停的学习，掌握最新技术。总之，学不可以已。</p><p>所谓“冰冻三尺，非一日之寒，水滴石穿，非一日之功”，通往架构师的道路漫长而又艰巨，轻易放弃，则所有付出瞬间付之东流。要想成为优秀的架构师，贵在坚持！</p><p>虽然知识更新很快，但是基础理论的变化却非常缓慢。这就是“道”和“象”关系，纵是世间万象，道却万变不离其宗。对于那些非常基础的理论知识，我们需要经常复习，也就是“学而时习之”。</p><h2 id="重视实践"><a href="#重视实践" class="headerlink" title="重视实践"></a>重视实践</h2><p>古人云：“纸上得来终觉浅，绝知此事要躬行。” 学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但对于工程师们来说，按照实践、学习和培训的方式进行重要性排序，大致是不错的。所以重视实践，在实践中成长是最重要的学习原则。</p><p>人类的认知有两种：感性认知和理性认知。这两种认知互相不可替代性。实践很大程度来自于感性学习，看书更像是理性学习。以学开汽车做例子，很难想象什么人能够仅仅通过学习书本知识就会开汽车。</p><p>书本知识主要是传道——讲述抽象原型，而对其具体应用场景的讲述往往含糊其辞，对抽象原型之间的关系也是浅尝辄止。采用同样精确的语言去描述应用场景和关联关系将会失去重点，让人摸不着头脑。所以，仅仅通过看书来获得成长就像是用一条腿走路。</p><p>重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。</p><h2 id="重视交流"><a href="#重视交流" class="headerlink" title="重视交流"></a>重视交流</h2><p>牛顿说：“如果说我看得比别人远一些，那是因为我站在巨人的肩膀上。”我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。</p><p>向老师和领导学习已经是人们生活习惯的一部分了。但是从同事甚至对手那里学习也很重要，因为这些人和我们自身更相似。所以要多多观察，取其所长，弃其所短。对于团队的小兄弟和下属，也要“不耻下问”。</p><p>此外，在项目中积极参与具体方案讨论也非常重要。参与者先验感知了相关背景，并且讨论的观点和建议也是综合了发言者多种知识和技能。所以，讨论让参与者能够非常全面，立体地理解书本知识。同时，和高手讨论，他们的观点就会像修剪机剪树枝一样，快速的剪掉自己知识领域里面的疑惑点。</p><h2 id="重视总结和输出"><a href="#重视总结和输出" class="headerlink" title="重视总结和输出"></a>重视总结和输出</h2><p>工程师在实践中会掌握大量细节，但是，即使掌握了所有细节，却没有深刻的总结和思考，也会陷入到“学而不思则罔”的境地。成长的“量变”来自于对细节的逐渐深入地把控，而真正的“质变”来自于对“道”的更深层次的理解。</p><p>将经验输出，接受别人的检验是高层次的总结。这种输出不仅帮助了别人，对自身更是大有裨益。总结的方式有很多，包括组织分享，撰写技术文章等等。当然“日三省吾身”也是不错的总结方式。总之，多多总结，多多分享，善莫大焉！</p><p>解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。</p><h2 id="重视规划"><a href="#重视规划" class="headerlink" title="重视规划"></a>重视规划</h2><p>凡事预则立，不预则废。对于漫长的学习生涯而言，好的计划是成功的一半。</p><h2 id="长期规划"><a href="#长期规划" class="headerlink" title="长期规划"></a>长期规划</h2><p>长期规划的实施需要毅力和决心，但是做正确的长期规划还需要高瞻远瞩的眼界、超级敏感的神经和中大奖的运气。对于大部分人来说，长期规划定主要是“定方向”。但遵循如下原则能够减少犯方向性错误的概率：</p><ul><li><p>远离日暮西山的行业。</p></li><li><p>做自己感兴趣的事情。</p></li><li><p>做有积累的事情。</p></li><li><p>一边走一边看，切勿一条道走到黑。</p></li></ul><h2 id="短期规划"><a href="#短期规划" class="headerlink" title="短期规划"></a>短期规划</h2><p>良好的短期规划应该在生活、成长、绩效和晋升之间取得平衡。大部分公司都会制定一个考核周期——少则一个月，多则一年。所以不妨以考核周期作为短期学习规划周期。本质上，规划是一个多目标优化问题，它有一系列的理论方案，这里不一一细说。基于相关理论，我给出一个简单易行的方案：</p><ul><li><p>确定目标优先级。比如：成长、生活、绩效。</p></li><li><p>确定每个目标的下限。从优化理论的角度来看，这被称为约束。比如绩效必须在一般以上，之前已经规划好的旅行不能更改，必须读完《Effective Java》等等。</p></li><li><p>优先为下限目标分配足够的资源。比如，事先规划好的旅行需要10天，这10天就必须预算出去。</p></li><li><p>按照各主目标的顺序依次分配资源。比如，最终分配给学习的时间是10天。</p></li><li><p>在给定的学习预算下，制定学习目标，要激进。然后给出执行方案。比如，学习目标是掌握基本的统计学知识，并成为Java专家。具体方案为：完成《Effective Java》、《Java Performance》、《Design Pattern》、《Head First Statistics》四本书的阅读。</p></li><li><p>对规划中的各学习任务按目标优先级进行排序，并最先启动优先级最高的任务。比如，最高优先级是掌握统计理论，那么就要先看《Head First Statistics》。</p></li></ul><p>对于该方案，要注意以下几点：</p><ul><li><p>最低目标必须能够轻松达成的目标，否则，从优化理论的角度来讲，该命题无解。比如，类似“半年内完成晋级两次、绩效全部S、从菜鸟成为Java专家”就不太合适作为最低目标。总之，要区分理想和梦想。</p></li><li><p>主要目标规划必须具备一定的挑战性，需要规划出不可能完成的目标。过度规划本质上是一种贪婪算法，目的是目标价值最大化。因为一切皆有变数，如果其他目标能够提前完成，就不妨利用这些时间去完成更多的学习目标。总之，前途必须光明，道路必须坎坷。</p></li><li><p>各目标之间不一定共享资源，规划不一定互有冲突。</p></li></ul><p>此外，短期规划还可以从如下几个方面进行优化：</p><ul><li><p>学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。比如，本季度规划去做一些数据分析工作，那么不妨把学习目标设置为学习统计知识。</p></li><li><p>要灵活对待规划的目标和具体执行步骤，需要避免“郑人买履”式的笑话。面临新的挑战和变化，规划需要不断地调整。</p></li></ul><h1 id="那些令人纠结的困惑"><a href="#那些令人纠结的困惑" class="headerlink" title="那些令人纠结的困惑"></a>那些令人纠结的困惑</h1><p>人生是一场马拉松，在漫长的征途中，难免有很多困惑。困惑就像枷锁，使我们步履蹒跚，困惑就像死锁，让我们停滞不前。</p><p>接下来我将总结自己在工作中碰到和看到的一些典型困惑。这些困惑或者长期困扰作者本人，或者困扰我身边的同事和朋友。当这些困惑被释然之后，大家都感觉如重获释，为下一阶段的征程提供满满的正能量。人生就像一场旅途，不必在乎目的地，在乎的，应该是沿途的风景，以及看风景的心情。良好的心态是技术之旅最好的伴侣。期望通过这个解惑之旅，让大家拥有一个愉快的心情去感受漫长的学习旅途。</p><h2 id="学无止境吗"><a href="#学无止境吗" class="headerlink" title="学无止境吗"></a>学无止境吗</h2><p>必须要承认一个残酷的现实：人的生命是有限的，知识却是无限的。用有限的生命去学习无限的知识是不可能完成的任务。一想到此，有些工程师不免产生一些悲观情绪。如果方法得当并且足够勤奋，悲伤大可不必。</p><p>虽然，人类的整体知识体系一直在扩张。但是就很多重要的工程细分领域，基础理论并不高深。计算机的很多重要领域，工程师有能力在有限时间内抓住核心要害。</p><p>比如，密码学被认为是门非常高深的学科，但是一大类密码技术的基础是数论中一个非常简单的理论——素因数分解：给出两个素数，很容易算出它们的积，然而反过来给定两个素数的积，分解的计算量却非常惊人。</p><p>“一致性”算得上是计算机领域里面最经典的难题，它是所有分布式系统的基础，从多核多CPU到多线程，从跨机器到跨机房，无所不在，几乎所有的计算机从业人员都在解决这个问题，但是Paxos给出了一个很优雅的解决方案。</p><p>权限管理是很多工程师的噩梦，但如果你能搞定“Attribute Based Access Control(ABAC)”和“Role-Based Access Control(RBAC)”，也能达到相当高度。</p><p>另外，技术学习是一场对抗赛，虽然学无止境，超越大部分对手就是一种胜利。所以，以正确的学习方式，长时间投入就会形成核心竞争力。</p><h2 id="没有绝对高明的技术，只有真正的高手"><a href="#没有绝对高明的技术，只有真正的高手" class="headerlink" title="没有绝对高明的技术，只有真正的高手"></a>没有绝对高明的技术，只有真正的高手</h2><p>致力于在技术上有所成就的工程师，都梦想有朝一日成为技术高手。但技术高手的标准却存在很大的争议。这是一个有着悠久历史的误解：以某种技术的掌握作为技术高手的评判标准。我经常碰到这样一些情景：因为掌握了某些技术，比如Spring、Kafka、Elasticsearch等，一些工程师就自封为高手。有些工程师非常仰慕别的团队，原因竟是那个团队使用了某种技术。</p><p>这种误解的产生有几个原因：首先，技多不压身，技术自然是掌握的越多越好，掌握很多技术的人自然不是菜鸟。其次，在互联网时代来临之前，信息获取是非常昂贵的事情。这就导致一项技能的掌握可以给个人甚至整个公司带来优势地位。互联网时代，各种框架的出现以及开源的普及快速淘汰或者降低了很多技能的价值，同时降低了很多技术的学习门槛。所以，在当前，掌握某项技能知识只能是一个短期目标。怀揣某些技能就沾沾自喜的人需要记住：骄傲使人退步。</p><p>所谓麻雀虽小，五脏俱全。如果让你来做造物主，设计麻雀和设计大象的复杂度并没有明显区别。一个看起来很小的业务需求，为了达到极致，所需要的技术和能力是非常综合和高深的。真正的高手不是拿着所掌握的技术去卡客户需求，而是倾听客户的需求，给出精益求精的方案。完成客户的需求是一场擂台赛，真正的高手，是会见招拆招的。</p><h2 id="不做项目就无法成长吗"><a href="#不做项目就无法成长吗" class="headerlink" title="不做项目就无法成长吗"></a>不做项目就无法成长吗</h2><p>在项目中学习是最快的成长方式之一，很多工程师非常享受这个过程。但是一年到头都做项目，你可能是在一家外包公司。对于一个做产品的公司，如果年头到年尾都在做项目，要不然就是在初步创业阶段，要不然就是做了大量失败的项目，总之不算是特别理想的状态。正常情况，在项目之间都会有一些非项目时间。在这段时间，有些同学会产生迷茫，成长很慢。</p><p>项目真的是越多越好吗？答案显然是否定的。重复的项目不会给工程师们带来新的成长。不停的做项目，从而缺乏学习新知识的时间，会导致“做而不学则殆”。真正让工程师出类拔萃的是项目的深度，而不是不停地做项目。所以，在项目之间的空档期，工程师们应该珍惜难得的喘息之机，深入思考，把项目做深，做精。</p><p>如何提高项目的深度呢？一般而言，任何项目都有一个目标，当项目完成后，目标就算基本达成了。但是，客户真的满意了吗？系统的可用性、可靠性、可扩展性、可维护性已经做到极致了吗？这几个问题的答案永远是否定的。所以，任何一个有价值的项目，都可以一直深挖。深挖项目，深度思考还可以锻炼工程师的创造力。期望不停地做项目的人，就像一个致力于训练更多千里马的人是发明不出汽车的。锻炼创造力也不是一蹴而就的事情，需要长时间地思考。总之，工程师们应该总是觉得时间不够用，毕竟时间是最宝贵的资源。</p><h2 id="职责真的很小吗"><a href="#职责真的很小吗" class="headerlink" title="职责真的很小吗"></a>职责真的很小吗</h2><p>很多时候，一个工程师所负责系统的数量和团队规模与其“江湖地位”正相关。但是，江湖地位与技术成长没有必然关联。提升技术能力的关键是项目深度以及客户的挑剔程度。项目越多，在单个项目中投入的时间就越少，容易陷入肤浅。特别需要避免的是“ 在其位不谋其政”的情况。团队越大，在管理方面需要投入的精力就越多。在管理技巧不成熟，技术眼界不够高的前提强行负责大团队，可能会导致个人疲于应付，团队毫无建树。最终“ 一将无能，累死三军”，效果可能适得其反。</p><p>从技术发展的角度来说，技术管理者应该关注自己所能把控的活跃项目的数量，并致力于提高活跃项目的影响力和技术深度。团队人数要与个人管理能力、规划能力和需求把控能力相适应。一份工作让多个人来干，每个人的成长都受限。每个人都做简单重复的工作，对技术成长没有任何好处。团队管理和项目管理需要循序渐进，忌“拔苗助长”。</p><h2 id="一定要当老大吗"><a href="#一定要当老大吗" class="headerlink" title="一定要当老大吗"></a>一定要当老大吗</h2><p>有一些工程师的人生理想是做团队里的技术老大，这当然是一个值得称赞的理想。可是，如果整个团队技术能力一般，发展潜力一般，而你是技术最强者，这与其说是幸运，不如说是悲哀。这种场景被称之为“武大郎开店”。 团队里的技术顶尖高手不是不能做，但为了能够持续成长，需要满足如下几个条件：</p><ul><li><p>首先你得是行业里面的顶尖专家了——实在很难找到比你更强的人了！</p></li><li><p>其次，你经常需要承担对你自己的能力有挑战的任务，但同时你拥有一批聪明能干的队友。虽然你的技术能力最高，但是在你不熟悉的领域，你的队友能够进行探索并扩展整个团队的知识。</p></li><li><p>最后，你必须要敏而好学，不耻下问。</p></li></ul><p>否则，加入更强的技术团队或许是更好的选择，最少不是什么值得骄傲的事情。</p><h2 id="平台化的传说"><a href="#平台化的传说" class="headerlink" title="平台化的传说"></a>平台化的传说</h2><p>平台化算得上是“高大上”的代名词了，很多工程师挤破头就为了和“平台化”沾点边。然而和其他业务需求相比，平台化需求并没有本质上的区别。无论是平台化需求还是普通业务需求，它的价值都来自于客户价值。不同点如下：</p><ul><li><p>很多平台化需求的客户来自于技术团队，普通需求的客户来自于业务方。</p></li><li><p>产品经理不同。普通业务需求来自于产品经理，平台化需求的产品经理可能就是工程师自己。长期被产品经理“压迫”的工程师们，在平台化上终于找到“翻身农奴把歌唱”的感觉。</p></li><li><p>很多平台化的关注点是接入能力和可扩展性，而普通业务的关注点更多。</p></li></ul><p>归根结底，平台化就是一种普通需求。在实施平台化之前，一定要避免下面两个误区：</p><ul><li><p>平台化绝对不是诸如“统一”、“全面”之类形容词的堆砌。是否需要平台化，应该综合考虑：客户数量，为客户解决的问题，以及客户价值是否值得平台化的投入。</p></li><li><p>平台化不是你做平台，让客户来服务你。一些平台化设计者的规划设计里面，把大量的平台接入工作、脏活累活交给了客户，然后自己专注于所谓“最高大上”的功能。恰恰相反，平台化应该是客户什么都不做，所有的脏活累活都由平台方来做。本质上讲，平台化的价值来自于技术深度。真正体现技术深度的恰恰是设计者能够很轻松的把所有的脏活累活搞定。</p></li></ul><p>所以平台化的最佳实践是：投入最少的资源，解决最多的问题。平台解决一切，客户坐享其成。</p><h2 id="搞基础技术就一定很牛吗"><a href="#搞基础技术就一定很牛吗" class="headerlink" title="搞基础技术就一定很牛吗"></a>搞基础技术就一定很牛吗</h2><p>经常听到同学们表达对基础技术部同学的敬仰之情，而对搞业务技术的同学表现出很轻视，认为存储、消息队列、服务治理框架（比如美团点评内部使用的OCTO）、Hadoop等才能被称为真正的技术。事实并非如此，更基础的并不一定更高深。</p><p>比如下面这个流传很久的段子：越高级的语言就越没有技术含量。但真是这样吗，就拿Java和C来说，这是完全不同的两种语言，所需要的技能完全不同。C或许跟操作系统更加接近一点，和CPU、内存打交道的机会更多一点。但是为了用好Java，程序员在面向对象、设计模式、框架技术方面必须要非常精通。Java工程师转到C方向确实不容易，但作者也见过很多转到Java语言的C工程师水土不服。</p><p>基础技术和业务应用技术必然会有不同的关注点，没有高低之分。之所以产生这种误解，有两个原因：</p><ul><li><p>基础技术相对成熟，有比较完整的体系，这给人一个高大上的感觉。业务应用技术相对来说，由于每个团队使用的不一样，所以成熟度参差不齐，影响力没有那么大。</p></li><li><p>基础技术的门槛相对来说高一点，考虑到影响面，对可靠性、可用性等有比较高的最低要求。但是门槛高不代表技术含量高，另外成熟技术相对来说在创新方面会受到很大的约束。但是最先进的技术都来自活跃的创新。</p></li></ul><p>对比下来，业务技术和基础技术各有千秋。但真正的高手关注的是解决问题，所有的技术都是技能而已。</p><h2 id="可行性调研的那些坑"><a href="#可行性调研的那些坑" class="headerlink" title="可行性调研的那些坑"></a>可行性调研的那些坑</h2><p>工作中开展可行性调研时有发生。做可行性调研要避免如下情况：</p><ul><li><p>把可行性调研做成不可行性调研。这真的非常糟糕。不可行性的结论往往是：因为这样或者那样的原因，所以不可行。</p></li><li><p>避免“老鼠给猫挂铃铛”式的高风险可行性方案。“天下大事必作于细”，可行性调研一定要细致入微，避免粗枝大叶。</p></li><li><p>避免调研时间过长。如果发现调研进展进入到指数级复杂度，也就是每前进一步需要之前两倍的时间投入，就应该果断的停止调研。</p></li></ul><p>可行性调研的结论应该是收益与成本的折衷，格式一般如下：</p><ul><li><p>首先明确预期的结果，并按照高中低收益进行分级。</p></li><li><p>阐述达成每种预期结果需要采取的措施和方案。</p></li><li><p>给出实施各方案需要付出的成本。</p></li></ul><h2 id="工程师天生不善沟通吗"><a href="#工程师天生不善沟通吗" class="headerlink" title="工程师天生不善沟通吗"></a>工程师天生不善沟通吗</h2><p>实际工作中，沟通所导致的问题层出不穷。工程师有不少是比较内向的，总是被贴上“不善沟通”的标签。实际上，沟通能力是工程师最重要的能力之一，良好的沟通是高效工作学习的基础，也是通过学习可以掌握的。下面我按工程师的语言说说沟通方面的经验。</p><p>第一类常见的问题是沟通的可靠性。从可靠性的角度来讲，沟通分为TCP模式和UDP模式。TCP模式的形象表述是：我知道你知道。UDP模式的形象表述是：希望你知道。TCP模式当然比较可靠，不过成本比较高，UDP模式成本低，但是不可靠。在沟通可靠性方面，常见错误有如下两种：</p><ul><li><p>经常听到的这样的争论。一方说：“我已经告诉他了”，另一方说：“我不知道这个事情呀”。把UDP模式被当作TCP模式来使用容易产生扯皮。</p></li><li><p>过度沟通。有些同学对沟通的可靠性产生了过度焦虑，不断的重复讨论已有结论问题。把TCP模式当成UDP来使用，效率会比较低。</p></li></ul><p>第二类沟通问题是时效性问题。从时效性讲，沟通分为：同步模式和异步模式。同步沟通形象地说就是：你现在给我听好了。异步沟通的形象表述是：记得给我做好了。在沟通时效性方面，有如下两种常见错误：</p><ul><li><p>已经出现线上事故，紧急万分。大家你一言，我一语，感觉事故可能和某几个人有关，但是也不能完全确定，所以没有通知相关人员。最终，一个普通的事故变成了严重事故。对于紧急的事情，必须要同步沟通。</p></li><li><p>半夜三点你正在熟睡，或者周末正在逛街，接到一个电话：“现在有个需求，能否立刻帮忙做完。”这会非常令人郁闷，因为那并不是紧急的事情。不是所有的需求都需要立刻解决。</p></li></ul><p>有效沟通的一个重要原则是提前沟通。沟通本质是信息交流和处理，可以把被沟通对象形象地比喻成串行信息处理的CPU。提前沟通，意味着将处理请求尽早放入处理队列里面。下面的例子让很多工程师深恶痛绝：一个需求策划了1个月，产品设计了2周。当开发工程是第一次听说该需求的时候，发现开发的时间是2天。工程师据理力争，加班加点1周搞定。最后的结论是工程师非常不给力，不配合。就像工程师讨厌类似需求一样。要协调一个大项目，希望获得别人的配合，也需要尽早沟通。</p><p>有效沟通的另外一个重点是“不要跑题”。很多看起来很接近的问题，本质上是完全不同的问题。比如：一个会议的主题是“如何实施一个方案”，有人却可能提出“是否应该实施该方案”。 “如何实施”和“是否应该实施”是完全不同的两个问题，很多看起来相关的问题实际上跑题很远。“跑题”是导致无效沟通的重要原因。</p><p>良好沟通的奥秘在于能掌握TCP模式和UDP模式精髓，正确判断问题的紧急性，尽量提前沟通，避免跑题。</p><h2 id="带人之道"><a href="#带人之道" class="headerlink" title="带人之道"></a>带人之道</h2><p>有些初为导师的工程师由于担心毕业生的能力太弱，安排任务时候谆谆教诲，最后感觉还是有所顾虑，干脆自己写代码。同样的事情发生在很多刚刚管理小团队的工程师身上。最终的结果他们：写完所有的代码，让下属无代码可写。“ 事必躬亲”当然非常糟糕，最终的往往是团队的整体绩效不高，团队成员的成长很慢，而自己却很累。</p><p>古人说：“用人不疑，疑人不用。”这句话并非“放之四海而皆准”。在古代，受限于通信技术，反馈延迟显著，而且信息在传递过程中有大量噪音，变形严重。在这种情况下，如果根据短期内收集的少量变形的信息做快速决断，容易陷于草率。在公司里，这句话用于选人环节更为恰当，应该改为：录用不疑，疑人不录。</p><p>考虑到招聘成本，就算是在录用层面，有时候也无法做到。作为一个小团队的管理者，能够快速准确的获取团队成员的各种反馈信息，完全不需要“用人不疑，疑人不用”。用人的真正理论基础来自于“探索和利用”(Exploration and Exploitation )。不能因为下属能做什么就只让他做什么，更不能因为下属一次失败就不给机会。</p><p>根据经典的“探索和利用”(Exploration and Exploitation )理论，良好的用人方式应该如下：</p><ul><li><p>首选选择相信，在面临失败后，收缩信任度。</p></li><li><p>查找失败的原因，提供改进意见，提升下属的能力。</p></li><li><p>总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。</p></li></ul><h2 id="效率、效率、效率"><a href="#效率、效率、效率" class="headerlink" title="效率、效率、效率"></a>效率、效率、效率</h2><p>经常看到有些同学给自己的绩效评分是100分——满分，原因是在过去一段时间太辛苦了，但最终的绩效却一般般。天道酬勤不错，但是天道更酬巧。工程师们都学过数据结构，不同算法的时间复杂度的差距，仅仅通过更长的工作时间是难以弥补的。为了提升工作学习效率，我们需要注意以下几点：</p><ul><li><p>主要关注效率提升。很多时候，与效率提升所带来的收益相比，延长时间所带来的成果往往不值得一提。</p></li><li><p>要有清晰的结果导向思维。功劳和苦劳不是一回事。</p></li><li><p>做正确的事情，而不仅仅正确地做事情。这是一个被不断提起的话题，但是错误每天都上演。为了在规定的时间内完成一个大项目，总是要有所取舍。如果没有重点，均匀发力，容易事倍功半。如果“南辕北辙”，更是可悲可叹。</p></li></ul><h1 id="架构师能力模型"><a href="#架构师能力模型" class="headerlink" title="架构师能力模型"></a>架构师能力模型</h1><p>前面我们已经讲完了原则和一些困惑，那么工程师到底应该怎么提升自己呢？</p><p>成为优秀的架构师是大部分初中级工程师的阶段性目标。优秀的架构师往往具备七种核心能力：编程能力、调试能力、编译部署能力、性能优化能力、业务架构能力、在线运维能力、项目管理能力和规划能力。</p><p>这几种能力之间的关系大概如下图。编程能力、调试能力和编译部署能力属于最基础的能力。不能精通掌握这三种能力，很难在性能优化能力和业务架构能力方面有所成就。具备了一定的性能优化能力和业务架构能力之后，才能在线运维能力和项目管理能力方面表现优越。团队管理能力是最高能力，它对项目管理能力的依赖度更大。</p><h2 id="编程能力"><a href="#编程能力" class="headerlink" title="编程能力"></a>编程能力</h2><p>对工程师而言，编程是最基础的能力，必备技能。其本质是一个翻译能力，将业务需求翻译成机器能懂的语言。</p><p>提升编程能力的书籍有很多。精通面向对象和设计模式是高效编程的基础。初级工程师应该多写代码、多看代码。找高手做Code Review，也是提升编程水平的捷径。</p><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>程序代码是系统的静态形式，调试的目的是通过查看程序的运行时状态来验证和优化系统。本质上讲，工程师们通过不断调试可以持续强化其通过静态代码去预测运行状态的能力。所以调试能力也是工程师编程能力提升的关键手段。很早之前有个传说：“调试能力有多强，编程能力就有多强。”不过现在很多编辑器的功能很强大，调试能力的门槛已经大大降低。</p><p>调试能力是项目能否按时、高质量提交的关键。即使一个稍具复杂度的项目，大部分工程师也无法一次性准确无误的完成。大项目都是通过不断地调试进行优化和纠错的。所以调试能力是不可或缺的能力。</p><p>多写程序，解决Bug，多请教高手是提升调试能力的重要手段。</p><h2 id="编译部署能力"><a href="#编译部署能力" class="headerlink" title="编译部署能力"></a>编译部署能力</h2><p>编译并在线上部署运行程序是系统上线的最后一个环节。随着SOA架构的普及以及业务复杂度的增加，大部分系统只是一个完整业务的一个环节，因此，本地编译和运行并不能完全模拟系统在线运行。为了快速验证所编写程序的正确性，编译并在线上部署就成了必要环节。所以编译部署能力是一个必备技能。</p><p>让盘根错节的众多子系统运行起来是个不小的挑战。得益于SOA架构的普及以及大量编译、部署工具的发展，编译部署的门槛已经大大降低。基于应用层进行开发的公司，已经很少有“编译工程师”的角色了。但是对于初级工程师而言，编译部署仍然不是一个轻松的事情。</p><h2 id="性能优化能力"><a href="#性能优化能力" class="headerlink" title="性能优化能力"></a>性能优化能力</h2><p>衡量一个系统成功的一个重要指标是使用量。随着使用量的增加和业务复杂度的增加，大部分系统最终都会碰到性能问题。 性能优化能力是一个综合能力。因为：</p><ul><li><p>影响系统性能的因素众多，包括：数据结构、操作系统、虚拟机、CPU、存储、网络等。为了对系统性能进行调优，架构师需要掌握所有相关的技术。</p></li><li><p>精通性能优化意味着深刻理解可用性、可靠性、一致性、可维护性、可扩展性等的本质。</p></li><li><p>性能优化与业务强耦合，最终所采取的手段是往往折衷的结果。所以，性能优化要深谙妥协的艺术。</p></li></ul><p>可以说，性能优化能力是工程师们成长过程中各种技能开始融会贯通的一个标志。这方面可以参考之前的博客文章“<a href="https://tech.meituan.com/performance_tunning.html" title="常见性能优化策略的总结" target="_blank" rel="noopener">见性能优化策略的总结</a>”。市场上还有很多与性能优化相关的书籍，大家可以参考。多多阅读开源框架中关于性能优化方面的文档和代码也不失为好的提升手段。动手解决线上性能问题也是提升性能优化能力的关键。如果有机会，跟着高手学习，分析性能优化解决方案案例（我们技术博客之前也发表了很多这方面的<a href="https://tech.meituan.com/tag/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" title="文章" target="_blank" rel="noopener">文章</a>），也是快速提升性能优化能力的手段。</p><h2 id="在线运维能力"><a href="#在线运维能力" class="headerlink" title="在线运维能力"></a>在线运维能力</h2><p>如果说性能优化能力体现的是架构师的静态思考能力，在线运维能力考验的就是动态反应能力。残酷的现实是，无论程序多么完美，Bug永远存在。与此同时，职位越高、责任越大，很多架构师需要负责非常重要的在线系统。对于线上故障，如果不能提前预防以及快速解决，损失可能不堪设想，所以在线运维能力是优秀架构师的必备技能。</p><p>为了对线上故障进行快速处理，标准化的监控、上报、升级，以及基本应对机制当然很重要。通过所观察到的现象，快速定位、缓解以及解决相关症状也相当关键。这要求架构师对故障系统的业务、技术具备通盘解读能力。解决线上故障的架构师就好比一个在参加比赛F1的车手。赛车手必须要了解自身、赛车、对手、同伴、天气、场地等所有因素，快速决策，不断调整。架构师必须要了解所有技术细节、业务细节、处理规范、同伴等众多因素，快速决断，迅速调整。</p><p>在线运维本质上是一个强化学习的过程。很多能力都可以通过看书、查资料来完成，但在线运维能力往往需要大量的实践来提升。</p><h2 id="业务架构能力"><a href="#业务架构能力" class="headerlink" title="业务架构能力"></a>业务架构能力</h2><p>工程师抱怨产品经理的故事屡见不鲜，抱怨最多的主要原因来自于需求的频繁变更。需求变更主要有两个来源：第一个原因是市场改变或战略调整，第二个原因是伪需求。对于第一个原因，无论是工程师还是产品经理，都只能无奈的接受。优秀的架构师应该具备减少第二种原因所导致的需求变更的概率。</p><h3 id="伪需求的产生有两个原因："><a href="#伪需求的产生有两个原因：" class="headerlink" title="伪需求的产生有两个原因："></a>伪需求的产生有两个原因：</h3><ul><li><p>第一个原因是需求传递变形。从信息论的角度来讲，任何沟通都是一个编码和解码的过程。典型的需求从需求方到产品经理，最终到开发工程师，最少需要经历三次编码和解码过程。而信息的每一次传递都存在一些损失并带来一些噪音，这导致有些时候开发出来的产品完全对不上需求。此外，需求方和产品经理在需求可行性、系统可靠性，开发成本控制方面的把控比较弱，也会导致需求变形。</p></li><li><p>第二个原因就是需求方完全没有想好自己的需求。</p></li></ul><p>优秀的架构师应该具备辨别真伪需求的能力。应该花时间去了解客户的真实业务场景，具备较强的业务抽象能力，洞悉客户的真实需求。系统的真正实施方是工程师，在明确客户真实需求后，高明的架构师应该具备准确判断项目对可行性、可靠性、可用性等方面的要求，并能具备成本意识。最后，由于需求与在线系统的紧耦合关系，掌握在线系统的各种细节也是成功的业务架构的关键。随着级别的提升，工程师所面对的需求会越来越抽象。承接抽象需求，提供抽象架构是架构师走向卓越的必经之途。</p><p>市场上有一些关于如何成为架构师的书，大家可以参考。但是架构能力的提升，实践可能是更重要的方式。业务架构师应该关注客户的痛点而不是PRD文档，应该深入关注真实业务。掌握现存系统的大量技术和业务细节也是业务架构师的必备知识。</p><h2 id="项目管理能力"><a href="#项目管理能力" class="headerlink" title="项目管理能力"></a>项目管理能力</h2><p>作为工业时代的产物，分工合作融入在互联网项目基因里面。架构师也需要负责几个重大项目才能给自己正名。以架构师角色去管理项目，业务架构能力当然是必备技能。此外，人员管理和成本控制意识也非常重要。</p><p>项目管理还意味着要有一个大心脏。重大项目涉及技术攻关、人员变动、需求更改等众多可变因素。面临各种变化，还要在确保目标顺利达成，需要较强的抗压能力。</p><p>人员管理需要注意的方面包括：知人善用，优化关系，简化沟通，坚持真理。</p><ul><li><p>知人善用意味着架构师需要了解每个参与者的硬技能和软素质。同时，关注团队成员在项目过程中的表现，按能分配。</p></li><li><p>优化关系意味着管理团队的情绪，毕竟项目的核心是团队，有士气的团队才能高效达成目标。</p></li><li><p>简化沟通意味着快速决策，该妥协的时候妥协，权责分明。</p></li><li><p>坚持真理意味着顶住压力，在原则性问题上绝不退步。</p></li></ul><p>成本控制意味着对项目进行精细化管理，需要遵循如下几个原则：</p><ul><li><p>以终为始、确定里程碑。为了达成目标，所有的计划必须以终为始来制定。将大项目分解成几个小阶段，控制每个阶段的里程碑可以大大降低项目失败的风险。</p></li><li><p>把控关键路径和关键项目。按照关键路径管理理论（CPM）的要求，架构师需要确定每个子项目的关键路径，确定其最早和最晚启动时间。同时，架构师需要关注那些可能会导致项目整体延期的关键节点，并集中力量攻破。</p></li><li><p>掌控团队成员的张弛度。大项目持续时间会比较长，也包含不同工种。项目实施是一个不断变化的动态过程，在这个过程中不是整个周期都很紧张，不是所有的工种都一样忙。优秀的架构师必须要具备精细阅读整体项目以及快速反应和实时调整的能力。这不仅仅可以大大降低项目成本，还可以提高产出质量和团队满意度。总体来说，“前紧后松”是项目管理的一个重要原则。</p></li></ul><p>项目管理方面的书籍很多。但是，提高业务架构能力同样重要。积极参与大项目并观察别人管理项目的方式也是非常重要的提升手段。</p><h2 id="团队管理能力"><a href="#团队管理能力" class="headerlink" title="团队管理能力"></a>团队管理能力</h2><p>不想做CTO的工程师不是一个好的架构师。走向技术管理应该是工程师的一个主流职业规划。团队管理的一个核心能力就是规划能力，这包括项目规划和人员规划。良好的规划需要遵循如下原则：</p><ul><li><p>规划是利益的博弈。良好的规划上面对得起老板，中间对得起自己，下面对得起团队。在三者利益者寻找平衡点，实现多方共赢考验着管理者的智慧和精细拿捏的能力。</p></li><li><p>任何规划都比没有规划好。没有规划的团队就是没头的苍蝇，不符合所有人的利益。</p></li><li><p>规划不是本本主义。市场在变，团队在变，规划也不应该一成不变。</p></li><li><p>客户至上的是项目规划的出发点。</p></li><li><p>就人员规划而言，规划需要考量团队成员的能力、绩效、成长等多方面的因素。</p></li></ul><p>市场上有很多规划管理方面的书籍，值得阅读。最优化理论虽然是技术书籍，但它是规划的理论基础，所以不妨多看看翻阅一下。从自我规划开始，多多学习别人的规划也是规划能力提升的重要手段。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为受邀去做一个关于“一边工作，一边学习”的分享，作者花了一段时间去思考和汇总学习方法论，接着每天不断地采集谣言并尝试解惑，再根据个人经验绘制出优秀架构师的能力模型，最后汇集成文。</p><p>文章系统性地阐述了学习原则、分析了常见困惑，并制定明确学习目标，期望对工程师们的工作学习有所帮助。需要申明的是，文章内容挂一漏万，所谓的架构师能力模型也是作者的个人观点。欢迎大家在评论中分享自己在学习成长方面的心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者： 刘丁 From 美团技术团队&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。&lt;/p&gt;
&lt;p&gt;如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="开发 学习 提升 编程 工程师" scheme="http://www.icrazyman.cn/tags/%E5%BC%80%E5%8F%91-%E5%AD%A6%E4%B9%A0-%E6%8F%90%E5%8D%87-%E7%BC%96%E7%A8%8B-%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
  </entry>
  
</feed>
