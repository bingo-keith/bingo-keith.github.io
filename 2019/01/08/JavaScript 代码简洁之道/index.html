<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">










  <meta name="google-site-verification" content="true">







  <meta name="baidu-site-verification" content="true">











<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。 本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。 我们将从几个方面展开讨论：  变量  函数  对象和数据结构  类  SOLID  测试  异步  错误处理  代码风格  注释">
<meta name="keywords" content="JavaScript 代码 风格 编码">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 代码简洁之道">
<meta property="og:url" content="http://www.icrazyman.cn/2019/01/08/JavaScript 代码简洁之道/index.html">
<meta property="og:site_name" content="科瑞兹曼的博客">
<meta property="og:description" content="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。 本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。 我们将从几个方面展开讨论：  变量  函数  对象和数据结构  类  SOLID  测试  异步  错误处理  代码风格  注释">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-01-08T14:58:59.151Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 代码简洁之道">
<meta name="twitter:description" content="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。 本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。 我们将从几个方面展开讨论：  变量  函数  对象和数据结构  类  SOLID  测试  异步  错误处理  代码风格  注释">



  <link rel="alternate" href="/atom.xml" title="科瑞兹曼的博客" type="application/atom+xml">




  <link rel="canonical" href="http://www.icrazyman.cn/2019/01/08/JavaScript 代码简洁之道/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript 代码简洁之道 | 科瑞兹曼的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">科瑞兹曼的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注于前端开发技术</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
    
  
  

  

  <article class="post post-type-normal true" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.icrazyman.cn/2019/01/08/JavaScript 代码简洁之道/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="科瑞兹曼">
      <meta itemprop="description" content="交流、学习、提升">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科瑞兹曼的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript 代码简洁之道

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-08 21:54:29 / 修改时间：22:58:59" itemprop="dateCreated datePublished" datetime="2019-01-08T21:54:29+08:00">2019-01-08</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/01/08/JavaScript 代码简洁之道/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/08/JavaScript 代码简洁之道/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/01/08/JavaScript 代码简洁之道/" class="leancloud_visitors" data-flag-title="JavaScript 代码简洁之道">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。"><a href="#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。" class="headerlink" title="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。"></a>测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</h1><p>代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。</p>
<p>本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。</p>
<p>我们将从几个方面展开讨论：</p>
<ol>
<li><p>变量</p>
</li>
<li><p>函数</p>
</li>
<li><p>对象和数据结构</p>
</li>
<li><p>类</p>
</li>
<li><p>SOLID</p>
</li>
<li><p>测试</p>
</li>
<li><p>异步</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>代码风格</p>
</li>
<li><p>注释</p>
</li>
</ol>
<a id="more"></a>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="用有意义且常用的单词命名变量"><a href="#用有意义且常用的单词命名变量" class="headerlink" title="用有意义且常用的单词命名变量"></a>用有意义且常用的单词命名变量</h2><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad:"></a>Bad:</h3><p><code>const yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;);</code></p>
<h3 id="Good"><a href="#Good" class="headerlink" title="Good:"></a>Good:</h3><p><code>const currentDate = moment().format(&#39;YYYY/MM/DD&#39;);</code></p>
<h2 id="保持统一"><a href="#保持统一" class="headerlink" title="保持统一"></a>保持统一</h2><p>可能同一个项目对于获取用户信息，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 codelf 搜索，看别人是怎么取名的。</p>
<h3 id="Bad-1"><a href="#Bad-1" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  getUserInfo();
  getClientData();
  getCustomerRecord();
</code></pre><h3 id="Good-1"><a href="#Good-1" class="headerlink" title="Good:"></a>Good:</h3><p><code>getUser()</code></p>
<h2 id="每个常量都该命名"><a href="#每个常量都该命名" class="headerlink" title="每个常量都该命名"></a>每个常量都该命名</h2><p>可以用 buddy.js 或者 ESLint 检测代码中未命名的常量。</p>
<h3 id="Bad-2"><a href="#Bad-2" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 三个月之后你还能知道 86400000 是什么吗?
setTimeout(blastOff, 86400000);
</code></pre><h3 id="Good-2"><a href="#Good-2" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const MILLISECOND_IN_A_DAY = 86400000;
setTimeout(blastOff, MILLISECOND_IN_A_DAY);
</code></pre><h2 id="可描述"><a href="#可描述" class="headerlink" title="可描述"></a>可描述</h2><p>通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。</p>
<h3 id="Bad-3"><a href="#Bad-3" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;
const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
saveCityZipCode(ADDRESS.match(CITY_ZIP_CODE_REGEX)[1],
                ADDRESS.match(CITY_ZIP_CODE_REGEX)[2]);
</code></pre><h3 id="Good-3"><a href="#Good-3" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const ADDRESS = &#39;One Infinite Loop, Cupertino 95014&#39;;
const CITY_ZIP_CODE_REGEX = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = ADDRESS.match(CITY_ZIP_CODE_REGEX) || [];
saveCityZipCode(city, zipCode);
</code></pre><h2 id="直接了当"><a href="#直接了当" class="headerlink" title="直接了当"></a>直接了当</h2><h3 id="Bad-4"><a href="#Bad-4" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const l = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];
locations.forEach((l) =&gt; {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  // 需要看其他代码才能确定 &#39;l&#39; 是干什么的。
  dispatch(l);
});
</code></pre><h3 id="Good-4"><a href="#Good-4" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const locations = [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];
locations.forEach((location) =&gt; {
  doStuff();
  doSomeOtherStuff();
  // ...
  // ...
  // ...
  dispatch(location);
});
</code></pre><h2 id="避免无意义的前缀"><a href="#避免无意义的前缀" class="headerlink" title="避免无意义的前缀"></a>避免无意义的前缀</h2><p>如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</p>
<h3 id="Bad-5"><a href="#Bad-5" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>  const car = {
    carMake: &#39;Honda&#39;,
    carModel: &#39;Accord&#39;,
    carColor: &#39;Blue&#39;
  };

  function paintCar(car) {
    car.carColor = &#39;Red&#39;;
  }
</code></pre><h3 id="Good-5"><a href="#Good-5" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const car = {
  make: &#39;Honda&#39;,
  model: &#39;Accord&#39;,
  color: &#39;Blue&#39;
};

function paintCar(car) {
  car.color = &#39;Red&#39;;
}
</code></pre><h2 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h2><h3 id="Bad-6"><a href="#Bad-6" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMicrobrewery(name) {
  const breweryName = name || &#39;Hipster Brew Co.&#39;;
  // ...
}
</code></pre><h3 id="Good-6"><a href="#Good-6" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMicrobrewery(name = &#39;Hipster Brew Co.&#39;) {
  // ...
}
</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数越少越好"><a href="#参数越少越好" class="headerlink" title="参数越少越好"></a>参数越少越好</h2><p>如果参数超过两个，使用 ES2015/ES6 的解构语法，不用考虑参数的顺序。（注：不要超过3个参数，如果确实需要3个以上的参数，用对象包起来）</p>
<h3 id="Bad-7"><a href="#Bad-7" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createMenu(title, body, buttonText, cancellable) {
  // ...
}
</code></pre><h3 id="Good-7"><a href="#Good-7" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createMenu({ title, body, buttonText, cancellable }) {
  // ...
}

createMenu({
  title: &#39;Foo&#39;,
  body: &#39;Bar&#39;,
  buttonText: &#39;Baz&#39;,
  cancellable: true
});
</code></pre><h2 id="只做一件事情"><a href="#只做一件事情" class="headerlink" title="只做一件事情"></a>只做一件事情</h2><p>这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。</p>
<h3 id="Bad-8"><a href="#Bad-8" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function emailClients(clients) {
  clients.forEach((client) =&gt; {
    const clientRecord = database.lookup(client);
    if (clientRecord.isActive()) {
      email(client);
    }
  });
}
</code></pre><h3 id="Good-8"><a href="#Good-8" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function emailActiveClients(clients) {
  clients
    .filter(isActiveClient)
    .forEach(email);
}
function isActiveClient(client) {
  const clientRecord = database.lookup(client);    
  return clientRecord.isActive();
}
</code></pre><h2 id="顾名思义"><a href="#顾名思义" class="headerlink" title="顾名思义"></a>顾名思义</h2><p>看函数名就应该知道它是干啥的。(注：其实就是语义化命名，代码是给人看的)</p>
<h3 id="Bad-9"><a href="#Bad-9" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function addToDate(date, month) {
  // ...
}

const date = new Date();

// 很难知道是把什么加到日期中
addToDate(date, 1);
</code></pre><h3 id="Good-9"><a href="#Good-9" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function addMonthToDate(month, date) {
  // ...
}

const date = new Date();
addMonthToDate(1, date);
</code></pre><h2 id="只需要一层抽象层"><a href="#只需要一层抽象层" class="headerlink" title="只需要一层抽象层"></a>只需要一层抽象层</h2><p>如果函数嵌套过多会导致很难复用以及测试。</p>
<h3 id="Bad-10"><a href="#Bad-10" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function parseBetterJSAlternative(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(&#39; &#39;);
  const tokens = [];
  REGEXES.forEach((REGEX) =&gt; {
    statements.forEach((statement) =&gt; {
      // ...
    });
  });

  const ast = [];
  tokens.forEach((token) =&gt; {
    // lex...
  });

  ast.forEach((node) =&gt; {
    // parse...
  });
}
</code></pre><h3 id="Good-10"><a href="#Good-10" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function parseBetterJSAlternative(code) {
  const tokens = tokenize(code);
  const ast = lexer(tokens);
  ast.forEach((node) =&gt; {
    // parse...
  });
}

function tokenize(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(&#39; &#39;);
  const tokens = [];
  REGEXES.forEach((REGEX) =&gt; {
    statements.forEach((statement) =&gt; {
      tokens.push( /* ... */ );
    });
  });

  return tokens;
}

function lexer(tokens) {
  const ast = [];
  tokens.forEach((token) =&gt; {
    ast.push( /* ... */ );
  });

  return ast;
}
</code></pre><h2 id="删除重复代码"><a href="#删除重复代码" class="headerlink" title="删除重复代码"></a>删除重复代码</h2><p>很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。</p>
<p>要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 SOLID 原则（SOLID 是什么？稍后会详细介绍）。</p>
<h3 id="Bad-11"><a href="#Bad-11" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function showDeveloperList(developers) {
  developers.forEach((developer) =&gt; {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();
    const data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

function showManagerList(managers) {
  managers.forEach((manager) =&gt; {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();
    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}
</code></pre><h3 id="Good-11"><a href="#Good-11" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function showEmployeeList(employees) {
  employees.forEach(employee =&gt; {
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();
    const data = {
      expectedSalary,
      experience,
    };

    switch(employee.type) {
      case &#39;develop&#39;:
        data.githubLink = employee.getGithubLink();
        break
      case &#39;manager&#39;:
        data.portfolio = employee.getMBAProjects();
        break
    }
    render(data);
  })
}
</code></pre><h2 id="对象设置默认属性"><a href="#对象设置默认属性" class="headerlink" title="对象设置默认属性"></a>对象设置默认属性</h2><h3 id="Bad-12"><a href="#Bad-12" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const menuConfig = {
  title: null,
  body: &#39;Bar&#39;,
  buttonText: null,
  cancellable: true
};

function createMenu(config) {
  config.title = config.title || &#39;Foo&#39;;
  config.body = config.body || &#39;Bar&#39;;
  config.buttonText = config.buttonText || &#39;Baz&#39;;
  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;
}

createMenu(menuConfig);
</code></pre><h3 id="Good-12"><a href="#Good-12" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const menuConfig = {
  title: &#39;Order&#39;,
  // &#39;body&#39; key 缺失
  buttonText: &#39;Send&#39;,
  cancellable: true
};

function createMenu(config) {
  config = Object.assign({
    title: &#39;Foo&#39;,
    body: &#39;Bar&#39;,
    buttonText: &#39;Baz&#39;,
    cancellable: true
  }, config);

  // config 就变成了: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}
  // ...
}

createMenu(menuConfig);
</code></pre><h2 id="不要传-flag-参数"><a href="#不要传-flag-参数" class="headerlink" title="不要传 flag 参数"></a>不要传 flag 参数</h2><p>通过 flag 的 true 或 false，来判断执行逻辑，违反了一个函数干一件事的原则。(这个持保留意见，只能说尽量不要把分支判断放在函数里面)</p>
<h3 id="Bad-13"><a href="#Bad-13" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}
</code></pre><h3 id="Good-13"><a href="#Good-13" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function createFile(name) {
  fs.create(name);
}
function createFileTemplate(name) {
  createFile(`./temp/${name}`)
}
</code></pre><h2 id="避免副作用（第一部分）"><a href="#避免副作用（第一部分）" class="headerlink" title="避免副作用（第一部分）"></a>避免副作用（第一部分）</h2><p>函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。</p>
<p>当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。</p>
<p>副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。</p>
<p>（注：这就是纯函数的作用，同样的输入，返回的一定是同样的输入，这样对于结果是可预料的，不会出现意料之外甚至很难修复的问题）</p>
<h3 id="Bad-14"><a href="#Bad-14" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 全局变量被一个函数引用
// 现在这个变量从字符串变成了数组，如果有其他的函数引用，会发生无法预见的错误。
var name = &#39;Ryan McDermott&#39;;

function splitIntoFirstAndLastName() {
  name = name.split(&#39; &#39;);
}

splitIntoFirstAndLastName();

console.log(name); // [&#39;Ryan&#39;, &#39;McDermott&#39;];
</code></pre><h3 id="Good-14"><a href="#Good-14" class="headerlink" title="Good:"></a>Good:</h3><pre><code>var name = &#39;Ryan McDermott&#39;;
var newName = splitIntoFirstAndLastName(name)

function splitIntoFirstAndLastName(name) {
  return name.split(&#39; &#39;);
}

console.log(name); // &#39;Ryan McDermott&#39;;
console.log(newName); // [&#39;Ryan&#39;, &#39;McDermott&#39;];
</code></pre><h2 id="避免副作用（第二部分）"><a href="#避免副作用（第二部分）" class="headerlink" title="避免副作用（第二部分）"></a>避免副作用（第二部分）</h2><p>在 JavaScript 中，基本类型通过赋值传递，对象和数组通过引用传递。以引用传递为例：</p>
<p>假如我们写一个购物车，通过 addItemToCart() 方法添加商品到购物车，修改 购物车数组。此时调用 purchase() 方法购买，由于引用传递，获取的 购物车数组 正好是最新的数据。</p>
<p>看起来没问题对不对？</p>
<p>如果当用户点击购买时，网络出现故障， purchase() 方法一直在重复调用，与此同时用户又添加了新的商品，这时网络又恢复了。那么 purchase() 方法获取到 购物车数组 就是错误的。</p>
<p>为了避免这种问题，我们需要在每次新增商品时，克隆 购物车数组 并返回新的数组。</p>
<h3 id="Bad-15"><a href="#Bad-15" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {
  cart.push({ item, date: Date.now() });
};
</code></pre><h3 id="Good-15"><a href="#Good-15" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const addItemToCart = (cart, item) =&gt; {
  return [...cart, {item, date: Date.now()}]
};
</code></pre><h2 id="不要写全局方法"><a href="#不要写全局方法" class="headerlink" title="不要写全局方法"></a>不要写全局方法</h2><p>在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 Array.prototype 上新增一个 diff 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 diff 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 Array 进行扩展。</p>
<h3 id="Bad-16"><a href="#Bad-16" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>Array.prototype.diff = function diff(comparisonArray) {
  const hash = new Set(comparisonArray);
  return this.filter(elem =&gt; !hash.has(elem));
};
</code></pre><h3 id="Good-16"><a href="#Good-16" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class SuperArray extends Array {
  diff(comparisonArray) {
    const hash = new Set(comparisonArray);
    return this.filter(elem =&gt; !hash.has(elem));        
  }
}
</code></pre><h2 id="比起命令式我更喜欢函数式编程"><a href="#比起命令式我更喜欢函数式编程" class="headerlink" title="比起命令式我更喜欢函数式编程"></a>比起命令式我更喜欢函数式编程</h2><p>函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。</p>
<h3 id="Bad-17"><a href="#Bad-17" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const programmerOutput = [
  {
    name: &#39;Uncle Bobby&#39;,
    linesOfCode: 500
  }, {
    name: &#39;Suzie Q&#39;,
    linesOfCode: 1500
  }, {
    name: &#39;Jimmy Gosling&#39;,
    linesOfCode: 150
  }, {
    name: &#39;Gracie Hopper&#39;,
    linesOfCode: 1000
  }
];

let totalOutput = 0;

for (let i = 0; i &lt; programmerOutput.length; i++) {
  totalOutput += programmerOutput[i].linesOfCode;
</code></pre><h3 id="Good-17"><a href="#Good-17" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const programmerOutput = [
  {
    name: &#39;Uncle Bobby&#39;,
    linesOfCode: 500
  }, {
    name: &#39;Suzie Q&#39;,
    linesOfCode: 1500
  }, {
    name: &#39;Jimmy Gosling&#39;,
    linesOfCode: 150
  }, {
    name: &#39;Gracie Hopper&#39;,
    linesOfCode: 1000
  }
];
let totalOutput = programmerOutput
  .map(output =&gt; output.linesOfCode)
  .reduce((totalLines, lines) =&gt; totalLines + lines, 0)
</code></pre><h2 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h2><h2 id="Bad-18"><a href="#Bad-18" class="headerlink" title="Bad:"></a>Bad:</h2><pre><code>if (fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) {
  // ...
}
</code></pre><h2 id="Good-18"><a href="#Good-18" class="headerlink" title="Good:"></a>Good:</h2><pre><code>// 持保留意见
function shouldShowSpinner(fsm, listNode) {
  return fsm.state === &#39;fetching&#39; &amp;&amp; isEmpty(listNode);
}

if (shouldShowSpinner(fsmInstance, listNodeInstance)) {
  // ...
}
</code></pre><h2 id="尽量别用“非”条件句"><a href="#尽量别用“非”条件句" class="headerlink" title="尽量别用“非”条件句"></a>尽量别用“非”条件句</h2><h3 id="Bad-19"><a href="#Bad-19" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function isDOMNodeNotPresent(node) {
  // ...
}

if (!isDOMNodeNotPresent(node)) {
  // ...
}
</code></pre><h3 id="Good-19"><a href="#Good-19" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function isDOMNodePresent(node) {
  // ...
}

if (isDOMNodePresent(node)) {
  // ...
}
</code></pre><h2 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h2><p>Q：不用条件语句写代码是不可能的。</p>
<p>A：绝大多数场景可以用多态替代。</p>
<p>Q：用多态可行，但为什么就不能用条件语句了呢？</p>
<p>A：为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则。</p>
<h3 id="Bad-20"><a href="#Bad-20" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Airplane {
  // ...

  // 获取巡航高度
  getCruisingAltitude() {
    switch (this.type) {
      case &#39;777&#39;:
        return this.getMaxAltitude() - this.getPassengerCount();
      case &#39;Air Force One&#39;:
        return this.getMaxAltitude();
      case &#39;Cessna&#39;:
        return this.getMaxAltitude() - this.getFuelExpenditure();
    }
  }
}
</code></pre><h3 id="Good-20"><a href="#Good-20" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Airplane {
  // ...
}
// 波音777
class Boeing777 extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getPassengerCount();
  }
}
// 空军一号
class AirForceOne extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude();
  }
}
// 赛纳斯飞机
class Cessna extends Airplane {
  // ...
  getCruisingAltitude() {
    return this.getMaxAltitude() - this.getFuelExpenditure();
  }
}

// 利用对象使用分支判断
var Airplane = {
    &#39;777&#39;: function() {
        return this.getMaxAltitude() - this.getPassengerCount();
    },
    &#39;Air Force One&#39;: function() {
        return this.getMaxAltitude();
    },
    &#39;Cessna&#39;: function() {
        return this.getMaxAltitude() - this.getFuelExpenditure();
    },
}
</code></pre><h2 id="避免类型检查（第一部分）"><a href="#避免类型检查（第一部分）" class="headerlink" title="避免类型检查（第一部分）"></a>避免类型检查（第一部分）</h2><p>JavaScript 是无类型的，意味着你可以传任意类型参数，这种自由度很容易让人困扰，不自觉的就会去检查类型。仔细想想是你真的需要检查类型还是你的 API 设计有问题？（注：持保留意见）</p>
<h3 id="Bad-21"><a href="#Bad-21" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function travelToTexas(vehicle) {
  if (vehicle instanceof Bicycle) {
    vehicle.pedal(this.currentLocation, new Location(&#39;texas&#39;));
  } else if (vehicle instanceof Car) {
    vehicle.drive(this.currentLocation, new Location(&#39;texas&#39;));
  }
}
</code></pre><h3 id="Good-21"><a href="#Good-21" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function travelToTexas(vehicle) {
  vehicle.move(this.currentLocation, new Location(&#39;texas&#39;));
}
</code></pre><h2 id="避免类型检查（第二部分）"><a href="#避免类型检查（第二部分）" class="headerlink" title="避免类型检查（第二部分）"></a>避免类型检查（第二部分）</h2><p>如果你需要做静态类型检查，比如字符串、整数等，推荐使用 TypeScript，不然你的代码会变得又臭又长。</p>
<pre><code class="Bad:">
function combine(val1, val2) {
  if (typeof val1 === &#39;number&#39; &amp;&amp; typeof val2 === &#39;number&#39; ||
      typeof val1 === &#39;string&#39; &amp;&amp; typeof val2 === &#39;string&#39;) {
    return val1 + val2;
  }

  throw new Error(&#39;Must be of type String or Number&#39;);
}
</code></pre>
<h3 id="Good-22"><a href="#Good-22" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(val1, val2) {
  return val1 + val2;
}
</code></pre><h2 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h2><p>现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间，想知道现代浏览器优化了哪些内容，请点这里。（注：持保留意见，低版本的浏览器没有做该优化，虽然性能提升不大，但这是一个好的编码习惯）</p>
<h3 id="Bad-22"><a href="#Bad-22" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 在老的浏览器中，由于 `list.length` 没有做缓存，每次迭代都会去计算，造成不必要开销。
// 现代浏览器已对此做了优化。
for (let i = 0, len = list.length; i &lt; len; i++) {
  // ...
}
</code></pre><h3 id="Good-23"><a href="#Good-23" class="headerlink" title="Good:"></a>Good:</h3><pre><code>for (let i = 0; i &lt; list.length; i++) {
  // ...
}
</code></pre><h2 id="删除弃用代码"><a href="#删除弃用代码" class="headerlink" title="删除弃用代码"></a>删除弃用代码</h2><p>很多时候有些代码已经没有用了，但担心以后会用，舍不得删。</p>
<p>如果你忘了这件事，这些代码就永远存在那里了。</p>
<p>放心删吧，你可以在代码库历史版本中找他它。</p>
<p>（持保留意见，因为保留部分注释的重要代码是以防出现问题可以直接线上恢复代码而不用上紧急版本）</p>
<h3 id="Bad-23"><a href="#Bad-23" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function oldRequestModule(url) {
  // ...
}

function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);
</code></pre><h3 id="Good-24"><a href="#Good-24" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker(&#39;apples&#39;, req, &#39;www.inventory-awesome.io&#39;);
</code></pre><h1 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h1><h2 id="用-get、set-方法操作数据"><a href="#用-get、set-方法操作数据" class="headerlink" title="用 get、set 方法操作数据"></a>用 get、set 方法操作数据</h2><p>这样做可以带来很多好处，比如在操作数据时打日志，方便跟踪错误；在 set 的时候很容易对数据进行校验…</p>
<h3 id="Bad-24"><a href="#Bad-24" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function makeBankAccount() {
  // ...

  return {
    balance: 0,
    // ...
  };
}

const account = makeBankAccount();
account.balance = 100;
</code></pre><h3 id="Good-25"><a href="#Good-25" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeBankAccount() {
  // 私有变量
  let balance = 0;

  function getBalance() {
    return balance;
  }

  function setBalance(amount) {
    // ... 在更新 balance 前，对 amount 进行校验
    balance = amount;
  }

  return {
    // ...
    getBalance,
    setBalance,
  };
}

const account = makeBankAccount();
account.setBalance(100);
</code></pre><h2 id="使用私有变量"><a href="#使用私有变量" class="headerlink" title="使用私有变量"></a>使用私有变量</h2><p>可以用闭包来创建私有变量</p>
<h3 id="Bad-25"><a href="#Bad-25" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const Employee = function(name) {
  this.name = name;
};

Employee.prototype.getName = function getName() {
  return this.name;
};

const employee = new Employee(&#39;John Doe&#39;);
console.log(`Employee name: ${employee.getName()}`); 
// Employee name: John Doe
delete employee.name;
console.log(`Employee name: ${employee.getName()}`);
 // Employee name: undefined
</code></pre><h3 id="Good-26"><a href="#Good-26" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function makeEmployee(name) {
  return {
    getName() {
      return name;
    },
  };
}

const employee = makeEmployee(&#39;John Doe&#39;);
console.log(`Employee name: ${employee.getName()}`); 
// Employee name: John Doe
delete employee.name;
console.log(`Employee name: ${employee.getName()}`); 
// Employee name: John Doe
</code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="使用-class"><a href="#使用-class" class="headerlink" title="使用 class"></a>使用 class</h2><p>在 ES2015/ES6 之前，没有类的语法，只能用构造函数的方式模拟类，可读性非常差。</p>
<h3 id="Bad-26"><a href="#Bad-26" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 动物
const Animal = function(age) {
  if (!(this instanceof Animal)) {
    throw new Error(&#39;Instantiate Animal with `new`&#39;);
  }

  this.age = age;
};

Animal.prototype.move = function move() {};

// 哺乳动物
const Mammal = function(age, furColor) {
  if (!(this instanceof Mammal)) {
    throw new Error(&#39;Instantiate Mammal with `new`&#39;);
  }

  Animal.call(this, age);
  this.furColor = furColor;
};

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = function liveBirth() {};

// 人类
const Human = function(age, furColor, languageSpoken) {
  if (!(this instanceof Human)) {
    throw new Error(&#39;Instantiate Human with `new`&#39;);
  }

  Mammal.call(this, age, furColor);
  this.languageSpoken = languageSpoken;
};

Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = function speak() {};
</code></pre><h3 id="Good-27"><a href="#Good-27" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 动物
class Animal {
  constructor(age) {
    this.age = age
  };
  move() {};
}

// 哺乳动物
class Mammal extends Animal{
  constructor(age, furColor) {
    super(age);
    this.furColor = furColor;
  };
  liveBirth() {};
}

// 人类
class Human extends Mammal{
  constructor(age, furColor, languageSpoken) {
    super(age, furColor);
    this.languageSpoken = languageSpoken;
  };
  speak() {};
</code></pre><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>这种模式相当有用，可以在很多库中发现它的身影，比如 jQuery、Lodash 等。它让你的代码简洁优雅。实现起来也非常简单，在类的方法最后返回 this 可以了。</p>
<h3 id="Bad-27"><a href="#Bad-27" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
  }

  setModel(model) {
    this.model = model;
  }

  setColor(color) {
    this.color = color;
  }

  save() {
    console.log(this.make, this.model, this.color);
  }
}

const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;);
car.setColor(&#39;pink&#39;);
car.save();
</code></pre><h3 id="Good-28"><a href="#Good-28" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
    return this;
  }

  setModel(model) {
    this.model = model;
    return this;
  }

  setColor(color) {
    this.color = color;
    return this;
  }

  save() {
    console.log(this.make, this.model, this.color);
    return this;
  }
}

const car = new Car(&#39;Ford&#39;,&#39;F-150&#39;,&#39;red&#39;)
  .setColor(&#39;pink&#39;);
  .save();
</code></pre><h2 id="不要滥用继承"><a href="#不要滥用继承" class="headerlink" title="不要滥用继承"></a>不要滥用继承</h2><p>很多时候继承被滥用，导致可读性很差，要搞清楚两个类之间的关系，继承表达的一个属于关系，而不是包含关系，比如 Human-&gt;Animal vs. User-&gt;UserDetails</p>
<h3 id="Bad-28"><a href="#Bad-28" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // ...
}

// TaxData（税收信息）并不是属于 Employee（雇员），而是包含关系。
class EmployeeTaxData extends Employee {
  constructor(ssn, salary) {
    super();
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}
</code></pre><h3 id="Good-29"><a href="#Good-29" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class EmployeeTaxData {
  constructor(ssn, salary) {
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}

class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  setTaxData(ssn, salary) {
    this.taxData = new EmployeeTaxData(ssn, salary);
  }
  // ...
}
</code></pre><h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。</p>
<h2 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 The Single Responsibility Principle"></a>单一功能原则 The Single Responsibility Principle</h2><p>如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p>
<h3 id="Bad-29"><a href="#Bad-29" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
</code></pre><h3 id="Good-30"><a href="#Good-30" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class UserAuth {
  constructor(user) {
    this.user = user;
  }
  verifyCredentials() {
    // ...
  }
}

class UserSetting {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(this.user);
  }
  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
</code></pre><h2 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 The Open Closed Principle"></a>开闭原则 The Open Closed Principle</h2><p>“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。</p>
<h3 id="Bad-30"><a href="#Bad-30" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#39;ajaxAdapter&#39;;
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#39;nodeAdapter&#39;;
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === &#39;ajaxAdapter&#39;) {
      return makeAjaxCall(url).then((response) =&gt; {
        // 传递 response 并 return
      });
    } else if (this.adapter.name === &#39;httpNodeAdapter&#39;) {
      return makeHttpCall(url).then((response) =&gt; {
        // 传递 response 并 return
      });
    }
  }
}

function makeAjaxCall(url) {
  // 处理 request 并 return promise
}

function makeHttpCall(url) {
  // 处理 request 并 return promise
}
</code></pre><h3 id="Good-31"><a href="#Good-31" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#39;ajaxAdapter&#39;;
  }

  request(url) {
    // 处理 request 并 return promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &#39;nodeAdapter&#39;;
  }

  request(url) {
    // 处理 request 并 return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then((response) =&gt; {
      // 传递 response 并 return
    });
  }
}
</code></pre><h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 Liskov Substitution Principle"></a>里氏替换原则 Liskov Substitution Principle</h2><p>名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。</p>
<h3 id="Bad-31"><a href="#Bad-31" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 长方形
class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

// 正方形
class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.forEach((rectangle) =&gt; {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); 
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
</code></pre><h3 id="Good-32"><a href="#Good-32" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach((shape) =&gt; {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
</code></pre><h2 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 The Interface Segregation Principle"></a>接口隔离原则 The Interface Segregation Principle</h2><p>JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。</p>
<h3 id="Bad-32"><a href="#Bad-32" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName(&#39;body&#39;),
  animationModule() {} // Most of the time, we won&#39;t need to animate when traversing.
  // ...
});
</code></pre><h3 id="Good-33"><a href="#Good-33" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName(&#39;body&#39;),
  options: {
    animationModule() {}
  }
});
</code></pre><h2 id="依赖倒置原则-The-Dependency-Inversion-Principle"><a href="#依赖倒置原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则 The Dependency Inversion Principle"></a>依赖倒置原则 The Dependency Inversion Principle</h2><p>说就两点：</p>
<ul>
<li><p>高层次模块不能依赖低层次模块，它们依赖于抽象接口。</p>
</li>
<li><p>抽象接口不能依赖具体实现，具体实现依赖抽象接口。</p>
</li>
</ul>
<p>总结下来就两个字，解耦。</p>
<h3 id="Bad-33"><a href="#Bad-33" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>// 库存查询
class InventoryRequester {
  constructor() {
    this.REQ_METHODS = [&#39;HTTP&#39;];
  }

  requestItem(item) {
    // ...
  }
}

// 库存跟踪
class InventoryTracker {
  constructor(items) {
    this.items = items;

    // 这里依赖一个特殊的请求类，其实我们只是需要一个请求方法。
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach((item) =&gt; {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;]);
inventoryTracker.requestItems();
</code></pre><h3 id="Good-34"><a href="#Good-34" class="headerlink" title="Good:"></a>Good:</h3><pre><code>// 库存跟踪
class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach((item) =&gt; {
      this.requester.requestItem(item);
    });
  }
}

// HTTP 请求
class InventoryRequesterHTTP {
  constructor() {
    this.REQ_METHODS = [&#39;HTTP&#39;];
  }

  requestItem(item) {
    // ...
  }
}

// webSocket 请求
class InventoryRequesterWS {
  constructor() {
    this.REQ_METHODS = [&#39;WS&#39;];
  }

  requestItem(item) {
    // ...
  }
}

// 通过依赖注入的方式将请求模块解耦，这样我们就可以很轻易的替换成 webSocket 请求。
const inventoryTracker = new InventoryTracker([&#39;apples&#39;, &#39;bananas&#39;], new InventoryRequesterHTTP());
inventoryTracker.requestItems();
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>随着项目变得越来越庞大，时间线拉长，有的老代码可能半年都没碰过，如果此时上线，你有信心这部分代码能正常工作吗？测试的覆盖率和你的信心是成正比的。</p>
<p>PS: 如果你发现你的代码很难被测试，那么你应该优化你的代码了。</p>
<h2 id="单一化"><a href="#单一化" class="headerlink" title="单一化"></a>单一化</h2><h3 id="Bad-34"><a href="#Bad-34" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import assert from &#39;assert&#39;;

describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {
  it(&#39;handles date boundaries&#39;, () =&gt; {
    let date;

    date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);
    date.addDays(30);
    assert.equal(&#39;1/31/2015&#39;, date);

    date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);
    date.addDays(28);
    assert.equal(&#39;02/29/2016&#39;, date);

    date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);
    date.addDays(28);
    assert.equal(&#39;03/01/2015&#39;, date);
  });
});
</code></pre><h3 id="Good-35"><a href="#Good-35" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import assert from &#39;assert&#39;;

describe(&#39;MakeMomentJSGreatAgain&#39;, () =&gt; {
  it(&#39;handles 30-day months&#39;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#39;1/1/2015&#39;);
    date.addDays(30);
    assert.equal(&#39;1/31/2015&#39;, date);
  });

  it(&#39;handles leap year&#39;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#39;2/1/2016&#39;);
    date.addDays(28);
    assert.equal(&#39;02/29/2016&#39;, date);
  });

  it(&#39;handles non-leap year&#39;, () =&gt; {
    const date = new MakeMomentJSGreatAgain(&#39;2/1/2015&#39;);
    date.addDays(28);
    assert.equal(&#39;03/01/2015&#39;, date);
  });
});

</code></pre><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="不再使用回调"><a href="#不再使用回调" class="headerlink" title="不再使用回调"></a>不再使用回调</h2><p>不会有人愿意去看嵌套回调的代码，用 Promises 替代回调吧。</p>
<h3 id="Bad-35"><a href="#Bad-35" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request&#39;;
import { writeFile } from &#39;fs&#39;;

get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;, (requestErr, response) =&gt; {
  if (requestErr) {
    console.error(requestErr);
  } else {
    writeFile(&#39;article.html&#39;, response.body, (writeErr) =&gt; {
      if (writeErr) {
        console.error(writeErr);
      } else {
        console.log(&#39;File written&#39;);
      }
    });
  }
});
</code></pre><h3 id="Good-36"><a href="#Good-36" class="headerlink" title="Good:"></a>Good:</h3><pre><code>get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)
  .then((response) =&gt; {
    return writeFile(&#39;article.html&#39;, response);
  })
  .then(() =&gt; {
    console.log(&#39;File written&#39;);
  })
  .catch((err) =&gt; {
    console.error(err);
  });
</code></pre><h2 id="Async-Await-比起-Promises-更简洁"><a href="#Async-Await-比起-Promises-更简洁" class="headerlink" title="Async/Await 比起 Promises 更简洁"></a>Async/Await 比起 Promises 更简洁</h2><h3 id="Bad-36"><a href="#Bad-36" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>import { get } from &#39;request-promise&#39;;
import { writeFile } from &#39;fs-promise&#39;;

get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;)
  .then((response) =&gt; {
    return writeFile(&#39;article.html&#39;, response);
  })
  .then(() =&gt; {
    console.log(&#39;File written&#39;);
  })
  .catch((err) =&gt; {
    console.error(err);
  });
</code></pre><h3 id="Good-37"><a href="#Good-37" class="headerlink" title="Good:"></a>Good:</h3><pre><code>import { get } from &#39;request-promise&#39;;
import { writeFile } from &#39;fs-promise&#39;;

async function getCleanCodeArticle() {
  try {
    const response = await get(&#39;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#39;);
    await writeFile(&#39;article.html&#39;, response);
    console.log(&#39;File written&#39;);
  } catch(err) {
    console.error(err);
  }
}
</code></pre><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要忽略抛异常"><a href="#不要忽略抛异常" class="headerlink" title="不要忽略抛异常"></a>不要忽略抛异常</h2><h3 id="Bad-37"><a href="#Bad-37" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>try {
  functionThatMightThrow();
} catch (error) {
  console.log(error);
}
</code></pre><h3 id="Good-38"><a href="#Good-38" class="headerlink" title="Good:"></a>Good:</h3><pre><code>try {
  functionThatMightThrow();
} catch (error) {
  // 这一种选择，比起 console.log 更直观
  console.error(error);
  // 也可以在界面上提醒用户
  notifyUserOfError(error);
  // 也可以把异常传回服务器
  reportErrorToService(error);
  // 其他的自定义方法
}
</code></pre><h2 id="不要忘了在-Promises-抛异常"><a href="#不要忘了在-Promises-抛异常" class="headerlink" title="不要忘了在 Promises 抛异常"></a>不要忘了在 Promises 抛异常</h2><h3 id="Bad-38"><a href="#Bad-38" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>getdata()
  .then((data) =&gt; {
    functionThatMightThrow(data);
  })
  .catch((error) =&gt; {
    console.log(error);
  });
</code></pre><h3 id="Good-39"><a href="#Good-39" class="headerlink" title="Good:"></a>Good:</h3><pre><code>getdata()
  .then((data) =&gt; {
    functionThatMightThrow(data);
  })
  .catch((error) =&gt; {
    // 这一种选择，比起 console.log 更直观
    console.error(error);
    // 也可以在界面上提醒用户
    notifyUserOfError(error);
    // 也可以把异常传回服务器
    reportErrorToService(error);
    // 其他的自定义方法
  });
</code></pre><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。</p>
<h2 id="常量大写"><a href="#常量大写" class="headerlink" title="常量大写"></a>常量大写</h2><h3 id="Bad-39"><a href="#Bad-39" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>const DAYS_IN_WEEK = 7;
const daysInMonth = 30;

const songs = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];
const Artists = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];

function eraseDatabase() {}
function restore_database() {}

class animal {}
class Alpaca {}
</code></pre><h3 id="Good-40"><a href="#Good-40" class="headerlink" title="Good:"></a>Good:</h3><pre><code>const DAYS_IN_WEEK = 7;
const DAYS_IN_MONTH = 30;

const SONGS = [&#39;Back In Black&#39;, &#39;Stairway to Heaven&#39;, &#39;Hey Jude&#39;];
const ARTISTS = [&#39;ACDC&#39;, &#39;Led Zeppelin&#39;, &#39;The Beatles&#39;];

function eraseDatabase() {}
function restoreDatabase() {}

class Animal {}
class Alpaca {}
</code></pre><h2 id="先声明后调用"><a href="#先声明后调用" class="headerlink" title="先声明后调用"></a>先声明后调用</h2><p>就像我们看报纸文章一样，从上到下看，所以为了方便阅读把函数声明写在函数调用前面。</p>
<h3 id="Bad-40"><a href="#Bad-40" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  lookupPeers() {
    return db.lookup(this.employee, &#39;peers&#39;);
  }

  lookupManager() {
    return db.lookup(this.employee, &#39;manager&#39;);
  }

  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(employee);
review.perfReview();
</code></pre><h3 id="Good-41"><a href="#Good-41" class="headerlink" title="Good:"></a>Good:</h3><pre><code>class PerformanceReview {
  constructor(employee) {
    this.employee = employee;
  }

  perfReview() {
    this.getPeerReviews();
    this.getManagerReview();
    this.getSelfReview();
  }

  getPeerReviews() {
    const peers = this.lookupPeers();
    // ...
  }

  lookupPeers() {
    return db.lookup(this.employee, &#39;peers&#39;);
  }

  getManagerReview() {
    const manager = this.lookupManager();
  }

  lookupManager() {
    return db.lookup(this.employee, &#39;manager&#39;);
  }

  getSelfReview() {
    // ...
  }
}

const review = new PerformanceReview(employee);
review.perfReview();
</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="只有业务逻辑需要注释"><a href="#只有业务逻辑需要注释" class="headerlink" title="只有业务逻辑需要注释"></a>只有业务逻辑需要注释</h2><p>代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p>
<h3 id="Bad-41"><a href="#Bad-41" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>function hashIt(data) {
  // 这是初始值
  let hash = 0;

  // 数组的长度
  const length = data.length;

  // 循环数组
  for (let i = 0; i &lt; length; i++) {
    // 获取字符代码
    const char = data.charCodeAt(i);
    // 修改 hash
    hash = ((hash &lt;&lt; 5) - hash) + char;
    // 转换为32位整数
    hash &amp;= hash;
  }
}
</code></pre><h3 id="Good-42"><a href="#Good-42" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function hashIt(data) {
  let hash = 0;
  const length = data.length;

  for (let i = 0; i &lt; length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash &lt;&lt; 5) - hash) + char;

    // 转换为32位整数
    hash &amp;= hash;
  }
}
</code></pre><h2 id="删掉注释的代码"><a href="#删掉注释的代码" class="headerlink" title="删掉注释的代码"></a>删掉注释的代码</h2><p>git 存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧。</p>
<h3 id="Bad-42"><a href="#Bad-42" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>doStuff();
// doOtherStuff();
// doSomeMoreStuff();
// doSoMuchStuff();
</code></pre><h3 id="Good-43"><a href="#Good-43" class="headerlink" title="Good:"></a>Good:</h3><pre><code>doStuff();
</code></pre><p>javascript</p>
<p>不要记日记<br>记住你有 git！，git log 可以帮你干这事。</p>
<h3 id="Bad-43"><a href="#Bad-43" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>/**
 * 2016-12-20: 删除了 xxx
 * 2016-10-01: 改进了 xxx
 * 2016-02-03: 删除了第12行的类型检查
 * 2015-03-14: 增加了一个合并的方法
 */
function combine(a, b) {
  return a + b;
}
</code></pre><h3 id="Good-44"><a href="#Good-44" class="headerlink" title="Good:"></a>Good:</h3><pre><code>function combine(a, b) {
  return a + b;
}
</code></pre><h2 id="注释不需要高亮"><a href="#注释不需要高亮" class="headerlink" title="注释不需要高亮"></a>注释不需要高亮</h2><p>注释高亮，并不能起到提示的作用，反而会干扰你阅读代码。（注：在联调或临时修改代码调试的时候可以用此方法引起自己的注意，保证在提交代码的时候可以注意到此处，不会造成调试代码的提交）</p>
<h3 id="Bad-44"><a href="#Bad-44" class="headerlink" title="Bad:"></a>Bad:</h3><pre><code>////////////////////////////////////////////////////////////////////////////////
// Scope Model Instantiation
////////////////////////////////////////////////////////////////////////////////
$scope.model = {
  menu: &#39;foo&#39;,
  nav: &#39;bar&#39;
};

////////////////////////////////////////////////////////////////////////////////
// Action setup
////////////////////////////////////////////////////////////////////////////////
const actions = function() {
  // ...
};
</code></pre><h3 id="Good-45"><a href="#Good-45" class="headerlink" title="Good:"></a>Good:</h3><pre><code>$scope.model = {
  menu: &#39;foo&#39;,
  nav: &#39;bar&#39;
};

const actions = function() {
  // ...
};
</code></pre><p>文末推荐一篇很好的讲述前端代码规范的文章，包含前端各种代码的规范，我觉得可以根据自己公司项目的实际情况借鉴一二。<a href="https://guide.aotu.io/docs/index.html" target="_blank" rel="noopener">前端代码规范</a></p>
<blockquote>
<p>翻译自 ryanmcdermott 的 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="noopener">clean-code-javascript</a>，本文对原文进行了一些修改。</p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript-代码-风格-编码/" rel="tag"># JavaScript 代码 风格 编码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/26/JavaScript运算符优先级和隐式转换/" rel="next" title="JavaScript运算符优先级和隐式转换">
                <i class="fa fa-chevron-left"></i> JavaScript运算符优先级和隐式转换
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/15/你需要了解的几种种JavaScript设计模式/" rel="prev" title="你需要了解的几种JavaScript设计模式">
                你需要了解的几种JavaScript设计模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">科瑞兹曼</p>
              <p class="site-description motion-element" itemprop="description">交流、学习、提升</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">60</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.zhangxinxu.com/wordpress/" title="http://www.zhangxinxu.com/wordpress/" rel="noopener" target="_blank">张鑫旭</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="http://www.ruanyifeng.com/blog/" rel="noopener" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jstherightway.org/zh-cn/" title="http://jstherightway.org/zh-cn/" rel="noopener" target="_blank">JavaScript之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://standardjs.com/readme-zhcn.html" title="https://standardjs.com/readme-zhcn.html" rel="noopener" target="_blank">前端代码规范</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。"><span class="nav-number">1.</span> <span class="nav-text">测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用有意义且常用的单词命名变量"><span class="nav-number">2.1.</span> <span class="nav-text">用有意义且常用的单词命名变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad"><span class="nav-number">2.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good"><span class="nav-number">2.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保持统一"><span class="nav-number">2.2.</span> <span class="nav-text">保持统一</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每个常量都该命名"><span class="nav-number">2.3.</span> <span class="nav-text">每个常量都该命名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可描述"><span class="nav-number">2.4.</span> <span class="nav-text">可描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接了当"><span class="nav-number">2.5.</span> <span class="nav-text">直接了当</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免无意义的前缀"><span class="nav-number">2.6.</span> <span class="nav-text">避免无意义的前缀</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-5"><span class="nav-number">2.6.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用默认值"><span class="nav-number">2.7.</span> <span class="nav-text">使用默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-6"><span class="nav-number">2.7.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-6"><span class="nav-number">2.7.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参数越少越好"><span class="nav-number">3.1.</span> <span class="nav-text">参数越少越好</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-7"><span class="nav-number">3.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-7"><span class="nav-number">3.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只做一件事情"><span class="nav-number">3.2.</span> <span class="nav-text">只做一件事情</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-8"><span class="nav-number">3.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-8"><span class="nav-number">3.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顾名思义"><span class="nav-number">3.3.</span> <span class="nav-text">顾名思义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-9"><span class="nav-number">3.3.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-9"><span class="nav-number">3.3.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只需要一层抽象层"><span class="nav-number">3.4.</span> <span class="nav-text">只需要一层抽象层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-10"><span class="nav-number">3.4.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-10"><span class="nav-number">3.4.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除重复代码"><span class="nav-number">3.5.</span> <span class="nav-text">删除重复代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-11"><span class="nav-number">3.5.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-11"><span class="nav-number">3.5.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象设置默认属性"><span class="nav-number">3.6.</span> <span class="nav-text">对象设置默认属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-12"><span class="nav-number">3.6.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-12"><span class="nav-number">3.6.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要传-flag-参数"><span class="nav-number">3.7.</span> <span class="nav-text">不要传 flag 参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-13"><span class="nav-number">3.7.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-13"><span class="nav-number">3.7.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免副作用（第一部分）"><span class="nav-number">3.8.</span> <span class="nav-text">避免副作用（第一部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-14"><span class="nav-number">3.8.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-14"><span class="nav-number">3.8.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免副作用（第二部分）"><span class="nav-number">3.9.</span> <span class="nav-text">避免副作用（第二部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-15"><span class="nav-number">3.9.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-15"><span class="nav-number">3.9.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要写全局方法"><span class="nav-number">3.10.</span> <span class="nav-text">不要写全局方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-16"><span class="nav-number">3.10.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-16"><span class="nav-number">3.10.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比起命令式我更喜欢函数式编程"><span class="nav-number">3.11.</span> <span class="nav-text">比起命令式我更喜欢函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-17"><span class="nav-number">3.11.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-17"><span class="nav-number">3.11.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装条件语句"><span class="nav-number">3.12.</span> <span class="nav-text">封装条件语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bad-18"><span class="nav-number">3.13.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Good-18"><span class="nav-number">3.14.</span> <span class="nav-text">Good:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尽量别用“非”条件句"><span class="nav-number">3.15.</span> <span class="nav-text">尽量别用“非”条件句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-19"><span class="nav-number">3.15.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-19"><span class="nav-number">3.15.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免使用条件语句"><span class="nav-number">3.16.</span> <span class="nav-text">避免使用条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-20"><span class="nav-number">3.16.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-20"><span class="nav-number">3.16.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免类型检查（第一部分）"><span class="nav-number">3.17.</span> <span class="nav-text">避免类型检查（第一部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-21"><span class="nav-number">3.17.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-21"><span class="nav-number">3.17.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免类型检查（第二部分）"><span class="nav-number">3.18.</span> <span class="nav-text">避免类型检查（第二部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-22"><span class="nav-number">3.18.1.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要过度优化"><span class="nav-number">3.19.</span> <span class="nav-text">不要过度优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-22"><span class="nav-number">3.19.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-23"><span class="nav-number">3.19.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除弃用代码"><span class="nav-number">3.20.</span> <span class="nav-text">删除弃用代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-23"><span class="nav-number">3.20.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-24"><span class="nav-number">3.20.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象和数据结构"><span class="nav-number">4.</span> <span class="nav-text">对象和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用-get、set-方法操作数据"><span class="nav-number">4.1.</span> <span class="nav-text">用 get、set 方法操作数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-24"><span class="nav-number">4.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-25"><span class="nav-number">4.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用私有变量"><span class="nav-number">4.2.</span> <span class="nav-text">使用私有变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-25"><span class="nav-number">4.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-26"><span class="nav-number">4.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类"><span class="nav-number">5.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-class"><span class="nav-number">5.1.</span> <span class="nav-text">使用 class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-26"><span class="nav-number">5.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-27"><span class="nav-number">5.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式调用"><span class="nav-number">5.2.</span> <span class="nav-text">链式调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-27"><span class="nav-number">5.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-28"><span class="nav-number">5.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要滥用继承"><span class="nav-number">5.3.</span> <span class="nav-text">不要滥用继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-28"><span class="nav-number">5.3.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-29"><span class="nav-number">5.3.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SOLID"><span class="nav-number">6.</span> <span class="nav-text">SOLID</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一功能原则-The-Single-Responsibility-Principle"><span class="nav-number">6.1.</span> <span class="nav-text">单一功能原则 The Single Responsibility Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-29"><span class="nav-number">6.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-30"><span class="nav-number">6.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开闭原则-The-Open-Closed-Principle"><span class="nav-number">6.2.</span> <span class="nav-text">开闭原则 The Open Closed Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-30"><span class="nav-number">6.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-31"><span class="nav-number">6.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#里氏替换原则-Liskov-Substitution-Principle"><span class="nav-number">6.3.</span> <span class="nav-text">里氏替换原则 Liskov Substitution Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-31"><span class="nav-number">6.3.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-32"><span class="nav-number">6.3.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口隔离原则-The-Interface-Segregation-Principle"><span class="nav-number">6.4.</span> <span class="nav-text">接口隔离原则 The Interface Segregation Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-32"><span class="nav-number">6.4.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-33"><span class="nav-number">6.4.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖倒置原则-The-Dependency-Inversion-Principle"><span class="nav-number">6.5.</span> <span class="nav-text">依赖倒置原则 The Dependency Inversion Principle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-33"><span class="nav-number">6.5.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-34"><span class="nav-number">6.5.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试"><span class="nav-number">7.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单一化"><span class="nav-number">7.1.</span> <span class="nav-text">单一化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-34"><span class="nav-number">7.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-35"><span class="nav-number">7.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步"><span class="nav-number">8.</span> <span class="nav-text">异步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不再使用回调"><span class="nav-number">8.1.</span> <span class="nav-text">不再使用回调</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-35"><span class="nav-number">8.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-36"><span class="nav-number">8.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Async-Await-比起-Promises-更简洁"><span class="nav-number">8.2.</span> <span class="nav-text">Async/Await 比起 Promises 更简洁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-36"><span class="nav-number">8.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-37"><span class="nav-number">8.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">9.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不要忽略抛异常"><span class="nav-number">9.1.</span> <span class="nav-text">不要忽略抛异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-37"><span class="nav-number">9.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-38"><span class="nav-number">9.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要忘了在-Promises-抛异常"><span class="nav-number">9.2.</span> <span class="nav-text">不要忘了在 Promises 抛异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-38"><span class="nav-number">9.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-39"><span class="nav-number">9.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码风格"><span class="nav-number">10.</span> <span class="nav-text">代码风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量大写"><span class="nav-number">10.1.</span> <span class="nav-text">常量大写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-39"><span class="nav-number">10.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-40"><span class="nav-number">10.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先声明后调用"><span class="nav-number">10.2.</span> <span class="nav-text">先声明后调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-40"><span class="nav-number">10.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-41"><span class="nav-number">10.2.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注释"><span class="nav-number">11.</span> <span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#只有业务逻辑需要注释"><span class="nav-number">11.1.</span> <span class="nav-text">只有业务逻辑需要注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-41"><span class="nav-number">11.1.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-42"><span class="nav-number">11.1.2.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删掉注释的代码"><span class="nav-number">11.2.</span> <span class="nav-text">删掉注释的代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-42"><span class="nav-number">11.2.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-43"><span class="nav-number">11.2.2.</span> <span class="nav-text">Good:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-43"><span class="nav-number">11.2.3.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-44"><span class="nav-number">11.2.4.</span> <span class="nav-text">Good:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释不需要高亮"><span class="nav-number">11.3.</span> <span class="nav-text">注释不需要高亮</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bad-44"><span class="nav-number">11.3.1.</span> <span class="nav-text">Bad:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Good-45"><span class="nav-number">11.3.2.</span> <span class="nav-text">Good:</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">科瑞兹曼</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: 'hXTDTSGSHRts2UhvBgMMCgbT-gzGzoHsz',
    appKey: 'VtFW2O1nWA3hNCVyr56QqvyG',
    placeholder: '我来说两句',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true
  });
</script>




  


  




  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; 
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
