<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>25个你不得不知道的数组reduce高级用法</title>
    <url>/2020/07/17/25%E4%B8%AA%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E7%BB%84reduce%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p> <code>reduce</code>作为ES5新增的常规数组方法之一，对比<code>forEach</code>、<code>filter</code>和<code>map</code>，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。 </p>
<p>下面对reduce的语法进行简单说明，详情可查看MDN的reduce()的相关说明。</p>
<ul>
<li><p>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</p>
</li>
<li><p>形式：array.reduce((t, v, i, a) =&gt; {}, initValue)</p>
</li>
<li><p>参数</p>
<ul>
<li>callback：回调函数(必选)</li>
<li>initValue：初始值(可选)</li>
</ul>
</li>
<li><p>回调函数的参数</p>
<ul>
<li>total(t)：累计器完成计算的返回值(必选)</li>
<li>value(v)：当前元素(必选)</li>
<li>index(i)：当前元素的索引(可选)</li>
<li>array(a)：当前元素所属的数组对象(可选)</li>
</ul>
</li>
<li><p>过程</p>
<ul>
<li>以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值</li>
<li>开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t</li>
<li>进入下一次循环，重复上述操作，直至数组最后一个元素</li>
<li>结束遍历，返回最终的t</li>
</ul>
<p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。下面举个简单的栗子，看看<code>reduce</code>的计算结果。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p> 代码不太明白没关系，贴一个<code>reduce</code>的作用动图应该就会明白了。 </p>
</li>
</ul>
<a id="more"></a>

<p> <img src="https://img-blog.csdnimg.cn/20200309234456121.gif" alt="reduce"> </p>
<p> <code>reduce</code>实质上是一个累计器函数，通过用户自定义的累计器对数组成员进行自定义累计，得出一个由累计器生成的值。另外<code>reduce</code>还有一个胞弟<code>reduceRight</code>，两个方法的功能其实是一样的，只不过<code>reduce</code>是升序执行，<code>reduceRight</code>是降序执行。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对空数组调用reduce()和reduceRight()是不会执行其回调函数的，可认为reduce()对空数组无效</span><br></pre></td></tr></table></figure>
<h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p> 单凭以上一个简单栗子不足以说明<code>reduce</code>是个什么。为了展示<code>reduce</code>的魅力，我为大家提供25种场景来应用<code>reduce</code>的高级用法。有部分高级用法可能需要结合其他方法来实现，这样为<code>reduce</code>的多元化提供了更多的可能性。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">部分示例代码的写法可能有些骚，看得不习惯可自行整理成自己的习惯写法</span><br></pre></td></tr></table></figure>
<h2 id="累加累乘"><a href="#累加累乘" class="headerlink" title="累加累乘"></a>累加累乘</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Accumulation</span>(<span class="params">...vals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Multiplication</span>(<span class="params">...vals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t * v, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Accumulation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">Multiplication(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h2 id="权重求和"><a href="#权重求和" class="headerlink" title="权重求和"></a>权重求和</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">90</span>, <span class="attr">subject</span>: <span class="string">&quot;chinese&quot;</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">95</span>, <span class="attr">subject</span>: <span class="string">&quot;math&quot;</span>, <span class="attr">weight</span>: <span class="number">0.3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">85</span>, <span class="attr">subject</span>: <span class="string">&quot;english&quot;</span>, <span class="attr">weight</span>: <span class="number">0.2</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v.score * v.weight, <span class="number">0</span>); <span class="comment">// 90.5</span></span><br></pre></td></tr></table></figure>
<h2 id="代替reverse"><a href="#代替reverse" class="headerlink" title="代替reverse"></a>代替reverse</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Reverse</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t.push(v), t), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<h2 id="代替map和filter"><a href="#代替map和filter" class="headerlink" title="代替map和filter"></a>代替map和filter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map：[0, 2, 4, 6]</span></span><br><span class="line"><span class="keyword">const</span> a = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> [...t, v * <span class="number">2</span>], []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替filter：[2, 3]</span></span><br><span class="line"><span class="keyword">const</span> c = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> d = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v &gt; <span class="number">1</span> ? [...t, v] : t, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map和filter：[4, 6]</span></span><br><span class="line"><span class="keyword">const</span> e = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> f = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v * <span class="number">2</span> &gt; <span class="number">2</span> ? [...t, v * <span class="number">2</span>] : t, []);</span><br></pre></td></tr></table></figure>
<h2 id="代替some和every"><a href="#代替some和every" class="headerlink" title="代替some和every"></a>代替some和every</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">45</span>, <span class="attr">subject</span>: <span class="string">&quot;chinese&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">90</span>, <span class="attr">subject</span>: <span class="string">&quot;math&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">60</span>, <span class="attr">subject</span>: <span class="string">&quot;english&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替some：至少一门合格</span></span><br><span class="line"><span class="keyword">const</span> isAtLeastOneQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t || v.score &gt;= <span class="number">60</span>, <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替every：全部合格</span></span><br><span class="line"><span class="keyword">const</span> isAllQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &amp;&amp; v.score &gt;= <span class="number">60</span>, <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chunk</span>(<span class="params">arr = [], size = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.length ? arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t[t.length - <span class="number">1</span>].length === size ? t.push([v]) : t[t.length - <span class="number">1</span>].push(v), t), [[]]) : [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Chunk(arr, <span class="number">2</span>); <span class="comment">// [[1, 2], [3, 4], [5]]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Difference</span>(<span class="params">arr = [], oarr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (!oarr.includes(v) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">Difference(arr1, arr2); <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fill</span>(<span class="params">arr = [], val = <span class="string">&quot;&quot;</span>, start = <span class="number">0</span>, end = arr.length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt;= end || end &gt; arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        ...arr.slice(<span class="number">0</span>, start),</span><br><span class="line">        ...arr.slice(start, end).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t.push(val || v), t), []),</span><br><span class="line">        ...arr.slice(end, arr.length)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">Fill(arr, <span class="string">&quot;aaa&quot;</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// [0, 1, &quot;aaa&quot;, &quot;aaa&quot;, &quot;aaa&quot;, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Flat</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t.concat(<span class="built_in">Array</span>.isArray(v) ? Flat(v) : v), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]], [<span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>, [<span class="number">11</span>, <span class="number">12</span>]]]];</span><br><span class="line">Flat(arr); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Uniq</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t.includes(v) ? t : [...t, v], []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">Uniq(arr); <span class="comment">// [2, 1, 0, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Max</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &gt; v ? t : v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Min</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &lt; v ? t : v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">65</span>, <span class="number">38</span>, <span class="number">76</span>, <span class="number">108</span>, <span class="number">43</span>];</span><br><span class="line">Max(arr); <span class="comment">// 108</span></span><br><span class="line">Min(arr); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h2 id="数组成员独立拆解"><a href="#数组成员独立拆解" class="headerlink" title="数组成员独立拆解"></a>数组成员独立拆解</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Unzip</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(</span><br><span class="line">        (t, v) =&gt; (v.forEach(<span class="function">(<span class="params">w, i</span>) =&gt;</span> t[i].push(w)), t),</span><br><span class="line">        <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="built_in">Math</span>.max(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v.length)) &#125;).map(<span class="function"><span class="params">v</span> =&gt;</span> [])</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="literal">false</span>]];</span><br><span class="line">Unzip(arr); <span class="comment">// [[&quot;a&quot;, &quot;b&quot;], [1, 2], [true, false]]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组成员个数统计"><a href="#数组成员个数统计" class="headerlink" title="数组成员个数统计"></a>数组成员个数统计</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t[v] = (t[v] || <span class="number">0</span>) + <span class="number">1</span>, t), &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">Count(arr); <span class="comment">// &#123; 0: 1, 1: 2, 2: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">此方法是字符统计和单词统计的原理，入参时把字符串处理成数组即可</span><br></pre></td></tr></table></figure>
<h2 id="数组成员位置记录"><a href="#数组成员位置记录" class="headerlink" title="数组成员位置记录"></a>数组成员位置记录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Position</span>(<span class="params">arr = [], val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> (v === val &amp;&amp; t.push(i), t), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">Position(arr, <span class="number">2</span>); <span class="comment">// [0, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="数组成员特性分组"><a href="#数组成员特性分组" class="headerlink" title="数组成员特性分组"></a>数组成员特性分组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Group</span>(<span class="params">arr = [], key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key ? arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (!t[v[key]] &amp;&amp; (t[v[key]] = []), t[v[key]].push(v), t), &#123;&#125;) : &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;GZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;YZW&quot;</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;GZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;TYJ&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;SZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;AAA&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;FS&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;BBB&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;SZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;CCC&quot;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;</span><br><span class="line">]; <span class="comment">// 以地区area作为分组依据</span></span><br><span class="line">Group(arr, <span class="string">&quot;area&quot;</span>); <span class="comment">// &#123; GZ: Array(2), SZ: Array(2), FS: Array(1) &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组成员所含关键字统计"><a href="#数组成员所含关键字统计" class="headerlink" title="数组成员所含关键字统计"></a>数组成员所含关键字统计</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Keyword</span>(<span class="params">arr = [], keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (arr.some(<span class="function"><span class="params">w</span> =&gt;</span> w.includes(v)) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = [</span><br><span class="line">    <span class="string">&quot;今天天气真好，我想出去钓鱼&quot;</span>,</span><br><span class="line">    <span class="string">&quot;我一边看电视，一边写作业&quot;</span>,</span><br><span class="line">    <span class="string">&quot;小明喜欢同桌的小红，又喜欢后桌的小君，真TM花心&quot;</span>,</span><br><span class="line">    <span class="string">&quot;最近上班喜欢摸鱼的人实在太多了，代码不好好写，在想入非非&quot;</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">&quot;偷懒&quot;</span>, <span class="string">&quot;喜欢&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;摸鱼&quot;</span>, <span class="string">&quot;真好&quot;</span>, <span class="string">&quot;一边&quot;</span>, <span class="string">&quot;明天&quot;</span>];</span><br><span class="line">Keyword(text, keyword); <span class="comment">// [&quot;喜欢&quot;, &quot;摸鱼&quot;, &quot;真好&quot;, &quot;一边&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseStr</span>(<span class="params">str = <span class="string">&quot;&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;reduce最牛逼&quot;</span>;</span><br><span class="line">ReverseStr(str); <span class="comment">// &quot;逼牛最ecuder&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="数字千分化"><a href="#数字千分化" class="headerlink" title="数字千分化"></a>数字千分化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThousandNum</span>(<span class="params">num = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = (+num).toString().split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> int = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">&quot;&quot;</span>).reverse().reduceRight(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + (i % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">&quot;&quot;</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> dec = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">&quot;&quot;</span>).reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + ((i + <span class="number">1</span>) % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">&quot;&quot;</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.length &gt; <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;int(str[<span class="number">0</span>])&#125;</span>.<span class="subst">$&#123;dec(str[<span class="number">1</span>])&#125;</span>`</span> : int(str[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ThousandNum(<span class="number">1234</span>); <span class="comment">// &quot;1,234&quot;</span></span><br><span class="line">ThousandNum(<span class="number">1234.00</span>); <span class="comment">// &quot;1,234&quot;</span></span><br><span class="line">ThousandNum(<span class="number">0.1234</span>); <span class="comment">// &quot;0.123,4&quot;</span></span><br><span class="line">ThousandNum(<span class="number">1234.5678</span>); <span class="comment">// &quot;1,234.567,8&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">AsyncTotal</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="keyword">async</span>(t, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> at = <span class="keyword">await</span> t;</span><br><span class="line">        <span class="keyword">const</span> todo = <span class="keyword">await</span> Todo(v);</span><br><span class="line">        at[v] = todo;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(&#123;&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> AsyncTotal(); <span class="comment">// 需要在async包围下使用</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">len = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [...new <span class="built_in">Array</span>(len).keys()];</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> (i &gt; <span class="number">1</span> &amp;&amp; t.push(t[i - <span class="number">1</span>] + t[i - <span class="number">2</span>]), t), [<span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Fibonacci(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>
<h2 id="URL参数反序列化"><a href="#URL参数反序列化" class="headerlink" title="URL参数反序列化"></a>URL参数反序列化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseUrlSearch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location.search.replace(<span class="regexp">/(^\?)|(&amp;$)/g</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;&amp;&quot;</span>).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [key, val] = v.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        t[key] = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设URL为：https://www.baidu.com?age=25&amp;name=TYJ</span></span><br><span class="line">ParseUrlSearch(); <span class="comment">// &#123; age: &quot;25&quot;, name: &quot;TYJ&quot; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="URL参数序列化"><a href="#URL参数序列化" class="headerlink" title="URL参数序列化"></a>URL参数序列化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringifyUrlSearch</span>(<span class="params">search = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(search).reduce(</span><br><span class="line">        (t, v) =&gt; <span class="string">`<span class="subst">$&#123;t&#125;</span><span class="subst">$&#123;v[<span class="number">0</span>]&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(v[<span class="number">1</span>])&#125;</span>&amp;`</span>,</span><br><span class="line">        <span class="built_in">Object</span>.keys(search).length ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">    ).replace(<span class="regexp">/&amp;$/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">StringifyUrlSearch(&#123; <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">name</span>: <span class="string">&quot;YZW&quot;</span> &#125;); <span class="comment">// &quot;?age=27&amp;name=YZW&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="返回对象指定键值"><a href="#返回对象指定键值" class="headerlink" title="返回对象指定键值"></a>返回对象指定键值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetKeys</span>(<span class="params">obj = &#123;&#125;, keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (keys.includes(v) &amp;&amp; (t[v] = obj[v]), t), &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line">GetKeys(target, keyword); <span class="comment">// &#123; a: 1, d: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;GZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;YZW&quot;</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">&quot;SZ&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;TYJ&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> map = people.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, ...rest &#125; = v;</span><br><span class="line">    t[name] = rest;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;, &#123;&#125;); <span class="comment">// &#123; YZW: &#123;…&#125;, TYJ: &#123;…&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Redux-Compose函数原理"><a href="#Redux-Compose函数原理" class="headerlink" title="Redux Compose函数原理"></a>Redux Compose函数原理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compose</span>(<span class="params">...funs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> t(v(...arg)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="兼容和性能"><a href="#兼容和性能" class="headerlink" title="兼容和性能"></a>兼容和性能</h1><p> 好用是挺好用的，但是兼容性如何呢？在<a href="https://caniuse.com/#search=reduce">Caniuse</a>上搜索一番，兼容性绝对的好，可大胆在任何项目上使用。不要吝啬你的想象力，尽情发挥<code>reduce</code>的<code>compose</code>技能啦。对于时常做一些累计的功能，<code>reduce</code>绝对是首选方法。 </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZS5wbmc?x-oss-process=image/format,png" alt="caniuse-reduce">  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9jYW5pdXNlLXJlZHVjZVJpZ2h0LnBuZw?x-oss-process=image/format,png" alt="caniuse-reduceRight"></p>
<p> 另外，有些同学可能会问，<code>reduce</code>的性能又如何呢？下面我们通过对<code>for</code>、<code>forEach</code>、<code>map</code>和<code>reduce</code>四个方法同时做<code>1~100000</code>的累加操作，看看四个方法各自的执行时间。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为100000的数组</span></span><br><span class="line"><span class="keyword">const</span> list = [...new <span class="built_in">Array</span>(<span class="number">100000</span>).keys()];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;for&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    result1 += i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result1);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;for&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;forEach&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">0</span>;</span><br><span class="line">list.forEach(<span class="function"><span class="params">v</span> =&gt;</span> (result2 += v + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result2);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;forEach&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;map&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">0</span>;</span><br><span class="line">list.map(<span class="function"><span class="params">v</span> =&gt;</span> (result3 += v + <span class="number">1</span>, v));</span><br><span class="line"><span class="built_in">console</span>.log(result3);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;reduce&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result4 = list.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result4);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;reduce&quot;</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>累加操作</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td><strong>for</strong></td>
<td><code>6.719970703125ms</code></td>
</tr>
<tr>
<td><strong>forEach</strong></td>
<td><code>3.696044921875ms</code></td>
</tr>
<tr>
<td><strong>map</strong></td>
<td><code>3.554931640625ms</code></td>
</tr>
<tr>
<td><strong>reduce</strong></td>
<td><code>2.806884765625ms</code></td>
</tr>
</tbody></table>
<p>以上代码在MacBook Pro 2019 15寸 16G内存 512G闪存的Chrome 79下执行，不同的机器不同的环境下执行以上代码都有可能存在差异。</p>
<p>我已同时测试过多台机器和多个浏览器，连续做了10次以上操作，发现reduce总体的平均执行时间还是会比其他三个方法稍微快一点，所以大家还是放心使用啦！本文更多是探讨reduce的使用技巧，如对reduce的兼容和性能存在疑问，可自行参考相关资料进行验证。</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UteC5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95YW5nencudmlwL3N0YXRpYy9hcnRpY2xlL3JlZHVjZS9yZWR1Y2UtMS5wbmc?x-oss-process=image/format,png" alt="乘法口诀表"> </p>
<p>原文地址：<a href="https://blog.csdn.net/JowayYoung/article/details/104293122">25个你不得不知道的数组reduce高级用法</a></p>
]]></content>
      <tags>
        <tag>JavaScript 代码  技巧 reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6入门之set和map</title>
    <url>/2017/08/13/ES6%E5%85%A5%E9%97%A8%E4%B9%8Bset%E5%92%8Cmap/</url>
    <content><![CDATA[<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 例一</span><br><span class="line">var set &#x3D; new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var s &#x3D; new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].map(x &#x3D;&gt; s.add(x));</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2 3 5 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Set内部，两个NaN是相等。两个对象总是不相等的。可以用length来检测</p>
</blockquote>
<p>四个操作方法：</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值<br>set内部的元素可以遍历for…of…</li>
</ul>
<h2 id="weakset"><a href="#weakset" class="headerlink" title="weakset"></a>weakset</h2><p>WeakSet结构与Set类似，也是不重复的值的集合。</p>
<h2 id="WeakSet和Set的区别："><a href="#WeakSet和Set的区别：" class="headerlink" title="WeakSet和Set的区别："></a>WeakSet和Set的区别：</h2><ul>
<li>WeakSet的成员只能是对象，而不能是其他类型的值</li>
<li>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map();</span><br><span class="line">var o &#x3D; &#123;p: &quot;Hello World&quot;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &quot;content&quot;)</span><br><span class="line">m.get(o) &#x2F;&#x2F; &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.has(o) &#x2F;&#x2F; true</span><br><span class="line">m.delete(o) &#x2F;&#x2F; true</span><br><span class="line">m.has(o) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p><code>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var map &#x3D; new Map();</span><br><span class="line"></span><br><span class="line">map.set([&#39;a&#39;], 555);</span><br><span class="line">map.get([&#39;a&#39;]) &#x2F;&#x2F; undefined</span><br><span class="line">上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</span><br></pre></td></tr></table></figure>
<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</p>
<p>实例属性和方法：size、set、get、has、delete、clear</p>
<p>遍历方法：keys（）、values（）、entries（）、forEach（）</p>
<h2 id="WeakMap可以参考WeakSet"><a href="#WeakMap可以参考WeakSet" class="headerlink" title="WeakMap可以参考WeakSet"></a>WeakMap可以参考WeakSet</h2>]]></content>
      <tags>
        <tag>Set Map ES6 ECMAScript6 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 缓存机制详解</title>
    <url>/2017/08/26/HTTP%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在请求一个静态文件的时候（图片，css，js）等，这些文件的特点是文件不经常变化，将这些不经常变化的文件存储起来，对客户端来说是一个优化用户浏览体验的方法。那么这个就是客户端缓存的意义了。</p>
<p>Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。</p>
<p>但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。</p>
<p>在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。</p>
<a id="more"></a>

<h1 id="缓存规则解析"><a href="#缓存规则解析" class="headerlink" title="缓存规则解析"></a>缓存规则解析</h1><p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)</p>
<p>在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p>
<p>已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：</p>
<p><img src="http://i.imgur.com/kc1QZ7U.png"></p>
<p>已存在缓存数据时，仅基于对比缓存，请求数据的流程如下：</p>
<p><img src="http://i.imgur.com/16l6wfk.png"></p>
<p>对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？</p>
<p>这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。</p>
<p>我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。</p>
<p>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<h1 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h1><p>从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？</p>
<p>我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p>
<p>对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。</p>
<p>不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<p>另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。</p>
<p>所以HTTP 1.1 的版本，使用Cache-Control替代。</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private:             客户端可以缓存</span><br><span class="line">public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）</span><br><span class="line">max-age=xxx:   缓存的内容将在 xxx 秒后失效</span><br><span class="line">no-cache:          需要使用对比缓存来验证缓存数据（后面介绍）</span><br><span class="line">no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发</span><br></pre></td></tr></table></figure>
<p>（对于前端开发来说，缓存越多越好，so…基本上和它说886）</p>
<p>举个例子：</p>
<p><img src="http://i.imgur.com/FQ9UTEr.png"></p>
<p>图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。</p>
<p>没懂的话，我们换通俗一点的话来说一遍。当客户端第一次访问资源的时候，服务端在返回资源内容的同时也返回了Expires: Sun, 16 Oct 2016 05:43:02 GMT。</p>
<p>服务端告诉浏览器： 你Y的先把这个文件给我缓存起来，在这个过期时间之前，这个文件都不会变化了，你下次需要这个文件的时候，你就不要过来找我要了，你就去缓存中拿就好了，又快又好。</p>
<p>浏览器回答说：诺。</p>
<p>于是在第二次html页面中又要访问这个资源的时候，并且访问的日期在Sun, 16 Oct 2016 05:43:02 GMT之前，浏览器就不去服务器那边获取文件了，自己从缓存中自食其力了。</p>
<p>但是呢，浏览器毕竟是在客户端的，客户端的时间可是不准确的，用户可以随着自己的喜好修改自己机器的时间，比如我把我机器的时间调成Sun, 16 Oct 2016 05:43:03 GMT，那么呢？我的浏览器就不会再使用缓存了，而每次都去服务器获取文件。于是，服务器怒了：给你个绝对时间，你由于环境被修改没法判断过期，那么我就给你相对时间吧。于是就返回了Cache-Control: max-age:600，浏览器你给我缓存个10分钟去。于是浏览器只有乖乖的缓存10分钟了。</p>
<p>但是问题又来了，如果有的服务器同时设置了Expires和Cache-Control怎么办呢？（不是闲的没事干，而是由于Cache-Controll是HTTP1.1中才有的）那么就是根据更先进的设置Cache-Control来为标准。</p>
<p>好了，现在有个问题，我有个文件可能时不时会更新，服务端非常希望客户端能时不时过来问一下这个文件是否过期，如果没有过期，服务端不返回数据给你，只告诉浏览器你的缓存还没有过期（304）。然后浏览器使用自己存储的缓存来做显示。这个就叫做条件请求。</p>
<h1 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h1><p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。</p>
<p>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。</p>
<h2 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified / If-Modified-Since"></a>Last-Modified / If-Modified-Since</h2><p>Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。</p>
<p><img src="http://i.imgur.com/Tw97Ba7.png"></p>
<p>If-Modified-Since：</p>
<p>再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。</p>
<p>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。</p>
<p>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<p><img src="http://i.imgur.com/EMlUqCI.png"></p>
<h2 id="Etag-If-None-Match（优先级高于Last-Modified-If-Modified-Since）"><a href="#Etag-If-None-Match（优先级高于Last-Modified-If-Modified-Since）" class="headerlink" title="Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）"></a>Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）</h2><p>第一次客户端访问资源的时候，服务端返回资源内容的同时返回了ETag：1234，告诉客户端：这个文件的标签是1234，我如果修改了我这边的资源的话，这个标签就会不一样了。</p>
<p>第二次客户端访问资源的时候，由于缓存中已经有了Etag为1234的资源，客户端要去服务端查询的是这个资源有木有过期呢？所以带上了If-None-Match: 1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了。如果不是的话，你再返回资源内容给我就行了。服务端就比较下Etag来看是返回304还是200。</p>
<p><img src="http://i.imgur.com/Udgon6i.png"></p>
<h1 id="各种刷新"><a href="#各种刷新" class="headerlink" title="各种刷新"></a>各种刷新</h1><p>理解了上面的缓存标签之后就很好理解各种刷新了。</p>
<p>刷新有三种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器中写地址，回车</span><br><span class="line">F5</span><br><span class="line">Ctrl+F5</span><br></pre></td></tr></table></figure>
<p>假设对一个资源：</p>
<p>浏览器第一次访问，获取资源内容和cache-control: max-age:600，Last_Modify: Wed, 10 Aug 2013 15:32:18 GMT于是浏览器把资源文件放到缓存中，并且决定下次使用的时候直接去缓存中取了。</p>
<p>浏览器url回车</p>
<p>浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）</p>
<p>下面我按下了F5刷新</p>
<p>F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT</p>
<p>然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。</p>
<p>但是呢，下面我们按下了Ctrl+F5</p>
<p>这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作…</p>
<p>还有说一下，那个ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。</p>
]]></content>
      <tags>
        <tag>http 缓存 协议 强制 对比</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 五大常见函数</title>
    <url>/2018/03/26/JavaScript%20%E4%BA%94%E5%A4%A7%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>　　在 JavaScript 中有一些问题会被拿出来经常讨论，这些问题每个人都有不同的思路，想要理解这些问题，最好的方法就是自己实现一遍，话不多说，开始正题。</p>
</blockquote>
<a id="more"></a>

<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p>数组扁平化有很多方法，但最终最好的方法就是递归，实现一个指定深度的扁平化方法，这样基本的套路都会了解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flattenDepth(array, depth &#x3D; 0)&#123;</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    array.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">        if (Array.isArray(item)) &#123;</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;;</span><br><span class="line">        if (Array.isArray(item) &amp;&amp; depth &gt; 0) &#123;</span><br><span class="line">            res.push(...flattenDepth(item, --depth));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flattenDepth([1,[2,21,[1,2,3,[2,3,[5,6],1],4],22,23],3,[4,5,[6,7,8]]]));</span><br><span class="line">&#x2F;&#x2F;[1, 2, 21, 1, 2, 3, 2, 3, 5, 6, 1, 4, 22, 23, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归实现很简洁易懂，就是将每一项遍历，如果某一项为数组，则让该项继续调用，这里指定了 depth 作为扁平化的深度，因为这个参数对数组的每一项都要起作用，故放在循环的里面。</p>
</blockquote>
<h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p>函数的柯里化都被讲烂了，每个人都有自己的理解和实现方法，一句话解释就是<strong>参数够了就执行，参数不够就返回一个函数，之前的参数存起来，直到够了为止。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curring(func)&#123;</span><br><span class="line">    var len &#x3D; func.length;</span><br><span class="line">    return function curried()&#123;</span><br><span class="line">        var args &#x3D; [].slice.apply(arguments);</span><br><span class="line">        if (args.length &lt; len) &#123;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                var argsInner &#x3D; [].slice.apply(arguments);</span><br><span class="line">                return curried.apply(this, args.concat(argsInner));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return func.apply(this, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function f(a, b, c, d)&#123;</span><br><span class="line">    console.log([a, b, c, d]);</span><br><span class="line">&#125;</span><br><span class="line">var curry &#x3D; curring(f);</span><br><span class="line">curry(1)(2)(3)(4)&#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line">curry(1,2)(3)(4)&#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line">curry(1,2)(3,4)&#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line">curry(1,2,3)(4)&#x2F;&#x2F;[1, 2, 3, 4]</span><br><span class="line">curry(1,2,3,4)&#x2F;&#x2F;[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码不难看出，每次判断参数的个数，与被柯里化的函数参数个数比较，如果小于就继续返回函数，否则就执行。</p>
</blockquote>
<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>防抖按照我的理解就是不管你触发多少次，都等到你最后触发后过一段你指定的时间才触发。按照这个解释，写一个基本版的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">  var timer;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this,</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">debounce(function()&#123;alert(&#39;测试&#39;)&#125;,2000)()</span><br></pre></td></tr></table></figure>
<p>现在有个要求就是刚开始的时候也触发，最后一次也触发，并且可以配置，先写个测试页面方便测试功能，来测试防抖和节流函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">var container &#x3D; document.getElementById(&#39;container&#39;);</span><br><span class="line">document.onkeydown &#x3D; debounce(getUserAction, 1000, false, true);</span><br><span class="line"></span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    if (e.keyCode &#x3D;&#x3D;&#x3D; 32) &#123; &#x2F;&#x2F; 空格</span><br><span class="line">        alert(&#39;测试&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function debounce(func, wait, leading, trailing) &#123;</span><br><span class="line">    var timer, lastCall &#x3D; 0,</span><br><span class="line">        flag &#x3D; true</span><br><span class="line">    return function(e) &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        if (now - lastCall &lt; wait) &#123;</span><br><span class="line">            flag &#x3D; false;</span><br><span class="line">            lastCall &#x3D; now;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            flag &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leading &amp;&amp; flag) &#123;</span><br><span class="line">            lastCall &#x3D; now;</span><br><span class="line">            return func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">        if (trailing) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 leading 和 trailing 两个参数来决定开始和结束是否执行，如果 leading 为 true，则每次按空格都会执行alert，如果 trailing 为 true，则每次结束都会将最后一次触发执行。以防抖函数距离，如果两者都为 true，则第一次按空格会alert，然后快速按空格，此时里面的 getUserAction 并不会执行，而是等到松手后再执行，加入 trailing 为 false，则松手后不会执行。</p>
</blockquote>
<blockquote>
<p>解释一下，每次记录上次调用的时间，与现在的时间对比，小于间隔的话，第一次执行后之后就不会执行，大于间隔或在间隔时间后调用了，则重置 flag，可以与上面那个基本版的对比着看。</p>
</blockquote>
<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>节流就是，<strong>不管怎么触发，都是按照指定的间隔来执行</strong>，同样给个基本版。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (!timer) &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">                timer &#x3D; null;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">throttle(function(a)&#123;alert(a)&#125;,1000)(&#39;测试节流&#39;);</span><br></pre></td></tr></table></figure>
<p>同样和防抖函数一样加上两个参数，也可使用上面的例子来测试，其实两者的代码很类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait, leading, trailing) &#123;</span><br><span class="line">    var timer, lastCall &#x3D; 0, flag &#x3D; true;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var context &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        flag &#x3D; now - lastCall &gt; wait;</span><br><span class="line">        if (leading &amp;&amp; flag) &#123;</span><br><span class="line">            lastCall &#x3D; now;</span><br><span class="line">            return func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!timer &amp;&amp; trailing &amp;&amp; !(flag &amp;&amp; leading)) &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">                timer &#x3D; null;</span><br><span class="line">                lastCall &#x3D; +new Date();</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lastCall &#x3D; now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">throttle(function(a)&#123;alert(a)&#125;,1000,false,true)(&#39;测试节流&#39;);</span><br></pre></td></tr></table></figure>
<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><p>对象拷贝都知道分为深拷贝和浅拷贝，黑科技手段就是使用<code>JSON.parse(JSON.stringify(obj))</code></p>
<p>还有个方法就是使用递归了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function clone(value, isDeep) &#123;</span><br><span class="line">  if (value &#x3D;&#x3D;&#x3D; null) return null</span><br><span class="line">  if (typeof value !&#x3D;&#x3D; &#39;object&#39;) return value</span><br><span class="line">  if (Array.isArray(value)) &#123;</span><br><span class="line">    if (isDeep) &#123;</span><br><span class="line">      return value.map(item &#x3D;&gt; clone(item, true))</span><br><span class="line">    &#125;</span><br><span class="line">    return [].concat(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (isDeep) &#123;</span><br><span class="line">      var obj &#x3D; &#123;&#125;</span><br><span class="line">      Object.keys(value).forEach(item &#x3D;&gt; &#123;</span><br><span class="line">        obj[item] &#x3D; clone(value[item], true)</span><br><span class="line">      &#125;)</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123; ...value &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objects &#x3D; &#123; c: &#123; &#39;a&#39;: 1, e: [1, &#123;f: 2&#125;] &#125;, d: &#123; &#39;b&#39;: 2 &#125; &#125;</span><br><span class="line">var shallow &#x3D; clone(objects, true)</span><br><span class="line">console.log(shallow.c.e[1]) &#x2F;&#x2F; &#123; f: 2 &#125;</span><br><span class="line">console.log(shallow.c &#x3D;&#x3D;&#x3D; objects.c) &#x2F;&#x2F; false</span><br><span class="line">console.log(shallow.d &#x3D;&#x3D;&#x3D; objects.d) &#x2F;&#x2F; false</span><br><span class="line">console.log(shallow &#x3D;&#x3D;&#x3D; objects) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于基本类型直接返回，对于引用类型，遍历递归调用 clone 方法。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实对于上面这些方法，总的来说思路就是递归和高阶函数的使用，其中就有关于闭包的使用，前端就爱问这些问题，最好就是自己实现一遍，这样有助于理解。</p>
]]></content>
      <tags>
        <tag>javscript 函数 高阶函数 方法 递归 数组扁平化 柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 可能为 true 吗？</title>
    <url>/2018/01/19/JavaScript%20%E5%8F%AF%E8%83%BD%E4%B8%BA%20true%20%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>　　今天看到一篇文章，觉得挺有意思，就好奇地点开看了下。这篇文章提到了一个面试题：在javascript中(a==1&amp;&amp;a==2&amp;a==3)可能为true吗？起初看到这个题目的时候觉得很懵逼，在同一个条件分支里a可能同时等于1、2和3吗？毫无头绪，但既然有人出了这道题目，肯定是事出有妖了，所以苦思冥想了两三个小时，还是感觉没什么头绪，唯一可以肯定的是应该与底层的东西有关，后来带着好奇的心理接着往下看了，不看不知道，一看才知道，原来与javascript底层的类型转换有关，javascript高程三里有过相关细致的讲解，在两个数据类型不同的值比较时会先让其中一个值调用valueOf方法转换后进行比较，如果类型还是不同的话会继续调用toString方法转换比较。当时看高程的时候其实对这个底层概念印象比较深的，但可能由于真正用到的地方不多，导致遗忘了，现在看到这道题的解法才恍然大悟，相信以后对这个概念记忆深刻， 今天把这个概念和这道题记下来！</p>
</blockquote>
<a id="more"></a>

<h1 id="价值-思考-共鸣"><a href="#价值-思考-共鸣" class="headerlink" title="价值 思考 共鸣"></a>价值 思考 共鸣</h1><h2 id="简评：你认为这个问题是一个好的面试题吗？"><a href="#简评：你认为这个问题是一个好的面试题吗？" class="headerlink" title="简评：你认为这个问题是一个好的面试题吗？"></a>简评：你认为这个问题是一个好的面试题吗？</h2><ul>
<li>在 JavaScript 中 (a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？</li>
</ul>
<blockquote>
<p>这个问题是国外一位求职者最近在面试一家大型科技公司时遇到的一个问题。</p>
</blockquote>
<blockquote>
<p>他的回答是「不可能」，而面试方说「nothing is impossible」，然后就没有然后了。</p>
</blockquote>
<blockquote>
<p>虽然在实际工作中可能没人会写这样的代码，但题主还是放不下，苦思冥想了两个礼拜，终于还是决定在 Stack Overflow 上寻求解答。</p>
</blockquote>
<blockquote>
<p>大家可以先自己想一想…</p>
</blockquote>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>这里给一个最高赞的答案：</p>
<p>自定义toString（或者valueOf）方法，每次调用改变一次返回值，从而满足判断条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; &#123;</span><br><span class="line">	i: 1,</span><br><span class="line">	toString: function () &#123;</span><br><span class="line">		return a.i++;</span><br><span class="line">		&#x2F;&#x2F;或 return this.i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;</span><br><span class="line">	console.log(&#39;Hello World!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用 == 时，如果两个参数的类型不一样，那么 JS 会尝试将其中一个的类型转换为和另一个相同。在这里左边对象，右边数字的情况下，会首先尝试调用 valueOf（如果可以调用的话）来将对象转换为数字，如果失败，再调用 toString。</p>
</blockquote>
<p>其实，还有很多其他的实现，感兴趣的可以去原问题里看看。</p>
<p>这个问题其实还是能考到对 Javascript 的基本理解的，而不是纯粹为了玩。</p>
<p>其一，对于一个对象做比较有 valueOf/toString 的调用问题。</p>
<p>其二，JS 里一个变量背后经常是一个 function。</p>
]]></content>
      <tags>
        <tag>javscript valueOf 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的语法糖（类）</title>
    <url>/2017/08/15/JavaScript%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%88%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>语法糖(Syntactic sugar),是由Peter J. Landin(和图灵一样的天才人物，是他最先发现了Lambda演算，由此而创立了函数式编程)创造的一个词语，它意指那些没有给计算机语言添加新功能，而只是对人类来说更“甜蜜”的语法。语法糖往往给程序员提供了更实用的编码方式，有益于更好的编码风格，更易读。不过其并没有给语言添加什么新东西。</p>
<p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：代码更简洁流畅，代码更语义自然… 写得爽，看着爽，就像吃了糖。效率高，错误少… 我觉着 js 里的对象原型继承有点「咸」，不然 ES6 也不会急着加糖（纯吐槽）简单说，语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。</p>
<p>听到了面向对象，可能很多人觉得很兴奋，毕竟现在JS是稳稳前十的计算机语言，随着全栈时代的到来，JS的市场日益壮大，不过，说到类，JS还真是与众不同。<br>JS刚开始是一个脚本语言，并没有像C++，JAVA，PHP这样正统的类，JS的类，只是基于原型的语法糖，所以，理解上，还是会有点别扭。</p>
<a id="more"></a>

<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>JS中的类，一般使用函数作为载体而存在，而JS中函数又是对象，所以这里温习一下对象的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;对象的直接量</span><br><span class="line">var Biology_1 &#x3D; &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;new来创建</span><br><span class="line">var Biology_2 &#x3D; new Object();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Object.create()创建,es5以上支持</span><br><span class="line">var Biology_3 &#x3D; Object.create(null);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与此同时，顺便提下三个词：</p>
</blockquote>
<ul>
<li>prototype 实例指向原型，构造函数指向原型。</li>
<li>construtor 原型指向构造函数。该构造函数的原型指向Object，而该Object的的construtor 又指回该构造函数。或者又说，属性返回对创建此对象的数组函数的引用。</li>
<li><strong>proto</strong> 实例指向构造函数的原型（其中，如果原型是Object,则它的<strong>proto</strong> 指向function,而该function的<strong>proto</strong> 又指向Object）。</li>
<li>听着有点绕，看看实例就明白了。</li>
</ul>
<p>想必听过诸多所谓类创建的模式，无非是使用函数与对象模拟：</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology(name) &#123;</span><br><span class="line">    var tempObj &#x3D; new Object();</span><br><span class="line">    tempObj.name &#x3D; name;</span><br><span class="line">    tempObj.printName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return tempObj;</span><br><span class="line">&#125;</span><br><span class="line">var animals &#x3D; Biology(&#39;animals&#39;);</span><br><span class="line">var plants &#x3D; Biology(&#39;plants&#39;);</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals</span><br><span class="line">plants.printName();&#x2F;&#x2F;plants</span><br><span class="line">animals.constructor;&#x2F;&#x2F;function Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实是实例化Object，缺点是无法识别对象类型</p>
</blockquote>
<h2 id="构造模式"><a href="#构造模式" class="headerlink" title="构造模式"></a>构造模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.printName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var animals &#x3D; new Biology(&#39;animals&#39;);</span><br><span class="line">var plants &#x3D; new Biology(&#39;plants&#39;);</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals</span><br><span class="line">plants.printName();&#x2F;&#x2F;plants</span><br><span class="line">animals.constructor;&#x2F;&#x2F;function Biology(name)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造函数的方式，实现对象类型识别,不过性能或封装性差</p>
</blockquote>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology() &#123;&#125;;</span><br><span class="line">Biology.prototype.name &#x3D; &#39;biology&#39;;</span><br><span class="line">Biology.prototype.printName &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var animals &#x3D; new Biology();</span><br><span class="line">animals.printName();&#x2F;&#x2F;biology</span><br><span class="line">var plants &#x3D; new Biology();</span><br><span class="line">plants.printName();&#x2F;&#x2F;biology</span><br><span class="line"> </span><br><span class="line">console.log(animals.name);&#x2F;&#x2F;biology</span><br><span class="line">animals.name &#x3D; &#39;animals&#39;;</span><br><span class="line">console.log(animals.name);&#x2F;&#x2F;animals</span><br><span class="line">console.log(plants.name);&#x2F;&#x2F;biology</span><br><span class="line">animals.printName &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;animals&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals</span><br><span class="line">plants.printName();&#x2F;&#x2F;biology</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原型的属性方法是所有实例共享的，而如果实例属性（方法）与原型属性（方法）重复时，优先实例属性（方法），其中有个hasOwnProperty用来判断是否实例属性。</p>
</blockquote>
<p>因为上述例子中，使用Biology.prototype.name,Biology.prototype.printName这样的直接修改，过于分散与重复，于是我们进行一个合并：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology() &#123;&#125;;</span><br><span class="line">Biology.prototype &#x3D; &#123;</span><br><span class="line">    name : &#39;biology&#39;,</span><br><span class="line">    printName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var biology &#x3D; new Biology();</span><br><span class="line">console.log(biology.name);&#x2F;&#x2F;biology</span><br><span class="line">console.log(biology.constructor);&#x2F;&#x2F;function Object() &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>合并后，看起来没什么问题，不过biology的构建函数不再是Biology，那并不是我们想要的。所以把构建函数指回Biology</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology() &#123;&#125;;</span><br><span class="line">Biology.prototype &#x3D; &#123;</span><br><span class="line">    constructor : Biology,</span><br><span class="line">    name : &#39;biology&#39;,</span><br><span class="line">    printName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var biology &#x3D; new Biology();</span><br><span class="line">console.log(biology.name);&#x2F;&#x2F;biology</span><br><span class="line">console.log(biology.constructor);&#x2F;&#x2F;function Biology() &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>已经如我们所愿，这是因为创建一个函数，同是会创建他的prototype对象，同时这对象自动获得constructor，重写prototype时，constructor不再指向原Biology。</p>
</blockquote>
<p>那如果实例化之后修改原型，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology() &#123;&#125;;</span><br><span class="line">var biology &#x3D; new Biology();</span><br><span class="line">Biology.prototype &#x3D; &#123;</span><br><span class="line">    constructor : Biology,</span><br><span class="line">    name : &#39;biology&#39;,</span><br><span class="line">    printName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(biology.name);&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>
<blockquote>
<p>undefined!，你没有看错。<br>如之前所说，同时，因为实例指向的是原型，而不是构造函数，所以，如果在实例化之后原型有变化，原来的实例指向的还是旧原型</p>
</blockquote>
<p>不过总的来说，原型模式如果修改的原型属性或方法，之后的创建的实例都会变化，没有隐私而言，所以还有改进空间</p>
<h2 id="构造模式与原型模式组合"><a href="#构造模式与原型模式组合" class="headerlink" title="构造模式与原型模式组合"></a>构造模式与原型模式组合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology(age) &#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;;</span><br><span class="line">Biology.prototype &#x3D; &#123;</span><br><span class="line">    constructor : Biology,</span><br><span class="line">    name        : &#39;biology&#39;,</span><br><span class="line">    printAll   : function()&#123;</span><br><span class="line">        console.log(this.name + &#39;:&#39; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var biology_1 &#x3D; new Biology(16);</span><br><span class="line">var biology_2 &#x3D; new Biology(18);</span><br><span class="line">biology_1.printAll();&#x2F;&#x2F;biology:16</span><br><span class="line">biology_2.printAll();&#x2F;&#x2F;biology:18</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把共享部分使用原型，不公享部分使用构造，本方法比较常见</p>
</blockquote>
<p>其他像的模式还有很多，像什么动态原型模式、寄生构造函数模式，原理上都是使用上述方式自由组合，就不一一列举了。</p>
<h1 id="类的属性与方法"><a href="#类的属性与方法" class="headerlink" title="类的属性与方法"></a>类的属性与方法</h1><p>比较Java，类有私有属性，公共属性，私有方法，公共方法，静态属性，静态方法，可惜在JS没有这些好东西，不过，我们知道JS中var有作用域以及原型的概念，所以我们可以模拟出这些东西。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology()&#123;</span><br><span class="line">    &#x2F;&#x2F;私有方法</span><br><span class="line">    function privateMethod()&#123;</span><br><span class="line">        return &#39;私有方法&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;私有属性</span><br><span class="line">    var privateProperty &#x3D; &#39;私有属性&#39;;</span><br><span class="line">    &#x2F;&#x2F;公共属性</span><br><span class="line">    this.publicProperty &#x3D; &#39;公共属性&#39;;</span><br><span class="line">    &#x2F;&#x2F;静态属性</span><br><span class="line">    Biology.prototype.staticProperty &#x3D; &#39;静态属性&#39;;</span><br><span class="line">    &#x2F;&#x2F;私有方法</span><br><span class="line">    &#x2F;*function privateMethod()&#123;</span><br><span class="line">        return &#39;私有方法&#39;;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    var privateMethod &#x3D; function()&#123;</span><br><span class="line">        return &#39;私有方法&#39;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;公共方法</span><br><span class="line">    this.publicMethod &#x3D; function()&#123;</span><br><span class="line">        return &#39;公共方法&#39;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;静态方法</span><br><span class="line">    Biology.prototype.staticMethod &#x3D; function()&#123;</span><br><span class="line">        return &#39;静态方法&#39;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;获得私有属性</span><br><span class="line">    this.getPrivateProperty &#x3D; function()&#123;</span><br><span class="line">        return privateProperty;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;设置私有属性</span><br><span class="line">    this.setPrivateProperty &#x3D; function(property)&#123;</span><br><span class="line">        privateProperty &#x3D; property;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;执行私有方法</span><br><span class="line">    this.getPrivateMethod &#x3D; function()&#123;</span><br><span class="line">        return privateMethod();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var biology &#x3D; new Biology();</span><br><span class="line">var biology_2 &#x3D; new Biology();</span><br><span class="line"> </span><br><span class="line">console.log(biology.privateProperty);&#x2F;&#x2F;undefined</span><br><span class="line"> </span><br><span class="line">console.log(biology.publicProperty);&#x2F;&#x2F;公共属性</span><br><span class="line">biology.publicProperty &#x3D; &#39;修改后的公共属性&#39;;</span><br><span class="line">console.log(biology.publicProperty);&#x2F;&#x2F;修改后的公共属性</span><br><span class="line">console.log(biology_2.publicProperty);&#x2F;&#x2F;公共属性</span><br><span class="line"> </span><br><span class="line">console.log(biology.getPrivateProperty());&#x2F;&#x2F;私有属性</span><br><span class="line">biology.setPrivateProperty(&#39;改变后的私有属性&#39;);</span><br><span class="line">console.log(biology.getPrivateProperty());&#x2F;&#x2F;改变后的私有属性</span><br><span class="line">console.log(biology_2.getPrivateProperty());&#x2F;&#x2F;私有属性</span><br><span class="line">console.log(privateProperty);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(biology.privateProperty);&#x2F;&#x2F;underfined</span><br><span class="line"> </span><br><span class="line">console.log(biology.staticProperty);</span><br><span class="line">Biology.prototype.staticProperty &#x3D; &#39;修改后的静态属性&#39;;</span><br><span class="line">console.log(biology.staticProperty);</span><br><span class="line">console.log(biology_2.staticProperty);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">console.log(biology.privateMethod);&#x2F;&#x2F;undefined</span><br><span class="line">console.log(biology.publicMethod());&#x2F;&#x2F;公共方法</span><br><span class="line">console.log(biology.getPrivateMethod());&#x2F;&#x2F;私有方法</span><br><span class="line"> </span><br><span class="line">console.log(biology.staticMethod());</span><br><span class="line">Biology.prototype.staticMethod &#x3D; function()&#123;</span><br><span class="line">    return &#39;修改后的静态方法&#39;;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(biology.staticMethod());&#x2F;&#x2F;修改后的静态方法</span><br><span class="line">console.log(biology_2.staticMethod());&#x2F;&#x2F;修改后的静态方法</span><br></pre></td></tr></table></figure>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">Biology.prototype &#x3D; &#123;</span><br><span class="line">    constructor : Biology,</span><br><span class="line">    printName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function Animals()&#123;&#125;;</span><br><span class="line">Animals.prototype &#x3D; new Biology(&#39;animals&#39;);</span><br><span class="line">var animals &#x3D; new Animals();</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals</span><br></pre></td></tr></table></figure>
<p>不过，为了便于使用与理解，我们一般会换成形式写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Biology &#x3D; &#123;</span><br><span class="line">    name : &#39;I am Biology&#39;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;继承parent</span><br><span class="line">function inherit(parent)&#123;</span><br><span class="line">    var type &#x3D; typeof parent;</span><br><span class="line">    if(!(type &#x3D;&#x3D;&#x3D; &#39;object&#39; || type &#x3D;&#x3D;&#x3D; &#39;function&#39;)) throw TypeError;</span><br><span class="line">    if(Object.create)&#123;</span><br><span class="line">        return Object.create(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    function temp() &#123;&#125;;</span><br><span class="line">    temp.prototype &#x3D; parent;</span><br><span class="line">    return new temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var animals &#x3D; inherit(Biology);</span><br><span class="line"> </span><br><span class="line">console.log(animals.name);&#x2F;&#x2F;I am Biology</span><br></pre></td></tr></table></figure>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造函数继承</span><br><span class="line">function Biology(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line">function Animals(name,age)&#123;</span><br><span class="line">    this.temp &#x3D; Biology;</span><br><span class="line">    this.temp(name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.printAll &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name + &#39;:&#39; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animals &#x3D; new Animals(&#39;animals&#39;,16);</span><br><span class="line">animals.printAll();&#x2F;&#x2F;animals:16</span><br></pre></td></tr></table></figure>
<h2 id="apply-call继承"><a href="#apply-call继承" class="headerlink" title="apply,call继承"></a>apply,call继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Biology(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.printName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Animals(age)&#123;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    Biology.call(this,age);</span><br><span class="line">&#125;</span><br><span class="line">function Plants(address)&#123;</span><br><span class="line">    this.address &#x3D; address;</span><br><span class="line">    Biology.apply(this,[address]);</span><br><span class="line">&#125;</span><br><span class="line">var animals &#x3D; new Animals(&#39;animals&#39;,16);</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals</span><br><span class="line">var plants &#x3D; new Plants(&#39;plants&#39;,&#39;深圳&#39;);</span><br><span class="line">plants.printName();&#x2F;&#x2F;plants</span><br></pre></td></tr></table></figure>
<h1 id="ES6类"><a href="#ES6类" class="headerlink" title="ES6类"></a>ES6类</h1><p>ES6则在上面基础上，增加了像class,extends,super等面向对象关键字，在写法上简化了类的写法，然后，这些关键字也是在之前的基础上模拟出来的，并且与原型息息相关，甚至有时带来更多的问题。</p>
<p>下面这个例子，简单的对ES6对类进行阐述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Biology &#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    printName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    static printNameTwice()&#123;</span><br><span class="line">        console.log(this.name + &#39;,&#39; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var biology &#x3D; new Biology(&#39;biology&#39;);</span><br><span class="line">biology.printName();&#x2F;&#x2F;biology</span><br><span class="line">Biology.printNameTwice();&#x2F;&#x2F;biology,biology</span><br><span class="line"> </span><br><span class="line">class Animals extends Biology &#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    printAll()&#123;</span><br><span class="line">        console.log(this.name + &#39;:&#39; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">    printName()&#123;</span><br><span class="line">        console.log(&#39;animals name&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return this._name.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    set name(name) &#123;</span><br><span class="line">        this._name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animals &#x3D; new Animals(&#39;animals&#39;,16);</span><br><span class="line">console.log(animals.name);&#x2F;&#x2F;ANIMALS</span><br><span class="line">console.log(animals._name);&#x2F;&#x2F;animals</span><br><span class="line">animals.printName();&#x2F;&#x2F;animals name</span><br><span class="line">animals.printAll();&#x2F;&#x2F;ANIMALS:16</span><br><span class="line">Animals.printNameTwice();&#x2F;&#x2F;Animals,Animals</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript 语法糖 类</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript运算符优先级和隐式转换</title>
    <url>/2018/12/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>昨天圣诞节，本应该是一个开心的日子，但对有些程序猿来说，是非常糟糕的一天。在很多技术开发群里，在技术论坛以及github社区都炸天了。我想说的是，使用开源的人，得有感激之心，但是贡献开源的人更应该要有敬畏之心。我们要感谢每一个开源的人，他们为这个世界贡献了自己的力量，为这个社会提高了效率，而开源的人也应该怀有敬畏之心，尊重每一个使用者，更好地回馈使用者，使用者和开源这相互成就。</p>
<p>好了，话说回来，今天看了一篇文章，其中有一个题目感觉非常有趣，我也给大家送一个彩蛋吧，其中也引发了我对JavaScript运算符和隐式转换的思考了，所以还是坐下来静下心把JavaScript的运算符和隐式转换学习总结了一下，但其中难免会有些错误，不喜勿喷啊！</p>
<p>先贴个彩蛋：</p>
<p><code>(&#123;&#125;+[])[[~!+[]]*~+[]]+(!(~+[])+&#123;&#125;)[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]</code></p>
<p>各位童鞋，你算出来了吗？点击后将揭晓答案哦！当然，等不及的童鞋肯定自己在控制台复制粘贴得出结果了吧，呵呵！</p>
<a id="more"></a>

<p>答案就是：</p>
<p><img src="https://i.loli.net/2021/01/11/R1FUlkQwyqS4ZDH.png" alt="img"></p>
<p>哈哈，是不是被骂了还在问人这段代码是什么意思呢？</p>
<p>我来告诉你：</p>
<p>这段代码为什么会输出sb呢？其实这段代码考的是js的类型转化的一些基本原理。</p>
<p>首先要运用到的第一个知识就是js运算符的优先级，因为这么长一段运算看的人眼花，我们必须得先根据优先级分成n小段，然后再各个击破。</p>
<h1 id="js运算符的优先级"><a href="#js运算符的优先级" class="headerlink" title="js运算符的优先级"></a>js运算符的优先级</h1><p>优先级的排列如下表，优先级从高到低：</p>
<p><img src="https://i.imgur.com/b834A7c.jpg"></p>
<p>根据此规则，我们把这一串运算分为以下表达式：</p>
<p><img src="https://i.imgur.com/cdDv5jr.png"></p>
<p>其实中括号[]也是一个运算符，用来通过索引访问数组项，另外也可以访问字符串的子字符，有点类似charAt方法，如：’abcd’[1] // 返回’b’。而且中括号的优先级还是最高的哦。</p>
<p>接下来需要运用的就是JavaScript的类型转化知识了，我们先说说什么情况下需要进行类型转化。当操作符两边的操作数类型不一致或者不是基本类型（也叫原始类型）时，需要进行类型转化。</p>
<p>让我们快速的复习一下，在JavaScript中，一共有两种类型的值：原始值(primitives)和对象值(objects)。</p>
<p>原始值有：undefined、null、布尔值(booleans)、数字(numbers)、还有字符串(strings)。</p>
<p>其他的所有值都是对象类型的值，包括数组(arrays)和函数(functions)。</p>
<h1 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h1><p>先按运算符来分一下类：</p>
<p>减号-，乘号*，肯定是进行数学运算，所以操作数需转化为number类型。</p>
<p>加号+，可能是字符串拼接，也可能是数学运算，所以可能会转化为number或string。</p>
<p>一元运算，如+[]，只有一个操作数的，转化为number类型。</p>
<p>下面来看一下转化规则。</p>
<h2 id="对于非原始类型的，通过ToPrimitive-将值转换成原始类型"><a href="#对于非原始类型的，通过ToPrimitive-将值转换成原始类型" class="headerlink" title="对于非原始类型的，通过ToPrimitive()将值转换成原始类型"></a>对于非原始类型的，通过ToPrimitive()将值转换成原始类型</h2><p><code>ToPrimitive(input, PreferredType?)</code></p>
<p>可选参数PreferredType是Number或者是String。返回值为任何原始值。</p>
<p>如果PreferredType是Number，执行顺序如下：</p>
<ol>
<li><p>如果input为primitive，返回；</p>
</li>
<li><p>如果input为Object。调用obj.valueOf()，如果结果是primitive，返回；</p>
</li>
<li><p>否则，调用obj.toString()，如果结果是primitive，返回；</p>
</li>
<li><p>否则，抛出TypeError。</p>
</li>
</ol>
<p>如果 PreferredType是String，步骤2跟3互换，如果PreferredType没有，Date实例被设置成String，其他都是Number。</p>
<h2 id="通过ToNumber-将值转换为数字"><a href="#通过ToNumber-将值转换为数字" class="headerlink" title="通过ToNumber()将值转换为数字"></a>通过ToNumber()将值转换为数字</h2><p>通过ToNumber()把值转换成Number，直接看ECMA 9.3的表格：</p>
<p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,Number)将该对象转换为原始值，然后在调用ToNumber()将这个原始值转换为数字。</p>
<h2 id="通过ToString-将值转换为字符串"><a href="#通过ToString-将值转换为字符串" class="headerlink" title="通过ToString()将值转换为字符串"></a>通过ToString()将值转换为字符串</h2><p>通过ToString()把值转化成字符串， 直接看ECMA 9.8的表格</p>
<p><img src="https://i.imgur.com/9hKHPCu.jpg"></p>
<p>如果输入的值是一个对象，则会首先会调用ToPrimitive(obj,String)将该对象转换为原始值，然后再调用ToString()将这个原始值转换为字符串.规则就这么多，接下来实践一下，根据我们上面划分出的子表达式，一步一步将这个神奇的代码给执行出来。开工~</p>
<p>先看最简单的子表达式：</p>
<p><code>+[]</code></p>
<p>只有一个操作数[]，肯定是转化为number了，根据上面的规则2，[]是个数组，object类型，即对象。所以得先调用toPrimitive转化为原始类型，并且PreferredType为number，这个参数表示更“倾向于”转化的类型，这里肯定是number了。然后首先调用数组的valueOf方法，数组调用valueOf会返回自身，</p>
<p>这个时候，我们得到一个空串“”，还没有结束，看上面的规则2描述，继续调用toNumber，转化为number类型，大功告成！子表达式16转化完毕，+[]，最终得到0。</p>
<p>来看子表达式：</p>
<p><code>[~+&quot;&quot;]</code></p>
<p>空串””前面有两个一元操作符，但是操作数还是只有一个，所以，最终要转化为的类型是number。看规则2吧，空串调用toNumber得到0。接下来是<del>，这是个什么东东呢？它是位运算符，作用可以记为把数字取负然后减一，所以</del>0就是-1 。</p>
<p>别忘了，这个子表达式外头还包着中括号，所以最终的值为[-1]，即一个数组，里面只有一个元素-1.</p>
<p>接下来看子表达式就简单了</p>
<p>把以上求出来的填进去，就变成了这样：–[-1][0]，取数组的第0个元素，然后自减，结果为-2，是不so easy!</p>
<p>继续往后走，子表达式：</p>
<p><code>[~+[]]</code></p>
<p>其实把上面的原理用上就非常明显了，答案[-1]。</p>
<p>继续，此刻它已变成：-2*[-1]，有稍许不一样，不过没关系，我们还是按照规则来，运算符是乘号*，当然是做数学运算，那后面的[-1]就得转化为number，过程如下：</p>
<ol>
<li><p>调用toPrimitive，发现是object类型</p>
</li>
<li><p>调用valueOf，返回自身[-1]</p>
</li>
<li><p>因为不是原始类型，继续调用toString，返回”-1”</p>
</li>
<li><p>“-1”是原始类型了，然后调用toNumber，返回-1</p>
</li>
<li><p>与-2相乘，返回2</p>
</li>
</ol>
<p>子表达式：</p>
<p><code>~~!+[]</code></p>
<p>不多说了，答案1。就是从右往左依次一元计算。</p>
<p>此刻它已经长这样了：2+1， 好，我不多说了。</p>
<p>继续看表达式：</p>
<p><code>!(~+[])，~+[]=-1</code></p>
<p>这个根据上面已经知道了，那!-1是什么呢？这里要说一下这个感叹号，它是逻辑取非的意思，会把表达式转化为布尔类型，转化规则和js的Truthy和Falsy原则是一样的，后面跟数字的，除0以外都为false，后面跟字符串的，除空串以外都为false。这里的!-1当然就是false了。</p>
<p>接下来这个表达式3：false+{}有点关键</p>
<p>一个布尔加一个对象，那这个{}应该先转化为原始类型，流程如下：</p>
<ol>
<li><p>调用toPrimitive，发现是object类型</p>
</li>
<li><p>调用valueOf，返回自身{}，</p>
</li>
<li><p>不是原始类型，调用toString，返回</p>
</li>
<li><p>[objectObject]</p>
</li>
<li><p>false与[objectObject]相加，false先转化为字符串”false”</p>
</li>
</ol>
<p>相加得结果false[objectObject] 此时它是这样的：false[objectObject][3]，因为这个[]可以取字符串的子字符，像charAt一样，所以得到了结果”s”</p>
<p>经过上面艰难的流程，我们拿到了字符”s”，也就是那张图的左半边，剩下的那个”b”，相同的原理可以搞出来，我这里就不一一演示了，留给你练练吧~</p>
<p>回顾一下这个过程其实也不复杂，只是有一些需要重复劳动的，只要你掌握了运算的优先级，能把大串分解成一个个小串，然后运用类型转化的知识挨个处理就搞定了。怎么样，看到这里你还觉得神奇吗？</p>
<p>同样的，中文字符也是由这样组成的，跟英文同样的道理。</p>
<h1 id="操作符也会影响数据的类型转换"><a href="#操作符也会影响数据的类型转换" class="headerlink" title="操作符也会影响数据的类型转换"></a>操作符也会影响数据的类型转换</h1><ol>
<li><p>当+号作为一元操作符操作单操作数的时候，他就会将这个数转换为数字类型</p>
</li>
<li><p>当+号作为二元操作符时，如果两个操作数中存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串</p>
</li>
<li><p>当+号作为二元操作符时，如果两个操作数一个都不是字符串的话，两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作</p>
</li>
<li><p>当算数运算的操作符是+号以外的其他操作数时，两个操作数都会转成数字类型进行数字运算。</p>
</li>
</ol>
<h1 id="引用对象如何转换为简单值"><a href="#引用对象如何转换为简单值" class="headerlink" title="引用对象如何转换为简单值"></a>引用对象如何转换为简单值</h1><ol>
<li><p>一个复杂对象在转为基础类型的时候会调用ToPrimitive(hint)方法来指定其目标类型</p>
</li>
<li><p>如果传入的hint值为number,那么就先调用对象的valueOf()方法，调用完valueOf()方法后，如果返回的是原始值，则结束ToPrimitive操作</p>
</li>
<li><p>如果返回的不是原始值，则继续调用对象的toString()方法，调用完toString()方法之后如果返回的是一个原始值，则结束ToPrimitive操作</p>
</li>
<li><p>如果返回的还是复杂值，则抛出异常。如果传入的hint值为string，则先调用toString()方法，再调用valueOf()方法，其余的过程一样。</p>
</li>
</ol>
<h1 id="那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？"><a href="#那么复杂对象是以什么标准来判断ToPrimitive-hint-操作传入的hint值到底是number还是string呢？" class="headerlink" title="那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？"></a>那么复杂对象是以什么标准来判断ToPrimitive(hint)操作传入的hint值到底是number还是string呢？</h1><ol>
<li><p>如果运行环境非常明确的需要将一个复杂对象转换为数字则传入number如 Number(value) 和 +value 则传入number</p>
</li>
<li><p>如果运行环境非常明确的需要将一个复杂对象转换为字符串则传入string如String(value) 和 alert(value) 则传入string</p>
</li>
<li><p>如果是用+号连接两个操作数，操作数在确定确定其中只要有一个为字符串的时候另外一个操作数会转为字符串，ToPrimitive()会传入string，但是如果两个操作数都不能确定是字符串的时候则默认传入number(Date对象是一个例外，它会默认传入string)进行数据类型转换。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript 运算符 优先级 隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript难点笔记</title>
    <url>/2018/03/22/JavaScript%E9%9A%BE%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天重新回顾了一下JavaScript，以下内容是我平时的学习笔记和其它参考资料整理完善后的内容，都是常用的，使用频率比较高，自己必须得精通的知识点的总结，便于以后再复习参考。</p>
<a id="more"></a>

<h1 id="JavaScript原型与原型链"><a href="#JavaScript原型与原型链" class="headerlink" title="JavaScript原型与原型链"></a>JavaScript原型与原型链</h1><h2 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h2><blockquote>
<p>自定义对象时，以构造函数为模板，对象的属性和方法，可以定义在构造函数内部。每当获取对象时都会在内存中创建新的对象属性和方法，这既是增加页面代码量又很浪费内存。</p>
</blockquote>
<p>同一个构造函数的对象实例之间无法共享属性，而所有的方法都是同样的行为（只是参数不一样），因此必要的属性和公共的方法完全应该共享。但构造函数无法实现这一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Student(name, age)&#123;</span><br><span class="line">	this.name &#x3D; name;</span><br><span class="line">	this.age &#x3D; age;</span><br><span class="line">	this.country &#x3D; &#39;Chinese&#39;;</span><br><span class="line">	this.say &#x3D; function()&#123;</span><br><span class="line">		console.log(&#96;hi,my name is $&#123;this.name&#125; , I am $&#123;this.age&#125; years old&#96;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每当用new关键字实例化对象时，就会声明一个country属性和say方法并为每一个都分配内存，</span><br><span class="line">&#x2F;&#x2F;但实际上country属性和say方法都是一样的，可以公用，这样重复的分配内存很浪费内存</span><br><span class="line">var s1 &#x3D; new Student(&#39;keith&#39;,12);</span><br><span class="line">s1.say();&#x2F;&#x2F;hi,my name is keith,I am 12 years old,I am Chinese</span><br><span class="line">var s2 &#x3D; new Student(&#39;lisa&#39;,11);</span><br><span class="line">s2.say();&#x2F;&#x2F;hi,my name is lisa,I am 11 years old,I am Chinese</span><br></pre></td></tr></table></figure>
<h2 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h2><blockquote>
<p>JavaScript中每一个对象都继承另一个对象，父类对象称之为“原型”(prototype)对象。只有null除外，其他都有自己的原型对象，而原型对象上的所有属性和方法，都能被子类对象继承。通过构造方法生成实例化对象时，会自动生成实例化对象分配原型对象。每一个构造方法都有一个prototype属性，这个属性就是实例化对象的原型对象。</p>
</blockquote>
<blockquote>
<p>还是用上面的栗子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Student(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.age&#x3D;age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;抽离对象的公共属性和公共方法，赋给构造函数的原型对象，这样就只会对该对象的公共属性和公共方法分配一次内存，所有实例化的对象共享这一份，节约了内存，提高了性能</span><br><span class="line">Student.prototype.country &#x3D; &#39;Chinese&#39;;</span><br><span class="line">Student.prototype.say &#x3D; function()&#123;</span><br><span class="line">    console.log(&#96;hi,my name is $&#123;this.name&#125;,I am $&#123;this.age&#125; years old,I am $&#123;this.country&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line">var s1 &#x3D; new Student(&#39;keith&#39;,12);</span><br><span class="line">s1.say();</span><br><span class="line">var s2 &#x3D; new Student(&#39;lisa&#39;,11);</span><br><span class="line">s2.say();</span><br></pre></td></tr></table></figure>
<p>构造函数Student的prototype对象就是实例化对象s1和s2的原型对象。在原型对象上添加一个country属性和say方法，这样实例化的对象都有该属性和方法，实现属性共享。</p>
<p>原型对象的属性不是实例化对象自身的属性，但只要修改原型对象，就会同步体现到所有实例化对象上。</p>
<p>如果实例化对象自身拥有同名的属性或方法，那么原型对象上的属性和方法便会失效，遵循了作用域的就近查找原则。</p>
<blockquote>
<p>总结：原型对象的作用就是定义所有实例化对象共享的属性和方法。这也是被称为原型式继承的原因，而实例化对象可以视作从原型对象派生出来的子对象。</p>
</blockquote>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>对象的属性和方法，有可能是定义在自身内部，也有可能是定义在它的原型对象上，由于原型对象本身也是对象，又有自己的原型链，所以生成了一条原型链。例如，a对象是b对象的原型，b对象是c对象的原型，依此类推。</p>
<p>如果一层层往上找，所有对象的原型最终都可以找到Object对象上，Object对象再往上找就是null了，null没有自己的原型，至此为止了。</p>
<p>附上自己总结JavaScript原型链图一张：</p>
<p><img src="https://i.imgur.com/IvQD884.jpg" alt="函数原型链完整三角形"></p>
<p>注意：一级一级网上找，在原型链寻找某个属性，对性能是有影响的。如果寻找某个不存在的属性将会遍历整个原型链。</p>
<h2 id="原型操作"><a href="#原型操作" class="headerlink" title="原型操作"></a>原型操作</h2><h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>对象有一个constructor属性指向原型对象所在的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(s1.constructor &#x3D;&#x3D;&#x3D; Student.prototype.constructor);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h3 id="设置获取原型对象"><a href="#设置获取原型对象" class="headerlink" title="设置获取原型对象"></a>设置获取原型对象</h3><p><code>Object.getPrototypeOf()</code>方法返回一个对象的原型对象，也就是通过它获取原型对象，这是标准的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(s1));</span><br></pre></td></tr></table></figure>
<p><code>Object.setPrototypeOd()</code>为现有对象设置原型对象，第一个参数是现有对象，第二个是要设置成为原型对象的对象，用这个方法来设置原型对象。</p>
<p><code>__proto__</code>属性：<code>__proto__</code>是<code>prototype</code>在实例上的副本，定义在<code>prototype</code>上的方法能够继承给所有实例，而<code>__proto__</code>只能影响到指定的实例，所以最好不用这个，用<code>Object.getPrototypeOf()</code>来读取，用<code>Object.setPrototypeof()</code>来设置。也就是用这两个方法来对原型对象做读写操作。</p>
<h3 id="获取原型对象的方法"><a href="#获取原型对象的方法" class="headerlink" title="获取原型对象的方法"></a>获取原型对象的方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造函数获取原型对象</span><br><span class="line">console.log(Student.prototype.constructor);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过实例化的对象获取原型对象</span><br><span class="line">console.log(s1.__proto__);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6提供的获取对象的原型对象</span><br><span class="line">console.log(Object.getPrototypeOf(s1));</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>JavaScript有两种作用域：全局作用域和函数作用域（局部作用域）。函数内部可以直接读取全局变量，但是函数外部无法读取函数内部声明的变量。但是，有时候却需要在函数外部访问函数内部的变量或方法；正常情况下，这是无法访问的，只有通过在函数内部返回一个变量或方法来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">	var name &#x3D; &#39;张三&#39;;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line">function Person1()&#123;</span><br><span class="line">	var name &#x3D; &#39;李四&#39;;</span><br><span class="line">	var say &#x3D; function()&#123;</span><br><span class="line">		console.log(name);</span><br><span class="line">	&#125;</span><br><span class="line">	return say;</span><br><span class="line">&#125;</span><br><span class="line">Person();&#x2F;&#x2F;张三</span><br><span class="line">var p &#x3D; Person1();</span><br><span class="line">p();&#x2F;&#x2F;李四</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：函数say可以就在函数Person内部，这时Person函数内部所有的变量对say方法都是可访问的，但是反过来就不行，内部函数中的局部变量对父类函数是不可访问的，这就是JavaScript中特有的链式作用域结构（也可以说词法作用域），子对象会一级一级地向上寻找所有父类对象的变量，所以，父对象的所有变量对子对象都是可见的，反之则不成立。</li>
</ul>
<p>既然say方法可以读取Person中的局部变量，那么只要把say方法作为返回值，我们就可以在Person外部拂去它内部的变量了。</p>
<ul>
<li>重点：</li>
</ul>
<blockquote>
<p>闭包就是上文中的函数say，能读取其它函数内部变量的函数。由于JavaScript中，只要函数内部的子函数才能够读取函数内部的局部变量，因此可以把闭包简单理解成“通过在函数内部返回一个变量或函数来访问其他函数内部的变量”。</p>
</blockquote>
<h2 id="垃圾回收机制及闭包"><a href="#垃圾回收机制及闭包" class="headerlink" title="垃圾回收机制及闭包"></a>垃圾回收机制及闭包</h2><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>在函数内部引入一个变量或者函数时，系统都会开辟一块内存空间；还会将这块内存的引用计数器初始化，初始化值为0；如果外部有全局变量或者程序引用了这块空间，则引用计数器会自动进行+1操作，当函数执行完毕后，变量计数器会重新归零，系统会运行垃圾回收机制，将函数运行产生的数据销毁；如果计数器不是0，则不会清除数据；这过程就是JavaScript的垃圾回收机制；</p>
<p><img src="https://i.imgur.com/zMkIdwk.jpg" alt="JavaScript的垃圾回收机制原理图"></p>
<ul>
<li>用闭包的分析更能体验此原理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func1()&#123;</span><br><span class="line">	var n &#x3D; 100;</span><br><span class="line">	function func2()&#123;</span><br><span class="line">		console.log(++n);</span><br><span class="line">	&#125;</span><br><span class="line">	return func2;</span><br><span class="line">&#125;</span><br><span class="line">var f &#x3D; func();</span><br><span class="line">f();&#x2F;&#x2F;101</span><br><span class="line">f();&#x2F;&#x2F;102</span><br><span class="line">f();&#x2F;&#x2F;103</span><br></pre></td></tr></table></figure>
<p><strong>代码分析（注释）：</strong></p>
<ul>
<li><p>因函数fun1被调用时，返回的结果是fun2函数体，也就是说，fun2函数被当做返回值给fun1的调用者，但是fun2函数并没有在此被调用执行（只是把函数体返回到函数外了）;</p>
</li>
<li><p>因此整个fun1函数体，无法判断子函数fun2会对其产生何种影响，无法判断变量n是否会被使用，即使fun1函数被调用结束，整个fun1函数始终保留在内存中，不会被垃圾回收机制回收；</p>
</li>
<li><p>也就是运行代码发现，函数调用一次（在这里是指fun2），其变量n变化一次；</p>
</li>
<li><p>闭包的最大用处：可以读取函数内部的变量。</p>
</li>
<li><p>让函数内部读取的变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</p>
</li>
<li><p>注意的是，外层函数每次运行，都会生成一个新的闭包，而这个闭包有会保留外层函数的内部变量，所以内存消耗很大；因此不能滥用闭包，否则会造成网页的性能问题。</p>
</li>
</ul>
<h1 id="call和apply方法"><a href="#call和apply方法" class="headerlink" title="call和apply方法"></a>call和apply方法</h1><p><strong>关于JavaScript中的this的指向：</strong></p>
<ol>
<li><p>全局作用域下，this指向window对象</p>
</li>
<li><p>构造函数中，this指向实例化对象</p>
</li>
</ol>
<p><strong>如果要在调用函数是直接修改函数内部的this指向使用call或者apply方法来修改指向。</strong></p>
<ol>
<li>call方法格式：</li>
</ol>
<p>函数名称.call(obj,arg1,arg2,…argN);说明其中：obj是函数内this要指向的对象，arg列表是参数列表，参数与参数之间使用一个逗号隔开</p>
<ol start="2">
<li>apply方法格式：</li>
</ol>
<p>函数名称.apply(obj,[arg1,,arg2,…argN]);说明其中：obj是函数内this要指向的对象，arg列表是参数列表，要求格式为数组</p>
<p><strong>两种修改this指向方法的区别：</strong></p>
<ul>
<li><p>相同点：功能完全一样，都是为了改变函数内部的hits指向，唯一的不同就在于参数传递方式不同</p>
</li>
<li><p>不同点：call方法可能多个参数，第一个要指向的对象，其他参数为函数的实参；apply方法最多只能有两个实参，第一个要指向的对象，第二个是数组，数组内容为函数的实参。</p>
</li>
</ul>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>前端中的定时器方法是浏览器提供的，并不是ECMAScript规范中的。是window对象的方法。</p>
<p><strong>JavaScript提供定时执行代码的功能叫做定时器；</strong></p>
<ol>
<li><p><code>setTimeout()</code>:用来指定某个函数或某代码，在多少秒之后执行。</p>
</li>
<li><p><code>setInterval()</code>:指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
</li>
</ol>
<blockquote>
<p><code>setTimeout()</code>,<code>setInterval()</code>的第一个参数都是指定执行的函数名称或者代码段，第二个参数是时间：</p>
</blockquote>
<p>这两个方法的参数是一模一样的：</p>
<ol>
<li><p>正常使用的话，至少需要有两个参数。【这一条可以忽略】</p>
</li>
<li><p>不想出现报错的话，至少必须得一个参数。</p>
</li>
<li><p>都可以传递无数个参数。</p>
</li>
<li><p>第一个参数是要执行的js语句，有三种以上的情况</p>
</li>
<li><p>1 字符串：”console.log(‘I am Pelli’);”【可读性差，推荐指数：1/10】</p>
</li>
<li><p>2 匿名函数:function(){console.log(“I am Pelli”)}【可读性强，推荐指数：8/10】</p>
</li>
<li><p>3 函数名:showName【可读性强,耦合度低，可装逼，推荐指数：9/10】</p>
</li>
<li><p>4 其他乱七八糟的内容【非正常程序员干的事情】</p>
</li>
<li><p>第二参数是用来描述时间，以毫秒为单位。有一种以上的情况</p>
</li>
<li><p>1 数值【正常情况下】</p>
</li>
<li><p>2数值以外的其他数据类型【异类程序员干的事情】</p>
</li>
<li><p>如果第一个参数为函数，那么从第三个参数开始到最后一个参数就是该函数的实参</p>
</li>
</ol>
<blockquote>
<p>关于JavaScript定时器，可以说的东西太多了，这里暂时先介绍到这里。下面留几个面试题，大家欣赏一下。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.下面的代码输出名字的顺序是什么？</span><br><span class="line">console.log(&quot;小明&quot;);</span><br><span class="line">var myname &#x3D; setTimeout(function()&#123;</span><br><span class="line">    console.log(&quot;小华&quot;);</span><br><span class="line">&#125;,0);</span><br><span class="line">console.log(&quot;小丽&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.下面的代码，会弹出什么内容？</span><br><span class="line">var alert_things &#x3D; setTimeout(function()&#123;</span><br><span class="line">    alert(&quot;Pelli&quot;);</span><br><span class="line">&#125;,2000);</span><br><span class="line">while(true)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.下面的代码，会输出什么？</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;,1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4.下面的代码，会输出什么？</span><br><span class="line">for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">     setTimeout(function() &#123;</span><br><span class="line">         console.log(i);</span><br><span class="line">     &#125;, 0);</span><br><span class="line">     console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5.下面的代码，会弹出哪些东西？</span><br><span class="line">var len&#x3D;4;</span><br><span class="line">while(len--)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        alert(len);</span><br><span class="line">    &#125;,0);</span><br><span class="line">    alert(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6.下面的代码是什么结果？</span><br><span class="line">var timer &#x3D; setInterval(function()&#123;</span><br><span class="line">    console.log(&quot;hello world&quot;);</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">clearInterval(timer);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 7.下面的代码会弹出什么？</span><br><span class="line">var t &#x3D; true;</span><br><span class="line">window.setTimeout(function ()&#123;</span><br><span class="line">    t &#x3D; false;</span><br><span class="line">&#125;,0);</span><br><span class="line">while (t)&#123;&#125;</span><br><span class="line">alert(&#39;end&#39;);</span><br></pre></td></tr></table></figure>
<p><strong>另外有一些开发过程中的最佳实践：</strong></p>
<ol>
<li><p>setTimeout和setInterval的第一个参数不建议传递字符串，传递字符串和eval有一样的问题，会造成性能方面的问题，甚至引起安全问题。</p>
</li>
<li><p>建议用setTimeout模拟setInterval，不建议使用setInterval。页面中setTimeout和clearTimeout不配合使用基本上不会出现问题，因为setTimeout只执行一次，不会造成累加的问题，使用setInterval的话，强烈建议在适当时候使用clearInterval，在这种情况，很容易出现问题。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Javascript JS ES6 干货</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级函数-----惰性函数</title>
    <url>/2018/06/10/JavaScript%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0-----%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>惰性函数很好理解，假如同一个函数被大量范围，并且这个函数内部又有许多判断来来检测函数，这样对于一个调用会浪费时间和浏览器资源，所有当第一次判断完成后，直接把这个函数改写，不在需要判断。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createXHR()&#123;</span><br><span class="line">     var xmlhttp;</span><br><span class="line">     try&#123;</span><br><span class="line">          &#x2F;&#x2F;firfox,opear,safari</span><br><span class="line">          xmlHttp&#x3D;new XMLHttpRequest();</span><br><span class="line">     &#125;catch(e)&#123;</span><br><span class="line">          try&#123;</span><br><span class="line">               xmlHttp&#x3D;new ActiveXobject(&#39;Msxm12.XMLHTTP&#39;);</span><br><span class="line">          &#125;catch (e)&#123;</span><br><span class="line">               try&#123;</span><br><span class="line">                    xmlHttp&#x3D;new ActiveXobject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">               &#125;catch(e)&#123;</span><br><span class="line">                 alert(&quot;您的浏览器不支持AJAX&quot;)</span><br><span class="line">                  return false;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return xmlHttp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">惰性函数写法</span><br><span class="line"></span><br><span class="line">function createXHR()&#123;</span><br><span class="line">     var xhr&#x3D;null;</span><br><span class="line">     if(typeof XMLHttpRequest!&#x3D;&#39;undefined&#39;)&#123;</span><br><span class="line">          xhr&#x3D;new XMLHttpRequest();</span><br><span class="line">         createXHR&#x3D;function()&#123;</span><br><span class="line">               return XMLHttpRequest();  &#x2F;&#x2F;直接返回一个懒函数，这样不必在往下走</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          try&#123;</span><br><span class="line">               xhr&#x3D;new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">              createXHR&#x3D;function()&#123;</span><br><span class="line">                    return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;catche(e)&#123;</span><br><span class="line">               try&#123;</span><br><span class="line">                    xhr &#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">                    createXHR&#x3D;function()&#123;</span><br><span class="line">                         return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;catch(e)&#123;</span><br><span class="line">                    createXHR&#x3D;function()&#123;</span><br><span class="line">                         return null</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;        </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript 高级函数 惰性 惰性函数</tag>
      </tags>
  </entry>
  <entry>
    <title>React创建组件的三种方式及其区别</title>
    <url>/2017/08/13/React%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 函数式定义的无状态组件</span><br><span class="line">2. es5原生方式React.createClass定义的组件</span><br><span class="line">3. es6形式的extends React.Component定义的组件</span><br></pre></td></tr></table></figure>
<p>虽然有三种方式可以定义react的组件，那么这三种定义组件方式有什么不同呢？或者说为什么会出现对应的定义方式呢？下面就简单介绍一下。</p>
<a id="more"></a>

<h2 id="无状态函数式组件"><a href="#无状态函数式组件" class="headerlink" title="无状态函数式组件"></a>无状态函数式组件</h2><p>创建无状态函数式组件形式是从React 0.14版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。具体的无状态函数式组件，其官方指出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无状态函数式组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无state状态的。具体的创建形式如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function HelloComponent(props, &#x2F;* context *&#x2F;) &#123;</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;HelloComponent name&#x3D;&quot;Sebastian&quot; &#x2F;&gt;, mountNode) </span><br></pre></td></tr></table></figure>
<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>
<ol>
<li>组件不会被实例化，整体渲染性能得到提升<br>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</li>
<li>组件不能访问this对象<br>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件</li>
<li>组件无法访问生命周期的方法<br>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</li>
<li>无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用。</li>
</ol>
<blockquote>
<p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p>
</blockquote>
<h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h2><blockquote>
<p><code>React.createClass</code>是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var InputControlES5 &#x3D; React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;&#x2F;&#x2F;定义传入props中的属性各种类型</span><br><span class="line">        initialValue: React.PropTypes.string</span><br><span class="line">    &#125;,</span><br><span class="line">    defaultProps: &#123; &#x2F;&#x2F;组件默认的props对象</span><br><span class="line">        initialValue: &#39;&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 设置 initial state</span><br><span class="line">    getInitialState: function() &#123;&#x2F;&#x2F;组件相关的状态对象</span><br><span class="line">        return &#123;</span><br><span class="line">            text: this.props.initialValue || &#39;placeholder&#39;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleChange: function(event) &#123;</span><br><span class="line">        this.setState(&#123; &#x2F;&#x2F;this represents react component instance</span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Type something:</span><br><span class="line">                &lt;input onChange&#x3D;&#123;this.handleChange&#125; value&#x3D;&#123;this.state.text&#125; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">InputControlES6.propTypes &#x3D; &#123;</span><br><span class="line">    initialValue: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line">InputControlES6.defaultProps &#x3D; &#123;</span><br><span class="line">    initialValue: &#39;&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与无状态组件相比，<code>React.createClass</code>和后面要描述的<code>React.Component</code>都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，<code>React.createClass</code>形式自身的问题暴露出来：</p>
</blockquote>
<ul>
<li>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</li>
<li>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考无状态组件(Stateless Component) 与高阶组件。</li>
</ul>
<h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h2><blockquote>
<p><code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代<code>React.createClass</code>形式；相对于<code>React.createClass</code>可以更好实现代码复用。将上面<code>React.createClass</code>的形式改为<code>React.Component</code>形式如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class InputControlES6 extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置 initial state</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            text: props.initialValue || &#39;placeholder&#39;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ES6 类中函数必须手动绑定</span><br><span class="line">        this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            text: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Type something:</span><br><span class="line">                &lt;input onChange&#x3D;&#123;this.handleChange&#125;</span><br><span class="line">               value&#x3D;&#123;this.state.text&#125; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">InputControlES6.propTypes &#x3D; &#123;</span><br><span class="line">    initialValue: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line">InputControlES6.defaultProps &#x3D; &#123;</span><br><span class="line">    initialValue: &#39;&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="React-createClass与React-Component区别"><a href="#React-createClass与React-Component区别" class="headerlink" title="React.createClass与React.Component区别"></a>React.createClass与React.Component区别</h2><blockquote>
<p>根据上面展示代码中二者定义组件的语法格式不同之外，二者还有很多重要的区别，下面就描述一下二者的主要区别。</p>
</blockquote>
<h3 id="函数this自绑定"><a href="#函数this自绑定" class="headerlink" title="函数this自绑定"></a>函数this自绑定</h3><blockquote>
<p><code>React.createClass</code>创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Contacts &#x3D; React.createClass(&#123;  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; React Component instance</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;this.handleClick&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>React.Component</code>创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Contacts extends React.Component &#123;  </span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(this); &#x2F;&#x2F; null</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;this.handleClick&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，<code>React.Component</code>有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用<code>method.bind(this)</code>来完成绑定，还可以使用<code>arrow function</code>来绑定。拿上例的handleClick函数来说，其绑定可以有：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">   super(props);</span><br><span class="line">   this.handleClick &#x3D; this.handleClick.bind(this); &#x2F;&#x2F;构造函数中绑定</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&#123;this.handleClick.bind(this)&#125;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;使用bind来绑定</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div onClick&#x3D;&#123;()&#x3D;&gt;this.handleClick()&#125;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;使用arrow function来绑定</span><br></pre></td></tr></table></figure>
<h3 id="组件属性类型propTypes及其默认props属性defaultProps配置不同"><a href="#组件属性类型propTypes及其默认props属性defaultProps配置不同" class="headerlink" title="组件属性类型propTypes及其默认props属性defaultProps配置不同"></a>组件属性类型propTypes及其默认props属性defaultProps配置不同</h3><blockquote>
<p><code>React.createClass</code>在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用<code>getDefaultProps</code>的方法来获取默认组件属性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TodoItem &#x3D; React.createClass(&#123;</span><br><span class="line">    propTypes: &#123; &#x2F;&#x2F; as an object</span><br><span class="line">        name: React.PropTypes.string</span><br><span class="line">    &#125;,</span><br><span class="line">    getDefaultProps()&#123;   &#x2F;&#x2F; return a object</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &#39;&#39;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>React.Component</code>在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。对应上面配置如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoItem extends React.Component &#123;</span><br><span class="line">    static propTypes &#x3D; &#123;&#x2F;&#x2F;类的静态属性</span><br><span class="line">        name: React.PropTypes.string</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    static defaultProps &#x3D; &#123;&#x2F;&#x2F;类的静态属性</span><br><span class="line">        name: &#39;&#39;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件初始状态state的配置不同"><a href="#组件初始状态state的配置不同" class="headerlink" title="组件初始状态state的配置不同"></a>组件初始状态state的配置不同</h3><blockquote>
<p><code>React.createClass</code>创建的组件，其状态state是通过<code>getInitialState方法</code>来配置组件相关的状态；<br><code>React.Component</code>创建的组件，其状态state是在<code>constructor</code>中像初始化组件属性一样声明的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TodoItem &#x3D; React.createClass(&#123;</span><br><span class="line">    &#x2F;&#x2F; return an object</span><br><span class="line">    getInitialState()&#123; </span><br><span class="line">        return &#123;</span><br><span class="line">            isEditing: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoItem extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123; &#x2F;&#x2F; define this.state in constructor</span><br><span class="line">            isEditing: false</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mixins的支持不同"><a href="#Mixins的支持不同" class="headerlink" title="Mixins的支持不同"></a>Mixins的支持不同</h3><blockquote>
<p><code>Mixins(混入)</code>是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用。具体可以参考React Mixin的前世今生。</p>
</blockquote>
<blockquote>
<p><code>React.createClass</code>在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var SomeMixin &#x3D; &#123;  </span><br><span class="line">  doSomething() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Contacts &#x3D; React.createClass(&#123;  </span><br><span class="line">  mixins: [SomeMixin],</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.doSomething(); &#x2F;&#x2F; use mixin</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;this.handleClick&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是遗憾的是<code>React.Component这种形式并不支持Mixins</code>，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代Mixins,那就是<code>Higher-Order Components</code>，具体细节可以参考<a href="https://leozdgao.me/chushi-hoc/">这篇文章</a></p>
<h2 id="如何选择哪种方式创建组件"><a href="#如何选择哪种方式创建组件" class="headerlink" title="如何选择哪种方式创建组件"></a>如何选择哪种方式创建组件</h2><p>由于React团队已经声明<code>React.createClass</code>最终会被<code>React.Component</code>的类形式所取代。但是在找到Mixins替代方案之前是不会废弃掉<code>React.createClass</code>形式。所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</span><br></pre></td></tr></table></figure>
<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、只要有可能，尽量使用无状态组件创建形式。</span><br><span class="line"></span><br><span class="line">2、否则（如需要state、生命周期方法等），使用&#96;React.Component&#96;这种es6形式创建组件</span><br></pre></td></tr></table></figure>
<h3 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h3><blockquote>
<p>无状态组件内部其实是可以使用ref功能的，虽然不能通过this.refs访问到，但是可以通过将ref内容保存到无状态组件内部的一个本地变量中获取到。</p>
</blockquote>
<p>例如下面这段代码可以使用ref来获取组件挂载到dom中后所指向的dom元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function TestComp(props)&#123;</span><br><span class="line">    let ref;</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">        &lt;div ref&#x3D;&#123;(node) &#x3D;&gt; ref &#x3D; node&#125;&gt;</span><br><span class="line">            ...</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>react reactjs 组件 创建 类</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记—UI交互</title>
    <url>/2017/08/11/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94UI%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><blockquote>
<p>先看个简单的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HelloWorld &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div data-title&#x3D;&#123;this.props.title&#125;&gt;&#123;this.props.content&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;HelloWorld title&#x3D;&quot;this is title&quot; content&#x3D;&quot;this is content&quot;&#x2F;&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>看代码就很容易理解：通过this.props我们可以拿到组件使用时的属性。稍微改变下代码，我们打印出this.props瞅瞅：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HelloWorld &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div data-title&#x3D;&#123;this.props.title&#125;&gt;&#123;JSON.stringify(this.props)&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;HelloWorld title&#x3D;&quot;this is title&quot; content&#x3D;&quot;this is content&quot;&#x2F;&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器页面效果：</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVlgHD"></p>
<blockquote>
<p>可以看出this.props就是组件的属性集合，稍微改下代码，再来看看：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HelloWorld &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&#123;JSON.stringify(this.props)&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;HelloWorld title&#x3D;&quot;this is title&quot;&gt;</span><br><span class="line">        &lt;span&gt;1&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;2&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;HelloWorld&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器页面效果：</p>
</blockquote>
<p><img src="https://segmentfault.com/img/bVlgHT"></p>
<blockquote>
<p>这个时候多了一个children的属性，React将组件的子节点封装到了children属性中，如果想获取到子节点的内容，可以这么写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var HelloWorld &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                this.props.children.map(function (child) &#123;</span><br><span class="line">                        return child;</span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;HelloWorld title&#x3D;&quot;this is title&quot;&gt;</span><br><span class="line">        &lt;span&gt;1&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;2&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;HelloWorld&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当子节点只有一个的时候直接通过this.props.children获取子节点。当子节点的个数大于1，this.props.children是一个数组。</p>
</blockquote>
<blockquote>
<p>综上我们可以看出，React将节点属性和子节点都封装到props当中，我们可以通过this.props获取到。在React的设定中，props是不可变的，当props属性确定后，我们不应该再去手动修改它。</p>
</blockquote>
<h2 id="一个陷阱"><a href="#一个陷阱" class="headerlink" title="一个陷阱"></a>一个陷阱</h2><blockquote>
<p>看下这个代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Hello &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;Hello&gt;</span><br><span class="line">        &lt;p&gt;content&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;Hello&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>咋一看是不是觉得页面渲染出来应该是这个效果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;content&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上渲染出来是这样的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看页面的渲染效果:我们要找到根节点，关注它的render方法的返回值。至于使用时的嵌套结构，看完props应该明白，这些都是组件属性，想要使用的话，请通过this.props.children.</p>
</blockquote>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><blockquote>
<p>state是同UI交互最重要的属性，看个简单的例子，点击按钮，切换按钮的颜色：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ColorButton &#x3D; React.createClass(&#123;</span><br><span class="line">    getInitialState: function () &#123;</span><br><span class="line">        return &#123;bColor: &#39;green&#39;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125; style&#x3D;&#123;&#123;backgroundColor: this.state.bColor&#125;&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick: function (event) &#123;</span><br><span class="line">        this.setState(&#123;bColor: this.state.bColor &#x3D;&#x3D;&#x3D; &#39;green&#39; ? &#39;red&#39; : &#39;green&#39;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;ColorButton &#x2F;&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>getInitialState是用来初始化state，handleClick是用来处理我们点击事件的。</p>
</blockquote>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><blockquote>
<p>React实现了自己的一套事件代理和处理机制，这套机制是符合W3C标准的。通过这套机制，React有两个很重要的特点：</p>
</blockquote>
<h4 id="自动绑定"><a href="#自动绑定" class="headerlink" title="自动绑定"></a>自动绑定</h4><blockquote>
<p>所有的事件处理函数当中的this指向组件的实例。如果想要拿到当前操作的DOM，通过参数event获取。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ColorButton &#x3D; React.createClass(&#123;</span><br><span class="line">    getInitialState: function () &#123;</span><br><span class="line">        return &#123;name: &#39;button&#39;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick: function (event) &#123;</span><br><span class="line">        console.log(this.state);</span><br><span class="line">        console.log(event.target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;ColorButton &#x2F;&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><blockquote>
<p>React并没有将事件处理添加到相应的每个节点上。当React启动时，在根节点上监听所有的事件，并管理事件到相应节点的映射。当组件mounted或者unmounted时，事件将会被添加到映射关系或者被删除。我感觉，有点jQuery的事件代理的意思：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#糟糕的写法</span><br><span class="line">$(&#39;li&#39;).on(&#39;click&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F;todo</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;好点的写法</span><br><span class="line">$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F;todo</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="状态机制"><a href="#状态机制" class="headerlink" title="状态机制"></a>状态机制</h3><blockquote>
<p>React将UI简单的看作状态机。看UI看作各种各样的状态，并在各种状态间切换，很容易保持UI的一致性。在React中，你只要改变组件的状态，就会重新渲染UI，React会在最有效的方式下更新DOM。</p>
</blockquote>
<h3 id="state工作原理"><a href="#state工作原理" class="headerlink" title="state工作原理"></a>state工作原理</h3><blockquote>
<p>通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。</p>
</blockquote>
<blockquote>
<p>后面在好好看看这个callback的功能和调用时机。</p>
</blockquote>
<h3 id="什么样的组件该有state"><a href="#什么样的组件该有state" class="headerlink" title="什么样的组件该有state"></a>什么样的组件该有state</h3><blockquote>
<p>大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：尽可能的保持你的组件无状态化。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。</p>
</blockquote>
<blockquote>
<p>React官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var RenderComponent &#x3D; React.createClass(&#123;</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.props[&#39;data-list&#39;].map(function (item) &#123;</span><br><span class="line">                        return (&lt;li&gt;&#123;item&#125;&lt;&#x2F;li&gt;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var StateComponent &#x3D; React.createClass(&#123;</span><br><span class="line">    getInitialState: function () &#123;</span><br><span class="line">        return &#123;list: [&#39;xxx&#39;, &#39;yyy&#39;]&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;RenderComponent data-list&#x3D;&#123;this.state.list&#125;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick: function () &#123;</span><br><span class="line">        this.setState(&#123;list: [1, 2, 3]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">    &lt;StateComponent &#x2F;&gt;,</span><br><span class="line">    document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="state应该包含什么样的数据"><a href="#state应该包含什么样的数据" class="headerlink" title="state应该包含什么样的数据"></a>state应该包含什么样的数据</h3><blockquote>
<p>UI交互会导致改变的数据。</p>
</blockquote>
<h3 id="state不应包含什么样的数据"><a href="#state不应包含什么样的数据" class="headerlink" title="state不应包含什么样的数据"></a>state不应包含什么样的数据</h3><ul>
<li>计算过的数据</li>
<li>组件</li>
<li>从props复制的数据</li>
</ul>
<blockquote>
<p>state应保含最原始的数据，比如说时间，格式化应该交给展现层去做。</p>
</blockquote>
<blockquote>
<p>组件应在render方法里控制。</p>
</blockquote>
]]></content>
      <tags>
        <tag>react js reactjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux源码深度解析</title>
    <url>/2017/10/25/Redux%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>一般情况下我们用js设置元素对象的样式会使用这样的形式：</p>
</blockquote>
<a id="more"></a>

<h2 id="1、什么是redux，这里就不做介绍，如想了解可以移步-ReadMe-redux，整体redux的代码只有800行，src下面分为一下几个部分。"><a href="#1、什么是redux，这里就不做介绍，如想了解可以移步-ReadMe-redux，整体redux的代码只有800行，src下面分为一下几个部分。" class="headerlink" title="1、什么是redux，这里就不做介绍，如想了解可以移步 ReadMe.redux，整体redux的代码只有800行，src下面分为一下几个部分。"></a>1、什么是redux，这里就不做介绍，如想了解可以移步 ReadMe.redux，整体redux的代码只有800行，src下面分为一下几个部分。</h2><ul>
<li><p>applyMiddleware.js</p>
</li>
<li><p>bindActionCreators.js</p>
</li>
<li><p>combineReducers.js</p>
</li>
<li><p>compose.js</p>
</li>
<li><p>createStore.js</p>
</li>
<li><p>index.js</p>
</li>
</ul>
<p>首先我们来看index.js主js的内容，很简单，就是引入和模块和抛出模块，这里有一句提醒内容，如果是production生产环境并且js已经被压缩，会输出warning信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isCrushed() &#123;&#125;</span><br><span class="line"></span><br><span class="line">if (</span><br><span class="line">  process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp;</span><br><span class="line">  typeof isCrushed.name &#x3D;&#x3D;&#x3D; &#39;string&#39; &amp;&amp;</span><br><span class="line">  isCrushed.name !&#x3D;&#x3D; &#39;isCrushed&#39;</span><br><span class="line">) &#123;</span><br><span class="line">  warning(</span><br><span class="line">    &#39;You are currently using minified code outside of NODE_ENV &#x3D;&#x3D;&#x3D; \&#39;production\&#39;. &#39; +</span><br><span class="line">    &#39;This means that you are running a slower development build of Redux. &#39; +</span><br><span class="line">    &#39;You can use loose-envify (https:&#x2F;&#x2F;github.com&#x2F;zertosh&#x2F;loose-envify) for browserify &#39; +</span><br><span class="line">    &#39;or DefinePlugin for webpack (http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;30030031) &#39; +</span><br><span class="line">    &#39;to ensure you have the correct code for your production build.&#39;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注: isCrushed.name 函数名.name是一个es6的属性，返回函数的名称。<br>除了index.js外，我们接下去从redux实现的接口，来深度分析一下Redux的源码。</p>
<h2 id="2、compose-js"><a href="#2、compose-js" class="headerlink" title="2、compose.js"></a>2、compose.js</h2><p>我们首先从compose.js入手，首先redux贯穿始终的是函数式变成的思想，个人对于函数式编程的理解为：</p>
<p>–首先是纯函数（相同的输入产生相同的输出）</p>
<p>–在范畴论理，状态或者输出表示点，函数表示边，从点到点的转移可以看成运算符，函数也是一种运算符，因为运算符是纯净的，因此函数式编程中的函数也是纯净的</p>
<p>–函数式编程中的函数，与变量等价，可以作为参数传递或者成为其他函数函数体里的一部分</p>
<p>–因为是函数式编程，便于函数的组合，这里有一个curry和compose的组合过程</p>
<p>基础了解函数式编程之后，下面我们来看compose.js的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line">  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    return arg &#x3D;&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a, b) &#x3D;&gt; (...args) &#x3D;&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个compose其实很简单，传入的参数为函数数组，返回的为reduce从左到右合并后的新的函数。是一个类似于链式调用的过程。</p>
<p>来看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">funcs.reduce((a, b) &#x3D;&gt; (...args) &#x3D;&gt; a(b(...args)))</span><br></pre></td></tr></table></figure>
<p>这句特别重要，组合函数的这部非常重要，我们发现…args参数会依次的从右到左执行，比如将b（…args）的执行结果，传入a中作为参数继续执行。</p>
<h2 id="3、applyMiddleware-js"><a href="#3、applyMiddleware-js" class="headerlink" title="3、applyMiddleware.js"></a>3、applyMiddleware.js</h2><p>applyMiddleware.js其实是基于compose.js来实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  return (createStore) &#x3D;&gt; (reducer, preloadedState, enhancer) &#x3D;&gt; &#123;</span><br><span class="line">    const store &#x3D; createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    let dispatch &#x3D; store.dispatch</span><br><span class="line">    let chain &#x3D; []</span><br><span class="line"></span><br><span class="line">    const middlewareAPI &#x3D; &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) &#x3D;&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))</span><br><span class="line">    dispatch &#x3D; compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码如果applyMiddleware(…Middleware)(createStore)这样调用，会生成一个新的createStore函数，用于创建新的createStore，新在哪里呢？就是链式的调用了所有的middleware：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let chain &#x3D; []</span><br><span class="line"></span><br><span class="line">const middlewareAPI &#x3D; &#123;</span><br><span class="line">   getState: store.getState,</span><br><span class="line">   dispatch: (action) &#x3D;&gt; dispatch(action)</span><br><span class="line">&#125;</span><br><span class="line">chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))</span><br><span class="line">dispatch &#x3D; compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>
<p>来看上述的代码，chain是一个函数数组，是middleware({})执行后的返回函数的数组，compose(…chain)是链式的组合函数，这里的…args是初始时候的store.dispatch，当最右边的函数以store.dispatch为参数，执行后生成一个新的store.dispatch，又向外传递，因此middleware是从右到左执行的。</p>
<p>从上述的描述中，我们知道了middle的书写形式，如果以纯函数的形式，首先第一个参数应该是{getState:”,dispatch:”}，第二个参数是store.dispatch，第三个参数应该是action，因此最基本形式的middleware应该是：</p>
<p>return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {</p>
<p>}</p>
<p>我们以redux-thunk为例，redux-thunk中间件是严格按照上述的形式，</p>
<p>代码只有13行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;</span><br><span class="line">    if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk &#x3D; createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument &#x3D; createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure>
<p>这个中间件的功能其实很简单，也就是action如果是一个函数就选择执行这个函数，并且action函数执行的时候，会传入dispatch和getState.</p>
<h2 id="4、createStore-js"><a href="#4、createStore-js" class="headerlink" title="4、createStore.js"></a>4、createStore.js</h2><p>createStore相对而言会较为的复杂，我们还是从接口出发。</p>
<p>（1）首先看,createStore()函数的返回值store有哪些接口：</p>
<p>–getState()：返回当前的state树</p>
<p>–dispatch(action)：分发action，是改变state的唯一方法</p>
<p>–subscribe(listener)：添加一个监听器，当state变化的时候，执行监听器里面的函数。</p>
<p>–unsubscribe(listener)：subscribe的返回值，用于移除监听器</p>
<p>–replaceReducer(nextReducer)：替换store中当前的reducer</p>
<p>（2）下面根据代码，依次来看，各个接口的实现情况。</p>
<p>首先明确createStore的形参，形参有3个，分别是reducer(处理函数)，preloadedState（初始化state），enhancer（一个高阶函数，可以改变store的接口）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getState函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let currentState &#x3D; preloadedState</span><br><span class="line">function getState() &#123;</span><br><span class="line">	return currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getState函数比较简单，类似于一个get的方法，返回currentState的值</p>
<ul>
<li>dispatch函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function dispatch(action) &#123;</span><br><span class="line">    if (!isPlainObject(action)) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        &#39;Actions must be plain objects. &#39; +</span><br><span class="line">        &#39;Use custom middleware for async actions.&#39;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        &#39;Actions may not have an undefined &quot;type&quot; property. &#39; +</span><br><span class="line">        &#39;Have you misspelled a constant?&#39;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDispatching) &#123;</span><br><span class="line">      throw new Error(&#39;Reducers may not dispatch actions.&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching &#x3D; true</span><br><span class="line">      currentState &#x3D; currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const listeners &#x3D; currentListeners &#x3D; nextListeners</span><br><span class="line">    for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      const listener &#x3D; listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch也不复杂，去掉判断类型（因为action必须是对象）的部分，其实只有2步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">  isDispatching &#x3D; true</span><br><span class="line">  currentState &#x3D; currentReducer(currentState, action)</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  isDispatching &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const listeners &#x3D; currentListeners &#x3D; nextListeners</span><br><span class="line">for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">  const listener &#x3D; listeners[i]</span><br><span class="line">  listener()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很显然易见了，就是执行currentReducer()传入当前的currentState和action，返回新的state，并且执行监听函数数组里面的所有函数。</p>
<ul>
<li>subscribe：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function subscribe(listener) &#123;</span><br><span class="line">  if (typeof listener !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    throw new Error(&#39;Expected listener to be a function.&#39;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let isSubscribed &#x3D; true</span><br><span class="line"></span><br><span class="line">  ensureCanMutateNextListeners()</span><br><span class="line">  nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">  return function unsubscribe() &#123;</span><br><span class="line">    if (!isSubscribed) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed &#x3D; false</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    const index &#x3D; nextListeners.indexOf(listener)</span><br><span class="line">    nextListeners.splice(index, 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听函数也挺简单，就是一个简单的移入和移出，这是一个底层 API。多数情况下，你不会直接使用它，会使用一些 React（或其它库）的绑定。比如react-redux中的容器组件中的props改变会自动的更新（也算一个监听过程）。</p>
<ul>
<li>replaceReducer：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function replaceReducer(nextReducer) &#123;</span><br><span class="line">    if (typeof nextReducer !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      throw new Error(&#39;Expected the nextReducer to be a function.&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentReducer &#x3D; nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就更加的简单了，replaceReducer是为了改变当前的reducer，因此只要将currentReducer赋值为形参即可。</p>
<h2 id="5、combineReducers-js"><a href="#5、combineReducers-js" class="headerlink" title="5、combineReducers.js"></a>5、combineReducers.js</h2><p>最复杂的部分就是combineReducer.js了</p>
<ul>
<li>combineReducer（reducer）接受一个reducer对象,recuder是key表示属性名，value是一个小的reduce函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历reducer中的对象，取出其中的value值（reduce函数），生成一个新的对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reducerKeys &#x3D; Object.keys(reducers)</span><br><span class="line">const finalReducers &#x3D; &#123;&#125;</span><br><span class="line">for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">  const key &#x3D; reducerKeys[i]</span><br><span class="line">  finalReducers[key] &#x3D; reducers[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为reduce函数有一个初始执行过程，即会自动执行一次 type: ActionTypes.INIT,因此有以下过程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assertReducerShape(finalReducers);</span><br><span class="line">function assertReducerShape(reducers) &#123;</span><br><span class="line">  Object.keys(reducers).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    const reducer &#x3D; reducers[key]</span><br><span class="line">    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后就是最终要的返回的combine函数：</li>
</ul>
<p>其原理也很简单，state的属性名和reducer对象的key是相对的，因此也就是在所有的小的reduce函数中，传入相对的state[key]，action,依次执行后得到一个新的newState，然后与state做比较，选择性返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return function combination(state &#x3D; &#123;&#125;, action) &#123;</span><br><span class="line"></span><br><span class="line">    let hasChanged &#x3D; false</span><br><span class="line">    const nextState &#x3D; &#123;&#125;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      const key &#x3D; finalReducerKeys[i]</span><br><span class="line">      const reducer &#x3D; finalReducers[key]</span><br><span class="line">      const previousStateForKey &#x3D; state[key]</span><br><span class="line">      const nextStateForKey &#x3D; reducer(previousStateForKey, action)</span><br><span class="line">      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">        const errorMessage &#x3D; getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        throw new Error(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] &#x3D; nextStateForKey</span><br><span class="line">      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    return hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、bindActionCreators-js"><a href="#6、bindActionCreators-js" class="headerlink" title="6、bindActionCreators.js"></a>6、bindActionCreators.js</h2><p>这个一般比较少用，这里就不分析源码了，只简单的阐述功能，</p>
<p>bindActionCreators（）把 action creators 转成拥有同名 keys 的对象，但使用 dispatch 把每个 action creator 包围起来，这样可以直接调用它们。</p>
]]></content>
      <tags>
        <tag>redux react 柯里化 纯函数 状态 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SeaJS学习笔记</title>
    <url>/2018/01/14/SeaJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>今天专题把seaJs模块化开发了解学习了下，算是把seaJS的基本用法弄清楚了，其他的跟着项目慢慢再深入！现在把自己整理出来的资料保存一下，也方便以后遗忘了可以快速地回顾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 先引seaJS - demo.html</span><br><span class="line">	&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;seajs&#x2F;2.3.0&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">2.1 定义模块app.js</span><br><span class="line">	define(function(require, exports, module)&#123;</span><br><span class="line">		var jquery &#x3D; require(&#39;.&#x2F;jquery.js&#39;);</span><br><span class="line">		var demo &#x3D; &#123;</span><br><span class="line">			&#39;jquery&#39;: jquery</span><br><span class="line">		&#125;</span><br><span class="line">		module.exports &#x3D; demo;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">2.2 修改jQuery.js为支持CMD模块(3.2.1版本，10308行)</span><br><span class="line">	if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.cmd) &#123;</span><br><span class="line">	  &#x2F;&#x2F; 有 Sea.js 等 CMD 模块加载器存在</span><br><span class="line">	  define(function (require, exports, module) &#123;</span><br><span class="line">	    &#x2F;&#x2F; 使用 module.exports 向外暴露接口对象</span><br><span class="line">	    module.exports &#x3D; jQuery;</span><br><span class="line">	  &#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">3. 启用模块 - demo.html</span><br><span class="line">	seajs.use(&#39;.&#x2F;app.js&#39;,function(v)&#123;</span><br><span class="line">		v.$(&#39;html, body&#39;).animate(&#123;&#39;scrollTop&#39;:v.$(&#39;input&#39;).offset().top&#125;,200).find(&#39;input&#39;).focus();</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="1-SeaJS-介绍"><a href="#1-SeaJS-介绍" class="headerlink" title="1 SeaJS 介绍"></a>1 SeaJS 介绍</h1><ul>
<li><p>关于 SeaJS</p>
<ul>
<li>SeaJS 是一个适用于浏览器环境的 JavaScript 模块加载器<ul>
<li>一个库文件，类似于 jQuery</li>
<li>使用这个库提供的规范的模块化的方式来编写 JavaScript 代码</li>
<li>只关心 JavaScript 文件代码模块如何组织<ul>
<li>只关心 JavaScript 文件之间如何相互协议、引用、依赖</li>
</ul>
</li>
</ul>
</li>
<li>SeaJS 的作者是阿里巴巴支付宝前端架构师，花名：玉伯，玉伯也叫射雕<ul>
<li><a href="http://www.csdn.net/article/2013-09-03/2816801-front-end-development-seajs-framework">Sea.js创始人玉伯的前端开发之路</a></li>
</ul>
</li>
<li><a href="http://seajs.org/">SeaJS</a></li>
<li><a href="https://github.com/seajs/seajs/">SeaJS -github</a></li>
</ul>
</li>
<li><p>为什么学习和使用 SeaJS ？</p>
<ul>
<li><strong>简单友好的模块定义规范</strong>：SeaJS 遵循 CMD 规范，可以像 Node 一样书写模块代码</li>
<li><strong>自然直观的代码组织方式</strong>：依赖的自动加载、配置简洁清晰，可以让我们更多的享受编码的乐趣</li>
<li>SeaJS兼容性非常好，几乎可以运行在任何浏览器引擎上</li>
<li>注1：SeaJS 只是实现模块化开发的一种方式或者说一种工具而已，重在模块化思想的理解</li>
<li>注2：因为 SeaJS 采用的 CMD 模块规范和 Node 中的 CommonJS 模块规范非常一致，所以有利于我们学习 Node 中的模块化编程</li>
</ul>
</li>
<li><p>谁在用？</p>
<ul>
<li>淘宝网、支付宝、京东、爱奇艺。。。</li>
</ul>
</li>
<li><p>SeaJS 适用场景</p>
<ul>
<li>没有使用任何框架，例如 AngularJS</li>
<li>例如 只写写 原生 JavaScript 或者用了一些第三方库</li>
<li>SeaJS 不提供任何功能性 API，只提供了解决 JavaScript 代码的命名污染和文件依赖的问题</li>
</ul>
</li>
</ul>
<h1 id="2-快速上手（Getting-Started）"><a href="#2-快速上手（Getting-Started）" class="headerlink" title="2 快速上手（Getting Started）"></a>2 快速上手（Getting Started）</h1><ol start="0">
<li>下载 sea.js 库文件</li>
</ol>
<ul>
<li><a href="https://github.com/seajs/seajs/releases">SeaJS - Release</a></li>
<li><code>bower install seajs</code></li>
<li><code>npm install seajs</code></li>
</ul>
<ol>
<li>在页面中引入 sea.js</li>
<li>使用 <code>define</code> 函数定义模块</li>
<li>使用 <code>require</code> 函数加载模块</li>
<li>使用 <code>module.exports</code> 对外暴露接口对象</li>
<li>使用 <code>seajs.use</code> 函数启动模块系统</li>
</ol>
<h1 id="3-API-详解"><a href="#3-API-详解" class="headerlink" title="3 API 详解"></a>3 API 详解</h1><h2 id="3-1-seajs-use"><a href="#3-1-seajs-use" class="headerlink" title="3.1 seajs.use"></a>3.1 <code>seajs.use</code></h2><p>加载模块，启动模块系统。</p>
<ul>
<li><p>加载一个模块 <code>seajs.use(&#39;id&#39;)</code></p>
</li>
<li><p>加载一个模块，在加载完成时，执行回调 <code>seajs.use(&#39;id&#39;, callback)</code></p>
</li>
<li><p>加载多个模块，加载完成时，执行回调 <code>seajs.use([&#39;id1&#39;,&#39;id2&#39;,...],callback)</code></p>
</li>
<li><p>注意：</p>
<ul>
<li>在调用 seajs.use 之前，需要先引入 sea.js 文件</li>
<li>seajs.use 与 <code>DOM ready</code> 事件没有任何关系。如果某些操作要确保在 <code>DOM ready</code> 后执行，需要使用 jquery 等类库来保证</li>
<li>seajs.use 理论上只用于加载启动，不应该出现在 <code>define</code> 中的模块代码里</li>
</ul>
</li>
</ul>
<h2 id="3-2-define-factory"><a href="#3-2-define-factory" class="headerlink" title="3.2 define(factory)"></a>3.2 <code>define(factory)</code></h2><p><code>define</code> 是一个全局函数，用来定义模块。</p>
<p><code>define</code> 接受 <code>factory</code> 参数，<code>factory</code> 可以是一个函数，也可以是一个对象或字符串。</p>
<p><code>factory</code> 为对象、字符串时，表示模块的接口就是该对象、字符串。</p>
<ul>
<li><p>factory 是一个对象时</p>
<ul>
<li><code>define(&#123;&#125;)</code></li>
</ul>
</li>
<li><p>factory 是一个字符串时</p>
<ul>
<li><code>define(&#39;hello&#39;)</code></li>
</ul>
</li>
<li><p>factory 是一个函数时</p>
<ul>
<li><code>define(function(require, exports, module)&#123;&#125;)</code></li>
</ul>
</li>
</ul>
<h2 id="3-3-require"><a href="#3-3-require" class="headerlink" title="3.3 require"></a>3.3 <code>require</code></h2><p>require 用来加载一个 js 文件模块，<br>require 用来获取指定模块的接口对象 <code>module.exports</code>。</p>
<p>require 在加载和执行的时候，js 会按照同步的方式和执行。</p>
<p>使用注意：</p>
<ul>
<li>正确拼写<ul>
<li>模块 factory 构造方法的第一个参数 <code>必须</code> 命名为 require</li>
</ul>
</li>
<li>不要修改<ul>
<li>不要重命名 require 函数，或在任何作用域中给 require 重新赋值</li>
</ul>
</li>
<li>使用字符串直接量<ul>
<li>require 的参数值 必须 是字符串直接量</li>
</ul>
</li>
</ul>
<p>Tips: 把 <code>require</code> 看做是语法关键字就好啦</p>
<h2 id="3-4-模块标识"><a href="#3-4-模块标识" class="headerlink" title="3.4 模块标识"></a>3.4 模块标识</h2><p>模块标识是一个字符串，用来标识模块。</p>
<ul>
<li><p>模块标识可以不包含文件后缀名，比如 <code>.js</code></p>
<ul>
<li>seajs 推荐不加 .js 文件模块后缀</li>
</ul>
</li>
<li><p>模块标识可以是 <strong>相对</strong> 或 <strong>顶级</strong> 标识</p>
</li>
<li><p>相对标识</p>
</li>
</ul>
<p>相对标识以 <code>.</code> 开头，永远相对于当前模块所处的路径来解析。</p>
<ul>
<li>顶级标识</li>
</ul>
<p>顶级标识不以 <code>.</code> 或 <code>/</code> 开始，会相对模块系统的基础路径（base路径，默认是 sea.js 文件所属的路径）。<br>可以手动配置 base 路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">  base: <span class="string">&#x27;./js&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>普通路径</li>
</ul>
<p>除了相对和顶级标识之外的标识都是普通路径。<br>普通路径的解析规则，会相对当前页面解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前页面是 http://example.com/path/to/page/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绝对路径是普通路径：</span></span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">&#x27;http://cdn.com/js/a&#x27;</span>);</span><br><span class="line">  <span class="comment">// =&gt; http://cdn.com/js/a.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根路径是普通路径：</span></span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">&#x27;/js/b&#x27;</span>);</span><br><span class="line">  <span class="comment">// =&gt; http://example.com/js/b.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use 中的相对路径始终是普通路径：</span></span><br><span class="line">seajs.use(<span class="string">&#x27;./c&#x27;</span>);</span><br><span class="line">  <span class="comment">// =&gt; 加载的是 http://example.com/path/to/page/c.js</span></span><br><span class="line"></span><br><span class="line">seajs.use(<span class="string">&#x27;../d&#x27;</span>);</span><br><span class="line">  <span class="comment">// =&gt; 加载的是 http://example.com/path/to/d.js</span></span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>:</p>
<ul>
<li>顶级标识始终相对 <code>base</code> 基础路径解析。<ul>
<li>如果不设置，base 路径默认就是 sea.js 库文件所属的路径</li>
<li>可以通过 <code>seajs.config(&#123; base: &#39;基础路径&#39; &#125;)</code> 来配置基础路径</li>
</ul>
</li>
<li>绝对路径和根路径始终相对当前页面解析。</li>
<li>相对标识永远相对于当前文件</li>
<li><code>seajs.use</code> 中的相对路径始终相对当前页面来解析。</li>
</ul>
<h2 id="3-5-module"><a href="#3-5-module" class="headerlink" title="3.5 module"></a>3.5 module</h2><p>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p>
<ul>
<li><code>module.id</code><ul>
<li>模块的唯一标识，可以通过 <code>define</code> 方法的第一个参数来指定，默认为该模块文件的绝对路径</li>
</ul>
</li>
<li><code>module.uri</code><ul>
<li>模块的绝对路径</li>
</ul>
</li>
<li><code>module.dependencies</code><ul>
<li>dependencies 是一个数组，表示当前模块的依赖</li>
</ul>
</li>
<li><code>module.exports</code><ul>
<li>当前模块对外提供的接口对象</li>
<li>相当于每个模块内部最终都执行了这么一句话：<code>return module.exports</code></li>
<li>模块与模块之间的通信接口</li>
</ul>
</li>
</ul>
<h2 id="3-6-exports"><a href="#3-6-exports" class="headerlink" title="3.6 exports"></a>3.6 exports</h2><p>exports 仅仅是 module.exports 的一个引用。<br>也就是说修改了 exports 就相当于修改了 module.exports。</p>
<p>但是一旦在 factory 内部给 exports 重新赋值，并不会改变 module.exports 的值。<br>因此给 exports 赋值是无效的。</p>
<h1 id="4-exports-和-module-exports-的区别"><a href="#4-exports-和-module-exports-的区别" class="headerlink" title="4 exports 和 module.exports 的区别"></a>4 exports 和 module.exports 的区别</h1><ul>
<li>每个模块内部对外到处的接口对象始终都是 <code>module.exports</code></li>
<li>可以通过修改 <code>module.exports</code> 或给它赋值改变模块接口对象</li>
<li><code>exports</code> 是 <code>module.exports</code> 的一个引用，就好比在每一个模块定义最开始的地方写了这么一句代码：<code>var exports = module.exports</code></li>
</ul>
<p>关于这俩哥们儿的区别请分析一下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeExports</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// var exports = module.exports</span></span><br><span class="line">  <span class="built_in">exports</span>.foo = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里赋值拿不到，不要使用使用</span></span><br><span class="line">  <span class="comment">// exports = function () &#123;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeExports(<span class="built_in">module</span>.exports, <span class="built_in">module</span>)</span><br></pre></td></tr></table></figure>
<p>那为啥要有 <code>exports</code> ？</p>
<p>为了开发体验，API更友好，使用 exports 的时候，可以少写一个点儿。</p>
<p>如果你实在分不清楚 <code>exports</code> 和 <code>module.exports</code> 之间的区别，就只记得 <code>module.exports</code> 就可以了。</p>
<h1 id="5-如何将一个普通的模块文件改造为兼容-CMD-规范的模块"><a href="#5-如何将一个普通的模块文件改造为兼容-CMD-规范的模块" class="headerlink" title="5 如何将一个普通的模块文件改造为兼容 CMD 规范的模块"></a>5 如何将一个普通的模块文件改造为兼容 CMD 规范的模块</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.cmd) &#123;</span><br><span class="line">  <span class="comment">// 有 Sea.js 等 CMD 模块加载器存在</span></span><br><span class="line">  define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 module.exports 向外暴露接口对象</span></span><br><span class="line">	<span class="built_in">module</span>.exports = jQuery; <span class="comment">//以jQuery为例</span></span><br><span class="line">	<span class="comment">// 或return jQuery 或 exports = jQuery （尽量不要用后者）</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-高级配置-seajs-config-options"><a href="#6-高级配置-seajs-config-options" class="headerlink" title="6 高级配置 seajs.config(options)"></a>6 高级配置 <code>seajs.config(options)</code></h1><p>可以对 Sea.js 进行配置，让模块编写、开发调试更方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别名配置</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">&#x27;es5-safe&#x27;</span>: <span class="string">&#x27;gallery/es5-safe/0.9.3/es5-safe&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;json&#x27;</span>: <span class="string">&#x27;gallery/json/1.0.2/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;jquery&#x27;</span>: <span class="string">&#x27;jquery/jquery/1.10.1/jquery&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路径配置</span></span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">&#x27;gallery&#x27;</span>: <span class="string">&#x27;https://a.alipayobjects.com/gallery&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sea.js 的基础路径</span></span><br><span class="line">  base: <span class="string">&#x27;http://example.com/path/to/base/&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>seaJS 模块 CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Token登录认证</title>
    <url>/2021/03/17/Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="基于-Cookie-Session-的认证方案"><a href="#基于-Cookie-Session-的认证方案" class="headerlink" title="基于 Cookie/Session 的认证方案"></a>基于 Cookie/Session 的认证方案</h2><blockquote>
<p>Cookie</p>
</blockquote>
<ul>
<li>Cookie的工作原理</li>
</ul>
<p>由于<code>HTTP</code>是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是。<br> <code>cookie</code>指的就是在浏览器里面存储的一种数据，仅仅是浏览器实现的一种数据存储功能。<br> <code>cookie</code>的保存时间，可以自己在程序中设置。如果没有设置保存时间，应该是一关闭浏览器，<code>cookie</code>就自动消失。</p>
<p><code>Cookie</code>实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用<code>response</code>向客户端浏览器颁发一个<code>Cookie</code>。客户端浏览器会把<code>Cookie</code>保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该<code>Cookie</code>一同提交给服务器。服务器检查该<code>Cookie</code>，以此来辨认用户状态。服务器还可以根据需要修改<code>Cookie</code>的内容。</p>
<p><strong>注意</strong>：<code>Cookie</code>功能需要浏览器的支持。如果浏览器不支持<code>Cookie</code>（如大部分手机中的浏览器）或者把<code>Cookie</code>禁用了，<code>Cookie</code>功能就会失效。不同的浏览器采用不同的方式保存<code>Cookie</code>。<code>IE</code>浏览器会以文本文件形式保存，一个文本文件保存一个<code>Cookie</code>。</p>
<a id="more"></a>

<ul>
<li>Cookie的不可跨域名性</li>
</ul>
<p><code>Cookie</code>具有不可跨域名性。根据<code>Cookie</code>规范，浏览器访问<code>Google</code>只会携带<code>Google</code>的<code>Cookie</code>，而不会携带<code>Baidu</code>的<code>Cookie</code>。浏览器判断一个网站是否能操作另一个网站<code>Cookie</code>的依据是域名。</p>
<blockquote>
<p>Session</p>
</blockquote>
<p><code>Session</code>是另一种记录客户状态的机制，<strong>不同的是</strong><code>Cookie</code>保存在客户端浏览器中，而<code>Session</code>保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是<code>Session</code>。客户端浏览器再次访问时只需要从该<code>Session</code>中查找该客户的状态就可以了。</p>
<p>如果说<code>Cookie</code>机制是通过检查客户身上的“通行证”来确定客户身份的话，那么<code>Session</code>机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<p><code>session</code> 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，<strong>服务器</strong>就要给每个<strong>客户端</strong>分配不同的“身份标识”，然后<strong>客户端</strong>每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。对于浏览器客户端，大家都默认采用 <code>cookie</code> 的方式，保存这个“身份标识”。</p>
<p>服务器使用<code>session</code>把用户的信息临时保存在了服务器上，用户离开网站后<code>session</code>会被销毁。这种用户信息存储方式相对<code>cookie</code>来说更安。</p>
<p>可是<code>session</code>有一个<strong>缺陷</strong>：如果<code>web</code>服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候<code>session</code>会丢失。</p>
<p><strong>提示</strong>：<code>Session</code>的使用比<code>Cookie</code>方便，但是过多的<code>Session</code>存储在服务器内存中，会对服务器造成压力。</p>
<blockquote>
<p>Cookie与Session的区别和联系</p>
</blockquote>
<ol>
<li><code>cookie</code>数据存放在客户的浏览器上，<code>session</code>数据放在服务器上；</li>
<li><code>cookie</code>不是很安全，别人可以分析存放在本地的<code>COOKIE</code>并进行 <code>COOKIE</code>欺骗，考虑到安全应当使用<code>session</code>；</li>
<li><code>session</code>会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用<code>COOKIE</code>；</li>
<li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</li>
</ol>
<p><code>Cookie</code>和<code>Session</code>的方案虽然分别属于客户端和服务端，但是服务端的<code>session</code>的实现对客户端的<code>cookie</code>有依赖关系的，上面我讲到服务端执行<code>session</code>机制时候会生成<code>session</code>的id值，这个<code>id</code>值会发送给客户端，客户端每次请求都会把这个<code>id</code>值放到<code>http</code>请求的头部发送给服务端，而这个<code>id</code>值在客户端会保存下来，保存的容器就是<code>cookie</code>，因此当我们完全禁掉浏览器的<code>cookie</code>的时候，服务端的<code>session</code>也会不能正常使用。</p>
<h2 id="基于token的认证方式"><a href="#基于token的认证方式" class="headerlink" title="基于token的认证方式"></a>基于token的认证方式</h2><p>在大多数使用<code>Web API</code>的互联网公司中，<code>tokens</code> 是多用户下处理认证的最佳方式。</p>
<p>以下几点特性会让你在程序中使用基于Token的身份验证</p>
<p>1.无状态、可扩展</p>
<p>2.支持移动设备</p>
<p>3.跨程序调用</p>
<p>4.安全</p>
<h3 id="Token的起源"><a href="#Token的起源" class="headerlink" title="Token的起源"></a>Token的起源</h3><p>在介绍基于<code>Token</code>的身份验证的原理与优势之前，不妨先看看<strong>之前</strong>的认证都是怎么做的。</p>
<ul>
<li>基于服务器的验证</li>
</ul>
<p>我们都是知道<code>HTTP</code>协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。</p>
<p>在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储<code>Session</code>来完成。</p>
<ul>
<li>基于服务器验证方式暴露的一些问题</li>
</ul>
<p>1.<code>Seesion</code>：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，<strong>内存</strong>的开销也会不断增加。</p>
<p>2.可扩展性：在服务端的内存中使用<code>Seesion</code>存储登录信息，伴随而来的是可扩展性问题。</p>
<p>3.<code>CORS</code>(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用<code>Ajax</code>抓取另一个域的资源，就可以会出现禁止请求的情况。</p>
<p>4.<code>CSRF</code>(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</p>
<p>在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。</p>
<h3 id="基于Token的验证原理"><a href="#基于Token的验证原理" class="headerlink" title="基于Token的验证原理"></a>基于Token的验证原理</h3><p>基于Token的身份验证是<strong>无状态</strong>的，我们<strong>不将</strong>用户信息存在服务器中。这种概念解决了在服务端存储信息时的许多问题。<code>NoSession</code>意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p>
<h3 id="基于Token的身份验证的过程如下"><a href="#基于Token的身份验证的过程如下" class="headerlink" title="基于Token的身份验证的过程如下:"></a>基于Token的身份验证的过程如下:</h3><ol>
<li>用户通过用户名和密码发送请求。</li>
<li>服务器端程序验证。</li>
</ol>
<p>3.服务器端程序返回一个<strong>带签名</strong>的<code>token</code> 给客户端。</p>
<p>4.客户端储存<code>token</code>,并且每次访问<code>API</code>都携带<code>Token</code>到服务器端的。</p>
<p>5.服务端验证<code>token</code>，校验成功则返回请求数据，校验失败则返回错误码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15096291-543566756c7218ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/639/format/webp" alt="img"></p>
<h3 id="Tokens的优势"><a href="#Tokens的优势" class="headerlink" title="Tokens的优势"></a>Tokens的优势</h3><ul>
<li>无状态、可扩展</li>
</ul>
<p>在客户端存储的<code>Tokens</code>是无状态的，并且能够被扩展。基于这种无状态和不存储<code>Session</code>信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。<br> <code>tokens</code>自己<code>hold</code>住了用户的验证信息。</p>
<ul>
<li>安全性</li>
</ul>
<p>请求中发送<code>token</code>而不再是发送<code>cookie</code>能够防止<code>CSRF</code>(跨站请求伪造)。即使在客户端使用<code>cookie</code>存储<code>token</code>，<code>cookie</code>也仅仅是一个存储机制而不是用于认证。不将信息存储在<code>Session</code>中，让我们少了对<code>session</code>操作。</p>
<p><code>token</code>是有时效的，一段时间之后用户需要重新验证。</p>
<ul>
<li>可扩展性</li>
</ul>
<p><code>Tokens</code>能够创建与其它程序共享权限的程序。</p>
<ul>
<li>多平台跨域</li>
</ul>
<p>我们提前先来谈论一下<code>CORS</code>(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。</p>
<h3 id="需要设置有效期吗？"><a href="#需要设置有效期吗？" class="headerlink" title="需要设置有效期吗？"></a>需要设置有效期吗？</h3><p>对于这个问题，我们不妨先看两个例子。一个例子是登录密码，一般要求定期改变密码，以防止泄漏，所以密码是有有效期的；另一个例子是安全证书。<code>SSL</code> 安全证书都有有效期，目的是为了解决吊销的问题。所以无论是从安全的角度考虑，还是从吊销的角度考虑，<code>Token</code> 都需要设有效期。</p>
<ul>
<li>那么有效期多长合适呢？</li>
</ul>
<p>只能说，根据系统的安全需要，尽可能的短，但也不能短得离谱</p>
<ul>
<li>然后新问题产生了，如果用户在正常操作的过程中，<code>Token</code> 过期失效了，要求用户重新登录……用户体验岂不是很糟糕？</li>
</ul>
<p>一种方案，使用 <code>Refresh Token</code>，它可以避免频繁的读写操作。这种方案中，服务端不需要刷新 <code>Token</code> 的过期时间，一旦 <code>Token</code> 过期，就反馈给前端，前端使用 <code>Refresh Token</code> 申请一个全新<code>Token</code> 继续使用。这种方案中，服务端只需要在客户端请求更新 <code>Token</code> 的时候对 <code>Refresh Token</code> 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 <code>Refresh Token</code> 也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。</p>
<ul>
<li>时序图表示</li>
</ul>
<p>使用 <code>Token</code> 和 <code>Refresh Token</code> 的时序图如下：</p>
<p>1）登录</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15096291-4a028da83d83b5b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="img"></p>
<p>2）业务请求</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15096291-75ad0bdfa6dd7506?imageMogr2/auto-orient/strip%7CimageView2/2/w/510/format/webp" alt="img"></p>
<p> 3）<code>Token</code>过期，刷新 <code>Token</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15096291-21cdaa18849f5ae7?imageMogr2/auto-orient/strip%7CimageView2/2/w/648/format/webp" alt="img"></p>
<p> 上面的时序图中并未提到 <code>Refresh Token</code> 过期怎么办。不过很显然，<code>Refresh Token</code> 既然已经过期，就该要求用户重新登录了。</p>
<h3 id="项目中使用token总结"><a href="#项目中使用token总结" class="headerlink" title="项目中使用token总结"></a>项目中使用token总结</h3><p>使用基于 <code>Token</code> 的身份验证方法，在服务端<strong>不需要</strong>存储用户的登录记录。大概的流程是这样的：</p>
<p>1.前端使用用户名跟密码请求首次登录</p>
<p>2.后服务端收到请求，去验证用户名与密码是否正确</p>
<p>3.验证成功后，服务端会根据用户<code>id</code>、用户名、定义好的秘钥、过期时间生成一个 <code>Token</code>，再把这个 <code>Token</code> 发送给前端</p>
<p>4.前端收到 返回的<code>Token</code> ，把它存储起来，比如放在 <code>Cookie</code> 里或者 <code>Local Storage</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface User &#123;</span><br><span class="line">    token: string;</span><br><span class="line">    userInfo: UserInfo | any;</span><br><span class="line">    companyInfo: CompanyInfo | any;</span><br><span class="line">    resources?: string[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">save(key: <span class="built_in">string</span>, <span class="keyword">value</span>: any, storageType ?: StorageType) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.storageService.put(</span><br><span class="line">        &#123;</span><br><span class="line">            pool: key,</span><br><span class="line">            key: <span class="string">&#x27;chris-app&#x27;</span>,</span><br><span class="line">            storageType: StorageType.localStorage</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">value</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.storageService.save(CACHE_USER_KEY, user);</span><br></pre></td></tr></table></figure>
<p>5.前端每次路由跳转，判断 <code>localStroage</code> 有无 <code>token</code> ，没有则跳转到登录页。有则请求获取用户信息，改变登录状态；<br> 6.前端每次向服务端请求资源的时候需要在<strong>请求头</strong>里携带服务端签发的<code>Token</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpInterceptor =&gt; headers = headers.<span class="keyword">set</span>(<span class="string">&#x27;token&#x27;</span>, <span class="keyword">this</span>.authService.getToken());</span><br></pre></td></tr></table></figure>
<p>7.服务端收到请求，然后去验证前端请求里面带着的 <code>Token</code>。没有或者 <code>token</code> 过期，返回<code>401</code>。如果验证成功，就向前端返回请求的数据。</p>
<p>8.前端得到 <code>401</code> 状态码，重定向到登录页面。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpInterceptor =&gt; </span><br><span class="line">    <span class="number">401</span>: <span class="string">&#x27;用户登陆状态失效，请重新登陆。&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>token 登录 认证 无状态</tag>
      </tags>
  </entry>
  <entry>
    <title>for of 与 for in的区别</title>
    <url>/2017/08/13/for%20of%20%E4%B8%8E%20for%20in%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>遍历数组通常使用for循环，ES5的话也可以使用forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，只不过他们的返回结果不一样。但是使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.method&#x3D;function()&#123;</span><br><span class="line">　　console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">var myArray&#x3D;[1,2,4,5,6,7]</span><br><span class="line">myArray.name&#x3D;&quot;数组&quot;</span><br><span class="line">for (var index in myArray) &#123;</span><br><span class="line">  console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用for in 也可以遍历数组，但是会存在以下问题：</p>
<ol>
<li><p>index索引为字符串型数字，不能直接进行几何运算</p>
</li>
<li><p>遍历顺序有可能不是按照实际数组的内部顺序</p>
</li>
<li><p>使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性</p>
</li>
</ol>
<blockquote>
<p>所以for in更适合遍历对象，不要使用for in遍历数组。</p>
</blockquote>
<p>那么除了使用for循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历method和name），<code>ES6中的for of更胜一筹</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.method&#x3D;function()&#123;</span><br><span class="line">　　console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">var myArray&#x3D;[1,2,4,5,6,7]</span><br><span class="line">myArray.name&#x3D;&quot;数组&quot;;</span><br><span class="line">for (var value of myArray) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。==</p>
<blockquote>
<p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>
</blockquote>
<blockquote>
<p>遍历对象 通常用for in来遍历对象的键名</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.method&#x3D;function()&#123;</span><br><span class="line">　　console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var myObject&#x3D;&#123;</span><br><span class="line">　　a:1,</span><br><span class="line">　　b:2,</span><br><span class="line">　　c:3</span><br><span class="line">&#125;</span><br><span class="line">for (var key in myObject) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for in 可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var key in myObject) &#123;</span><br><span class="line">　　if（myObject.hasOwnProperty(key))&#123;</span><br><span class="line">　　　　console.log(key);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.method&#x3D;function()&#123;</span><br><span class="line">　　console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var myObject&#x3D;&#123;</span><br><span class="line">　　a:1,</span><br><span class="line">　　b:2,</span><br><span class="line">　　c:3</span><br><span class="line">&#125;</span><br><span class="line">Object.keys(myObject).forEach(function(key,index)&#123;&lt;br&gt;　　console.log(key,myObject[key])&lt;br&gt;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>forin forof 遍历 数组 对象 ES6 ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery和javascript使用技巧</title>
    <url>/2017/09/15/jQuery%E5%92%8Cjavascript%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>把平时不常用或很少用到的但是比较实用的方法收集整理出来，方便查阅回顾。</p>
<a id="more"></a>

<h1 id="jQuery实现全选和反选"><a href="#jQuery实现全选和反选" class="headerlink" title="jQuery实现全选和反选"></a>jQuery实现全选和反选</h1><blockquote>
<p>该效果使用了prop方法，利用第二个参数是一个函数，返回一个布尔值，通过该值取反实现全选和反选功能。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;input[type&#x3D;&#39;button&#39;]&quot;).on(&#39;click&#39;,function()&#123;</span><br><span class="line">  $(&quot;input[type&#x3D;&#39;checkbox&#39;]&quot;).prop(&quot;checked&quot;,function(i,v)&#123;</span><br><span class="line">    console.log(i+&#39;,&#39;+v);</span><br><span class="line">    return !v</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="jQuery-实现给元素切换不同类名"><a href="#jQuery-实现给元素切换不同类名" class="headerlink" title="jQuery 实现给元素切换不同类名"></a>jQuery 实现给元素切换不同类名</h1><blockquote>
<p>该效果使用了toggleClass方法，利用该方法的参数可以为一个函数，返回值作为每次切换的类名，此处利用index方法查到当前对象的索引并在函数返回值里调用来实现切换不同的类名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;input[type&#x3D;&#39;button&#39;]&quot;).on(&#39;click&#39;,function()&#123;</span><br><span class="line">  $(&quot;input[type&#x3D;&#39;checkbox&#39;]&quot;).toggleClass(function()&#123;</span><br><span class="line">    return &#39;item&#39;+$(this).index();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="jQuery-给元素添加样式并让其逐步变化"><a href="#jQuery-给元素添加样式并让其逐步变化" class="headerlink" title="jQuery 给元素添加样式并让其逐步变化"></a>jQuery 给元素添加样式并让其逐步变化</h1><blockquote>
<p>该效果使用了jQuery的css方法、width方法和height方法，后两种方法返回选择元素的宽高，然后通过css方法设置元素的宽高，其中width方法和height方法可以设置一个函数，返回元素的宽高，其中函数有两个参数，可选，一个是该元素的索引位置，一个是该元素的当前值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;input[type&#x3D;&#39;button&#39;]&quot;).on(&#39;click&#39;, function() &#123;</span><br><span class="line">  $(&#39;div&#39;).css(&#123;</span><br><span class="line">    width:function( index, oldvalue )&#123;</span><br><span class="line">      return parseFloat( oldvalue ) * 1.2;</span><br><span class="line">    &#125;,</span><br><span class="line">    height:function( index, v )&#123;</span><br><span class="line">      return parseFloat( oldvalue ) * 1.2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="jQuery-替换元素的标签和内容为指定的标签和内容"><a href="#jQuery-替换元素的标签和内容为指定的标签和内容" class="headerlink" title="jQuery 替换元素的标签和内容为指定的标签和内容"></a>jQuery 替换元素的标签和内容为指定的标签和内容</h1><blockquote>
<p>该效果使用了jQuery的replaceWith方法，该方法有两个参数，一个是该元素的索引值，一个是该元素的text(input中为空)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;p&#39;).replaceWith(function( i, v )&#123;</span><br><span class="line">  return &#39;&lt;\b&gt;&#39;+ $(this).text() + i +&#39;,&#39; +  v +&#39;&lt;&#x2F;\b&gt;&lt;\br&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="javascript中位运算符-的妙用"><a href="#javascript中位运算符-的妙用" class="headerlink" title="javascript中位运算符~的妙用"></a>javascript中位运算符~的妙用</h1><p><strong>按位非运算符，简单的理解就是改变运算数的符号并减去1，当然，这是只是简单的理解能转换成number类型的数据。</strong></p>
<blockquote>
<p>项目中用到了indexOf的方法，该方法返回指定索引值，如[1,2,3].indexOf(2)返回的就是2在数组中的索引1，该方法返回值有一个规律，如果该元素存在于指定数组中，返回数组中该元素的索引值，如果不存在的话一律返回-1。该方法的应用场景很多，比如判断类中是否存在指定类，得出布尔值，根据该值写业务逻辑；再比如此次项目中遇到的，一个多选select标签，根据接口返回的数据（组）判断是否被选中，其中利用到了prop方法、attr方法、、text方法、indexof方法、map方法和html方法，同样也运用了~运算符，非常灵活地实现了项目需求。~~运算符可以简单的理解为去掉小数保留整数，不遵循四舍五入个规则。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select style&#x3D;&quot;width:200px&quot; id&#x3D;&quot;sel1&quot;&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;1&quot;&gt;1&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;select style&#x3D;&quot;width:200px;height: 200px;&quot; id&#x3D;&quot;sel2&quot; multiple&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;select style&#x3D;&quot;width:200px;height: 200px;&quot; id&#x3D;&quot;sel3&quot; multiple&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(&#39;&lt;option &#x2F;&gt;&#39;).attr(&#39;value&#39;,&#39;a&#39;).text(&#39;测试&#39;).appendTo(&#39;#sel1&#39;);</span><br><span class="line">  var arr &#x3D; [1,2,3,4,5];</span><br><span class="line">  var arr2 &#x3D; [1,3,5,7,9,11,13,15];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;the following codes have same effects</span><br><span class="line">  &#x2F;&#x2F;method one</span><br><span class="line">  $(&#39;#sel2&#39;).html(arr.map(function(v,i)&#123;</span><br><span class="line">    return $(&#39;&lt;option&#x2F;&gt;&#39;).attr(&#39;value&#39;,&#39;v&#39;).text(&#39;测试&#39;+v).prop(&#39;selected&#39;,~arr2.indexOf(v) ? false : true);</span><br><span class="line">  &#125;))</span><br><span class="line">  &#x2F;&#x2F;method two</span><br><span class="line">  $(&#39;#sel3&#39;).html(arr.map(function(v,i)&#123;</span><br><span class="line">    return $(&#39;&lt;option&#x2F;&gt;&#39;).attr(&#39;value&#39;,&#39;v&#39;).text(&#39;测试&#39;+v).prop(&#39;selected&#39;,arr2.indexOf(v) &#x3D;&#x3D; -1 ? false : true);</span><br><span class="line">  &#125;))</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="is-方法比你想象的更为强大"><a href="#is-方法比你想象的更为强大" class="headerlink" title="is()方法比你想象的更为强大"></a>is()方法比你想象的更为强大</h1><p><strong>根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; First, cache the element into a variable:</span><br><span class="line">var elem &#x3D; $(&#39;#elem&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Is this a div?</span><br><span class="line">elem.is(&#39;div&#39;) &amp;&amp; log(&quot;it&#39;s a div&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Does it have the bigbox class?</span><br><span class="line">elem.is(&#39;.bigbox&#39;) &amp;&amp; log(&quot;it has the bigbox class!&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Is it visible? (we are hiding it in this example)</span><br><span class="line">elem.is(&#39;:not(:visible)&#39;) &amp;&amp; log(&quot;it is hidden!&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Animating</span><br><span class="line">elem.animate(&#123;&#39;width&#39;:200&#125;,1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; is it animated?</span><br><span class="line">elem.is(&#39;:animated&#39;) &amp;&amp; log(&quot;it is animated!&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="jQuery方法-实际上是拥有两个参数的，你知道第二个参数的作用吗？"><a href="#jQuery方法-实际上是拥有两个参数的，你知道第二个参数的作用吗？" class="headerlink" title="jQuery方法$()实际上是拥有两个参数的，你知道第二个参数的作用吗？"></a>jQuery方法$()实际上是拥有两个参数的，你知道第二个参数的作用吗？</h1><p><strong>注意：<code>$(&#39;selector1,selector2&#39;)</code>和<code>$(&#39;selector&#39;,contextmenu || attribute Object)</code>的区别</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Select an element. The second argument is context to limit the search</span><br><span class="line">&#x2F;&#x2F; You can use a selector, jQuery object or dom element</span><br><span class="line"></span><br><span class="line">$(&#39;li&#39;,&#39;#firstList&#39;).each(function()&#123;</span><br><span class="line">    log($(this).html());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log(&#39;-----&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an element. The second argument is an</span><br><span class="line">&#x2F;&#x2F; object with jQuery methods to be called</span><br><span class="line"></span><br><span class="line">var div &#x3D; $(&#39;&lt;div&gt;&#39;,&#123;</span><br><span class="line">    &quot;class&quot;: &quot;bigBlue&quot;,</span><br><span class="line">    &quot;css&quot;: &#123;</span><br><span class="line">        &quot;background-color&quot;:&quot;purple&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;width&quot; : 20,</span><br><span class="line">    &quot;height&quot;: 20,</span><br><span class="line">    &quot;animate&quot; : &#123;   &#x2F;&#x2F; You can use any jQuery method as a property!</span><br><span class="line">        &quot;width&quot;: 200,</span><br><span class="line">        &quot;height&quot;:50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">div.appendTo(&#39;#result&#39;);</span><br></pre></td></tr></table></figure>
<h1 id="禁用网页右键菜单"><a href="#禁用网页右键菜单" class="headerlink" title="禁用网页右键菜单"></a>禁用网页右键菜单</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; Prevent right clicking on this page</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(document).on(&quot;contextmenu&quot;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="更方便的分解URL"><a href="#更方便的分解URL" class="headerlink" title="更方便的分解URL"></a>更方便的分解URL</h1><p><strong>也许你会使用正则表达式来解析URL，但这绝对不是一种好的方法，我们可以借用a标签来实现它。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; You want to parse this address into parts:</span><br><span class="line">var url &#x3D; &#39;http:&#x2F;&#x2F;tutorialzine.com&#x2F;books&#x2F;jquery-trickshots?trick&#x3D;12#comments&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The trickshot:</span><br><span class="line">var a &#x3D; $(&#39;&lt;a&gt;&#39;,&#123; href: url &#125;);</span><br><span class="line"></span><br><span class="line">log(&#39;Host name: &#39; + a.prop(&#39;hostname&#39;));</span><br><span class="line">log(&#39;Path: &#39; + a.prop(&#39;pathname&#39;));</span><br><span class="line">log(&#39;Query: &#39; + a.prop(&#39;search&#39;));</span><br><span class="line">log(&#39;Protocol: &#39; + a.prop(&#39;protocol&#39;));</span><br><span class="line">log(&#39;Hash: &#39; + a.prop(&#39;hash&#39;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="当做复杂的修改时要分离元素"><a href="#当做复杂的修改时要分离元素" class="headerlink" title="当做复杂的修改时要分离元素"></a>当做复杂的修改时要分离元素</h1><p>** 修改一个dom元素要求网页重绘，这个代价是高昂的，所以如果你想要再提高性能，就可以尝试着当对一个元素进行大量修改时先从页面中分离这个元素，修改完之后再添加到页面。 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Modifying in place</span><br><span class="line">var elem &#x3D; $(&#39;#elem&#39;);</span><br><span class="line"></span><br><span class="line">timer(&#39;In place&#39;);</span><br><span class="line"></span><br><span class="line">for(i&#x3D;0; i &lt; iterations; i++)&#123;</span><br><span class="line"></span><br><span class="line">    elem.width(Math.round(100*Math.random()));</span><br><span class="line">    elem.height(Math.round(100*Math.random()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer_result(&#39;In place&#39;);</span><br><span class="line"></span><br><span class="line">var parent &#x3D; elem.parent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Detaching first</span><br><span class="line">timer(&#39;Detached&#39;);</span><br><span class="line"></span><br><span class="line">elem.detach();</span><br><span class="line"></span><br><span class="line">for(i&#x3D;0; i &lt; iterations; i++)&#123;</span><br><span class="line"></span><br><span class="line">    elem.width(Math.round(100*Math.random()));</span><br><span class="line">    elem.height(Math.round(100*Math.random()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elem.appendTo(parent);</span><br><span class="line"></span><br><span class="line">timer_result(&#39;Detached&#39;);</span><br></pre></td></tr></table></figure>
<h1 id="创建自己习惯的事件"><a href="#创建自己习惯的事件" class="headerlink" title="创建自己习惯的事件"></a>创建自己习惯的事件</h1><p>** 你可以使用on()方法创建自己喜欢的事件名称，然后通过trigger来触发。举例如下： **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var button1 &#x3D; $(&#39;#button1&#39;),</span><br><span class="line">    button2 &#x3D; $(&#39;#button2&#39;),</span><br><span class="line">    button3 &#x3D; $(&#39;#button3&#39;),</span><br><span class="line">    clear &#x3D; $(&#39;#clear&#39;),</span><br><span class="line">    div &#x3D; $(&#39;#eventDiv&#39;);</span><br><span class="line"></span><br><span class="line">div.on(&#123;</span><br><span class="line">    jump : function()&#123;</span><br><span class="line">        alert(&#39;Jumped!&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    punch : function(e,data)&#123;</span><br><span class="line">        alert(&#39;Punched &#39;+data+&#39;!&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    click : function()&#123;</span><br><span class="line">        alert(&#39;Simulated click!&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button1.click(function()&#123;</span><br><span class="line">    div.trigger(&#39;jump&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button2.click(function()&#123;</span><br><span class="line">    &#x2F;&#x2F; Pass data along with the event</span><br><span class="line">    div.trigger(&#39;punch&#39;,[&#39;hard&#39;]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button3.click(function()&#123;</span><br><span class="line">    div.trigger(&#39;click&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">clear.click(function()&#123;</span><br><span class="line">    &#x2F;&#x2F;some clear code</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="使用延迟简化你的Ajax请求"><a href="#使用延迟简化你的Ajax请求" class="headerlink" title="使用延迟简化你的Ajax请求"></a>使用延迟简化你的Ajax请求</h1><p>** 延迟(deferreds)是一个强大的工具。jQuery对于每一个Ajax请求都会返回一个deferred对象。 <code>deferred.done()</code>方法接受一个或多个参数，所有这些都参数可以是一个单一的函数或一个函数数组。当Deferred（延迟）解决时，doneCallbacks被调用。回调是依照他们添加的顺序执行。一旦<code>deferred.done()</code>返回Deferred（延迟）对象，Deferred（延迟）可以链接其它的延迟对象，包括增加额外的<code>.done()</code>方法。下面这样就会使你的代码更易读： **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; This is equivalent to passing a callback as the</span><br><span class="line">&#x2F;&#x2F; second argument (executed on success):</span><br><span class="line"></span><br><span class="line">$.get(&#39;assets&#x2F;misc&#x2F;1.json&#39;).done(function(r)&#123;</span><br><span class="line">    log(r.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Requesting a file that does not exist. This will trigger</span><br><span class="line">&#x2F;&#x2F; the failure response. To handle it, you would normally have to</span><br><span class="line">&#x2F;&#x2F; use the full $.ajax method and pass it as a failure callback,</span><br><span class="line">&#x2F;&#x2F; but with deferreds you can can simply use the fail method:</span><br><span class="line"></span><br><span class="line">$.get(&#39;assets&#x2F;misc&#x2F;non-existing.json&#39;).fail(function(r)&#123;</span><br><span class="line">    log(&#39;Oops! The second ajax request was &quot;&#39; + r.statusText + &#39;&quot; (error &#39; + r.status + &#39;)!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="平行的运行多个Ajax请求"><a href="#平行的运行多个Ajax请求" class="headerlink" title="平行的运行多个Ajax请求"></a>平行的运行多个Ajax请求</h1><p>** 当我们需要发送多个Ajax请求时，相反于等待一个发送结束再发送下一个，我们可以平行地发送来加速Ajax请求发送。 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The trick is in the $.when() function:</span><br><span class="line"></span><br><span class="line">$.when($.get(&#39;assets&#x2F;misc&#x2F;1.json&#39;), $.get(&#39;assets&#x2F;misc&#x2F;2.json&#39;)).then(function(r1, r2)&#123;</span><br><span class="line">    log(r1[0].message + &quot; &quot; + r2[0].message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript jQuery API 技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 代码规范</title>
    <url>/2018/04/11/javascript%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="为什要遵守代码规范"><a href="#为什要遵守代码规范" class="headerlink" title="为什要遵守代码规范"></a>为什要遵守代码规范</h1><p>软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p>
<ul>
<li><p>花时间学习和理解这个问题</p>
</li>
<li><p>花时间是了解应该解决的问题代码</p>
</li>
<li><p>还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。</p>
</li>
</ul>
<a id="more"></a>

<p><strong>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。</strong></p>
<p>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p>
<ul>
<li><p>bug是暴露的</p>
</li>
<li><p>新功能被添加到应用程序</p>
</li>
<li><p>程序在新的环境下工作（例如，市场上出现新想浏览器）</p>
</li>
<li><p>代码改变用途</p>
</li>
<li><p>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</p>
</li>
</ul>
<p><strong>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。</strong></p>
<blockquote>
<p>可维护的代码意味着：</p>
</blockquote>
<ul>
<li><p>可读的</p>
</li>
<li><p>一致的</p>
</li>
<li><p>可预测的</p>
</li>
<li><p>看上去就像是同一个人写的</p>
</li>
<li><p>已记录</p>
</li>
</ul>
<h1 id="编写代码需遵守的几个原则"><a href="#编写代码需遵守的几个原则" class="headerlink" title="编写代码需遵守的几个原则"></a>编写代码需遵守的几个原则</h1><p>提示： 不遵守这些原则代码也能运行起来。只是可能出现难以维护的现象。规范就像一种模式，大家按照一种模式来，那么阅读其他人的代码，成本就降低了。</p>
<p><strong>编写代码注意事项：</strong></p>
<h2 id="尽量减少声明全局变量"><a href="#尽量减少声明全局变量" class="headerlink" title="尽量减少声明全局变量"></a>尽量减少声明全局变量</h2><h2 id="定义变量是，尽量放到顶部"><a href="#定义变量是，尽量放到顶部" class="headerlink" title="定义变量是，尽量放到顶部"></a>定义变量是，尽量放到顶部</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">    var a &#x3D; 1,</span><br><span class="line">        b &#x3D; 2,</span><br><span class="line">        sum &#x3D; a + b,</span><br><span class="line">        myobject &#x3D; &#123;&#125;,</span><br><span class="line">        i,</span><br><span class="line">        j;</span><br><span class="line">    &#x2F;&#x2F; function body...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在es6中，使用let 定义，可能出现’暂时性死区’, 具体想知道什么叫做’暂时性死区’ , 请查看阮一峰<a href="http://es6.ruanyifeng.com/#docs/let">ECMAScript 6 入门</a></p>
<h2 id="for循环-for-Loops"><a href="#for循环-for-Loops" class="headerlink" title="for循环(for Loops)"></a>for循环(for Loops)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 次佳的循环</span><br><span class="line">for (var i &#x3D; 0; i &lt; myarray.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 使用myarray[i]做点什么</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更好的方式</span><br><span class="line">for (var i &#x3D; 0, max &#x3D; myarray.length; i &lt; max; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 使用myarray[i]做点什么</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JSLint提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手，如果你直接无视它，JSLint的plusplus选项会是false（默认是default）。</strong></p>
<p>还有两种变化的形式，其又有了些微改进，因为：</p>
<ul>
<li><p>少了一个变量(无max)</p>
</li>
<li><p>向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率 //第一种变化的形式：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i, myarray &#x3D; [];</span><br><span class="line">for (i &#x3D; myarray.length; i–-;) &#123;</span><br><span class="line">	&#x2F;&#x2F; 使用myarray[i]做点什么</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;第二种使用while循环： </span><br><span class="line">var myarray &#x3D; [],</span><br><span class="line">i &#x3D; myarray.length;</span><br><span class="line">while (i–-) &#123;</span><br><span class="line">	&#x2F;&#x2F; 使用myarray[i]做点什么</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-in循环-for-in-Loops"><a href="#for-in循环-for-in-Loops" class="headerlink" title="for-in循环(for-in Loops)"></a>for-in循环(for-in Loops)</h2><p>for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。</p>
<blockquote>
<p>从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p>
</blockquote>
<p>有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">var man &#x3D; &#123;</span><br><span class="line">    hands: 2,</span><br><span class="line">    legs: 2,</span><br><span class="line">    heads: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在代码的某个地方</span><br><span class="line">&#x2F;&#x2F; 一个方法添加给了所有对象</span><br><span class="line">if (typeof Object.prototype.clone &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">    Object.prototype.clone &#x3D; function () &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; for-in 循环</span><br><span class="line">for (var i in man) &#123;</span><br><span class="line">if (man.hasOwnProperty(i)) &#123; &#x2F;&#x2F; 过滤</span><br><span class="line">    console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 控制台显示结果</span><br><span class="line">hands : 2</span><br><span class="line">legs : 2</span><br><span class="line">heads : 1</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; 反面例子:</span><br><span class="line">&#x2F;&#x2F; for-in loop without checking hasOwnProperty()</span><br><span class="line">for (var i in man) &#123;</span><br><span class="line">	console.log(i, &quot;:&quot;, man[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">控制台显示结果</span><br><span class="line">hands : 2</span><br><span class="line">legs : 2</span><br><span class="line">heads : 1</span><br><span class="line">clone: function()</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes"><a href="#（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes" class="headerlink" title="（不）扩展内置原型((Not) Augmenting Built-in Prototypes)"></a>（不）扩展内置原型((Not) Augmenting Built-in Prototypes)</h2><p>增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。</p>
<p><strong>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</strong></p>
<ul>
<li><p>可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，- 你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</p>
</li>
<li><p>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。</p>
</li>
<li><p>你清楚地文档记录并和团队交流了变化。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (typeof Object.protoype.myMethod !&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">   Object.protoype.myMethod &#x3D; function () &#123;</span><br><span class="line">       &#x2F;&#x2F; 实现...</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，强烈不建议使用</p>
<h2 id="避免隐式类型转换-Avoiding-Implied-Typecasting"><a href="#避免隐式类型转换-Avoiding-Implied-Typecasting" class="headerlink" title="避免隐式类型转换(Avoiding Implied Typecasting )"></a>避免隐式类型转换(Avoiding Implied Typecasting )</h2><p>JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var zero &#x3D; 0;</span><br><span class="line">if (zero &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">	&#x2F;&#x2F; 不执行，因为zero为0, 而不是false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反面示例</span><br><span class="line">if (zero &#x3D;&#x3D; false) &#123;</span><br><span class="line">	&#x2F;&#x2F; 执行了...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免-Avoiding-eval"><a href="#避免-Avoiding-eval" class="headerlink" title="避免(Avoiding) eval()"></a>避免(Avoiding) eval()</h2><p>如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 反面示例</span><br><span class="line">var property &#x3D; &quot;name&quot;;</span><br><span class="line">alert(eval(&quot;obj.&quot; + property));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更好的</span><br><span class="line">var property &#x3D; &quot;name&quot;;</span><br><span class="line">alert(obj[property]);</span><br></pre></td></tr></table></figure>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h2><p>代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p>
<p>一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，<strong>使用四个空格缩进，这也是JSLint中默认的缩进。</strong></p>
<p>什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function outer(a, b) &#123;</span><br><span class="line">    var c &#x3D; 1,</span><br><span class="line">        d &#x3D; 2,</span><br><span class="line">        inner;</span><br><span class="line">    if (a &gt; b) &#123;</span><br><span class="line">        inner &#x3D; function () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                r: c - d</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        inner &#x3D; function () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                r: c + d</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="花括号-Curly-Braces"><a href="#花括号-Curly-Braces" class="headerlink" title="花括号{}(Curly Braces)"></a>花括号{}(Curly Braces)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 糟糕的实例</span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i +&#x3D; 1)</span><br><span class="line">alert(i);</span><br><span class="line">&#x2F;&#x2F; 好的实例</span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i +&#x3D; 1) &#123;</span><br><span class="line">	alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左花括号的位置-Opening-Brace-Location"><a href="#左花括号的位置-Opening-Brace-Location" class="headerlink" title="左花括号的位置(Opening Brace Location)"></a>左花括号的位置(Opening Brace Location)</h2><p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 警告： 意外的返回值</span><br><span class="line">function func() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#x2F;&#x2F; 下面代码不执行</span><br><span class="line">    &#123;</span><br><span class="line">        name : &quot;Batman&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 警告： 意外的返回值</span><br><span class="line">function func() &#123;</span><br><span class="line">    return undefined;</span><br><span class="line">    &#x2F;&#x2F; 下面代码不执行</span><br><span class="line">    &#123;</span><br><span class="line">        name : &quot;Batman&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格(White Space)"></a>空格(White Space)</h2><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p>
<blockquote>
<p>适合使用空格的地方包括：</p>
</blockquote>
<ul>
<li><p>for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {…}</p>
</li>
<li><p>for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {…}</p>
</li>
<li><p>分隔数组项的逗号的后面：var a = [1, 2, 3];</p>
</li>
<li><p>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2};</p>
</li>
<li><p>限定函数参数：myFunc(a, b, c)</p>
</li>
<li><p>函数声明的花括号的前面：function myFunc() {}</p>
</li>
<li><p>匿名函数表达式function的后面：var myFunc = function () {};</p>
</li>
</ul>
<p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=等前后都需要空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 宽松一致的间距</span><br><span class="line">&#x2F;&#x2F; 使代码更易读</span><br><span class="line">&#x2F;&#x2F; 使得更加“透气”</span><br><span class="line">var d &#x3D; 0,</span><br><span class="line">    a &#x3D; b + 1;</span><br><span class="line">if (a &amp;&amp; b &amp;&amp; c) &#123;</span><br><span class="line">    d &#x3D; a % c;</span><br><span class="line">    a +&#x3D; d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反面例子</span><br><span class="line">&#x2F;&#x2F; 缺失或间距不一</span><br><span class="line">&#x2F;&#x2F; 使代码变得疑惑</span><br><span class="line">var d &#x3D; 0,</span><br><span class="line">    a &#x3D; b + 1;</span><br><span class="line">if (a&amp;&amp;b&amp;&amp;c) &#123;</span><br><span class="line">    d&#x3D;a % c;</span><br><span class="line">    a+&#x3D; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后需要注意的一个空格——花括号间距。最好使用空格：</strong></p>
<ul>
<li><p>函数、if-else语句、循环、对象字面量的左花括号的前面({)</p>
</li>
<li><p>else或while之间的右花括号(}) //{} 空格</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (4) &#123;</span><br><span class="line">	console.log(1)</span><br><span class="line">&#125; else if (3) &#123;</span><br><span class="line">	console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><ul>
<li><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p>
</li>
<li><p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p>
</li>
</ul>
<h2 id="以大写字母写构造函数-Capitalizing-Constructors"><a href="#以大写字母写构造函数-Capitalizing-Constructors" class="headerlink" title="以大写字母写构造函数(Capitalizing Constructors)"></a>以大写字母写构造函数(Capitalizing Constructors)</h2><p>JavaScript并没有类，但有new调用的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var adam &#x3D; new Person();  </span><br></pre></td></tr></table></figure>
<p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。<br>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyConstructor() &#123;...&#125;</span><br><span class="line">function myFunction() &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分隔单词-Separating-Words"><a href="#分隔单词-Separating-Words" class="headerlink" title="分隔单词(Separating Words)"></a>分隔单词(Separating Words)</h2><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p>
<ul>
<li><p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。</p>
</li>
<li><p>对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是myFunction(), calculateArea()和getFirstName()。</p>
</li>
</ul>
<h2 id="注释-Writing-Comments"><a href="#注释-Writing-Comments" class="headerlink" title="注释(Writing Comments)"></a>注释(Writing Comments)</h2><blockquote>
<p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p>
</blockquote>
<blockquote>
<p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p>
</blockquote>
<h1 id="css代码规范"><a href="#css代码规范" class="headerlink" title="css代码规范"></a>css代码规范</h1><p>css规范我们伟大的张旭鑫老师，讲的很清楚。<a href="http://www.zhangxinxu.com/wordpress/2010/09/%E7%B2%BE%E7%AE%80%E9%AB%98%E6%95%88%E7%9A%84css%E5%91%BD%E5%90%8D%E5%87%86%E5%88%99%E6%96%B9%E6%B3%95/">面向属性的命名</a></p>
<p>这是比较好的命名规范。简介来说，就是我们先定义好一些常用基础类样式。组件则使用less,或者sass进行组装，形成即可。</p>
]]></content>
      <tags>
        <tag>javascript 编程 开发 规范 可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript造轮子心得与总结</title>
    <url>/2017/09/10/javascript%E8%87%AA%E5%B7%B1%E9%80%A0%E8%BD%AE%E5%AD%90%E5%BF%83%E5%BE%97%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>造了一个忒简单的轮子。。。。。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;点击&lt;&#x2F;button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  &#x2F;*</span><br><span class="line">  *  本次只是写了一个基于jquery和bootbox的一个最简单的插件，学习领会自己造轮子的原理和其中的乐趣。</span><br><span class="line">  *  总结：</span><br><span class="line">  *  1、插件外面用自调用函数包裹，防止变量污染</span><br><span class="line">  *  2、插件外面传入想要传入的对象，如jquery($)和全局window，以便可以采用$.xxx或window.xxx来进行调用(window可省略)</span><br><span class="line">  *  3、如果要用javascript来造轮子，可以借鉴jquery的方法，方法内部返回该实例，这样调用时就不用实例化了(new关键字)</span><br><span class="line">  *  4、在匿名函数前加!、+、-、()、&#x3D;转换成函数表达式，然后就可以直接通过()进行调用了，最好用()转换，因为其他的几个运算符会对函数返回结果进行运算造成不可预料的结果</span><br><span class="line">  *  5、通过jquery的extend方法设置参数的默认值，同时可以利用传入的同名参数对默认值进行覆盖，注意引用类型要深度克隆，合并后的对象（第二个参数）最好是空对象</span><br><span class="line">  *&#x2F;</span><br><span class="line">  +function($,win)&#123;</span><br><span class="line">    var htmlStr &#x3D; &#39;&lt;div style&#x3D;&quot;color:blue&quot;&gt;测试编写不能覆盖的插件模板&lt;&#x2F;div&gt;&#39;;</span><br><span class="line">    $.demo &#x3D; $.demo || function(options)&#123;</span><br><span class="line">      var setting &#x3D; $.extend(true,&#123;&#125;, &#123;</span><br><span class="line">        size: &#39;middle&#39;,</span><br><span class="line">        backdrop: false,</span><br><span class="line">        title: &#39;测试插件的默认标题&#39;,</span><br><span class="line">        message: &#39;&#39;,</span><br><span class="line">        buttons: &#123;</span><br><span class="line">          ok: &#123;</span><br><span class="line">            label:&#39;确认&#39;,</span><br><span class="line">            className:&#39;btn-primary&#39;,</span><br><span class="line">            callback:function()&#123;bootbox.alert(&#39;测试默认的确认按钮回调&#39;)&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          cancel:&#123;</span><br><span class="line">            label:&#39;取消&#39;,</span><br><span class="line">            className:&#39;btn-default&#39;,</span><br><span class="line">            callback:function()&#123;bootbox.alert(&#39;测试默认的取消按钮回调&#39;)&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,options);</span><br><span class="line">      setting.message &#x3D; htmlStr;&#x2F;&#x2F;覆盖合并参数时的默认值</span><br><span class="line">      var dlg &#x3D; bootbox.dialog(setting);</span><br><span class="line">      return dlg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(jQuery, window);</span><br><span class="line"></span><br><span class="line">  $(&#39;#btn&#39;).click(function()&#123;</span><br><span class="line">    $.demo(&#123;</span><br><span class="line">      size:&#39;small&#39;,</span><br><span class="line">      backdrop:true,</span><br><span class="line">      title:&#39;覆盖了插件的标题&#39;,</span><br><span class="line">      message:&#39;&lt;div style&#x3D;&quot;red&quot;&gt;测试没有覆盖默认内容&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">      buttons:&#123;</span><br><span class="line">        ok:&#123;</span><br><span class="line">          label:&#39;覆盖默认按钮&#39;,</span><br><span class="line">          callback:function()&#123;bootbox.alert(&#39;测试覆盖默认确认按钮&#39;)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript js 造轮子 插件 总结</tag>
      </tags>
  </entry>
  <entry>
    <title>js 事件循环（Event Loop）机制</title>
    <url>/2018/12/22/js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event%20Loop%EF%BC%89%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>先放个测试题，压压惊</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const interval &#x3D; setInterval(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setInterval&#39;);</span><br><span class="line">&#125;,0);</span><br><span class="line"> </span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">  console.log(&#39;setTimeout 1&#39;);</span><br><span class="line">  Promise.resolve()</span><br><span class="line">    .then(()&#x3D;&gt;&#123;</span><br><span class="line">      console.log(&#39;promise1&#39;);  </span><br><span class="line">    &#125;)</span><br><span class="line">    .then(()&#x3D;&gt;&#123;</span><br><span class="line">      setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#39;setTimeout 2&#39;);</span><br><span class="line">        clearInterval(interval);</span><br><span class="line">      &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,0);</span><br><span class="line"> </span><br><span class="line">Promise.resolve()</span><br><span class="line">  .then(()&#x3D;&gt;&#123;</span><br><span class="line">     console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>末尾揭晓答案</strong></p>
<a id="more"></a>

<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。</p>
<p>单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p>
<p>而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>
<p>线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</p>
<p>当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。</p>
<p>然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。</p>
<p>可以预见，未来的javascript也会一直是一门单线程的语言。</p>
<h1 id="单线程的优劣势"><a href="#单线程的优劣势" class="headerlink" title="单线程的优劣势"></a>单线程的优劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><p>降低处理复杂性，简化开发，例如不用考虑竞争机制等。</p>
</li>
<li><p>作为用于预处理与用户互动的脚本语言，可以更加容易地处理状态同步的问题。</p>
</li>
<li><p>JS核心维护人员自身的理解与设计。</p>
</li>
<li><p>越简单越容易推广，快速上手。</p>
</li>
</ol>
<h2 id="明显的劣势"><a href="#明显的劣势" class="headerlink" title="明显的劣势"></a>明显的劣势</h2><ol>
<li><p>并发处理能力，任务处于 I/O 等待状态，导致CPU处理资源的浪费。</p>
</li>
<li><p>于是JavaScript语言将任务的执行模分成两种：同步任务和异步任务。通过事件循环处理任务。</p>
</li>
<li><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p>
</li>
<li><p>异步任务：不进入主线程、而进入任务队列（Task queue），只有任务通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p>
</li>
</ol>
<h1 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h1><p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>
<p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>
<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并吧这个执行环境销毁。接着继续执行队列里的下一段代码。</p>
<h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><p>先看一段伪代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; eventLoop是一个用作队列的数组，（先进，先出）</span><br><span class="line">var eventLoop &#x3D; [ ];</span><br><span class="line">var event;</span><br><span class="line">&#x2F;&#x2F; “永远”执行</span><br><span class="line">while (true)&#123;</span><br><span class="line">  if (eventLoop.length &gt; 0)&#123;</span><br><span class="line">    &#x2F;&#x2F; 拿到队列中的下一个事件</span><br><span class="line">    event &#x3D; eventLoop.shift();</span><br><span class="line">    &#x2F;&#x2F; 现在，执行下一个事件</span><br><span class="line">    try &#123;</span><br><span class="line">      event();</span><br><span class="line">    &#125;catch (err)&#123;</span><br><span class="line">      reportError(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。</p>
<p>再贴张流程图</p>
<p><img src="https://i.loli.net/2021/01/11/XhrE7PtlaZGpVd3.jpg" alt="img"></p>
<p>事件循环的具体步骤</p>
<ol>
<li><p>同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。</p>
</li>
<li><p>系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。</p>
</li>
<li><p>执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。</p>
</li>
</ol>
<p>请看下面一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;A&#39;+ new Date());</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line"> console.log(&#39;B&#39;+new Date());</span><br><span class="line">&#125;,1000);</span><br><span class="line">var end &#x3D; Date.now()+3000;</span><br><span class="line">while(Date.now()&lt;end)&#123;&#125;</span><br><span class="line">console.log(&#39;C&#39;+new Date());</span><br></pre></td></tr></table></figure>
<p>A,B,C输出的顺序，以及输出的时间 ?</p>
<p>A会被立即输出，执行到setTimeout(…)时，将会等待1秒后在任务队列添加一个打印B的任务，然后继续往下执行。JS主线程会在while循环通过后继续往下执行，在等待3秒后C被打印，此时任务队列中还有个定时任务回调函数。JS执行栈执行完一个任务之后会再去任务队列取任务，所以C输出后。直接输出B。</p>
<p>PS：一定要清楚， setTimeout(..) 并 没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。</p>
<h1 id="macro-task-宏任务-与micro-task-微任务"><a href="#macro-task-宏任务-与micro-task-微任务" class="headerlink" title="macro task(宏任务)与micro task(微任务)"></a>macro task(宏任务)与micro task(微任务)</h1><p>以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。</p>
<p>以下事件属于宏任务：</p>
<ul>
<li>script</li>
<li>setInterval()</li>
<li>setTimeout()</li>
<li>setImmediate</li>
<li>用户交互操作</li>
<li>UI渲染</li>
</ul>
<p>以下事件属于微任务</p>
<ul>
<li>new Promise()</li>
<li>process.nextTick</li>
<li>new MutaionObserver()</li>
<li>Object.observe</li>
</ul>
<p>事件循环做的事情如下：</p>
<ol>
<li><p>检查Macrotask 队列是否为空（同步代码），若不为空，则进行下一步，若为空，则跳到3；</p>
</li>
<li><p>从Macrotask队列中取首个任务推入执行栈执行，执行完后进入下一步；</p>
</li>
<li><p>检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）；</p>
</li>
<li><p>从Microtask队列取首个任务执行，执行完后，跳到3；</p>
</li>
<li><p>然后开始下一轮 Event loop，执行宏任务中的异步代码；</p>
</li>
</ol>
<p><strong>简单来讲，整体的js代码这个macrotask先执行，同步代码执行完后有microtask执行microtask，没有microtask执行下一个macrotask，如此往复循环；</strong></p>
<hr>
<p>文首测试题的答案为：</p>
<p>promise2</p>
<p>setInterval</p>
<p>setTimeout 1</p>
<p>promise1</p>
<p>setInterval</p>
<p>setTimeout2</p>
]]></content>
      <tags>
        <tag>javascript　js　事件循环 eventloop</tag>
      </tags>
  </entry>
  <entry>
    <title>js优化嵌套的条件语句</title>
    <url>/2017/12/04/js%E4%BC%98%E5%8C%96%E5%B5%8C%E5%A5%97%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>最近在网上看了一篇文章，讲的是遇到多种分支条件判断的场景下，尽量避免使用swich和if，一个是因为性能不好，一个是因为代码阅读导致调试困难。我觉得文章讲述的这种技巧是可以借鉴的，记录下来，工作中可以采用。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (color) &#123;</span><br><span class="line">  if (color &#x3D;&#x3D;&#x3D; &#39;black&#39;) &#123;</span><br><span class="line">    printBlackBackground();</span><br><span class="line">  &#125; else if (color &#x3D;&#x3D;&#x3D; &#39;red&#39;) &#123;</span><br><span class="line">    printRedBackground();</span><br><span class="line">  &#125; else if (color &#x3D;&#x3D;&#x3D; &#39;blue&#39;) &#123;</span><br><span class="line">    printBlueBackground();</span><br><span class="line">  &#125; else if (color &#x3D;&#x3D;&#x3D; &#39;green&#39;) &#123;</span><br><span class="line">    printGreenBackground();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printYellowBackground();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一种方法来提高嵌套的if语句是用switch语句。虽然它不那么啰嗦而且排列整齐，但是并不建议使用它，因为这对于调试错误很困难。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(color) &#123;</span><br><span class="line">  case &#39;black&#39;:</span><br><span class="line">    printBlackBackground();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;red&#39;:</span><br><span class="line">    printRedBackground();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;blue&#39;:</span><br><span class="line">    printBlueBackground();</span><br><span class="line">    break;</span><br><span class="line">  case &#39;green&#39;:</span><br><span class="line">    printGreenBackground();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    printYellowBackground();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是我们应该时刻注意避免太多判断在一个条件里，尽量少的使用switch，考虑最有效率的方法：借助object。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var colorObj &#x3D; &#123;</span><br><span class="line">  &#39;black&#39;: printBlackBackground,</span><br><span class="line">  &#39;red&#39;: printRedBackground,</span><br><span class="line">  &#39;blue&#39;: printBlueBackground,</span><br><span class="line">  &#39;green&#39;: printGreenBackground,</span><br><span class="line">  &#39;yellow&#39;: printYellowBackground</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (color in colorObj) &#123;</span><br><span class="line">  colorObj[color]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js 嵌套 性能 优化 javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeJs之express框架学习笔记</title>
    <url>/2018/07/31/nodeJs%E4%B9%8Bexpress%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>先介绍下express：</p>
<blockquote>
<p>Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。</p>
</blockquote>
<p>放上<a href="http://www.expressjs.com.cn/">Express中文官网</a>，虽然是中文官网，但对于详细的API翻译并不完整，英文好的同学可以去阅读一下。至于为什么选择Express而不是koa，因为这两个框架来自同一团队，在绝大多数的用法上其实是很相似的，koa有更多的ECMAscript6的语法，而Express更适合初学者学习。</p>
<a id="more"></a>

<h1 id="首先需要安装Nodejs"><a href="#首先需要安装Nodejs" class="headerlink" title="首先需要安装Nodejs"></a>首先需要安装Nodejs</h1><p>Nodejs官网点击下一步、下一步，这里不在赘述，如果成功安装，点击开始=&gt;运行=&gt;输入”cmd”=&gt;输入node -v就可看到安装在电脑上的nodeJs的版本号。</p>
<h1 id="NPM安装Express"><a href="#NPM安装Express" class="headerlink" title="NPM安装Express"></a>NPM安装Express</h1><p>npm会和nodeJs一起安装，是一个包管理工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>
<h1 id="新建一个app-js"><a href="#新建一个app-js" class="headerlink" title="新建一个app.js"></a>新建一个app.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">app.get(&#39;&#x2F;&#39;,function(req,res)&#123;</span><br><span class="line">    res.send(&#39;&lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(1234);</span><br></pre></td></tr></table></figure>
<p>这样一个简单的例子就写好了，在浏览器中输入<a href="http://localhost:1234，就可看到网页上的Hello">http://localhost:1234，就可看到网页上的Hello</a> world!</p>
<h1 id="app-get方法"><a href="#app-get方法" class="headerlink" title="app.get方法"></a>app.get方法</h1><p>app.get(path,function(req, res));req为请求信息，res为响应信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line"> </span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res) &#123;</span><br><span class="line">       res.send(&#39;首页&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&#39;&#x2F;about&#39;, function(req, res) &#123;</span><br><span class="line">       res.send(&#39;关于&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(1234);</span><br></pre></td></tr></table></figure>
<p>localhost:1234 会看到首页，localhost:1234/about 会看到关于。<br>上面的get请求返回的是文字，以下代码返回文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">app.get(&#39;&#x2F;test&#39;,function(req,res)&#123;</span><br><span class="line">    res.sendfile(&#39;test.html&#39;);&#x2F;&#x2F;返回文件</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>若需访问其他静态文件则需以下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根目录作为静态文件访问目录 （可访问根目录内所有文件）</span><br><span class="line">app.use(express.static(path.join(__dirname, &#39;&#x2F;&#39;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根目录下&#x2F;src作为静态文件访问目录 （指定可访问的文件目录）访问地址为localhost:1234&#x2F;main.css</span><br><span class="line">app.use(express.static(&#39;src&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们还可以添加&#39;伪访问目录&#39;，这样访问的地址就是localhost:1234&#x2F;src&#x2F;main.css</span><br><span class="line">app.use(&#39;&#x2F;src&#39;,express.static(&#39;src&#39;));</span><br></pre></td></tr></table></figure>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件是用来处理HTTP请求的函数（所有的请求都会走中间件），可以用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。 它最大的特点就是，一个中间件处理完，可以把相应数据再传递给下一个中间件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function(request, response, next)&#123;</span><br><span class="line">    console.log(&quot;第一！&quot;);</span><br><span class="line">    next();&#x2F;&#x2F;执行next(),进入下一个中间件</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(function(request, response,next)&#123;</span><br><span class="line">    console.log(&quot;第二！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>若在next()中写入任何参数next(‘error’)，则代表抛出错误，程序不再执行下去。app.use()也可以根据不同的访问路径返回不同的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&quot;express&quot;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line"> </span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">    if(req.url &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">        res.send(&quot;首页&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">    if(req.url &#x3D;&#x3D; &quot;&#x2F;about&quot;) &#123;</span><br><span class="line">        res.send(&quot;关于&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(function(req, res) &#123;</span><br><span class="line">    res.send(&quot;404!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(1234);</span><br></pre></td></tr></table></figure>
<h1 id="app-all"><a href="#app-all" class="headerlink" title="app.all()"></a>app.all()</h1><p>app.all()函数可以过滤所有路径的请求<br>格式：app.all(path,function(req, res));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.all(&quot;*&quot;, function(req, res, next) &#123;</span><br><span class="line">    console.log(&#39;所有的路径请求都会走我这里&#39;)</span><br><span class="line">    res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html;charset&#x3D;utf-8&quot; &#125;); &#x2F;&#x2F;设置响应头属性值</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="query获取GET请求所带参数"><a href="#query获取GET请求所带参数" class="headerlink" title="query获取GET请求所带参数"></a>query获取GET请求所带参数</h1><p>假定请求地址为localhost:1234?name=myname</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line"> </span><br><span class="line">app.get(&quot;&#x2F;&quot;, function(req, res) &#123;</span><br><span class="line">    console.log(req.query.name);&#x2F;&#x2F;myname</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(1234);</span><br></pre></td></tr></table></figure>
<h1 id="param也可获取参数"><a href="#param也可获取参数" class="headerlink" title="param也可获取参数"></a>param也可获取参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;req.param(&quot;name&quot;)同样可以获得参数</span><br><span class="line">console.log(req.param(&quot;name&quot;)); &#x2F;&#x2F;myname</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不同的是 ‘ param可以获取不同的路由规则参数 ’</span><br><span class="line">app.get(&quot;&#x2F;user&#x2F;:name&#x2F;&quot;, function(req, res) &#123;</span><br><span class="line">    console.log(req.param(&quot;name&quot;)); &#x2F;&#x2F;myname</span><br><span class="line">    res.send(&quot;使用req.param属性获取具有路由规则的参数对象值!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="params"><a href="#params" class="headerlink" title="params"></a>params</h1><p>和param相似，但params是一个可以解析包含着有复杂命名路由规则的请求对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&quot;&#x2F;user&#x2F;:name&#x2F;:id&quot;, function(req, res) &#123;</span><br><span class="line">    console.log(req.params.name); &#x2F;&#x2F;&quot;myname&quot;</span><br><span class="line">    console.log(req.params.id); &#x2F;&#x2F;&quot;123&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>模版引擎这块就不写了，建议前后端分离。</p>
<h1 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h1><p>格式：app.post(path,function(req, res));<br>前端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var da&#x3D;&#123;data:&#39;testData&#39;&#125;;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&#39;&#x2F;api&#39;,</span><br><span class="line">    type:&#39;POST&#39;,</span><br><span class="line">    dataType:&#39;json&#39;,</span><br><span class="line">    data:da,</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>要想使用body属性解析post请求参数值，我们需要先安装和引用body-parser中间件<br>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install body-parser</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">....</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br></pre></td></tr></table></figure>
<p>node代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express&#x3D;require(&#39;express&#39;);</span><br><span class="line">var bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">var app&#x3D;express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;post 请求</span><br><span class="line">app.post(&#39;&#x2F;api&#39;,function(req,res)&#123;</span><br><span class="line">    res.send( &#123; &#39;a &#39; : req.body.data &#125; );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(1234);</span><br></pre></td></tr></table></figure>
<p>请求结果{a,’testData’}</p>
<h1 id="链式路由"><a href="#链式路由" class="headerlink" title="链式路由"></a>链式路由</h1><p>可使用 app.route()创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.route(&#39;&#x2F;book&#39;)</span><br><span class="line">    .get(function(req, res) &#123; </span><br><span class="line">        res.send(&#39;Get a random book&#39;); </span><br><span class="line">    &#125;) </span><br><span class="line">    .post(function(req, res) &#123; </span><br><span class="line">        res.send(&#39;Add a book&#39;); </span><br><span class="line">    &#125;) </span><br><span class="line">    .put(function(req, res) &#123; </span><br><span class="line">        res.send(&#39;Update the book&#39;); </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="express-Router模块化路由"><a href="#express-Router模块化路由" class="headerlink" title="express.Router模块化路由"></a>express.Router模块化路由</h1><p>路由文件 route.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var router &#x3D; express.Router();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该路由使用的中间件</span><br><span class="line">router.use(function timeLog(req, res, next) &#123;</span><br><span class="line">    console.log(&#39;Time: &#39;, Date.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 定义网站主页的路由</span><br><span class="line">router.get(&#39;&#x2F;&#39;, function(req, res) &#123;</span><br><span class="line">    res.send(&#39;home page&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 定义 about 页面的路由</span><br><span class="line">router.get(&#39;&#x2F;about&#39;, function(req, res) &#123;</span><br><span class="line">    res.send(&#39;About birds&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;导出</span><br><span class="line">module.exports &#x3D; router;</span><br></pre></td></tr></table></figure>
<p>app.js 引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var birds &#x3D; require(&#39;.&#x2F;birds&#39;);</span><br><span class="line">...</span><br><span class="line">app.use(&#39;&#x2F;birds&#39;, birds);</span><br><span class="line">&#x2F;&#x2F;应用即可处理发自 &#x2F;birds和 &#x2F;birds&#x2F;about 的请求，并且调用为该路由指定的 timeLog中间件。</span><br></pre></td></tr></table></figure>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;网址重定向 例1：使用一个完整的url跳转到一个完全不同的域名。</span><br><span class="line">res.redirect(&quot;http:&#x2F;&#x2F;www.hubwiz.com&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例2：跳转指定页面，比如登陆页，如下：</span><br><span class="line">res.redirect(&quot;login&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var session &#x3D; require(&#39;express-session&#39;);</span><br><span class="line">...</span><br><span class="line">app.use(session(&#123;</span><br><span class="line"> secret:&#39;secret&#39;,</span><br><span class="line"> resave:true,</span><br><span class="line"> saveUninitialized:false,</span><br><span class="line"> cookie:&#123;</span><br><span class="line"> maxAge:1000*60*10 &#x2F;&#x2F;过期时间设置(单位毫秒)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>node nodejs express</tag>
      </tags>
  </entry>
  <entry>
    <title>react优化总结</title>
    <url>/2019/01/31/react%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>写了一段时间的react之后，渐渐的喜欢上了使用react来写应用。</p>
<p>我们知道，Facebook在推出react时打出的旗号之一就是高性能。</p>
<p>今天我们还一起来聊一聊react的性能优化，思考还能通过哪些手段来提升React的性能，使我们的react更快，性能更好。</p>
<a id="more"></a>

<h1 id="请慎用setState，因其容易导致重新渲染"><a href="#请慎用setState，因其容易导致重新渲染" class="headerlink" title="请慎用setState，因其容易导致重新渲染"></a>请慎用setState，因其容易导致重新渲染</h1><blockquote>
<p>既然将数据主要交给了Redux来管理，那就尽量使用Redux管理你的数据和状态state，除了少数情况外，别忘了shouldComponentUpdate也需要比较state。</p>
</blockquote>
<h1 id="请将方法的bind一律置于constructor"><a href="#请将方法的bind一律置于constructor" class="headerlink" title="请将方法的bind一律置于constructor"></a>请将方法的bind一律置于constructor</h1><blockquote>
<p>Component的render里不动态bind方法，方法都在constructor里bind好，如果要动态传参，方法可使用闭包返回一个最终可执行函数。如：showDelBtn(item) { return (e) =&gt; {}; }。如果每次都在render里面的jsx去bind这个方法，每次都要绑定会消耗性能。</p>
</blockquote>
<h1 id="请只传递component需要的props"><a href="#请只传递component需要的props" class="headerlink" title="请只传递component需要的props"></a>请只传递component需要的props</h1><blockquote>
<p>传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（）。</p>
</blockquote>
<h1 id="请尽量使用const-element"><a href="#请尽量使用const-element" class="headerlink" title="请尽量使用const element"></a>请尽量使用const element</h1><blockquote>
<p>我们可以将不怎么变动，或者不需要传入状态的component写成const element的形式，这样能加快这个element的初始渲染速度。</p>
</blockquote>
<h1 id="保证key值唯一"><a href="#保证key值唯一" class="headerlink" title="保证key值唯一"></a>保证key值唯一</h1><blockquote>
<p>保证key值唯一方便diff算法比较，注意不要用数组的index作为key，原因非唯一性</p>
</blockquote>
<h1 id="合理使用shouldComponentUpdate"><a href="#合理使用shouldComponentUpdate" class="headerlink" title="合理使用shouldComponentUpdate"></a>合理使用shouldComponentUpdate</h1><blockquote>
<p>子组件更新时候对props作出新老数据比对，如果改变了，才render子组件</p>
</blockquote>
<h1 id="使用pureComponent"><a href="#使用pureComponent" class="headerlink" title="使用pureComponent"></a>使用pureComponent</h1><blockquote>
<p>使用pureComponent会默认添加shouldComponentUpdate并进行浅比较</p>
</blockquote>
<h1 id="使用Immutablejs"><a href="#使用Immutablejs" class="headerlink" title="使用Immutablejs"></a>使用Immutablejs</h1><blockquote>
<p>使用不可变的数据来解决数据状态的变化比对，提高性能</p>
</blockquote>
]]></content>
      <tags>
        <tag>react 规范 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>react前端框架dva</title>
    <url>/2017/08/29/react%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6dva/</url>
    <content><![CDATA[<p>最近正在看dva框架，发现这是一个很好应用于React的框架。<br>众所周知，react的学习成本是较高的，而antd推出的这款框架，大大的降低了react的学习成本。dva简化了 react-redux 的部署的文件复杂度。使其清晰易懂。相信熟悉redux 的人，并不需要了解太多知识就能很快的上手。</p>
<a id="more"></a>

<h1 id="Dva的安装"><a href="#Dva的安装" class="headerlink" title="Dva的安装"></a>Dva的安装</h1><blockquote>
<p>首先需要安装的是 dva-cli 。dva-cli 是 dva 的命令行工具，包含 init、new、generate 等功能，目前最重要的功能是可以快速生成项目以及你所需要的代码片段。 </p>
</blockquote>
<p><code>npm install -g dva-cli </code></p>
<blockquote>
<p>安装完成后，可以通过 dva -v 查看版本，以及 dva -h 查看帮助信息。 </p>
</blockquote>
<h1 id="创建新应用"><a href="#创建新应用" class="headerlink" title="创建新应用"></a>创建新应用</h1><p>安装完 dva-cli 后，我们用他来创建一个新应用，取名 myDome 。<br><code>dva new myDome –demo </code></p>
<blockquote>
<p>注意： –demo 用于创建简单的 demo 级项目，正常项目初始化不加要这个参数。然后进入项目目录，并启动。 </p>
</blockquote>
<p><code>cd myDome </code><br><code>npm start </code></p>
<blockquote>
<p>几秒之后，会看到这样的输出： </p>
</blockquote>
<p><code>proxy: listened on 8989 livereload: listening on 35729 :package: 173/173 build modules webpack: bundle build is now finished.</code> </p>
<ul>
<li>(如需关闭 server，请按 Ctrl-C.)</li>
</ul>
<blockquote>
<p>在浏览器里打开 <a href="http://localhost:8989/">http://localhost:8989/</a> ，正常情况下，你会看到一个 “Yay! Welcome to dva!” 页面。</p>
</blockquote>
]]></content>
      <tags>
        <tag>react 前端 框架 dva js</tag>
      </tags>
  </entry>
  <entry>
    <title>useEffect引起的React Hooks深入了解</title>
    <url>/2021/01/12/useEffect%E5%BC%95%E8%B5%B7%E7%9A%84React%20Hooks%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>参考文章 <strong>react源码</strong>，<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a>，<a href="https://juejin.im/post/5d985deae51d4577f9285c2f">呕心沥血，一文看懂 react hooks</a>，<a href="https://react.docschina.org/docs/hooks-intro.html">react官网</a></p>
</blockquote>
<p>在进入正式阅读之前，最好先思考一下下面的问题：</p>
<ol>
<li>React Hooks真的有生命周期吗？</li>
<li>React Hooks的函数里面定义的函数或者变量会被缓存吗，这样下次再调用组件的时候就可以不用重新声明了。</li>
<li>为什么我的useEffect有时候拿到了之前的值。</li>
</ol>
<a id="more"></a>

<h2 id="React-Hooks函数式渲染"><a href="#React-Hooks函数式渲染" class="headerlink" title="React Hooks函数式渲染"></a>React Hooks函数式渲染</h2><blockquote>
<p>我非常喜欢参考文章里面说的，如果你想要学好React Hooks，那么你摒弃掉之前组件的想法可能会更加好</p>
</blockquote>
<p>为什么我会这么讲？</p>
<p>React Hooks会璞归真，其实就是将我们之前封装好的组件对象重新变回来了我们原始的代码模式。让你只要考虑执行过程中的栈，堆和队列</p>
<h3 id="函数式渲染与生命周期的关系"><a href="#函数式渲染与生命周期的关系" class="headerlink" title="函数式渲染与生命周期的关系"></a>函数式渲染与生命周期的关系</h3><p>在React Hooks里面，当我们声明一个组件时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      我是React Hooks</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>我们可以很明显的看到，这就是一个函数嘛，只是加入JSX的写法，返回了组件而已。是的，你没有理解错，这应该也是React Hooks的创始人的想法，不比Vue，虽然轻量，但是封装好了一切，导致可能前端就是学习框架去了~</p>
<p>但是，React不也是组件化的框架吗？是的，当代码增多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> &#123;setName(name + <span class="string">&#x27;world&#x27;</span>)&#125;&#125;&gt;</span><br><span class="line">      我是&#123;name&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>让我们来大胆的猜想一下，当这段代码运行完了之后，页面会发生什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次渲染</span></span><br><span class="line">-----函数开始-----</span><br><span class="line">useState定义了一个为<span class="string">&#x27;name&#x27;</span>的state</span><br><span class="line">useEffect定义了一个函数，他没有任何的依赖项</span><br><span class="line">返回一个JSX显示到我们页面上</span><br><span class="line">页面加载成功，发现我们有个useEffect，发现他不依赖任何属性，他就要运行，于是他从此次函数中拿到name--&gt;打印hello</span><br><span class="line">-----函数结束-----</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当点击我们的文本</span></span><br><span class="line">点击事件回调修改我们的state，告诉我们相应的组件，你需要更新了</span><br><span class="line">-----函数开始-----</span><br><span class="line">从我们的state中拿出修改后的<span class="string">&#x27;name&#x27;</span>，这时候name为helloworld</span><br><span class="line">第二次渲染了，useEffect已经被声明过了，不理他了</span><br><span class="line">返回一个JSX显示到我们页面上</span><br><span class="line">页面加载成功，发现我们有个useEffect，发现他不依赖任何属性，他就要运行，于是他从此次函数中拿到name--&gt;打印helloworld</span><br><span class="line">-----函数结束-----</span><br></pre></td></tr></table></figure>
<p>想必，看完了这段例子之后，你对React Hooks也有了一定的理解了。其实就是使用useState去存储我们需要存储的数据，当他更新的时候刷新页面，当页面刷新的时候，我们再使用useEffect来进行我们需要的操作。</p>
<p><strong>这样看的话，useEffect岂不就是相当于我们之前的componentDidMount + componentDidUpdate</strong></p>
<p>我可以很负责任的告诉你，不是的，useEffect是我们更新页面的副作用，当我们对他加上了依赖项之后，他就会在页面加载完了之后，检查依赖项是否有变化来进行决定是否要运行自己，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [myName, setMyName] = useState(<span class="string">&#x27;my Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第一个副作用&#x27;</span> + name)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第二个副作用&#x27;</span> + name)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第三个副作用&#x27;</span> + name)</span><br><span class="line">  &#125;, [myName])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是第四个副作用&#x27;</span> + name)</span><br><span class="line">  &#125;, [name])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span> onClick=&#123;<span class="function">() =&gt;</span> &#123;setName(name + <span class="string">&#x27;world&#x27;</span>)&#125;&#125;&gt;</span><br><span class="line">      我是&#123;name&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>这时候我们执行完了之后和点击文本之后会发生什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次渲染</span></span><br><span class="line">-----函数开始-----</span><br><span class="line">...（省略相同步骤）</span><br><span class="line">页面加载完毕</span><br><span class="line">发现没有依赖项，打印：我是第一个副作用hello</span><br><span class="line">发现是首次渲染，打印：我是第二个副作用hello</span><br><span class="line">发现是首次渲染，打印：我是第三个副作用hello</span><br><span class="line">发现是首次渲染，打印：我是第四个副作用hello</span><br><span class="line">-----函数开始-----</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击我们的文本</span></span><br><span class="line">更新state</span><br><span class="line">-----函数开始-----</span><br><span class="line">...（省略相同步骤）</span><br><span class="line">发现没有依赖项，打印：我是第一个副作用helloworld</span><br><span class="line">发现依赖项还是空，与上次相同，不打印</span><br><span class="line">发现myName没有更新，与上次相同，不打印</span><br><span class="line">发现name更新，打印：我是第四个副作用helloworld</span><br><span class="line">-----函数结束-----</span><br></pre></td></tr></table></figure>
<p>详情可参考例子：<a href="https://codesandbox.io/s/react-effect-demo1-ceb61">https://codesandbox.io/s/reac…</a></p>
<h3 id="函数式渲染的特点"><a href="#函数式渲染的特点" class="headerlink" title="函数式渲染的特点"></a>函数式渲染的特点</h3><p>上面的例子可能还没能够理解为什么是函数式渲染，接下来这一次你可能就能意会到，而且是开发中可能经常出现的问题，看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例子中，我们点击了Show alert之后，再去点击Click me，发现弹出来的是了Show alert时候的count，详情可参考例子：<a href="https://codesandbox.io/s/priceless-tereshkova-ucvpe?file=/src/App.js">https://codesandbox.io/s/pric…</a></p>
<blockquote>
<p>为什么会出现这样的情况呢</p>
</blockquote>
<p>因为Counter是一个函数，在点击Show alert，此时的count为当前值，在我们每次点击Click me的时候Counter函数都会运行一次。这样是不是就能理解了呢</p>
<h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><ol>
<li>一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留，所以定义的函数会被清除</li>
<li>React hook更新 state 变量总是替换它而不是合并它。跟class不一样</li>
<li>useEffect只有一个参数的时候=componentDidMount+componentDidUpdate</li>
<li>useEffect它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制</li>
<li>return一个函数，运行就会清理，因为 useEffect 默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理</li>
<li>在条件语句违反Hook的规则原因如下</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🔴 在条件语句中使用 Hook 违反第一条规则</span></span><br><span class="line">  <span class="keyword">if</span> (name !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;formData&#x27;</span>, name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 第二次调用</span></span><br><span class="line">useState(<span class="string">&#x27;Mary&#x27;</span>)           <span class="comment">// 1. 读取变量名为 name 的 state（参数被忽略）</span></span><br><span class="line"><span class="comment">// useEffect(persistForm)  // 🔴 此 Hook 被忽略！</span></span><br><span class="line">useState(<span class="string">&#x27;Poppins&#x27;</span>)        <span class="comment">// 🔴 2 （之前为 3）。读取变量名为 surname 的 state 失败</span></span><br><span class="line">useEffect(updateTitle)     <span class="comment">// 🔴 3 （之前为 4）。替换更新标题的 effect 失败</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript react hooks 函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>【HTTP基础】HTTPS原理及WebSocket原理</title>
    <url>/2021/01/11/%E3%80%90HTTP%E5%9F%BA%E7%A1%80%E3%80%91HTTPS%E5%8E%9F%E7%90%86%E5%8F%8AWebSocket%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>由于HTTP没有加密机制，其传输的内容很容易泄漏，并且HTTP协议没法确认通信方，也无法保证接收到的报文在传输过程中是否被篡改，因此HTTPS是在HTTP协议的基础上提供了加密、认证和完整性保护的功能。HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替而已，通常HTTP直接和传输层的TCP协议通信，当使用了SSL后，HTTP先和SSL协议通信，SSL再和TCP协议通信。</p>
<a id="more"></a>

<h2 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h2><p>近代的加密方法中加密算法是公开的，而密钥却是保密的，加密和解密都需要用到密钥，没有密钥就没法对加密内容进行解密，通过这种方式得以保持加密方法的安全性。加密和解密同用一个密钥的方式陈为共享密钥加密，也被称为<code>对称密钥加密</code>。以共享密钥方式的加密必须将密钥也发给对方，在网络上发送密钥很容易被攻击者获取。并且服务器如果对所有客户端都使用同样的共享密钥，无异于没有加密，所以HTTPS采用生成的<code>随机数</code>来作为共享加密算法的密钥。</p>
<p>公开密钥加密使用一对<code>非对称的密钥</code>，一把叫做私有密钥，一把叫做公有密钥，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密，这样就不用担心密钥被攻击者获取。</p>
<p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制，如果仅仅保证密钥的安全性，使用公开密钥加密的方式就可以实现了，但是公开密钥加密方式比共享密钥加密，其处理速度要慢。所以<code>HTTPS在交换密钥环节采用公开密钥加密方式，之后建立通信交换报文阶段采用共享密钥加密方式</code>。</p>
<p>公开密钥加密方式也不能保证公开密钥本身的真实性，比如，在与某台服务器建立连接时，无法保证接收到的公开密钥就是需要连接的那个服务器的密钥，这个时候可以采用数字证书认证机构和其相关机关颁发的公开密钥证书。</p>
<h2 id="HTTPS的握手过程"><a href="#HTTPS的握手过程" class="headerlink" title="HTTPS的握手过程"></a>HTTPS的握手过程</h2><ol>
<li>首先，客户端会发送一个https的请求，把自身支持的一系列密钥算法组件(Cipher Suite)发送给服务器。</li>
<li>服务器接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选择一种加密算法和HASH算法以证书的形式返回给客户端，证书中包含了加密公钥，颁证机构，网站地址，失效日期等等。</li>
<li>客户端收到服务器端的响应后会做以下几件事：<br>1：验证证书的合法性，颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等，证书验证通过后，在浏览器的地址栏会加上一把小锁。<br>2：证书验证通过后，生成随机密码，用证书中的公钥加密。<br>3：使用约定好的HASH计算握手消息，并使用生产的随机数对消息进行加密，最后将之前生成的所有消息发送给网站。</li>
<li>服务器接收到客户端传来的密文，用自己的私钥来解密取出随机数密码，然后用随机数密码解密浏览器发送过来的握手消息，并验证HASH是否是与浏览器发来的一致，然后使用密码加密一段握手消息，发送给浏览器。</li>
<li>客户端用随机数解密并计算出握手消息的HASH，如果与服务器端发来的HASH一致，此时握手过程结束。</li>
</ol>
<p>之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。因为这串密码只有客户端和服务器知道，所有即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。<br>其中非对称加密算法用于在握手消息过程中加密生成的随机数密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性，TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输，由于HTTPS非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。</p>
<h2 id="HTTPS攻击手段"><a href="#HTTPS攻击手段" class="headerlink" title="HTTPS攻击手段"></a>HTTPS攻击手段</h2><p>浏览器在对证书进行验证时，以下几种情况会导致验证失败：</p>
<ol>
<li>SSL证书不是由受信任的CA机构颁发的</li>
<li>证书过期</li>
<li>访问的网站域名与证书绑定的域名不一致</li>
</ol>
<p>对HTTPS最常见的攻击手段就是SSL证书欺骗或者叫SSL劫持，是一种典型的中间人攻击，不过SSL劫持并非只是用于攻击目的，在一些特殊情况下利用SSL劫持可以更顺畅的访问网络。SSL劫持需要将攻击者接入到浏览器与目标网站之间，在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输的数据，中间人攻击最好的环境是在局域网中，因为局域网中所有的计算机需要通过网关来接入互联网，因此攻击者只需要实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。一般SSL劫持，浏览器会给出证书错误的提示，如果继续访问，所有加密的数据都可以被攻击者解密。</p>
<p>SSLStrip攻击也需要将攻击者设置为中间人，之后将HTTPS访问替换为HTTP返回给浏览器，由于HTTP协议传输的数据都是未加密的，从而截获用户访问的数据。对于登录账号密码等关键信息，可以在发送之前用javaScript进行一次加密处理，这种方法对SSLScrip和SSL劫持都是有效的。</p>
<p>HTTPS也存在一些问题，那就是处理速度会变慢，一是由于存在HTTPS握手环节，导致通信变慢，二是由于存在传输信息加密处理，消耗CPU及内存资源，这对于高并发的服务器而言，更是一种性能瓶颈，所以服务器只是对含有敏感信息的数据进行加密。</p>
<h1 id="WebSoket原理"><a href="#WebSoket原理" class="headerlink" title="WebSoket原理"></a>WebSoket原理</h1><p>HTTP协议的通信都是浏览器发出一个请求，服务器接收请求后进行处理并返回结果，浏览器再将接收到的信息进行渲染，这种机制对于实时性要求高的应用场景显得捉襟见肘，传统请求-响应模式的web开发通常采用轮询方案，就是浏览器以一定时间间隔频繁的向服务器请求数据，来保持客户端数据的实时更新，但是服务器数据可能并没有更新，会带来很多无谓的请求，浪费带宽，效率低下。</p>
<p>webSocket是HTML5下的一种新的协议，基于TCP传输协议，本身属于应用层协议，并且复用了HTTP握手通道。它实现了浏览器与服务器的全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的，webSocket与HTTP长连接的区别：HTTP长连接在建立TCP连接后，在每个请求中任需要单独发送请求头，数据传输的效率低，并且服务器不能主动给浏览器推送数据。</p>
<h2 id="WebSocket建立连接"><a href="#WebSocket建立连接" class="headerlink" title="WebSocket建立连接"></a>WebSocket建立连接</h2><p>webSocket借用HTTP的协议来完成握手，首先通过HTTP发起请求报文，报文如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1,1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http:&#x2F;&#x2F;127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-key:w4v7O6xFTi36lq3RNcgctw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol:chat, superchat</span><br><span class="line">Sec-WebSocket-Version:13</span><br></pre></td></tr></table></figure>
<p>在上面的HTTP请求头中，Connection和Upgrade字段表示请求服务器升级协议为webSocket，其中Sec-WebSocket-key的值是随机生成的Base64编码的字符串，Sec-WebSocket-Protocol和Sec-WebSocket-Version字段指定子协议和版本。服务器响应头如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU&#x3D;</span><br></pre></td></tr></table></figure>
<p>状态码101表示协议切换，到此完成协议升级，后续的数据交互都按照新的协议来。Sec-WebSocket-Accept是根据请求字段Sec-WebSocket-key计算出来的，其计算过程为：</p>
<ol>
<li>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11字符串进行拼接，形成新的字符串w4v7O6xFTi36lq3RNcgctw==258EAFA5-E914-47DA-95CA-C5AB0DC85B11；</li>
<li>通过sha1算法计算出结果，并转换成base64字符串。</li>
</ol>
<p>浏览器会校验Sec-WebSocket-Accept的值，如果成功，webSocket的握手成功将开始接下来的数据传输。</p>
<p>webSocket传输数据的基本单位是帧，一般webScoket传输的一条消息会被切割成多个帧，数据帧有一个标志位FIN，FIN=1表示这是消息的最后一帧，接收端接收到帧数据后，如果该帧的FIN标识为1，就会将已经接收到的数据帧组装成一个完整的消息。</p>
<h2 id="WebSocket实战"><a href="#WebSocket实战" class="headerlink" title="WebSocket实战"></a>WebSocket实战</h2><h3 id="HTML5中的WebSoket"><a href="#HTML5中的WebSoket" class="headerlink" title="HTML5中的WebSoket"></a>HTML5中的WebSoket</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Socket &#x3D; new WebSocket(url,[protocol])</span><br></pre></td></tr></table></figure>
<p>URL字符串必须以“ws”或“wss”(加密通信时)文字作为开头，protocol是Web应用能够使用的协议，可以是字符串，也可以是数组，如果一下代码中proto1和proto2是定义明确、可能已注册且标准化的协议名称，它们能够同时为客户端和服务器所理解，服务器会从列表中选择首选协议。webSocket支持onopen、onmessage、onclose、onerror四个异步事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.kuang</span>&#123;<span class="attribute">text-align</span>: center;<span class="attribute">margin-top</span>:<span class="number">200px</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#mess</span>&#123;<span class="attribute">text-align</span>: center&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.value</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid;<span class="attribute">text-align</span>: center;<span class="attribute">line-height</span>: <span class="number">200px</span>;<span class="attribute">display</span>: inline-block;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mess&quot;</span>&gt;</span>正在连接...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mytext&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dosend&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> mess = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mess&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&quot;content&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://127.0.0.1:8001&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;连接服务器成功&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ws.send(<span class="string">&quot;game1&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;服务器关闭&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        ws.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;连接出错&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(e.data===<span class="string">&quot;success&quot;</span>)&#123;</span></span><br><span class="line"><span class="javascript">                mess.innerHTML = <span class="string">&quot;连接成功&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                content.innerHTML += e.data+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">&quot;#dosend&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            ws.send(<span class="string">&quot;a:&quot;</span>+<span class="built_in">document</span>.querySelector(<span class="string">&quot;#mytext&quot;</span>).value);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">&quot;#mytext&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>webSocket.bufferAmount属性表示已在WebSocket上发送但尚未写入网络的字节数，一般用于调节发送速率。WebSocket API支持以二进制发送Blob和ArrayBuffer实例。当然也可以设置接收Blob和ArrayBuffer对象。</p>
<h3 id="Nodejs中的webSocket"><a href="#Nodejs中的webSocket" class="headerlink" title="Nodejs中的webSocket"></a>Nodejs中的webSocket</h3><p>webSocket的数据帧格式为以下部分：</p>
<p><img src="https://i.loli.net/2021/01/11/2AvJO8FgMWn3qYz.png" alt="图片描述"><br>FIN：1位，表示是否结束, 1:结束<br>RSV[1-3]：用于协商扩展<br>opcode: 4位，0，1，2属于数据帧，8，9，10属于控制帧<br>mask:掩码，0表示不使用亚掩码，一般服务器回消息不会使用掩码，接收消息需要掩码<br>payloadLen 0-125 直接表示 数据长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">126，后面16位对应数据长度</span><br><span class="line">127，后面64位对应数据长度</span><br></pre></td></tr></table></figure>
<p>masking-key：如果mask为1，后面32位作为masking-key，mask为0，则缺省<br>payload Data: 负载的数据<br>其连接的代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">&quot;nodejs-websocket&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;开始建立连接...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> game1 = <span class="literal">null</span>,game2 = <span class="literal">null</span> , game1Ready = <span class="literal">false</span> , game2Ready = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">conn</span>)</span>&#123;</span><br><span class="line">  conn.on(<span class="string">&quot;text&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;收到的信息为:&quot;</span>+str)</span><br><span class="line">    <span class="keyword">if</span>(str===<span class="string">&quot;game1&quot;</span>)&#123; <span class="comment">// game1已连接</span></span><br><span class="line">      game1 = conn;</span><br><span class="line">      game1Ready = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//conn.sendText(&quot;success&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str===<span class="string">&quot;game2&quot;</span>)&#123; <span class="comment">// game2已连接</span></span><br><span class="line">      game2 = conn;</span><br><span class="line">      game2Ready = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//conn.sendText(&quot;success&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(game1Ready &amp;&amp; game2Ready) &#123; <span class="comment">// 两个同时连接</span></span><br><span class="line">        <span class="comment">// console.log(game1Ready, game2Ready)</span></span><br><span class="line">        <span class="comment">// console.log(typeof str, &#x27;str&#x27;)</span></span><br><span class="line">        <span class="comment">// console.log(str, &#x27;str&#x27;)</span></span><br><span class="line">      <span class="keyword">if</span>(str===<span class="string">&quot;game1&quot;</span> || str===<span class="string">&quot;game2&quot;</span>)&#123; <span class="comment">// 连接成功的状态</span></span><br><span class="line">        <span class="comment">// console.log(str===&quot;game2&quot;, &#x27;str1&#x27;)</span></span><br><span class="line">        game1.sendText(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        game2.sendText(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123; <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="comment">// console.log(str===&quot;game2&quot;, &#x27;str2&#x27;)</span></span><br><span class="line">        game1.sendText(str);</span><br><span class="line">        game2.sendText(str);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//conn.sendText(str);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  conn.on(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;关闭连接&quot;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  conn.on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异常关闭&quot;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8001</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;WebSocket建立完毕&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>HTTP WebSoket 前端 网络 协议 聊天</tag>
      </tags>
  </entry>
  <entry>
    <title>不破不立的哲学与个人成长</title>
    <url>/2018/12/02/%E4%B8%8D%E7%A0%B4%E4%B8%8D%E7%AB%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<h1 id="从团建狼人杀说起"><a href="#从团建狼人杀说起" class="headerlink" title="从团建狼人杀说起"></a>从团建狼人杀说起</h1><p>一切要从上周五团队团建中的狼人杀游戏说起。第一局我是狼人，韬光养晦，不鸣不飞，胜；后两局不起眼神职，点兵点将，“瞎指一通”，侃侃而谈，结果都是大胜。</p>
<p>这种看似有些破坏正常套路的行为站在宏观层面来看，实际上可以大大增加好人获胜的概率。</p>
<p>对于狼人，取胜之匙可以简单归结为“避免身份被暴露”，对于好人，取胜之匙则是“让狼人身份暴露”。</p>
<p>要知道狼在在暗处，如果按部就班，要想让狼人暴露，就比较考验直觉和运气了，如果一开始不能灭掉几个狼人，越拖则越不利。如何让狼人暴露呢？我的策略就是破坏平衡，不怕犯错，让狼人露出马脚，从而提高获胜的概率。</p>
<p>一开始狼人对彼此身份是互相知道的，胡乱指两个人，其中有狼人概率相当高，此时狼人的表现就很容易暴露一些重要信息；就算指的都是好人，狼人表现也会不一样，可能指认的人数会稍稍多一些，此时，人已经开始分组，同时也透露出你指的人好人概率更大之类的判断信息，所有这些加起来都会提高获胜的概率，也就是一开始想办法让狼人也参与进来，狼人是知道彼此的身份，说得越多做的越多透出信息越多。但是，如果一开始大家就巴拉巴拉说些有的没的话，第一局基本上就靠运气，狼人已经占得先机了。</p>
<p>我们工作中很多事情与之都是类似的道理。例如软件开发中的bug测试，软件中的bug我们可以看出是狼人杀中的狼人，要让这些bug出现，我们平时正常的操作套路是远远不够的。必须要进行破坏性的极端测试边界测试来让这些bug暴露，例如没有数据情况，网络异常情况，网络访问突然峰值10倍情况等。</p>
<p>可以看到，要想让潜在的问题，潜在的坏蛋出现，破坏平衡，故意出错，引蛇出洞是一个非常行之有效的方法。这种策略也是自己工作与学习成长的策略。</p>
<a id="more"></a>

<h1 id="不破不立的哲学"><a href="#不破不立的哲学" class="headerlink" title="不破不立的哲学"></a>不破不立的哲学</h1><p>如果把我们的人生发展看成是一局狼人杀，则停滞、重复、局限以及安逸就可以看成是狼人，我们需要把它们找出来扼杀掉，但是，人总是习惯呆在舒适区，轻松省力，往往就看不到背后的狼人其实每晚都在杀害你内心的那些好人，久而久之，你的人生可能就会被狼人给弄失败。</p>
<p>举个例子，很多开发人员进入互联网圈子后，头1<del>2年成长会非常快，每天接触很多新鲜的东西，总有很多不会的东西，然而，等工作个2</del>3年，等业务驾轻就熟之后，就会发现每天的工作好像没有什么挑战，工作内容也重复，每天好像没有明显成长，此时，显然就已经进入舒适区了，也可以看成是成长的瓶颈。很多人的做法是换个换个工作，不同业务不同团队不同文化重新刺激自己，确实很很有效，但这并不是长久之计，当换来换去后你会发现大同小异，通常10年左右，你就会发现又陷入了瓶颈，一切并没有本质变化，而且年龄越大，换工作成本越高，不得不呆在一个地方舒适下去，然后眼睁睁看着后辈超越自己，所谓中年危机就是这么来的。</p>
<p>所以，要想人生有所成，尤其新兴且竞争激烈的互联网行业，关键还是要练自己的内功远离舒适区，而不是依赖于环境，通过自身的行为和策略把藏在暗处的狼人揪出来，灭之，则你就能取得人生的胜利。</p>
<p>如何揪出这些狼人呢？我的做法和上面狼人杀是一致的，进行破坏，所谓不破不立，具体做法包括下面几点：破坏平衡，主动犯错，广度刺激，自造难度。</p>
<h2 id="破坏平衡"><a href="#破坏平衡" class="headerlink" title="破坏平衡"></a>破坏平衡</h2><p><img src="https://image.zhangxinxu.com/image/blog/201808/niuniu-car.jpg" alt="破坏平衡"></p>
<p>上图这个叫做“扭扭车”，家里小朋友很喜欢玩，玩得还很溜。扭扭车的动力很有意思，其要前进，必须要扭来扭去，通过不平衡来制造前进的动力。这其实很技术的成长，或者人生的前进类似，你需要一些不平衡在获得前进的东西。</p>
<p>如果说远点，这个其实跟阶级差异贫富差异内在是类似的。会想以前吃大锅饭，人人均等的时代，社会经济的发展是很慢的，看上去的平衡却造成了前进停滞；而估计能者居上，产生不平衡后，国家40年来的经济发展就非常迅速，不平衡可以产生动力，只要掌握好这个平衡度，不翻车，就能持续前进。</p>
<p>人生也是如此，如果满于现状，觉得都挺好的，无欲无求；或者迷茫，不知道未来路在哪里，自己想要什么，则发展就会停滞，对于互联网行业，如果停滞意味就会被赶超，是非常危险的。</p>
<p>如果你是这种状态，则需要打破这种平衡，来获得前进动力。方法很多，比方说斗破苍穹里面萧炎被悔婚，算是一种平衡的打破；或者谈一场轰轰烈烈但失败的恋爱，让我想起了董明珠如果不是丈夫去世，怕没有今天的成就；或者让老大给你打个1星激励下。</p>
<p>我以前是通过刺激打破迷茫的状态，而现在则是通过设立目标来获得前进动力。</p>
<p>比方说我想要改变世界，发现现在离这个目标还很远，必须要加油，然后每天就很努力，因为当前状态和目标状态相比是一种不平衡的状态，这种不平衡就产生了前进的动力。</p>
<p><img src="https://image.zhangxinxu.com/image/blog/201808/change-wrold.png"></p>
<p>当然，你的目标可以不是改变世界这么虚这么远的，可以是短期的，例如这个季度我要在团队完成10个分享，我1个月时间翻译某某文档。也不一定工作上的，也可以连续一个月每天中午和女朋友打个电话，你们关系一定会变得更好，每周至少去健身一次等等。</p>
<p>制作不平衡，远离当下状态，获得成长动力。</p>
<h2 id="主动犯错"><a href="#主动犯错" class="headerlink" title="主动犯错"></a>主动犯错</h2><p>不怕犯错，甚至主动犯错。</p>
<p>可以举举我开车识路的例子。</p>
<p><img src="https://image.zhangxinxu.com/image/blog/201808/car-drive.jpg"></p>
<p>对于经常走的路线，例如回老家，或者上班，在前期，我几乎病态地每次都开不一样的路，比方说回老家，先不说沪常高速，京沪高速，沈海高速这几个高速主干道开了个遍，我多次直接不走高速从下面慢慢溜达，走过全程不走高速，走过一半省道一半高速，市区内各条小道也是走了个遍。结果这些偏门道路80%都是糟糕的选择，比方说高速2小时，下面屁颠屁颠开了4小时，一路上大货车一堆，红绿灯一堆，拍照一堆，有一次还擦擦碰碰，那些省道也不是免费的，芝麻点路还收10块钱，比高速还贵。看起来这些决策是错误的，费时有费力，带来的是痛苦，但是，这种主动犯错带来的经验与学习却是宝贵的，令人印象深刻的，不同道路的不同特色就了然于心，识路的技能成长就很快，在日后会带来巨大的价值。果然，节假日来了，高速堵车堵成了狗屎，而我，则和老婆大人在车里，吃着火锅，哼着小曲，沿着下面道路，完美避开拥堵，一路畅通回到了家，比堵车的这些家伙快了1倍时间。</p>
<p>成为道路达人的的秘诀就是主动尝试，不怕犯错，失败才能快速成长，只要发现一条曲径通幽的道路就是赚到，就是赚不到，沿途的风景也是不错的收获。</p>
<p>我在技能学习的时候，也会各种尝试，不怕犯错，人生有些错误是不能挽回的，但是，代码和技能不是这样的，不要怕，勇敢的上。</p>
<p>例如我在学习padStart()和padEnd()这两个ES6 API的时候，后面的补全参数按照道理应该是字符串，但是自己就主动犯错，各种数据类型都试一遍，结果发现了以外的收获，同样是一个API的学习，所get到的知识点，知识细节就比按部就班浅尝辄止学习的同学多很多，当你有无数多个这样的积累的时候，你就可以甩别人一条长安街了。</p>
<h2 id="广度刺激"><a href="#广度刺激" class="headerlink" title="广度刺激"></a>广度刺激</h2><p>通过换工作寻求新的刺激成本是比较高的，通常而言，大多数企业是不喜欢频繁的换工作的员工的。但是，我们通过广度刺激自己远离安逸和惰性则是百益无一害的。</p>
<p>广度刺激一方面是关注新技术，不一定要深知，至少要了解，可以扩展自己的技术选型的广度。有些技术如果对团队非常有帮助，则可以推动在团队落地，容易出好的绩效，升职加薪那就自然而然就来了。</p>
<p>另外一方面是关注新的模式，新的业务。例如去年直播很多，还有抖音，拼多多的崛起，对这些新模式新业务的了解有助于开阔自己的眼界，不至于坐井观天。否则一直呆在公司这点弹丸之地，不对外部事物保持关注，很容易淹没在滚滚潮流中，被时代淘汰。</p>
<p>以前很多在IBM这类公司工作人，被这个传统IT公司所累，很多认知都落后于时代，在新兴的互联网企业完全玩不开，掌握的理论都过时，是很危险的，大家可以引以为鉴，有效避之。</p>
<h2 id="自造难度"><a href="#自造难度" class="headerlink" title="自造难度"></a>自造难度</h2><p>人在江湖，身不由己。难免会接到没有技术含量的枯燥工作，对于前端而言，做一些简单的运营活动就是件很无趣的事情。你是按部就班完成工作把生命无形中浪费掉，还是有点追求在工作中给自己自增难度找点乐子呢？</p>
<p>所谓找点乐子，就是不要老是把自己掌握的那丁点技术重复来重复去使用，抓住每一次机会给自己来一个有意思的挑战，实现快速成长。</p>
<p>举一些我自己给自己下挑战的例子：</p>
<ul>
<li>这个图标我纯CSS绘制；</li>
<li>这个效果纯CSS实现；</li>
<li>这个效果我用SVG实现试试；</li>
<li>这个页面所有资源加载尺寸我要控制100K以内；</li>
<li>重复工作好无聊，写个自动化工具，这个页面我正好让我测一测工具跑起来怎么样；</li>
<li>最近学了点新技术，用在大项目中风险比较高，这个也就内部同事看看的运营页面正好可以用来试试手；</li>
<li>……</li>
</ul>
<p>等等等等。<strong>为什么觉得工作无聊，因为重复，那就想办法不重复，给自己增加点挑战不就好了，越折腾越成长，虽然说多花了点时间，但是，你让原本半天没有意义浪费生命的时光也变得有意义了，自己也成长了，然后再和同事分享分享，那不得了，影响力也有了，自然更容易取得人生上的成功了。</strong></p>
<h1 id="没有掉馅饼的事"><a href="#没有掉馅饼的事" class="headerlink" title="没有掉馅饼的事"></a>没有掉馅饼的事</h1><p>在互联网这个新兴行业，你想指望每天划划水，呆在自己舒适的小天地，同时升职加薪走上人生巅峰，那是不可能的。</p>
<p>互联网行业是目前而言相对比较公平的行业，你努力付出，积极进度，能力出众，技术优秀，自然会得到符合的报酬和地位，因为行业里这样的人稀缺无比。同样的，那些守着前几年学的点东西指望在公司养老一辈子的，也一定会被淘汰，被边缘，消失在滚滚红尘中。这就是公平，这也是为什么中国互联网的发展在全球处于领先的原因之一。</p>
<p>本文转载自【<a href="http://www.zhangxinxu.com/life/?p=801" title="不破不立的哲学与个人成长">不破不立的哲学与个人成长</a>】</p>
]]></content>
      <tags>
        <tag>编码 成长</tag>
      </tags>
  </entry>
  <entry>
    <title>为你定制的 React 学习路线</title>
    <url>/2017/08/03/%E4%B8%BA%E4%BD%A0%E5%AE%9A%E5%88%B6%E7%9A%84%20React%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>以下所谈及的，就是为你定制的 React 学习路线。</p>
<p>为了能稳固基础，我们一定要逐步地来进行学习。</p>
<p>倘若你正在建造一间房子，那么为了能快点完成，你是否会跳过建造过程中的部分步骤？如在具体建设前先铺设好部分石头？或直接在一块裸露的土地上先建立起墙面？</p>
<a id="more"></a>

<p>又假如你是在堆砌一个结婚蛋糕：能因为上半部分装饰起来更有趣，而直接忽略了下半部分？</p>
<p>不行吗？</p>
<p>当然不行。众所周知，这些做法只会导致失败。</p>
<p>因此，不要想着通过接触 React 来将 ES6 + Webpack + Babel + React + Routing + AJAX 这些知识一次性学好。因为想一下，就能明白这难道不正是导致学习失败的原因吗？</p>
<p>既然我把该文章称作是一条学习路线，那么每一次都应该走好每一步。既不要尝试去跨越，也不要贪步。</p>
<p>一步一脚印。若把其置身于每一天的那么一点时间，那么也许几周就能把整个学习完成。</p>
<p>制定该路线的主要目的在于：使你在学习过程中避免头脑不堪重负。因此，请脚踏实地地去学习 React 吧。</p>
<p>当然，你也可以为整个学习过程制定一个可打印的 PDF 文件，以便在学习过程中能够查记。</p>
<h3 id="第零步：JavaScript"><a href="#第零步：JavaScript" class="headerlink" title="第零步：JavaScript"></a>第零步：JavaScript</h3><p>在学习之前的你，理应对 JavaScript 有所了解，或至少是 ES5 标准下的 JavaScript。可若了解甚少，那么，你就应该停下手头上的工作，学习好该基础部分后，才可迈步前行。</p>
<p>可倘若早已熟知 ES6 所带来的新特性，那么请继续。因为如你所料，React 的 API 接口在 ES5 和 ES6 两标准间存在着较大的差异性。所以对于你来说，熟悉两种标准其特性的不同至关重要。尽管发生了异常，你也可以通过两种标准之间的转换，寻找出广泛有效的答案。</p>
<h3 id="第半步：NPM"><a href="#第半步：NPM" class="headerlink" title="第半步：NPM"></a>第半步：NPM</h3><p>NPM 在 JavaScript 世界中，可谓是软件管理方的王者。然而，在这里你却并不需要学习太多关于 NPM 自身的东西。只要在安装好后 （连同 Node.js），学习如何使用其安装软件即可。（npm install <package name>）</p>
<h3 id="第一步：React"><a href="#第一步：React" class="headerlink" title="第一步：React"></a>第一步：React</h3><p>学习一个新的编程技术，我们往往会从熟悉的 Hello World 教程开始。首先，我们可以通过使用 React 官方教程所展示的原生 HTML 文件来实现，而该文件包含有一些 script 标签。其次，我们还可以通过使用像 React Heatpack 这样的工具来快速上手。</p>
<p>尝试一下该三分钟运行起 Hello World 的教程。</p>
<h3 id="第二步：构建后摒弃"><a href="#第二步：构建后摒弃" class="headerlink" title="第二步：构建后摒弃"></a>第二步：构建后摒弃</h3><p>由于这一步是一个棘手的中间过程，所以往往会有大量的人忽略了该步。</p>
<p>谨记，请勿犯这样的错误。因为，倘若对 React 的概念没有一个稳固的掌握而擅自前行，那么，最后只会对自己的大脑搪塞过多的知识，以致遗忘。</p>
<p>当然，该步需要一定时间的斟酌：该构建什么呢？是工作中的一个原型项目？还是能贴合于整个框架的一些 Facebook 克隆项目呢？</p>
<p>其实，我们应该构建的都不是这些项目。因为，它们要不是包裹过甚，以致无甚可学；要不是过于庞大，以致成本过高。</p>
<p>尤其是工作中的“原型项目”，它们更为糟糕。因为在你心目中，早已明白这些项目并不会占有一席之地。况且，该类项目往往会长期驻留在原型阶段，或变成线上的软件。最终，你将无法摒弃或重写。</p>
<p>此外，把原型项目当作学习的项目将会为带来大量的烦恼。对于你来说，你可能会就未来的因素考虑一切可能发生的事情。而当你认为这不仅仅是一个原型的时候，你就会产生疑惑 —— 是否要测试一下呢？我应该要保证架构能延伸扩展……我需要延后重构的工作吗？还是不进行测试呢？</p>
<p>为了解决该问题，我希望能用上我所写的一篇指引《为 Augular 开发者所准备的 React》：一旦你完成了 “Hello World” 的基础课程，你将如何去学习 ”think in React” 的课程。</p>
<p>在这里，我有一些个人的提议给到大家：那就是，理想的项目是介乎于 “Hello World” 和 ”All of Twitter“ 之间。</p>
<p>另外，请尝试去构建一些官方文档列表中所展示的项目（TODOs、beers、movies），然后，借此学会数据流（data flow）的工作原理。</p>
<p>当然，你也可以把一些已有的大型 UI 项目（Twitter、Reddit、Hacker News等）分割成一小块来构建 —— 即把其瓜分成组件（components），并使用静态的数据去进行构建。</p>
<p>总的来说，我们需要构建的，理应是一些小型且可被摒弃的应用程序项目。这些项目必须是可摒弃的。否则，你将深陷于一些不为重要的东西，如可维护性和代码结构等。</p>
<p>值得提醒的是，如果你曾经订阅于我，那么当《为 Angular 开发者准备的 React》发布的时候，你将会第一时间收到通知。</p>
<h3 id="第三步：Webpack"><a href="#第三步：Webpack" class="headerlink" title="第三步：Webpack"></a>第三步：Webpack</h3><p>构建工具是学习过程中的一个主要的难点。搭建 Webpack 的环境会让你感觉是一件繁杂的工作，而且，完全不同于 UI 代码的书写。这就是为什么我要将 Webpack 放在了整个学习路线的第三步，而不是第零步。</p>
<p>在这里，我推荐一篇名为《Webpack —— 令人疑惑的地方》的文章，作为对 Webpack 的简介。此外，该文章还讲述了 Webpack 本身所具有的一些思考方式。</p>
<p>一旦你清楚 Webpack 所负责的工作（打包生成各种的文件，而不仅仅是 JS 文件） —— 以及其中的工作原理（适用于各种文件类型的加载器），那么，Webpack 对于你来说将会是一个更为欣喜的部分。</p>
<h3 id="第四步：ES6"><a href="#第四步：ES6" class="headerlink" title="第四步：ES6"></a>第四步：ES6</h3><p>如今，进入了整个路线的第四步。上述的所有将会作为下面的铺垫。之前，在学习 ES6 过程中，所学到的部分也将会让你写出更为利落简洁的代码 —— 以及性能更高的代码。回想起一开始那时候，某些问题本不应卡住在那 —— 但现在的你，已然清楚知道为啥 ES6 能完美地融合在其中。</p>
<p>在 ES6 中，你应该学习一些常用的部分：箭头函数（arrow functions）、let/const、类（classes）、析构（destructuring）和 import</p>
<h3 id="第五步：Routing"><a href="#第五步：Routing" class="headerlink" title="第五步：Routing"></a>第五步：Routing</h3><p>有些人会把 React Router 和 Redux 这两个概念混为一谈 —— 但是，它们之间并没有任何的关系或依赖。因此，你可以（也理应）在深入 Redux 之前学习如何去使用 React Router。</p>
<p>由于在之前“think in React”的教程中，积累了坚实的基础。因此，相比于第一天学习 React Router，我们此时更能从基于组件（component-based）的构建方式中，领悟出更多的精髓。</p>
<h3 id="第六步：Redux"><a href="#第六步：Redux" class="headerlink" title="第六步：Redux"></a>第六步：Redux</h3><p>Dan Abramov，作为 Redux 的创造人，他会告诉你们不要过早地接触 Redux。其实，这是有缘由的 —— Redux 其复杂度在早期的学习过程中，将会带来灾难性的影响。</p>
<p>虽然，在 Redux 背后所隐藏着的原理相当简单，但想要从理解跃至实践，却是一个很大的跨度。</p>
<p>因此，重复第二步所做的：构建一次性的应用程序。通过些许的 Redux 经验，去逐渐理解其背后的工作原理。</p>
<h3 id="非步骤"><a href="#非步骤" class="headerlink" title="非步骤"></a>非步骤</h3><p>在前面列出的步骤中，你曾否看见过”选择一个模板项目“的字眼吗？并没有。</p>
<p>若仅通过挑选大量模板项目中的其中一个，去深入学习 React。那么，后面将只会带来大量的疑惑。虽然这些项目会含有一切可能的库，且规定要求一定的目录结构 —— 但对于小型的应用程序，或开始入门的我们来说，并不需要。</p>
<p>也许你会说，“Dave，我可并不是在构建一个小应用。我所构建的，是一个服务于上万用户级别的复杂应用！”……那么，请你重新阅读一下关于原型的理解</p>
]]></content>
      <tags>
        <tag>react react.js mvc 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <url>/2017/03/14/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<blockquote>
<p>最近在进行前端面试方面的一些准备，看了网上许多相关的文章，发现有一个问题始终绕不开: 在浏览器中输入URL到整个页面显示在用户面前时这个过程中到底发生了什么。仔细思考这个问题，发现确实很深，这个过程涉及到的东西很多。这个问题的回答真的能够很好的考验一个web工程师的水平，于是我自问自答一番。总体来说分为以下几个过程:DNS解析TCP连接发送HTTP请求服务器处理请求并返回HTTP报文浏览器解析渲染…</p>
</blockquote>
<a id="more"></a>

<p>总体来说分为以下几个过程:</p>
<ol>
<li><p>DNS解析</p>
</li>
<li><p>TCP连接</p>
</li>
<li><p>发送HTTP请求</p>
</li>
<li><p>服务器处理请求并返回HTTP报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>连接结束</p>
</li>
</ol>
<h1 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h1><p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<a href="http://www.baidu.com,其实不是百度网站真正意义上的地址.互联网上每一台计算机的唯一标识是它的ip地址,但是ip地址并不方便记忆.用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机,也就是上面提到的百度的网址.所以互联网设计者需要在用户的方便性与可用性方面做一个权衡,这个权衡就是一个网址到ip地址的转换,这个过程就是dns解析.它实际上充当了一个翻译的角色,实现了网址到ip地址的转换.网址到ip地址转换的过程是如何进行的/">www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的</a>?</p>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>DNS解析是一个递归查询的过程。</p>
<p><img src="https://segmentfault.com/img/bVDM45?w=1928&h=1248"></p>
<p>上述图片是查找<a href="http://www.google.com的ip地址过程.首先在本地域名服务器中查询ip地址,如果没有找到的情况下,本地域名服务器会向根域名服务器发送一个请求,如果根域名服务器也不存在该域名时,本地域名会向com顶级域名服务器发送一个请求,依次类推下去.直到最后本地域名服务器得到google的ip地址并把它缓存到本地,供下次查询使用.从上述过程中,可以看出网址的解析是一个从右向左的过程/">www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程</a>: com -&gt; google.com -&gt; <a href="http://www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为">www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为</a>: . -&gt; .com -&gt; google.com. -&gt; <a href="http://www.google.com../">www.google.com.。</a></p>
<h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><p>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<ul>
<li><p>在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。</p>
</li>
<li><p>系统缓存主要存在/etc/hosts(Linux系统)中:</p>
</li>
</ul>
<p><img src="https://segmentfault.com/img/bVDM5c?w=956&h=366"></p>
<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的CDN(免费)储存图片，作为我个人博客的图床使用。</p>
<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。但由于TCP优化这一块我平常接触的并不是很多，再加上大学时的计算机网络的基础基本上忘完，所以这一部分我也就不在这里分析了。</p>
<h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>我不知道把HTTPS放在这个部分是否合适，但是放在这里好像又说的过去。HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p>
<p><img src="https://segmentfault.com/img/bVp65j"></p>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">TLS/SSL</a>握手过程。</p>
<p>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p>
<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行, 请求报头和请求正文。</strong></p>
<h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>格式如下:</p>
<p><strong>Method Request-URL HTTP-Version CRLF</strong></p>
<p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。</p>
<p>TODO：</p>
<ul>
<li>GET和POST有什么区别？</li>
</ul>
<h1 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h1><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p>
<p><img src="https://segmentfault.com/img/bVC1BZ?w=1919&h=822"></p>
<p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p>
<h2 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h2><p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p>
<h1 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h1><p>自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。</p>
<p>HTTP响应报文也是由三部分组成: <strong>状态码, 响应报头和响应报文。</strong></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>
<ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理。</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
</li>
<li><p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。</p>
</li>
</ul>
<p>TODO:</p>
<ul>
<li><p>301和302有什么区别？</p>
</li>
<li><p>HTTP缓存</p>
</li>
</ul>
<p><img src="https://segmentfault.com/img/bVDNI1?w=2404&h=1342"></p>
<p>该图是本公司对状态码的一个总结，绘制而成的status code map，请大家参考。</p>
<h2 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h2><p>常见的响应报头字段有: Server, Connection…。</p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。</p>
<h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p>
<p><img src="https://segmentfault.com/img/bVCZ1H?w=694&h=340"></p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p>
<p><img src="https://segmentfault.com/img/bVC1uE?w=734&h=689"></p>
<p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p>
<p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p>
<h1 id="Web优化"><a href="#Web优化" class="headerlink" title="Web优化"></a>Web优化</h1><p>上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了Web优化。在谈到Web优化之前，我们回到一个更原始的问题，Web前端的本质是什么。我的理解是: 将信息快速并友好的展示给用户并能够与用户进行交互。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了10几秒才显示出物品，这个时候你还有心情去购买吗？怎么快速的完成页面的加载呢？优雅的学院派雅虎给出了常用的一些手段，也就是我们熟悉的<a href="https://developer.yahoo.com/performance/">雅虎34条军规</a>。这34军规实际上就是围绕请求过程进行的一些优化方式。</p>
<p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写这篇文章真的非常纠结，前前后后断断续续写了两个星期，因为涉及到的东西比较多，再加上有些东西记忆的没有那么清晰了，所以不好下笔。所涉及到的大部分内容，也基本上是一笔带过，只是给读者一个浅显的认知，当遇到相关的问题时，知道如何去查询。大家可以当成一篇Web开发的科普类文章去阅读。</p>
<p>另外在这里为公司的产品打个广告，在Chrome store中搜索DHC，这是一款超级好用的Web客户端工具，囊括了很多的功能: 报文分析，API测试等等，可谓说是WEB工程师必备工具。</p>
]]></content>
      <tags>
        <tag>URL 页面 前端 面试</tag>
      </tags>
  </entry>
  <entry>
    <title>写一手漂亮的js(react篇)</title>
    <url>/2018/01/20/%E5%86%99%E4%B8%80%E6%89%8B%E6%BC%82%E4%BA%AE%E7%9A%84js(react%E7%AF%87)/</url>
    <content><![CDATA[<blockquote>
<p>　　近来有空一直在学习react的技术栈，虽说学习的深度没那么深，但总归初窥门径了，今天把在编码中的一些好方法好习惯记录一下。</p>
</blockquote>
<a id="more"></a>

<h1 id="个人原则"><a href="#个人原则" class="headerlink" title="个人原则"></a>个人原则</h1><ol>
<li>既然react是组件化的，那么相同的代码，我不会写第二遍</li>
<li>不在dom结构中夹杂太多js逻辑</li>
</ol>
<h1 id="对生命周期函数排序"><a href="#对生命周期函数排序" class="headerlink" title="对生命周期函数排序"></a>对生命周期函数排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  componentWillMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="传递多个props时注意换行"><a href="#传递多个props时注意换行" class="headerlink" title="传递多个props时注意换行"></a>传递多个props时注意换行</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">&lt;Demo className&#x3D;&#39;a&#39; value&#x3D;&#123;a&#125; onClick&#x3D;&#123;() &#x3D;&gt; &#123;&#125;&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; goood</span><br><span class="line">&lt;Demo</span><br><span class="line">  className&#x3D;&#39;a&#39;</span><br><span class="line">  value&#x3D;&#123;a&#125;</span><br><span class="line">  onClick&#x3D;&#123;() &#x3D;&gt; &#123;&#125;&#125;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="利用对象展开符传递props"><a href="#利用对象展开符传递props" class="headerlink" title="利用对象展开符传递props"></a>利用对象展开符传递props</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const someProps &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">&lt;Demo</span><br><span class="line">  a&#x3D;&#123;someProps.a&#125;</span><br><span class="line">  b&#x3D;&#123;someProps.b&#125;</span><br><span class="line">  c&#x3D;&#123;someProps.c&#125;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; goood</span><br><span class="line">&lt;Demo &#123;...someProps&#125; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当有些属性不需要传递的时候</span><br><span class="line">const &#123;</span><br><span class="line">  a,</span><br><span class="line">  ...otherProps</span><br><span class="line">&#125; &#x3D; someProps</span><br><span class="line"></span><br><span class="line">&lt;Demo &#123;...otherProps&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="利用箭头函数绑定this"><a href="#利用箭头函数绑定this" class="headerlink" title="利用箭头函数绑定this"></a>利用箭头函数绑定this</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;Button</span><br><span class="line">      onClick&#x3D;&#123;this.handleClick.bind(this)&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;Button</span><br><span class="line">      onClick&#x3D;&#123;this.handleClick&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="提前解构state，props"><a href="#提前解构state，props" class="headerlink" title="提前解构state，props"></a>提前解构state，props</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.props.add(this.state.a + this.state.b)</span><br><span class="line">    this.props.respond()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const &#123; a, b &#125; &#x3D; this.state</span><br><span class="line">    const &#123; respond, add &#125; &#x3D; this.props</span><br><span class="line"></span><br><span class="line">    add(a + b)</span><br><span class="line">    respond()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="map时不要使用index当做key，用item的id"><a href="#map时不要使用index当做key，用item的id" class="headerlink" title="map时不要使用index当做key，用item的id"></a>map时不要使用index当做key，用item的id</h1><blockquote>
<p>index没办法利用key来避免不必要的渲染</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return arr.map((item, i) &#x3D;&gt; (</span><br><span class="line">      &lt;span key&#x3D;&#123;i&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return arr.map(item &#x3D;&gt; (</span><br><span class="line">      &lt;span key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不要将大段的内联样式写在组件上"><a href="#不要将大段的内联样式写在组件上" class="headerlink" title="不要将大段的内联样式写在组件上"></a>不要将大段的内联样式写在组件上</h1><blockquote>
<p>影响阅读</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;&#123;</span><br><span class="line">        width: &#39;100px&#39;,</span><br><span class="line">        height: &#39;100px&#39;,</span><br><span class="line">        textAlign: &#39;center&#39;,</span><br><span class="line">        lineHeight: &#39;100px&#39;</span><br><span class="line">      &#125;&#125;&gt;11&lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">const styles &#x3D; &#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    width: &#39;100px&#39;,</span><br><span class="line">    height: &#39;100px&#39;,</span><br><span class="line">    textAlign: &#39;center&#39;,</span><br><span class="line">    lineHeight: &#39;100px&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;styles.container&#125;&gt;11&lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="给props加上类型检查"><a href="#给props加上类型检查" class="headerlink" title="给props加上类型检查"></a>给props加上类型检查</h1><blockquote>
<p>一定程度上能及时发现问题，当然更好的选择是flow、ts</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; nothing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line"></span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  static propTypes &#x3D; &#123;</span><br><span class="line">    className: PropTypes.string,</span><br><span class="line">    style: PropTypes.object,</span><br><span class="line">    url: PropTypes.oneOfType([</span><br><span class="line">      PropTypes.string,</span><br><span class="line">      PropTypes.array,</span><br><span class="line">    ]),</span><br><span class="line">    onClick: PropTypes.func,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="尽量不要在渲染组件时传递匿名函数"><a href="#尽量不要在渲染组件时传递匿名函数" class="headerlink" title="尽量不要在渲染组件时传递匿名函数"></a>尽量不要在渲染组件时传递匿名函数</h1><ol>
<li>首先它会影响阅读</li>
<li>每次渲染会生成新的匿名函数，对子组件来说就是新的props，就会触发再一次更新</li>
<li>当然，当函数只有一行的时候，我觉得也是可以这么做的，从代码简洁性考虑</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    a++</span><br><span class="line">    this.props.add()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Hello onClick&#x3D;&#123;this.handleClick&#125;&gt;11&lt;&#x2F;Hello&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Hello onClick&#x3D;&#123;() &#x3D;&gt; &#123;</span><br><span class="line">        a++</span><br><span class="line">        this.props.add()</span><br><span class="line">      &#125;&#125;&gt;11&lt;&#x2F;Hello&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javscript react 代码 优化 习惯</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程之纯函数</title>
    <url>/2017/10/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>纯函数 我们应该还记得初中的一些数学知识，函数f的概念就是，对于输入x产生一个输出y=f（x），这就是普通的纯函数。它的定义是 相同的输入，结果总会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>
</blockquote>
<a id="more"></a>

<p>最常见的一个例子就是在我们操作数组的时候slice就是纯函数，splice就是不纯的，看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">    var arr &#x3D; [1,2,3,4,5,6] ;</span><br><span class="line">    console.log(arr.slice(0,3))&#x2F;&#x2F;1,2,3</span><br><span class="line">    console.log(arr.slice(0,3))&#x2F;&#x2F;1,2,3这是纯函数相同输入总是得到相同的输出，可以这很函数式</span><br><span class="line">    console.log(arr.splice(0,3))&#x2F;&#x2F;1,2,3</span><br><span class="line">    console.log(arr.splice(0,3))&#x2F;&#x2F;4,5,6不纯的相同输入，不同输出</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>我们不喜欢splice，因为它会把原来数据弄得一团糟</p>
<p>不依赖外部状态 看看下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i &#x3D; 20 ;</span><br><span class="line">function test(num) &#123;</span><br><span class="line">    if(num&gt;i)&#123;&#x2F;&#x2F;这里的行为是由外部环境决定的 将来会有很多不可预知的问题</span><br><span class="line">        &#x2F;&#x2F;..dosomething</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;..dosomething</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">test(22) ;</span><br><span class="line"></span><br><span class="line">function test(num) &#123;</span><br><span class="line">    if(num&gt;20)&#123;&#x2F;&#x2F;虽然这里扩展性差但是，可以这很纯，不会因为外部环境改变而影响</span><br><span class="line">        &#x2F;&#x2F;..dosomething</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;..dosomething</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">test(22) ;</span><br></pre></td></tr></table></figure>
<p>这里我们可以用柯里化解决扩展性问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(min) &#123;</span><br><span class="line">    return function(num) &#123;</span><br><span class="line">        if(num&gt;min) &#123;</span><br><span class="line">        console.log(&#39;大于20&#39;) ;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        console.log(&#39;小于20&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var compare &#x3D; test(20) ;</span><br><span class="line">compare(20) ;&#x2F;&#x2F;大于20</span><br></pre></td></tr></table></figure>
<p>柯里化就是先传递部分参数返回一个函数去处理剩下的参数（这里因为闭包对参数进行保存）</p>
]]></content>
      <tags>
        <tag>函数 编程 开发 纯函数</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 api 请求缓存的 5 种方案</title>
    <url>/2020/11/23/%E5%89%8D%E7%AB%AF%20api%20%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E7%9A%84%205%20%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在开发 web 应用程序时，性能都是必不可少的话题。对于webpack打包的单页面应用程序而言，我们可以采用很多方式来对性能进行优化，比方说 tree-shaking、模块懒加载、利用 extrens 网络cdn 加速这些常规的优化。甚至在vue-cli 项目中我们可以使用 –modern 指令生成新旧两份浏览器代码来对程序进行优化。</p>
<p>而事实上，缓存一定是提升web应用程序有效方法之一，尤其是用户受限于网速的情况下。提升系统的响应能力，降低网络的消耗。当然，内容越接近于用户，则缓存的速度就会越快，缓存的有效性则会越高。</p>
<p>以客户端而言，我们有很多缓存数据与资源的方法，例如 标准的浏览器缓存 以及 目前火热的 Service worker。但是，他们更适合静态内容的缓存。例如 html，js，css以及图片等文件。而缓存系统数据，我采用另外的方案。</p>
<p>那我现在就对我应用到项目中的各种 api 请求缓存方案，从简单到复杂依次介绍一下。</p>
<a id="more"></a>

<hr>
<h2 id="方案一-数据缓存"><a href="#方案一-数据缓存" class="headerlink" title="方案一 数据缓存"></a>方案一 数据缓存</h2><p>简单的 数据 缓存，第一次请求时候获取数据，之后便使用数据，不再请求后端api。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dataCache &#x3D; new Map()</span><br><span class="line"></span><br><span class="line">async getWares() &#123;</span><br><span class="line">    let key &#x3D; &#39;wares&#39;</span><br><span class="line">    &#x2F;&#x2F; 从data 缓存中获取 数据</span><br><span class="line">    let data &#x3D; dataCache.get(key)</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有数据请求服务器</span><br><span class="line">        const res &#x3D; await request.get(&#39;&#x2F;getWares&#39;)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 其他操作</span><br><span class="line">        ...</span><br><span class="line">        data &#x3D; ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置数据缓存</span><br><span class="line">        dataCache.set(key, data)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return data</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>第一行代码 使用了 es6以上的 Map，如果对map不是很理解的情况下，你可以参考<br><a href="https://es6.ruanyifeng.com/#docs/set-map">ECMAScript 6 入门 Set 和 Map</a> 或者 <a href="http://exploringjs.com/es6/ch_maps-sets.html">Exploring ES6</a> 关于 map 和 set的介绍，此处可以理解为一个键值对存储结构。</p>
<p>之后 代码 使用 了 async 函数，可以将异步操作变得更为方便。 你可以参考<a href="https://es6.ruanyifeng.com/#docs/async">ECMAScript 6 入门 async函数</a>来进行学习或者巩固知识。</p>
<p>代码本身很容易理解，是利用 Map 对象对数据进行缓存，之后调用从 Map 对象来取数据。对于及其简单的业务场景，直接利用此代码即可。</p>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWares().then( ... )</span><br><span class="line">&#x2F;&#x2F; 第二次调用 取得先前的data</span><br><span class="line">getWares().then( ... )</span><br></pre></td></tr></table></figure>
<h2 id="方案二-promise缓存"><a href="#方案二-promise缓存" class="headerlink" title="方案二 promise缓存"></a>方案二 promise缓存</h2><p>方案一本身是不足的。因为如果考虑同时两个以上的调用此 api，会因为请求未返回而进行第二次请求api。当然，如果你在系统中添加类似于 vuex、redux这样的单一数据源框架，这样的问题不太会遇到，但是有时候我们想在各个复杂组件分别调用api，而不想对组件进行组件通信数据时候，便会遇到此场景。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promiseCache &#x3D; new Map()</span><br><span class="line"></span><br><span class="line">getWares() &#123;</span><br><span class="line">    const key &#x3D; &#39;wares&#39;</span><br><span class="line">    let promise &#x3D; promiseCache.get(key);</span><br><span class="line">    &#x2F;&#x2F; 当前promise缓存中没有 该promise</span><br><span class="line">    if (!promise) &#123;</span><br><span class="line">        promise &#x3D; request.get(&#39;&#x2F;getWares&#39;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 对res 进行操作</span><br><span class="line">            ...</span><br><span class="line">        &#125;).catch(error &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 在请求回来后，如果出现问题，把promise从cache中删除 以避免第二次请求继续出错S</span><br><span class="line">            promiseCache.delete(key)</span><br><span class="line">            return Promise.reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回promise</span><br><span class="line">    return promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码避免了方案一的同一时间多次请求的问题。同时也在后端出错的情况下对promise进行了删除，不会出现缓存了错误的promise就一直出错的问题。</p>
<p>调用方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWares().then( ... )</span><br><span class="line">&#x2F;&#x2F; 第二次调用 取得先前的promise</span><br><span class="line">getWares().then( ... )</span><br></pre></td></tr></table></figure>
<h2 id="方案三-多promise-缓存"><a href="#方案三-多promise-缓存" class="headerlink" title="方案三 多promise 缓存"></a>方案三 多promise 缓存</h2><p>该方案是同时需要 一个以上 的api请求的情况下，对数据同时返回，如果某一个api发生错误的情况下。均不返回正确数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const querys &#x3D;&#123;</span><br><span class="line">    wares: &#39;getWares&#39;,</span><br><span class="line">    skus: &#39;getSku&#39;</span><br><span class="line">&#125;</span><br><span class="line">const promiseCache &#x3D; new Map()</span><br><span class="line"></span><br><span class="line">async queryAll(queryApiName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断传入的数据是否是数组</span><br><span class="line">    const queryIsArray &#x3D; Array.isArray(queryApiName)</span><br><span class="line">    &#x2F;&#x2F; 统一化处理数据，无论是字符串还是数组均视为数组</span><br><span class="line">    const apis &#x3D; queryIsArray ? queryApiName : [queryApiName]</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取所有的 请求服务</span><br><span class="line">    const promiseApi &#x3D; []</span><br><span class="line"></span><br><span class="line">    apis.forEach(api &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 利用promise </span><br><span class="line">        let promise &#x3D; promiseCache.get(api)</span><br><span class="line"></span><br><span class="line">        if (promise) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果 缓存中有，直接push</span><br><span class="line">            promise.push(promise)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">             promise &#x3D; request.get(querys[api]).then(res &#x3D;&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; 对res 进行操作</span><br><span class="line">                ...</span><br><span class="line">                &#125;).catch(error &#x3D;&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; 在请求回来后，如果出现问题，把promise从cache中删除</span><br><span class="line">                promiseCache.delete(api)</span><br><span class="line">                return Promise.reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">            promiseCache.set(api, promise)</span><br><span class="line">            promiseCache.push(promise)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.all(promiseApi).then(res &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据传入的 是字符串还是数组来返回数据，因为本身都是数组操作</span><br><span class="line">        &#x2F;&#x2F; 如果传入的是字符串，则需要取出操作</span><br><span class="line">        return queryIsArray ? res : res[0]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方案是同时获取多个服务器数据的方式。可以同时获得多个数据进行操作，不会因为单个数据出现问题而发生错误。</p>
<p>调用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queryAll(&#39;wares&#39;).then( ... )</span><br><span class="line">&#x2F;&#x2F; 第二次调用 不会去取 wares，只会去skus</span><br><span class="line">queryAll([&#39;wares&#39;, &#39;skus&#39;]).then( ... )</span><br></pre></td></tr></table></figure>
<h2 id="方案四-添加时间有关的缓存"><a href="#方案四-添加时间有关的缓存" class="headerlink" title="方案四 添加时间有关的缓存"></a>方案四 添加时间有关的缓存</h2><p>往往缓存是有危害的，如果我们在知道修改了数据的情况下，直接把 cache 删除即可，此时我们调用方法就可以向服务器进行请求。这样我们规避了前端显示旧的的数据。但是我们可能一段时间没有对数据进行操作，那么此时旧的数据就一直存在，那么我们最好规定个时间来去除数据。<br>该方案是采用了 类 持久化数据来做数据缓存，同时添加了过期时长数据以及参数化。<br>代码如下：<br>首先定义持久化类,该类可以存储 promise 或者 data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ItemCache() &#123;</span><br><span class="line">    construct(data, timeout) &#123;</span><br><span class="line">        this.data &#x3D; data</span><br><span class="line">        &#x2F;&#x2F; 设定超时时间，设定为多少秒</span><br><span class="line">        this.timeout &#x3D; timeout</span><br><span class="line">        &#x2F;&#x2F; 创建对象时候的时间，大约设定为数据获得的时间</span><br><span class="line">        this.cacheTime &#x3D; (new Date()).getTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们定义该数据缓存。我们采用Map 基本相同的api</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExpriesCache &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义静态数据map来作为缓存池</span><br><span class="line">    static cacheMap &#x3D;  new Map()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据是否超时</span><br><span class="line">    static isOverTime(name) &#123;</span><br><span class="line">        const data &#x3D; ExpriesCache.cacheMap.get(name)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 没有数据 一定超时</span><br><span class="line">        if (!data) return true</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取系统当前时间戳</span><br><span class="line">        const currentTime &#x3D; (new Date()).getTime()        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取当前时间与存储时间的过去的秒数</span><br><span class="line">        const overTime &#x3D; (currentTime - data.cacheTime) &#x2F; 1000</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果过去的秒数大于当前的超时时间，也返回null让其去服务端取数据</span><br><span class="line">        if (Math.abs(overTime) &gt; data.timeout) &#123;</span><br><span class="line">            &#x2F;&#x2F; 此代码可以没有，不会出现问题，但是如果有此代码，再次进入该方法就可以减少判断。</span><br><span class="line">            ExpriesCache.cacheMap.delete(name)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 不超时</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前data在 cache 中是否超时</span><br><span class="line">    static has(name) &#123;</span><br><span class="line">        return !ExpriesCache.isOverTime(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除 cache 中的 data</span><br><span class="line">    static delete(name) &#123;</span><br><span class="line">        return ExpriesCache.cacheMap.delete(name) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取</span><br><span class="line">    static get(name) &#123;</span><br><span class="line">        const isDataOverTiem &#x3D; ExpriesCache.isOverTime(name)</span><br><span class="line">        &#x2F;&#x2F;如果 数据超时，返回null，但是没有超时，返回数据，而不是 ItemCache 对象</span><br><span class="line">        return isDataOverTiem ? null : ExpriesCache.cacheMap.get(name).data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 默认存储20分钟</span><br><span class="line">    static set(name, data, timeout &#x3D; 1200) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置 itemCache</span><br><span class="line">        const itemCache &#x3D; mew ItemCache(data, timeout)</span><br><span class="line">        &#x2F;&#x2F;缓存</span><br><span class="line">        ExpriesCache.cacheMap.set(name, itemCache)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时数据类以及操作类 都已经定义好,我们可以在api层这样定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成key值错误</span><br><span class="line">const generateKeyError &#x3D; new Error(&quot;Can&#39;t generate key from name and argument&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成key值</span><br><span class="line">function generateKey(name, argument) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从arguments 中取得数据然后变为数组</span><br><span class="line">    const params &#x3D; Array.from(argument).join(&#39;,&#39;)</span><br><span class="line">    </span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F; 返回 字符串，函数名 + 函数参数</span><br><span class="line">        return &#96;$&#123;name&#125;:$&#123;params&#125;&#96;</span><br><span class="line">    &#125;catch(_) &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回生成key错误</span><br><span class="line">        return generateKeyError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async getWare(params1, params2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 生成key</span><br><span class="line">    const key &#x3D; generateKey(&#39;getWare&#39;, [params1, params2]) </span><br><span class="line">    &#x2F;&#x2F; 获得数据</span><br><span class="line">    let data &#x3D; ExpriesCache.get(key)</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        const res &#x3D; await request(&#39;&#x2F;getWares&#39;, &#123;params1, params2&#125;)</span><br><span class="line">        &#x2F;&#x2F; 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求</span><br><span class="line">        ExpriesCache.set(key, res, 10)</span><br><span class="line">    &#125;</span><br><span class="line">    return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方案使用了 过期时间 和 api 参数不同而进行 缓存的方式。已经可以满足绝大部分的业务场景。</p>
<p>调用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWares(1,2).then( ... )</span><br><span class="line">&#x2F;&#x2F; 第二次调用 取得先前的promise</span><br><span class="line">getWares(1,2).then( ... )</span><br><span class="line">&#x2F;&#x2F; 不同的参数，不取先前promise</span><br><span class="line">getWares(1,3).then( ... )</span><br></pre></td></tr></table></figure>
<h2 id="方案五-基于修饰器的方案四"><a href="#方案五-基于修饰器的方案四" class="headerlink" title="方案五 基于修饰器的方案四"></a>方案五 基于修饰器的方案四</h2><p>和方案四是的解法一致的，但是是基于修饰器来做。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成key值错误</span><br><span class="line">const generateKeyError &#x3D; new Error(&quot;Can&#39;t generate key from name and argument&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成key值</span><br><span class="line">function generateKey(name, argument) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从arguments 中取得数据然后变为数组</span><br><span class="line">    const params &#x3D; Array.from(argument).join(&#39;,&#39;)</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F; 返回 字符串</span><br><span class="line">        return &#96;$&#123;name&#125;:$&#123;params&#125;&#96;</span><br><span class="line">    &#125;catch(_) &#123;</span><br><span class="line">        return generateKeyError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decorate(handleDescription, entryArgs) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断 当前 最后数据是否是descriptor，如果是descriptor,直接 使用</span><br><span class="line">    &#x2F;&#x2F; 例如 log 这样的修饰器</span><br><span class="line">    if (isDescriptor(entryArgs[entryArgs.length - 1])) &#123;</span><br><span class="line">        return handleDescription(...entryArgs, [])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不是</span><br><span class="line">        &#x2F;&#x2F; 例如 add(1) plus(20) 这样的修饰器</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return handleDescription(...Array.protptype.slice.call(arguments), entryArgs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleApiCache(target, name, descriptor, ...config) &#123;</span><br><span class="line">    &#x2F;&#x2F; 拿到函数体并保存</span><br><span class="line">    const fn &#x3D; descriptor.value</span><br><span class="line">    &#x2F;&#x2F; 修改函数体</span><br><span class="line">    descriptor.value &#x3D; function () &#123; </span><br><span class="line">        const key &#x3D;  generateKey(name, arguments)</span><br><span class="line">        &#x2F;&#x2F; key无法生成，直接请求 服务端数据</span><br><span class="line">        if (key &#x3D;&#x3D;&#x3D; generateKeyError)  &#123;</span><br><span class="line">            &#x2F;&#x2F; 利用刚才保存的函数体进行请求</span><br><span class="line">            return fn.apply(null, arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        let promise &#x3D; ExpriesCache.get(key)</span><br><span class="line">        if (!promise) &#123;</span><br><span class="line">            &#x2F;&#x2F; 设定promise</span><br><span class="line">            promise &#x3D; fn.apply(null, arguments).catch(error &#x3D;&gt; &#123;</span><br><span class="line">                 &#x2F;&#x2F; 在请求回来后，如果出现问题，把promise从cache中删除</span><br><span class="line">                ExpriesCache.delete(key)</span><br><span class="line">                &#x2F;&#x2F; 返回错误</span><br><span class="line">                return Promise.reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F; 使用 10s 缓存，10s之后再次get就会 获取null 而从服务端继续请求</span><br><span class="line">            ExpriesCache.set(key, promise, config[0])</span><br><span class="line">        &#125;</span><br><span class="line">        return promise </span><br><span class="line">    &#125;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 制定 修饰器</span><br><span class="line">function ApiCache(...args) &#123;</span><br><span class="line">    return decorate(handleApiCache, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 我们就会使用 类来对api进行缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Api &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存10s</span><br><span class="line">    @ApiCache(10)</span><br><span class="line">    &#x2F;&#x2F; 此时不要使用默认值，因为当前 修饰器 取不到</span><br><span class="line">    getWare(params1, params2) &#123;</span><br><span class="line">        return request.get(&#39;&#x2F;getWares&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为函数存在函数提升，所以没有办法利用函数来做 修饰器<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">var add &#x3D; function () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line">function foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@add</span><br><span class="line">function foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var counter;</span><br><span class="line">var add;</span><br><span class="line"></span><br><span class="line">counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">add &#x3D; function () &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以没有 办法在函数上用修饰器。具体参考<a href="https://es6.ruanyifeng.com/#docs/decorator">ECMAScript 6 入门 Decorator</a><br>此方式写法简单且对业务层没有太多影响。但是不可以动态修改 缓存时间</p>
<p>调用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWares(1,2).then( ... )</span><br><span class="line">&#x2F;&#x2F; 第二次调用 取得先前的promise</span><br><span class="line">getWares(1,2).then( ... )</span><br><span class="line">&#x2F;&#x2F; 不同的参数，不取先前promise</span><br><span class="line">getWares(1,3).then( ... )</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>api的缓存机制与场景在这里也基本上介绍了，基本上能够完成绝大多数的数据业务缓存，在这里我也想请教教大家，有没有什么更好的解决方案，或者这篇博客中有什么不对的地方，欢迎指正，在这里感谢各位了。<br>同时这里也有很多没有做完的工作，可能会在后面的博客中继续完善。</p>
]]></content>
      <tags>
        <tag>JavaScript 前端 缓存 api 性能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全编码规范</title>
    <url>/2020/11/01/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着互联网高速的发展，信息安全已经成为企业重点关注焦点之一，而前端又是引发安全问题的高危据点，所以，作为一个前端开发人员，需要了解前端的安全问题，以及如何去预防、修复安全漏洞。<br>下面就以前端可能受到的攻击方式为起点，讲解web中可能存在的安全漏洞以及如何去检测这些安全漏洞，如何去防范潜在的恶意攻击。</p>
<a id="more"></a>

<hr>
<h4 id="1-跨站脚本攻击（Cross-Sites-Script）"><a href="#1-跨站脚本攻击（Cross-Sites-Script）" class="headerlink" title="1. 跨站脚本攻击（Cross Sites Script）"></a>1. 跨站脚本攻击（Cross Sites Script）</h4><p><strong><code>跨站脚本攻击</code>**，Cross Site Script（简称 CSS或）。指黑客通过“</strong><code>HTML注入</code><strong>”篡改了网页，插入了恶意的脚本（主要是</strong><code>JavaScript脚本</code>**），从而在用户浏览网页时，控制用户浏览器的一种攻击。</p>
<p>了解了什么是XSS，那你一定想知道，它有什么危害以及如何去防御<br>这里罗列一张列表：</p>
<ul>
<li>挂马</li>
<li>盗取用户Cookie。</li>
<li>钓鱼攻击，高级的钓鱼技巧。</li>
<li>删除目标文章、恶意篡改数据、嫁祸。</li>
<li>劫持用户Web行为，甚至进一步渗透内网。</li>
<li>爆发Web2.0蠕虫。</li>
<li>蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据</li>
<li>其它安全问题</li>
</ul>
<p>常见的跨站脚本攻击也可分为：反射型XSS、存储型XSS、DOM Based XSS<br>下面针对这三种常见的类型做具体的分析</p>
<hr>
<h6 id="1-1-反射型XSS–也可被称为是HTML注入"><a href="#1-1-反射型XSS–也可被称为是HTML注入" class="headerlink" title="1.1 反射型XSS–也可被称为是HTML注入"></a>1.1 反射型XSS–也可被称为是HTML注入</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射型XSS，也称为&quot;非持久型XSS&quot;简单的把用户输入的数据&quot;反射&quot;给浏览器，即黑客往往需要诱使用户&quot;点击&quot;一个恶意链接攻击才能成功，用户通过点击这个恶意链接，攻击者可以成功获取用户隐私数据的一种方式。如：&quot;盗取用户Cookie信息&quot;、&quot;破坏页面结构&quot;、&quot;重定向到其他网站&quot;，盗取内网IP等。</span><br></pre></td></tr></table></figure>
<p>那么既然反射型XSS也可以是HTML注入，那么它注入的关键自然也就从前端的HTML页面开始下手：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用户能够与浏览器页面产生交互动作（输入搜索的关键词，点击按钮，点击链接等等），但这些都需要去诱使用户去操作，说起来容易，做起来难。</span><br><span class="line">2. 用户输入的数据会被攻击方拼接出合适的html去执行恶意的js脚本，这样的过程就像是&quot;一次反射&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="1-2-存储型XSS"><a href="#1-2-存储型XSS" class="headerlink" title="1.2 存储型XSS"></a>1.2 存储型XSS</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储型XSS，也称为&quot;&#96;持久型XSS&#96;&quot;，它与&#96;反射型XSS&#96;不同之处在于，它会将用户输入的数据&quot;存储&quot;在攻击方的服务器上，具有很强的&quot;稳定性&quot;。</span><br><span class="line">例如：访问某黑客写下的一篇含有恶意JavaScript代码的博客文章，黑客把恶意脚本保存到服务端。</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="1-3-DOM-based-XSS"><a href="#1-3-DOM-based-XSS" class="headerlink" title="1.3 DOM based XSS"></a>1.3 DOM based XSS</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从效果上来说，也是&quot;反射型XSS&quot;，单独划分出来，是因为其形成是通过修改页面的&quot;DOM节点&quot;形成的XSS。</span><br><span class="line">例如：通过修改DOM节点上的绑定方法，用户无意间通过点击、输入等行为执行这些方法获取到用户的相关信息</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="1-4-如何去检测是否存在XSS"><a href="#1-4-如何去检测是否存在XSS" class="headerlink" title="1.4 如何去检测是否存在XSS"></a>1.4 如何去检测是否存在XSS</h6><p>一般方法是，用户可以在有关键字输入搜索的地方输入**<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>**后点击搜索，若弹框出现展示123，说明存在XSS漏洞，这就说明前端并没有对用户输入的内容过滤处理。</p>
<hr>
<h6 id="1-5-XSS的攻击方式"><a href="#1-5-XSS的攻击方式" class="headerlink" title="1.5 XSS的攻击方式"></a>1.5 XSS的攻击方式</h6><p>1.Cookie劫持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过伪装一些&#96;图片和按钮&#96;等，诱使用户对其操作，使网页执行了攻击者的恶意脚本，使攻击者能够获取当前用户的Cookie信息</span><br></pre></td></tr></table></figure>
<p>2.构造GET和POST请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">若某攻击者想删除某网站的一篇文章，首先获得当前文章的id，然后通过使用脚本&#96;插入图片&#96;发送一个&#96;GET请求&#96;，或&#96;构造表单&#96;，&#96;XMLHTTPRequest&#96;发送&#96;POST请求&#96;以达到删除该文章的目的</span><br></pre></td></tr></table></figure>
<p>3.XSS钓鱼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;钓鱼&#96;这个词一般认识是起源于&#96;社会工程学&#96;，黑客使用这个这门学科的理念思想，在未授权不知情的情况下诱骗用户，并得到对方对方的姓名、年龄、邮箱账号、甚至是银行卡密码等私人信息。</span><br><span class="line"></span><br><span class="line">比如：&quot;某用户在某网站（已被攻击）上操作黑客伪造的一个登录框，当用户在登录框中输入了用户名（这里可能是身份证号等）和密码之后，将其信息上传至黑客的服务器上（该用户的信息就已经从该网站泄漏）&quot;</span><br></pre></td></tr></table></figure>
<p>4.获取用户真实的IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过第三方软件获取，比如客户端安装了Java环境（JRE），则可通过调用&#96;Java Applet&#96;的接口获取客户端本地的IP地址</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="1-6-XSS的防御方式"><a href="#1-6-XSS的防御方式" class="headerlink" title="1.6 XSS的防御方式"></a>1.6 XSS的防御方式</h6><p>1.HttpOnly</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：浏览器禁止页面的Javascript访问带有HttpOnly属性的cookie。（实质解决的是：XSS后的cookie劫持攻击）如今已成为一种“标准”的做法</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">JavaEE给Cookie添加HttpOnly的方式为：</span><br><span class="line">response.setHeader(&quot;Set-Cookie&quot;,&quot;cookiename&#x3D;value; Path&#x3D;&#x2F;;Domain&#x3D;domainvalue;Max-Age&#x3D;seconds;HTTPOnly&quot;);</span><br></pre></td></tr></table></figure>
<p>2.输入检查（XSS Filter）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：让一些基于特殊字符的攻击失效。（常见的Web漏洞如XSS、SQLInjection等，都要求攻击者构造一些特殊字符）</span><br><span class="line">* 输入检查的逻辑，必须在服务端实现，因为客户端的检查也是很容易被攻击者绕过，现有的普遍做法是两端都做同样的检查，客户端的检查可以阻挡大部分误操作的正常用户，从而节约服务器的资源。</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">检查是否包含&quot;JavaScript&quot;，&quot;&lt;script&gt;&lt;&#x2F;script&gt;&quot;等敏感字符。以及对字符串中的&lt;&gt;:&quot;&amp;&#x2F;&#39;等特殊字符做处理</span><br></pre></td></tr></table></figure>
<p>3.输出检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：一般来说除了富文本输出之外，在变量输出到HTML页面时，使用编码或转义的方式来防御XSS攻击</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">*   针对HTML代码的编码方式：HtmlEncode</span><br><span class="line">*   PHP：htmlentities()和htmlspecialchars()两个函数</span><br><span class="line">*   Javascript：JavascriptEncode（需要使用&quot;&quot;对特殊字符进行转义，同时要求输出的变量必须在引号内部）</span><br><span class="line">*   在URL的path（路径）或者search（参数）中输出，使用URLEncode</span><br></pre></td></tr></table></figure>
<p>4.更严格的做法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除了数字和字母外的所有字符，都使用十六进制的方式进行编码</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-跨站点请求伪造（Cross-Sites-Request-Forgery）"><a href="#2-跨站点请求伪造（Cross-Sites-Request-Forgery）" class="headerlink" title="2. 跨站点请求伪造（Cross Sites Request Forgery）"></a>2. 跨站点请求伪造（Cross Sites Request Forgery）</h4><p>跨站点请求伪造，指利用用户身份操作用户账户的一种攻击方式，即攻击者诱使用户访问一个页面，就以该用户身份在第三方有害站点中执行了一次操作，泄露了用户的身份信息，接着攻击者就可以使用这个伪造的，但真实存在的身份信息，到某网站冒充用户执行恶意操作。</p>
<p>但是，攻击者只有预测到URL的所有参数与参数值，才能成功地伪造一个请求（当然了，他可以在安全站点里以自己的身份实际去操作一下，还是能拿到参数的）；反之，攻击者无法攻击成功</p>
<p>下图通俗解释什么是**<code>CSRF</code>**，又是如何给用户带来危害的</p>
<p><img src="https://i.loli.net/2021/01/11/7gcGRxUaSjnVOib.png" alt="1"></p>
<p>参考上图，我们可以总结，完成一次CSRF攻击，必须满足两个条件</p>
<ul>
<li>用户登录受信任网站A，并且在本地生成Cookie</li>
<li>在不登出网站A的情况下，访问有害网站B</li>
</ul>
<hr>
<h6 id="2-1-CSRF的原理"><a href="#2-1-CSRF的原理" class="headerlink" title="2.1 CSRF的原理"></a>2.1 CSRF的原理</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CSRF攻击是攻击者利用**&#96;用户身份&#96;**操作用户账户的一种攻击方式</span><br><span class="line"></span><br><span class="line">如电影速度与激情5中吉赛尔使用内裤获取巴西大佬指纹，最后成功使用伪造指纹的手法打开保险柜，CSRF只不过是网络上这个手法的实现。</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="2-2-CSRF的攻击方式"><a href="#2-2-CSRF的攻击方式" class="headerlink" title="2.2 CSRF的攻击方式"></a>2.2 CSRF的攻击方式</h6><p>1.浏览器的Cookie策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器所持有的策略一般分为两种：</span><br><span class="line">Session Cookie，临时Cookie。保存在浏览器进程的内存中，浏览器关闭了即失效。</span><br><span class="line">Third-party Cookie，本地Cookie。服务器在Set-Cookie时指定了Expire Time。过期了本地Cookie失效，则网站会要求用户重新登录。</span><br><span class="line">* 在浏览网站的过程中，即使浏览器打开了Tab页，Session Cookie都是有效的，因此发起CSRF攻击是可行的。</span><br></pre></td></tr></table></figure>
<p>2.P3P头的副作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;P3P Header&quot;是 &quot;W3C&quot; 制定的一项关于隐私的标准，全称是 &quot;The Platform for Privacy Preference&quot;（隐私偏好平台）</span><br><span class="line"></span><br><span class="line">如果网站返回给浏览器的 HTTP 头包含有 P3P 头，则在某种程度上来说，将允许 浏览器发送第三方 Cookie。在 IE 下即使是&quot;&lt;iframe&gt;&quot;、&#96;&lt;script&gt;&#96;等标签页将不再拦截第三方 Cookie 的发送。主要应用在类似广告等需要跨域访问的页面。</span><br></pre></td></tr></table></figure>
<p>3.GET，POST请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 这里有个误区</span><br><span class="line">大多数 CSRF 攻击，都是通过 &lt;img&gt; 、 &lt;iframe&gt; 、 &lt;script&gt; 等带 src 属性的标签，这类标签只能发送一次 GET 请求，而不能发送 POST 请求，由此也有了认为 CSRF 攻击只能由 GET 请求发起的错误观点。</span><br><span class="line"></span><br><span class="line">构造一个 POST 请求，只需要在一个不可见的iframe窗口中，构造一个form表单，然后使用JavaScript自动提交这个表单。那么整个自动提交表单的过程，对于用户来说就是不可见的。</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="2-3-CSRF的防御方式"><a href="#2-3-CSRF的防御方式" class="headerlink" title="2.3 CSRF的防御方式"></a>2.3 CSRF的防御方式</h6><p>1.验证码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：</span><br><span class="line">CSRF攻击过程中，用户在不知情的情况下构造了网络请求，添加验证码后，强制用户必须与应用进行交互</span><br><span class="line"></span><br><span class="line">*  优点：简洁而有效</span><br><span class="line">*  缺点：网站不能给所有的操作都加上验证码</span><br></pre></td></tr></table></figure>
<p>2.Referer Check</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：</span><br><span class="line">* 利用HTTP头中的Referer判断请求来源是否合法</span><br><span class="line">* Referer首部包含了当前请求页面的来源页面的地址，一般情况下Referer的来源页就是发起请求的那个页面，如果是在iframe中发起的请求，那么对应的页面URL就是iframe的src</span><br><span class="line"></span><br><span class="line">*  优点：简单易操作（只需要在最后给所有安全敏感的请求统一添加一个拦截器来检查Referer的值就行）</span><br><span class="line">*  缺点：服务器并非什么时候都能取到Referer</span><br><span class="line">        1.很多出于保护用户隐私的考虑，限制了Referer的发送。</span><br><span class="line">        2.比如从HTTPS跳转到HTTP，出于安全的考虑，浏览器不会发送Referer</span><br></pre></td></tr></table></figure>
<p>3.使用Anti CSRF Token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原理：把参数加密，或者使用一些随机数，从而让攻击者无法猜测到参数值，也就无法构造请求的 URL，也就无法发起 CSRF 攻击。</span><br><span class="line"></span><br><span class="line">例子（增加token）：</span><br><span class="line">*  比如一个删除操作的URL是：&#96;http:&#x2F;&#x2F;host&#x2F;path&#x2F;delete?uesrname&#x3D;abc&amp;item&#x3D;123&#96;</span><br><span class="line">*  保持原参数不变，新增一个参数Token，Token值是随机的，不可预测</span><br><span class="line">*  http:&#x2F;&#x2F;host&#x2F;path&#x2F;delete?username&#x3D;abc&amp;item&#x3D;123&amp;token&#x3D;[random(seed)]</span><br><span class="line"></span><br><span class="line">*  优点：比检查Referer方法更安全，并且不涉及用户隐私</span><br><span class="line">*  缺点：</span><br><span class="line">        加密</span><br><span class="line">        1. 加密后的URL非常难读，对用户非常不友好</span><br><span class="line">        2. 加密的参数每次都在改变，导致用户无法对页面进行搜索</span><br><span class="line">        3. 普通参数也会被加密或哈希，将会给DBA工作带来很大的困扰，因为数据分析常常需要用到参数的明文</span><br><span class="line">        </span><br><span class="line">        token</span><br><span class="line">        1. 对所有的请求都添加Token比较困难</span><br></pre></td></tr></table></figure>
<p><strong><code>需要注意的点</code></strong></p>
<ol>
<li>Token需要足够随机，必须用足够安全的随机数生成算法</li>
<li>Token应该为用户和服务器所共同持有，不能被第三方知晓</li>
<li>Token可以放在用户的Session或者浏览器的Cookie中</li>
<li>尽量把Token放在表单中，把敏感操作由GET改为POST，以form表单的形式提交，可以避免Token泄露（比如一个页面：<code>http://host/path/manage?username=abc&amp;token=[random]</code>，在此页面用户需要在这个页面提交表单或者单击“删除”按钮，才能完成删除操作，在这种场景下，如果这个页面包含了一张攻击者能指定地址的图片<code>&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</code>，则这个页面地址会作为HTTP请求的Refer发送到evil.com的服务器上，从而导致Token泄露）</li>
</ol>
<h6 id="2-4-XSRF"><a href="#2-4-XSRF" class="headerlink" title="2.4 XSRF"></a>2.4 XSRF</h6><p>当网站同时存在XSS和CSRF漏洞时，XSS可以模拟客户端浏览器执行任意操作，在XSS攻击下，攻击者完全可以请求页面后，读取页面内容中的Token值，然后再构造出一个合法的请求</p>
<h4 id="3-点击劫持（ClickJacking）"><a href="#3-点击劫持（ClickJacking）" class="headerlink" title="3. 点击劫持（ClickJacking）"></a>3. 点击劫持（ClickJacking）</h4><p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如，程序员小王在访问A网页时，点击空白区域，浏览器却意外打开了xx新葡京赌场的页面，于是他在A网页打开控制台，在空白区域发现了一个透明的iframe，该iframe嵌入了一个第三方网页的URL</span><br></pre></td></tr></table></figure>
<h6 id="3-1-点击劫持防御方式"><a href="#3-1-点击劫持防御方式" class="headerlink" title="3.1 点击劫持防御方式"></a>3.1 点击劫持防御方式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.X-Frame-Options HTTP响应头是用来给浏览器指示允许一个页面能否在&#96;&lt;frame&gt;、&lt;iframe&gt;、&lt;object&gt;&#96;中展现的标记</span><br><span class="line"></span><br><span class="line">#### 有三个可选的值</span><br><span class="line">1.  DENY：浏览器会拒绝当前页面加载任何frame页面（即使是相同域名的页面也不允许）</span><br><span class="line">2.  SAMEORIGIN：允许加载frame页面，但是frame页面的地址只能为同源域名下的页面</span><br><span class="line">3.  ALLOW-FROM：可以加载指定来源的frame页面（可以定义frame页面的地址）</span><br><span class="line"></span><br><span class="line">2.禁止iframe的嵌套</span><br><span class="line">if(window.top.location !&#x3D;&#x3D; window.loaction)&#123;window.top.location &#x3D;&#x3D;&#x3D; window.self.location&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-其他安全问题"><a href="#4-其他安全问题" class="headerlink" title="4. 其他安全问题"></a>4. 其他安全问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.1 跨域问题处理</span><br><span class="line">    当服务端设置 &#39;Access-Control-Allow-Origin&#39; 时使用了通配符 &quot;*&quot;,允许来自任意域的跨域请求，这是极其危险的</span><br><span class="line"></span><br><span class="line">4.2 postMessage 跨窗口传递信息</span><br><span class="line">    postMessage 允许每一个 window（包括当前窗口、弹出窗口、iframes等）对象往其他的窗口发送文本消息，从而实现跨窗口的消息传递。并且这个功能不受同源策略限制。</span><br><span class="line">    必要时，在接受窗口验证 Domain，甚至验证URL，以防止来自非法页面的消息。实际上是在代码上实现一次同源策略的验证过程。接受窗口对接口的信息进行安全检查。</span><br><span class="line">    </span><br><span class="line">4.3 Web Storage</span><br><span class="line">    Web Storage 分为 Session Storage 和 Local Storage。</span><br><span class="line">    虽然受同源策略的约束，但当存有敏感信息时，也可能会成为攻击的目标。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ol>
<li>谨慎用户输入信息，进行输入检查（客户端和服务端同时检查）</li>
<li>在变量输出到HTML页面时，都应该进行编码或转义来预防XSS攻击</li>
<li>该用验证码的时候一定要添上</li>
<li>尽量在重要请求上添加Token参数，注意Token要足够随机，用足够安全的随机数生成算法</li>
</ol>
<h4 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h4><ol>
<li><a href="https://blog.csdn.net/weixin_41656968/article/details/81270071">十大常见web漏洞及防范</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">hyddd</a></li>
<li><a href="https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369">CSRF攻击与防御</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1136202">浅谈前端安全</a></li>
<li><a href="https://juejin.im/post/6844904024337022984">前端安全</a></li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript 网络 前端 安全 编码 规范</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的Nginx知识梳理</title>
    <url>/2021/01/14/%E5%89%8D%E7%AB%AF%E7%9A%84Nginx%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>因为开发中有很多环境，开发环境，测试环境，预生产环境等，所以会经常会用到nginx来配置代理。但是我也只是会用，想仔细梳理一下nginx的知识。</p>
<a id="more"></a>

<h2 id="1-什么是Nginx"><a href="#1-什么是Nginx" class="headerlink" title="1. 什么是Nginx"></a>1. 什么是Nginx</h2><p><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器。</p>
<p>Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡服务器。在性能上，Nginx占用很少的系统资源，能支持更多的并发连接，达到更高的访问效率；在功能上，Nginx是优秀的代理服务器和负载均衡服务器；在安装配置上，Nginx安装简单、配置灵活。</p>
<p>Nginx支持热部署，启动速度特别快，还可以在不间断服务的情况下对软件版本或配置进行升级，即使运行数月也无需重新启动。</p>
<p>在微服务的体系之下，Nginx正在被越来越多的项目采用作为网关来使用，配合Lua做限流、熔断等控制。</p>
<p><img src="https://i.loli.net/2021/01/14/BTjMkDdobUv5SlL.png" alt="img"></p>
<p><strong>这里提到了反向代理，什么是反向代理？</strong></p>
<p>Nginx根据接收到的请求的端口，域名，url，将请求转发给不同的机器，不同的端口（或直接返回结果），然后将返回的数据返回给客户端。</p>
<p>在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。</p>
<p><strong>反向代理:客户端 一&gt;代理 &lt;一&gt; 服务端</strong></p>
<p>反向代理用一个租房的例子:</p>
<p>A(客户端)想租一个房子,B(代理)就把这个房子租给了他。<br> 这时候实际上C(服务端)才是房东。<br> B(代理)是中介把这个房子租给了A(客户端)。</p>
<p>这个过程中A(客户端)并不知道这个房子到底谁才是房东<br> 他都有可能认为这个房子就是B(代理)的</p>
<p><strong>反向代理特点</strong></p>
<ul>
<li>Nginx没有自己的地址，它的地址就是服务器的地址，如<a href="http://www.baidu.com,对外部来讲,它就是数据的生产者./">www.baidu.com，对外部来讲，它就是数据的生产者。</a></li>
<li>Ngxin明确的知道应该去哪个服务器获取数据（在未接收到请求之前，已经确定应该连接哪台服务器）</li>
</ul>
<p><strong>有反向就应该有正向。</strong></p>
<p>所谓正向代理就是顺着请求的方向进行的代理，即代理服务器他是由你配置为你服务，去请求目标服务器地址。正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息</p>
<p><strong>正向代理:客户端 &lt;一&gt; 代理 一&gt;服务端</strong></p>
<p>正向代理也简单地打个租房的比方:</p>
<p>A(客户端)想租C(服务端)的房子,但是A(客户端)并不认识C(服务端)租不到。<br> B(代理)认识C(服务端)能租这个房子所以你找了B(代理)帮忙租到了这个房子。</p>
<p>这个过程中C(服务端)不认识A(客户端)只认识B(代理)<br> C(服务端)并不知道A(客户端)租了房子，只知道房子租给了B(代理)。</p>
<p><img src="https://i.loli.net/2021/01/14/nSMsdWUO2ht78fT.png" alt="1_看图王.web"></p>
<h2 id="2-Nginx应用场景"><a href="#2-Nginx应用场景" class="headerlink" title="2. Nginx应用场景"></a>2. Nginx应用场景</h2><p>1、 <strong>http服务器</strong>。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</p>
<p>2、 <strong>虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</strong></p>
<ul>
<li>基于端口的，不同的端口</li>
<li>基于域名的，不同域名</li>
</ul>
<p>3、 <strong>反向代理，负载均衡</strong>。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>
<h2 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3. 安装Nginx"></a>3. 安装Nginx</h2><p><a href="http://blog.s135.com/nginx_php_v5/">blog.s135.com/nginx_php_v…</a></p>
<p><img src="https://i.loli.net/2021/01/14/PpzKGSRFgYs2ku4.png" alt="2"></p>
<h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reopen #重启Nginx</span><br><span class="line">nginx -s reload #重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class="line">nginx -s stop #强制停止Nginx服务</span><br><span class="line">nginx -s quit #优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br><span class="line">nginx -?,-h #打开帮助信息</span><br><span class="line">nginx -v #显示版本信息并退出</span><br><span class="line">nginx -V #显示版本和配置选项信息，然后退出</span><br><span class="line">nginx -t #检测配置文件是否有语法错误，然后退出</span><br><span class="line">nginx -T #检测配置文件是否有语法错误，转储并退出</span><br><span class="line">nginx -q #在检测配置文件期间屏蔽非错误信息</span><br><span class="line">nginx -p prefix #设置前缀路径(默认是:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;)nginx -c filename #设置配置文件(默认是:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf)</span><br><span class="line">nginx -g directives #设置配置文件外的全局指令</span><br><span class="line">killall nginx #杀死所有nginx进程</span><br></pre></td></tr></table></figure>
<p><strong>转储：</strong> 在内存、CPU、I/O等设备上的数据都是动态的（或者说是易失的），也就是说数据使用完或者发生异常就会丢掉。如果我想得到某些时刻的数据（有可能是调试程序Bug或者收集某些信息），就要把他转储（dump）为静态（如文件）的形式。否则，这些数据你永远都拿不到。</p>
<h2 id="5-Nginx配置"><a href="#5-Nginx配置" class="headerlink" title="5. Nginx配置"></a>5. Nginx配置</h2><p>Nginx的主配置文件是：nginx.conf。</p>
<p><img src="https://i.loli.net/2021/01/14/KzfdE5JNlvQOrMw.png" alt="3"></p>
<p>里面的配置主要是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局区   有一个工作子进程，一般设置为CPU数 * 核数</span><br><span class="line">        worker_processes  1;</span><br><span class="line"></span><br><span class="line">        events &#123;</span><br><span class="line">                # 一般是配置nginx进程与连接的特性</span><br><span class="line">                # 如1个word能同时允许多少连接，一个子进程最大允许连接1024个连接</span><br><span class="line">                worker_connections  1024;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 配置HTTP服务器配置段</span><br><span class="line">        http &#123;</span><br><span class="line"></span><br><span class="line">                # 配置虚拟主机段</span><br><span class="line">                    server &#123;</span><br><span class="line"></span><br><span class="line">                        # 定位，把特殊的路径或文件再次定位。</span><br><span class="line">                location  &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server &#123;</span><br><span class="line">                       ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>我们可以很明显的将 nginx.conf 配置文件分为三部分：</strong></p>
<p><strong>全局块：</strong> 从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p>
<p>比如上面第一行配置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure>
<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p>
<p><strong>events块：</strong>涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p>
<p><strong>http块：</strong> Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<h2 id="6-反向代理"><a href="#6-反向代理" class="headerlink" title="6. 反向代理"></a>6. 反向代理</h2><p>上面已经解释过反向代理了，我们现在来写一个。当我在公司配置反向代理的时候，我会在http中添加一个server：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">    listen            80;</span><br><span class="line">    server_name       dev-customer.sdyxmall.com ;</span><br><span class="line">    gzip              off;</span><br><span class="line">    gzip_buffers      4 16k;</span><br><span class="line">    gzip_comp_level   5;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_min_length   1k;</span><br><span class="line">    gzip_types        text&#x2F;plain text&#x2F;css application&#x2F;javascript application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript image&#x2F;x-icon image&#x2F;bmp;</span><br><span class="line">    gzip_vary         on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">       proxy_pass   http:&#x2F;&#x2F;127.0.0.1:5000;</span><br><span class="line">       proxy_set_header X-real-ip $remote_addr;</span><br><span class="line">       proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">       proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后hosts中配置：</p>
<p><img src="https://i.loli.net/2021/01/14/2u3V9TRZpAoBstX.png" alt="4"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.3.100.13 dev-customer.sdyxmall.com</span><br></pre></td></tr></table></figure>
<p>接下来我们梳理一下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 listen *:80 | *:8080 #监听所有80端口和8080端口</span><br><span class="line">2 listen  IP_address:port   #监听指定的地址和端口号</span><br><span class="line">3 listen  IP_address     #监听指定ip地址所有端口</span><br><span class="line">4 listen port     #监听该端口的所有IP连接</span><br></pre></td></tr></table></figure>
<p>server_name指令主要用于配置基于名称虚拟主机</p>
<p>gzip的作用是是否需要开启压缩传输</p>
<p>location指令用于匹配 URL</p>
<p>proxy_pass指令用于设置被代理服务器的地址</p>
<p>proxy_set_header用来设定被代理服务器接收到的header信息（请求头）</p>
<p>基本上我们了解server_name，location，proxy_pass就可以配置反向代理</p>
<h2 id="7-Nginx管理虚拟主机"><a href="#7-Nginx管理虚拟主机" class="headerlink" title="7.Nginx管理虚拟主机"></a>7.Nginx管理虚拟主机</h2><p>这部分我工作中没有接触过，但是查找资料的时候名字看起来很高大上，就特意研究了一下。当我们想在一台服务器虚拟出多个网站，我们就可以用虚拟主机来实现。</p>
<p>虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台“虚拟”的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，具有完整的Intemet服务器功能（WWW、FTP、Email等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。</p>
<h3 id="7-1-基于域名的虚拟主机"><a href="#7-1-基于域名的虚拟主机" class="headerlink" title="7.1 基于域名的虚拟主机"></a>7.1 基于域名的虚拟主机</h3><p>1、在http大括号中添加如下代码段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">        #监听端口 80  </span><br><span class="line">        listen 80;   </span><br><span class="line">                                </span><br><span class="line">        #监听域名feng.com;  </span><br><span class="line">        server_name feng.com;</span><br><span class="line">          </span><br><span class="line">        location &#x2F; &#123;              </span><br><span class="line">                # 相对路径，相对nginx根目录。也可写成绝对路径  </span><br><span class="line">            root    feng;  </span><br><span class="line">            </span><br><span class="line">            # 默认跳转到index.html页面  </span><br><span class="line">            index index.html;                 </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2、切换安装目录：cd/usr/local/software/nginx</p>
<p>3、创建目录：mkdir feng</p>
<p>4、新建index.html文件：vi /usr/local/software/nginx/feng/index.html，文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;h2&gt;枫&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>5、重新读取配置文件：</p>
<p>/usr/local/software/nginx/sbin/nginx-s reload</p>
<p>kill -HUP进程号</p>
<p>6、配置windows本机host：</p>
<p>192.168.197.142 feng.com #<a href="http://lib.csdn.net/base/linux">Linux</a>服务器IP地址</p>
<p>7、访问：<a href="http://feng.com/">http://feng.com:80/</a></p>
<h3 id="7-2-基于端口的虚拟主机配置"><a href="#7-2-基于端口的虚拟主机配置" class="headerlink" title="7.2 基于端口的虚拟主机配置"></a>7.2 基于端口的虚拟主机配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  2022;</span><br><span class="line">        server_name     feng.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           root    &#x2F;home;</span><br><span class="line">           index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-基于IP地址虚拟主机配置"><a href="#7-3-基于IP地址虚拟主机配置" class="headerlink" title="7.3 基于IP地址虚拟主机配置"></a>7.3 基于IP地址虚拟主机配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  192.168.197.142;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">          root    ip;</span><br><span class="line">          index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-负载均衡"><a href="#8-负载均衡" class="headerlink" title="8. 负载均衡"></a>8. 负载均衡</h2><p>我们使用Nginx听到的最多的就是负载均衡，那么什么是负载均衡呢？</p>
<p><strong>负载均衡：</strong>由于目前现有网络的各个核心部分随着业务量的提高，访问量和数据流量的快速增长，其处理能力和计算强度也相应地增大，使得单一的服务器设备根本无法承担。</p>
<p>针对此情况而衍生出来的一种廉价有效透明的方法以扩展现有网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性的技术就是负载均衡（Load Balance）。</p>
<p>Nginx实现负载均衡有几种方案。</p>
<h3 id="8-1-轮询"><a href="#8-1-轮询" class="headerlink" title="8.1 轮询"></a>8.1 轮询</h3><p>轮询即Round Robin，根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-weight"><a href="#8-2-weight" class="headerlink" title="8.2 weight"></a>8.2 weight</h3><p>基于权重的负载均衡即Weighted Load Balancing，这种方式下，我们可以配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14 weight&#x3D;3;</span><br><span class="line">    server 192.168.0.15 weight&#x3D;7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权重越高，在被访问的概率越大，如上例，分别是30%，70%。</p>
<h3 id="8-3-ip-hash"><a href="#8-3-ip-hash" class="headerlink" title="8.3 ip_hash"></a>8.3 ip_hash</h3><p>前述的两种负载均衡方案中，同一客户端连续的Web请求可能会被分发到不同的后端服务器进行处理，因此如果涉及到会话Session，那么会话会比较复杂。常见的是基于数据库的会话持久化。要克服上面的难题，可以使用基于IP地址哈希的负载均衡方案。这样的话，同一客户端连续的Web请求都会被分发到同一服务器进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.14:88;</span><br><span class="line">    server 192.168.0.15:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-fair"><a href="#8-4-fair" class="headerlink" title="8.4 fair"></a>8.4 fair</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server server1;</span><br><span class="line">    server server2;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-url-hash"><a href="#8-5-url-hash" class="headerlink" title="8.5 url_hash"></a>8.5 url_hash</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server squid1:3128;</span><br><span class="line">    server squid2:3128;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要使用负载均衡的server中增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_pass http:&#x2F;&#x2F;backserver&#x2F;; </span><br><span class="line">upstream backserver&#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) </span><br><span class="line">    server 127.0.0.1:8080 weight&#x3D;2; (weight 默认为1.weight越大，负载的权重就越大) </span><br><span class="line">    server 127.0.0.1:6060; </span><br><span class="line">    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</p>
<p>fail_timeout:max_fails次失败后，暂停的时间。</p>
<p><strong>配置实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"></span><br><span class="line">worker_processes  4;</span><br><span class="line">events &#123;</span><br><span class="line"># 最大并发数</span><br><span class="line">worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    # 待选服务器列表</span><br><span class="line">    upstream myproject&#123;</span><br><span class="line">        # ip_hash指令，将同一用户引入同一服务器。</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 125.219.42.4 fail_timeout&#x3D;60s;</span><br><span class="line">        server 172.31.2.183;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">        # 监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        # 根目录下</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        # 选择哪个服务器列表</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;myproject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-6-深入实践"><a href="#8-6-深入实践" class="headerlink" title="8.6 深入实践"></a>8.6 深入实践</h3><p>上面写的都是负载均衡的方案，具体实现我看到知乎大佬写的很不错，而且看起来帅的起飞。</p>
<p>地址：<a href="https://zhuanlan.zhihu.com/p/32122459">zhuanlan.zhihu.com/p/32122459</a></p>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>Nginx真的很强大，而且使用的越来越广泛，虽然我目前在公司使用的不多，但是学到了Nginx很多知识，对项目的构建，优化，心里有了更多的想法。或许不一定要了解的很深入，满足我们的日常需要就可以了，了解它，当我们在做项目或者解决问题，能够作为我们的一种解决方案，就很Nice了。</p>
<p>作者：黑色的枫<br>链接：<a href="https://juejin.cn/post/6914160814152744973">https://juejin.cn/post/6914160814152744973</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>Nginx 负载均衡 反向代理 服务</tag>
      </tags>
  </entry>
  <entry>
    <title>图解 Vue 响应式原理</title>
    <url>/2020/08/06/%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ul>
<li><p>最近部门分享，有同学提到了 Vue 响应式原理，大家在讨论时，发现一些同学对这一知识理解还不够深入，不能形成一个闭环，为了帮助大家理解这个问题，我重新过了一下 Vue 源码，并整理了多张流程图，便于大家理解。</p>
<ul>
<li>Vue 初始化</li>
<li>模板渲染</li>
<li>组件渲染</li>
</ul>
<blockquote>
<p>本文 Vue 源码版本：2.6.11，为了便于理解，均有所删减。</p>
</blockquote>
<p>本文将从以下两个方面进行探索：</p>
<ul>
<li>从 Vue 初始化，到首次渲染生成 DOM 的流程。</li>
<li>从 Vue 数据修改，到页面更新 DOM 的流程。</li>
</ul>
</li>
</ul>
<a id="more"></a>



<h2 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h2><p>先从最简单的一段 Vue 代码开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;hello world&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，最终会在页面上打印一个 hello world，它是如何实现的呢？</p>
<p>我们从源头：new Vue 的地方开始分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行 new Vue 时会依次执行以下方法</span><br><span class="line">&#x2F;&#x2F; 1. Vue.prototype._init(option)</span><br><span class="line">&#x2F;&#x2F; 2. initState(vm)</span><br><span class="line">&#x2F;&#x2F; 3. observe(vm._data)</span><br><span class="line">&#x2F;&#x2F; 4. new Observer(data)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5. 调用 walk 方法，遍历 data 中的每一个属性，监听数据的变化。</span><br><span class="line">function walk(obj) &#123;</span><br><span class="line">  const keys &#x3D; Object.keys(obj);</span><br><span class="line">  for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. 执行 defineProperty 监听数据读取和设置。</span><br><span class="line">function defineReactive(obj, key, val) &#123;</span><br><span class="line">  &#x2F;&#x2F; 为每个属性创建 Dep（依赖搜集的容器，后文会讲）</span><br><span class="line">  const dep &#x3D; new Dep();</span><br><span class="line">  &#x2F;&#x2F; 绑定 get、set</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      const value &#x3D; val;</span><br><span class="line">      &#x2F;&#x2F; 如果有 target 标识，则进行依赖搜集</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal) &#123;</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">      &#x2F;&#x2F; 修改数据时，通知页面重新渲染</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据描述符绑定完成后，我们就能得到以下的流程图：</p>
<p><img src="https://i.loli.net/2021/01/11/49KdpFaOBTHmGuX.png" alt="img"></p>
<p>图中我们可以看到，Vue 初始化时，进行了数据的 get、set 绑定，并创建了一个 Dep 对象。</p>
<p>对于数据的 get、set 绑定我们并不陌生，但是 Dep 对象什么呢？</p>
<p>Dep 对象用于依赖收集，它实现了一个发布订阅模式，完成了数据 Data 和渲染视图 Watcher 的订阅，我们一起来剖析一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据 ts 类型提示，我们可以得出 Dep.target 是一个 Watcher 类型。</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  &#x2F;&#x2F; subs 存放搜集到的 Watcher 对象集合</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.subs &#x3D; [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub: Watcher) &#123;</span><br><span class="line">    &#x2F;&#x2F; 搜集所有使用到这个 data 的 Watcher 对象。</span><br><span class="line">    this.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  depend() &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      &#x2F;&#x2F; 搜集依赖，最终会调用上面的 addSub 方法</span><br><span class="line">      Dep.target.addDep(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    const subs &#x3D; this.subs.slice();</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 调用对应的 Watcher，更新视图</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据对 Dep 的源码分析，我们得到了下面这张逻辑图：</p>
<p><img src="https://i.loli.net/2021/01/11/xGwDBUTZri13C4d.png" alt="img"></p>
<p>了解 Data 和 Dep 之后，我们来继续揭开 Watcher 的面纱。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(vm: Component, expOrFn: string | Function) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 vm._render 方法赋值给 getter。</span><br><span class="line">    &#x2F;&#x2F; 这里的 expOrFn 其实就是 vm._render，后文会讲到。</span><br><span class="line">    this.getter &#x3D; expOrFn;</span><br><span class="line">    this.value &#x3D; this.get();</span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    &#x2F;&#x2F; 给 Dep.target 赋值为当前 Watcher 对象</span><br><span class="line">    Dep.target &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; this.getter 其实就是 vm._render</span><br><span class="line">    &#x2F;&#x2F; vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom。</span><br><span class="line">    const value &#x3D; this.getter.call(this.vm, this.vm);</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  addDep(dep: Dep) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将当前的 Watcher 添加到 Dep 收集池中</span><br><span class="line">    dep.addSub(this);</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    &#x2F;&#x2F; 开启异步队列，批量更新 Watcher</span><br><span class="line">    queueWatcher(this);</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    &#x2F;&#x2F; 和初始化一样，会调用 get 方法，更新视图</span><br><span class="line">    const value &#x3D; this.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中我们看到，Watcher 实现了渲染方法 <code>_render</code> 和 Dep 的关联， 初始化 Watcher 的时候，打上 Dep.target 标识，然后调用 get 方法进行页面渲染。加上上文的 Data，目前 Data、Dep、Watcher 三者的关系如下：</p>
<p><img src="https://i.loli.net/2021/01/11/a9cI5fHDEgQ3t2w.png" alt="img"></p>
<p>我们再拉通串一下整个流程：Vue 通过 <code>defineProperty</code> 完成了 Data 中所有数据的代理，当数据触发 get 查询时，会将当前的 Watcher 对象加入到依赖收集池 Dep 中，当数据 Data 变化时，会触发 set 通知所有使用到这个 Data 的 Watcher 对象去 update 视图。</p>
<p>目前的整体流程如下：</p>
<p><img src="https://i.loli.net/2021/01/11/T4VZberJnC2zG78.png" alt="img"></p>
<p>上图的流程中 Data 和 Dep 都是 Vue 初始化时创建的，但现在我们并不知道 Wacher 是从哪里创建的，带着这个问题，我们接着往下探索。</p>
<h2 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h2><p>上文中，我们分析了初始化 Vue 过程中处理数据的部分，接下来，我们分析一下数据渲染的部分。</p>
<p>其实 new Vue 执行到最后，会调用 mount 方法，将 Vue 实例渲染成 dom 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; new Vue 执行流程。</span><br><span class="line">&#x2F;&#x2F; 1. Vue.prototype._init(option)</span><br><span class="line">&#x2F;&#x2F; 2. vm.$mount(vm.$options.el)</span><br><span class="line">&#x2F;&#x2F; 3. render &#x3D; compileToFunctions(template) ，编译 Vue 中的 template 模板，生成 render 方法。</span><br><span class="line">&#x2F;&#x2F; 4. Vue.prototype.$mount 调用上面的 render 方法挂载 dom。</span><br><span class="line">&#x2F;&#x2F; 5. mountComponent</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. 创建 Watcher 实例</span><br><span class="line">const updateComponent &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  vm._update(vm._render());</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 结合上文，我们就能得出，updateComponent 就是传入 Watcher 内部的 getter 方法。</span><br><span class="line">new Watcher(vm, updateComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 7. new Watcher 会执行 Watcher.get 方法</span><br><span class="line">&#x2F;&#x2F; 8. Watcher.get 会执行 this.getter.call(vm, vm) ，也就是执行 updateComponent 方法</span><br><span class="line">&#x2F;&#x2F; 9. updateComponent 会执行 vm._update(vm._render())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10. 调用 vm._render 生成虚拟 dom</span><br><span class="line">Vue.prototype._render &#x3D; function (): VNode &#123;</span><br><span class="line">  const vm: Component &#x3D; this;</span><br><span class="line">  const &#123; render &#125; &#x3D; vm.$options;</span><br><span class="line">  let vnode &#x3D; render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">  return vnode;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 11. 调用 vm._update(vnode) 渲染虚拟 dom</span><br><span class="line">Vue.prototype._update &#x3D; function (vnode: VNode) &#123;</span><br><span class="line">  const vm: Component &#x3D; this;</span><br><span class="line">  if (!prevVnode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初次渲染</span><br><span class="line">    vm.$el &#x3D; vm.__patch__(vm.$el, vnode, hydrating, false);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 更新</span><br><span class="line">    vm.$el &#x3D; vm.__patch__(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 12. vm.__patch__ 方法就是做的 dom diff 比较，然后更新 dom，这里就不展开了。</span><br></pre></td></tr></table></figure>
<p>看完 Vue 模板渲染的过程，我们可以得到如下的流程图：</p>
<p><img src="https://i.loli.net/2021/01/11/WVOeow1XDBIjH6d.png" alt="img"></p>
<p>到这里，我们就知道了 Watcher 其实是在 Vue 初始化的阶段创建的，属于生命周期中 beforeMount 的位置创建的，创建 Watcher 时会执行 render 方法，最终将 Vue 代码渲染成真实的 DOM。</p>
<p>我们再将之前的流程整合一下，就能得到以下的流程：</p>
<p><img src="https://i.loli.net/2021/01/11/S4FLiUV1YoKs9Jp.png" alt="img"></p>
<p>上图分析了 Vue 初始化到渲染 DOM 的整个过程，最后我们再分析一下，当数据变化时，Vue 又是怎么进行更新的？</p>
<p>其实，在上图也能看出，在 Data 变化时，会调用 Dep.notify 方法，随即调用 Watcher 内部的 update 方法，此方法会将所有使用到这个 Data 的 Watcher 加入一个队列，并开启一个异步队列进行更新，最终执行 <code>_render</code> 方法完成页面更新。</p>
<p>整体的流程如下：</p>
<p><img src="https://i.loli.net/2021/01/11/PFcKShgqH5x3kWT.png" alt="img"></p>
<p>好了，探索到这里，Vue 的响应式原理，已经被我们分析透彻了，如果你还没有明白，不妨再细品一下上图。</p>
<h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>本来探索到上面的流程图就结束了，但好奇的我又想到了一个问题 😂。</p>
<blockquote>
<p>Vue 组件又是怎么渲染的呢？</p>
</blockquote>
<p>带着这个问题，我继续查阅了源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从模板编译开始，当发现一个自定义组件时，会执行以下函数</span><br><span class="line">&#x2F;&#x2F; 1. compileToFunctions(template)</span><br><span class="line">&#x2F;&#x2F; 2. compile(template, options);</span><br><span class="line">&#x2F;&#x2F; 3. const ast &#x3D; parse(template.trim(), options)</span><br><span class="line">&#x2F;&#x2F; 4. const code &#x3D; generate(ast, options)</span><br><span class="line">&#x2F;&#x2F; 5. createElement</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. createComponent</span><br><span class="line">export function createComponent(</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line">  &#x2F;&#x2F; $options._base 其实就是全局 Vue 构造函数，在初始化时 initGlobalAPI 中定义的：Vue.options._base &#x3D; Vue</span><br><span class="line">  const baseCtor &#x3D; context.$options._base;</span><br><span class="line">  &#x2F;&#x2F; Ctor 就是 Vue 组件中 &lt;script&gt; 标签下 export 出的对象</span><br><span class="line">  if (isObject(Ctor)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将组件中 export 出的对象，继承自 Vue，得到一个构造函数</span><br><span class="line">    &#x2F;&#x2F; 相当于 Vue.extend(YourComponent)</span><br><span class="line">    Ctor &#x3D; baseCtor.extend(Ctor);</span><br><span class="line">  &#125;</span><br><span class="line">  const vnode &#x3D; new VNode(&#96;vue-component-$&#123;Ctor.cid&#125;xxx&#96;);</span><br><span class="line">  return vnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 7. 实现组件继承 Vue，并调用 Vue._init 方法，进行初始化</span><br><span class="line">Vue.extend &#x3D; function (extendOptions: Object): Function &#123;</span><br><span class="line">  const Super &#x3D; this;</span><br><span class="line">  const Sub &#x3D; function VueComponent(options) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用 Vue.prototype._init，之后的流程就和首次加载保持一致</span><br><span class="line">    this._init(options);</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 原型继承，相当于：Component extends Vue</span><br><span class="line">  Sub.prototype &#x3D; Object.create(Super.prototype);</span><br><span class="line">  Sub.prototype.constructor &#x3D; Sub;</span><br><span class="line">  return Sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看完组件渲染的源码后，结合上文，重新整理了一张流程图，图中的蓝色部分就是渲染组件的过程。</p>
<p><img src="https://i.loli.net/2021/01/11/WGcHyvUJTqDYEba.png" alt="img"></p>
<p>好了，现在是真的结束了，最终的流程图就是上面的这一张图。</p>
<p>问个问题，现在你理解 Vue 响应式原理了吗？</p>
<p>如果仍觉得不好理解，我这里还准备了一张带标注的简图 😂</p>
<p><img src="https://i.loli.net/2021/01/11/sud8jT57Aay4vOU.png" alt="img"></p>
<h2 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h2><p>本文从源码的角度，介绍了 Vue 响应式原理，来简单回顾一下吧。</p>
<ol>
<li>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</li>
<li>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</li>
<li>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</li>
<li>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</li>
</ol>
]]></content>
      <tags>
        <tag>前端 vue.js javascript 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用JavaScript访问设备摄像头（前后）</title>
    <url>/2020/06/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JavaScript%E8%AE%BF%E9%97%AE%E8%AE%BE%E5%A4%87%E6%91%84%E5%83%8F%E5%A4%B4%EF%BC%88%E5%89%8D%E5%90%8E%EF%BC%89/</url>
    <content><![CDATA[<p>在这篇文章中，我将向您展示如何通过JavaScript在网页上访问设备的摄像头，并支持多种浏览器，而无需外部库。</p>
<a id="more"></a>

<h1 id="如何使用相机API"><a href="#如何使用相机API" class="headerlink" title="如何使用相机API"></a>如何使用相机API</h1><p>要访问用户的相机（或麦克风），我们使用JavaScript <strong>MediaStream API</strong>。该API允许通过流访问这些设备捕获的视频和音频。</p>
<p>第一步是检查浏览器是否支持此API：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="string">&quot;mediaDevices&quot;</span> <span class="keyword">in</span> navigator &amp;&amp;</span><br><span class="line">  <span class="string">&quot;getUserMedia&quot;</span> <span class="keyword">in</span> navigator.mediaDevices</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ok, 浏览器支持它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在现代浏览器中，支持是不错的（当然没有Internet Explorer）。</p>
<h2 id="捕获视频流"><a href="#捕获视频流" class="headerlink" title="捕获视频流"></a>捕获视频流</h2><p>要捕获由摄像机生成的视频流，我们使用 <code>mediaDevices</code> 对象的 <code>getUserMedia</code> 方法。这个方法接收一个对象，其中包含我们要请求的媒体类型（视频或音频）和一些要求。首先，我们可以通过 <code>&#123;video: true&#125;</code> 来获取摄像机的视频。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> videoStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(&#123; <span class="attr">video</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此调用将询问用户是否允许访问摄像机。如果用户拒绝，它将引发异常并且不返回流。因此，必须在 <code>try/catch</code> 块内完成处理这种情况。</p>
<p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/2.png"></p>
<p>请注意，它返回一个Promise，因此您必须使用 <code>async/await</code> 或 <code>then</code> 块。在Mac OS系统上还会弹出授权</p>
<p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/3.png"></p>
<p>点击“好”，就可以访问电脑摄像头了，控制台输出的 <code>videoStream</code> 对象如下</p>
<p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/4.png"></p>
<h2 id="视频规格（requirements）"><a href="#视频规格（requirements）" class="headerlink" title="视频规格（requirements）"></a>视频规格（requirements）</h2><p>我们可以通过传递有关所需分辨率以及最小和最大限制的信息来改善视频的要求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constraints = &#123;</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123;</span><br><span class="line">      min: <span class="number">1280</span>,</span><br><span class="line">      ideal: <span class="number">1920</span>,</span><br><span class="line">      max: <span class="number">2560</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    height: &#123;</span><br><span class="line">      min: <span class="number">720</span>,</span><br><span class="line">      ideal: <span class="number">1080</span>,</span><br><span class="line">      max: <span class="number">1440</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> videoStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(constraints);</span><br></pre></td></tr></table></figure>
<p>这样，流以正确的宽度和高度比例进入，如果它是处于纵向模式的手机，则需要进行尺寸反转。</p>
<h2 id="在页面上显示视频"><a href="#在页面上显示视频" class="headerlink" title="在页面上显示视频"></a>在页面上显示视频</h2><p>既然有了流，我们该如何处理？</p>
<p>我们可以在页面上的 <code>video</code> 元素中显示视频：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有一个 &lt;video autoplay id=&quot;video&quot;&gt;&lt;/video&gt; 标签</span></span><br><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#video&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> videoStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(constraints);</span><br><span class="line">video.srcObject = videoStream;</span><br></pre></td></tr></table></figure>
<p>请注意 <code>video</code> 标签中的自动播放属性 <code>autoplay</code>，没有它，你需要调用 <code>video.play()</code> 才能真正开始显示图像。</p>
<p><img src="http://myimgcloud.oss-cn-hangzhou.aliyuncs.com/202006/cameras-with-javascript/5.png"></p>
<h2 id="访问手机的前后摄像头"><a href="#访问手机的前后摄像头" class="headerlink" title="访问手机的前后摄像头"></a>访问手机的前后摄像头</h2><p>默认情况下，<code>getUserMedia</code> 将使用系统默认的视频录制设备。如果是有两个摄像头的手机，它使用前置摄像头。</p>
<p>要访问后置摄像头，我们必须在视频规格中包括 <code>faceModeMode:&quot;environment&quot;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constraints = &#123;</span><br><span class="line">  video: &#123;</span><br><span class="line">    width: &#123; ... &#125;,</span><br><span class="line">    height: &#123; ... &#125;,</span><br><span class="line">    facingMode: <span class="string">&quot;environment&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认值为 <code>faceingMode:&quot;user&quot;</code>，即前置摄像头。</p>
<p>需要注意的是，如果你想在已经播放视频的情况下更换摄像机，你需要先停止当前的视频流，然后再将其替换成另一台摄像机的视频流。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">videoStream.getTracks().forEach(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">  track.stop();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><p>你可以做的另一件很酷的事情是捕获视频的图像（屏幕快照）。</p>
<p>你可以在canvas上绘制当前视频帧，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面中有一个 &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 标签</span></span><br><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#canvas&quot;</span>);</span><br><span class="line">canvas.width = video.videoWidth;</span><br><span class="line">canvas.height = video.videoHeight;</span><br><span class="line">canvas.getContext(<span class="string">&quot;2d&quot;</span>).drawImage(video, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>你还可以在 <code>img</code> 元素中显示画布内容。</p>
<p>在本教程创建的示例中，我添加了一个按钮，该按钮可从画布动态创建图像并将其添加到页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.src = canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">screenshotsContainer.prepend(img);</span><br></pre></td></tr></table></figure>
<h2 id="完整示例和代码"><a href="#完整示例和代码" class="headerlink" title="完整示例和代码"></a>完整示例和代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>摄像头<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#video</span> &#123;</span></span><br><span class="line">          width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.is-hidden</span> &#123;</span></span><br><span class="line">          display: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.btns</span> &#123;</span></span><br><span class="line">          margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        button &#123;</span><br><span class="line">          font-size: 22px;</span><br><span class="line">          padding: 8px 10px;</span><br><span class="line"><span class="css">          <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">          border-radius: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.video-screenshot</span> &#123;</span></span><br><span class="line">          display: grid;</span><br><span class="line">          grid-template-columns: 1fr 1fr;</span><br><span class="line">          grid-column-gap: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>如何使用JavaScript访问设备摄像头（前后）<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btns&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button is-hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnPlay&quot;</span>&gt;</span></span><br><span class="line">    播放</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnPause&quot;</span>&gt;</span></span><br><span class="line">    暂停</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnScreenshot&quot;</span>&gt;</span></span><br><span class="line">    截屏</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnChangeCamera&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding: 6px 10px;&quot;</span>&gt;</span></span><br><span class="line">    切换摄像头</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video-screenshot&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">autoplay</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;screenshotsContainer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">class</span>=<span class="string">&quot;is-hidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// https://segmentfault.com/a/1190000022867561</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (</span></span><br><span class="line"><span class="javascript">    !<span class="string">&quot;mediaDevices&quot;</span> <span class="keyword">in</span> navigator ||</span></span><br><span class="line"><span class="javascript">    !<span class="string">&quot;getUserMedia&quot;</span> <span class="keyword">in</span> navigator.mediaDevices</span></span><br><span class="line">  ) &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">&#x27;当前浏览器不支持Camera API，请更新浏览器。&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#video&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> screenshotsContainer = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#screenshotsContainer&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> videoStream = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> useFrontCamera = <span class="literal">true</span>; <span class="comment">// 前置摄像头</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> constraints = &#123;</span></span><br><span class="line">    video: &#123;</span><br><span class="line">      width: &#123;</span><br><span class="line">        min: 1280,</span><br><span class="line">        ideal: 1920,</span><br><span class="line">        max: 2560,</span><br><span class="line">      &#125;,</span><br><span class="line">      height: &#123;</span><br><span class="line">        min: 720,</span><br><span class="line">        ideal: 1080,</span><br><span class="line">        max: 1440,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// play</span></span></span><br><span class="line"><span class="javascript">  btnPlay.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    video.play();</span><br><span class="line"><span class="javascript">    btnPlay.classList.add(<span class="string">&quot;is-hidden&quot;</span>);</span></span><br><span class="line"><span class="javascript">    btnPause.classList.remove(<span class="string">&quot;is-hidden&quot;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// pause</span></span></span><br><span class="line"><span class="javascript">  btnPause.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    video.pause();</span><br><span class="line"><span class="javascript">    btnPause.classList.add(<span class="string">&quot;is-hidden&quot;</span>);</span></span><br><span class="line"><span class="javascript">    btnPlay.classList.remove(<span class="string">&quot;is-hidden&quot;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 切换摄像头</span></span></span><br><span class="line"><span class="javascript">  btnChangeCamera.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    useFrontCamera = !useFrontCamera;</span><br><span class="line">    init();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 停止视频流</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">stopVideoStream</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (videoStream) &#123;</span></span><br><span class="line"><span class="javascript">      videoStream.getTracks().forEach(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span></span><br><span class="line">        track.stop();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 截图</span></span></span><br><span class="line"><span class="javascript">  btnScreenshot.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;screenshot&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!img) &#123;</span></span><br><span class="line"><span class="javascript">      img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="javascript">      img.id = <span class="string">&#x27;screenshot&#x27;</span>;</span></span><br><span class="line"><span class="javascript">      img.style.width = <span class="string">&#x27;100%&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    canvas.width = video.videoWidth;</span><br><span class="line">    canvas.height = video.videoHeight;</span><br><span class="line"><span class="javascript">    canvas.getContext(<span class="string">&quot;2d&quot;</span>).drawImage(video, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    img.src = canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>);</span></span><br><span class="line">    screenshotsContainer.prepend(img);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    stopVideoStream();</span><br><span class="line"><span class="javascript">    constraints.video.facingMode = useFrontCamera ? <span class="string">&quot;user&quot;</span> : <span class="string">&quot;environment&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">      videoStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(constraints);</span></span><br><span class="line">      video.srcObject = videoStream;</span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(error)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端 javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好技术 Team Leader？</title>
    <url>/2021/01/22/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%8A%80%E6%9C%AF%20Team%20Leader%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 作为一个技术TL（Team Leader），除了自身技能，还会面临诸多团队管理上的困难和挑战。如何定义和明确团队的目标？怎样建立优秀的工程文化？让团队长期发挥战斗力和创新能力的核心是什么？本文作者基于四年的团队管理经验，分享他在招聘、目标管理、团队沟通和工程文化等方面的思考与总结，介绍相关的经验方法，并推荐几本关于体验、思考的书籍。希望对同学们有所启发。</p>
<a id="more"></a>

<p>曾子曰：吾日三省吾身，反思是人类进化出来的一项异常宝贵的能力。我在阿里带团队也有四年多的时间，有必要总结一下此间得失；另外，前几天和一个刚开始带团队的同学聊天，他觉得角色转变对于他有不小的挑战，因此我想做一点不算成熟的总结并分享出来。当然，此文第一不代表我必然是一个多么成熟的管理者；第二不代表我的总结放之四海而皆准（事实上很多人的管理方式和我推崇的方法是反的，但是如果从某些角度评价，这些人更成功）；第三我并无雄心壮志解答所有问题。总结仅仅是期望通过反思，帮助自己成为更好的管理者，而分享是希望能够多多少少帮助到其他的管理者。</p>
<p>本文会重点讲述我对招聘、目标管理、团队沟通和工程文化的理解。挑选这几个主题讲述，主要是因为在带团队的这一段时间内，我认为这几个要素是团队长期发挥战斗力和创新能力的核心。得到这个认识对我来说并不容易，市面上有纷繁复杂的书籍（机场书店尤其多）尝试告诉你什么叫领导力，公司也有相关的培训介绍，周围也有很多 TL 用每日的言行告诉你他们是怎么做的。但是我认为这些来自周围的知识，很多是无效的，有更多是错误的。例如有 TL 每天在办公室坐到半夜下班，给团队巨大的加班压力，表面看起来是奋斗，实际上会让大家趋向于更多关注工作时长，从而降低对了对工作价值的思考；又有一些例子是，当团队同学犯错后，把故障和绩效强关联，在我看来这不仅无助于大家深入思考系统健壮性，更是鼓励推责，扼杀创新；更常见的例子可能是 TL 积极向上汇报，承诺超出团队负责的交付能力，导致团队完全无视工程师文化，久而久之优秀的人才逐渐流失，团队整体研发能力实则越来越弱。</p>
<p>很多事情是知易行难的，技术 TL 实践更是这样，之后不断学习，执行，反思，才能慢慢做得更好。如果我团队的同学在离开这个团队五年或者十年后，回想起这段时间，会感慨：“我们当时的团队多好啊，大家一起做了很多有意思的事情。” 那我这个技术 TL 的工作，就算做的出色了。</p>
<h1 id="一-招聘"><a href="#一-招聘" class="headerlink" title="一 招聘"></a>一 招聘</h1><p>招聘的第一原则是宁缺毋滥。这么说出来大家都会认同，但是实际执行往往会因为短期压力而变形，尤其是招聘越来越难，好不容易面到一个看起来差不多的同学，难免会内心有点小倾斜，算了，先招进来了。这其实是非常危险的，因为一旦招聘了错误的人，对于 TL 需要耗费的管理时间会成倍增加，这些时间本来可以用来做更重要的时间。更危险的是，错误的人可能会对团队整体产生负面的影响，例如需要其他人不断地补位，或者和人不断争吵，消耗大家的精力。</p>
<p>因此招聘一定是要严格要求的，如何面试我就不详细讲了，通常我会关注以下一些方面，基本上是缺一不可：</p>
<ol>
<li>coding 能力</li>
<li>对技术的热情</li>
<li>能简明扼要地沟通</li>
<li>积极乐观</li>
<li>对团队目标的认同</li>
</ol>
<p>招聘是个长期的事情，如果仅仅是在有名额的窗口去找人，通常是非常困难的。遇到合适的人，我会长期和他保持沟通，了解对方工作的状态，这其实也是一个不断建立信任的关系。当机会合适的时候，对方肯定会优先考虑你。</p>
<p>当候选人选择机会的时候，团队的 TL 是个怎样的人肯定是他重点考虑的因素之一。因此 TL 一定要做技术发声，不论是开源项目的参与，撰写技术文章，还是在技术大会做演讲，都是充分体现 TL 个人技术能力，技术思考，以及个人特质的重要机会。</p>
<h1 id="二-目标"><a href="#二-目标" class="headerlink" title="二 目标"></a>二 目标</h1><p>团队之所以为团队，是因为这些人有共同的目标，如果没有共同目标，这些人就是散兵游勇，不可能相互协同，无法成就巨大价值。而团队的目标，主要还是由 TL 去负责定义和明确的。</p>
<p>近期比较流行谈 OKR（Objectives and Key Results，目标与关键成果法），我认为这就是一种协同团队聚焦目标的方法。定方向 O（Objective），定数字目标 KR（Key Result），就是期望团队能够凝聚在一起，朝共同的方向努力，相互理解和支持。量化的指标（KR）用来指导方向，暴露问题。我比较反对用 KR 或者其他量化指标来简单粗暴地考核工程师，数字指标如果用来考核，很容易导致大家舍本逐末。例如有人 KR 完成了 200%，却挖了一堆坑；而有人 KR 完成 50%，但的确解决了棘手问题，代码扎扎实实。我必然会把好的绩效给后者，差的绩效给前者。</p>
<p>定义团队目标实际上是个非常困难的事情，因为这个目标的定义要求你回答：</p>
<ul>
<li>是否和你的用户/客户做了充分沟通，是否理解他们真正需要什么，你能给他们解决什么问题，他们的工作因为有了你团队会发生怎样的改变。</li>
<li>和上下游协作方能够做好协同，要兑现你给客户承诺的价值，你会依赖于谁做什么事情？需要谁和你一起参与？这些依赖和协作方，是否认同你的目标？</li>
<li>你定义的目标和价值，和你自己的的 TL 的目标，或者自己部门的目标，是否是一致的？</li>
<li>在技术团队，你的目标定义中有没有考虑技术竞争力？持续建设技术竞争力不仅能帮助团队长期发展得更好，也能帮助吸引更多优秀的人才。</li>
</ul>
<p>当然，如果这个目标有那么点理想主义，那就更好了。工程师骨子都有那么点容易被理想主义吸引。有了清晰的团队目标后，就是要和团队不断的沟通了，让每个人都清晰地理解目标，不要怕重复，不要怕啰嗦。</p>
<p>下一步是把团队目标分解为每个人的目标，这件事本质上是产品架构或者技术架构。为什么这么说呢？在做软件设计的时候，我们都会说高内聚，低耦合；会说面向契约设计。人与人协作的时候，我们也希望每个人的目标足够清晰（对比软件交付功能的定义，或者非功能性指标的度量），以及人和人之间的协作边界清晰（对比软件系统之间的契约）。因此我们要不断去思考团队负责产品的架构，和团队同学不断讨论细化，直至架构及目标足够清晰。当然还有一些横向的目标，或者项目管理的工作目标，需要有同学去承担，这没什么问题，但我非常不建议在研发团队中，让一个同学有超过一半的时间在做横向，因为技术没有深度是谈不上广度的。</p>
<h1 id="三-沟通"><a href="#三-沟通" class="headerlink" title="三 沟通"></a>三 沟通</h1><p>如果团队同学找你，那就要尽可能立即响应。立即响应的意思是，如果你当下有时间，就立刻和他沟通；如果你白天时间排满了，那就晚上和他沟通；如果你实在晚上的时间也被占了，那就立刻安排明天一个时间，发出会议邀约。同学如果没有他认为重要的事情，一般是不会主动找主管沟通的，立即响应是和同学建立信任的重要方式。如果同学找你一次两次都没得到响应，或者响应比较慢（给人不重视的感觉），那慢慢的很多事情就不会找你了。最差的情况，同学下次找你的时候可能是提转岗了。</p>
<p>要尽量和同学做 1-on-1，国外专职做管理岗位的，把 1-on-1 作为一个非常正经的日常工作在做，频率也很高，例如两周一次。在阿里巴巴，技术 TL 通常没有这么多的时间，因为身上承担的职责除了管理外，还要带技术，带项目等等。但还是应该做好日常的 1-on-1 沟通，而不仅仅是绩效季。比较理想的频率是一个月一次。在 1-on-1 的时候，一方面要给到非常具体的反馈，例如：</p>
<ul>
<li>你做的 x 方案，在设计上非常好，考虑到了和隔壁团队的协作。</li>
<li>你近期的代码，在 UT 覆盖上做的不够。</li>
<li>我看到你推进的 y 项目，进展不及理想，是遇到了什么问题吗？需要我提供什么帮助？</li>
</ul>
<p>除了反馈 1-on-1 更重要的是倾听，同学在表述自己工作的时候，状态好不好？在什么地方遇到了问题，作为 TL 能提供什么帮助？_其实很多时候，即使你暂时帮不了什么，但是用认真的态度去听一下同学的心情，无论这个心情是充满热情，还是沮丧，还是迷茫，对于同学来说都是非常重要的。我在做 1-on-1 的时候，都会做个简单的记录，留着下次 1-on-1 的时候 review，做好追踪。</p>
<h1 id="四-工程文化"><a href="#四-工程文化" class="headerlink" title="四 工程文化"></a>四 工程文化</h1><p>要建设一支有战斗力的团队，优秀的工程文化是必不可少的。什么是优秀的工程文化？那就是对自己写代码，写的测试，写的设计，做的产品，所有这些工程师的产出物，对其质量和细节有足够的尊重。为什么说，优秀的工程师文化必不可少，我通过以下几点解释下：</p>
<ul>
<li>从团队产品的长期发展来看，只有保证优秀的质量，才能保证产品可以长期，高效率的，持续的迭代。如果设计凌乱，代码质量差，无测试覆盖，那么渐渐所有人的精力都会被消耗在各种”安全生产“问题上。渐渐的，一个需求的上线实现，从数小时演变成了数天，甚至数周。</li>
<li>只有拥有优秀工程文化的团队，才能吸引优秀的工程师。优秀的工程师，真心把编程当作一门手艺，以自己的手艺为傲。如果团队 TL 不认为这是一门应当引以为傲的手艺，大家渐渐的大家都把事情看成和搬砖无异的性质，区别只是工资高低。这样的氛围下，团队的人才构成必然是二流甚至是三流的。</li>
</ul>
<p>建设工程文化，就是要鼓励大家做 Code Review，写 UT，做好 CI，做知识分享。这些事情听起来很容易，难的是，如何在项目压力很大的时候，依旧坚持住。另外，就是要承认技术债的存在，产品上线一段时间后，必然会有很多“临时方案”存在，作为 TL 要给团队创造空间，鼓励他们花时间去偿还技术债。</p>
<p>工程文化是技术团队的根基，可以让所有人有一个正确的参照，什么是对的，什么是应该学习的，什么是需要遵守的。我们可以看到很多丢失了工程文化的团队，演变成一个什么样的状态，写看起来都差不多的 PPT，天天拉会推动这个推动那个，遇到问题自己不去查根究底弄清楚原理，而是拉群，组会，沟通…… 渐渐的这样的团队的技术人才会逐渐流失，剩下的人继续用他们擅长的非技术技能生存。</p>
<h1 id="五-TL-对自己说"><a href="#五-TL-对自己说" class="headerlink" title="五 TL 对自己说"></a>五 TL 对自己说</h1><p>除了对外，我还经常对自己说：</p>
<ul>
<li>做真实的自己</li>
<li>Don’t Panic！</li>
<li>耐心点</li>
</ul>
<p>做真实的自己。每个人都有自己的性格特质，虽然因为人生经历，人的个性会发生变化，但在短时间内一个人最本质的东西是不会变化的。或温文儒雅，或狭义豪情，或积极勤奋…… “真实不装”是阿里价值观中我最喜欢的一条。伪装一时是很容易做到了，常年累月把自己伪装成一种人设，一来自己会非常累，二来团队同学也不是傻子，早晚会看出这其中虚伪的一面。而一旦一个 TL 让人感到虚伪，那就无从谈起信任的建立了。当然，对自我分析，认识自己也并不是一件简单的事情，心理学分析的书浩如烟海，我喜欢夜深人静的时候读一些。</p>
<p>Don’t Panic！TL 会面临各种各样的压力，目标变化，目标难以达成，绩效考核，人和人之间的冲突，团队很团队之间的冲突，这个时候大家都在看着你怎么处理。在这么多压力下，人的自然反应就是焦虑，甚至惊慌失措。我们知道，在运动的时候，演讲的时候，过度的焦虑会导致动作变形，乃至连自己的正常水平都无法发挥。而 TL 在这种状态下，更容易做出错误的判断，而且严重焦虑的情绪很容易传导给整个团队。越是这种时刻，越好稳住自己，在有限的条件下，努力做出最合理的判断，我们必须要承认自己再怎么聪明勤奋，也只是普通人而已，并不是漫威中的超级英雄。</p>
<p>耐心点。程序员可能是最没耐心的一批人，代码写下去，首先期望机器必然给反馈，其次期望机器立刻给出反馈，对了，还是出错了，一切都要清清楚楚，明明白白。可当程序员的角色转变成管理者的时候，一切就发生了巨大的变化。你给团队宣导的目标，可能有人记住了，有人没记住；你给同学指出的问题，可能他几个月半年都改不了，或者他根本不想改；你想在团队建立的工程文化，好像进展非常慢，和预期相差太远。其实这一切都很正常，人脑接受和转化信息，除非是性命攸关的信息，否则效率都是很低的，一个人自身积累几十年的行为模式，哪怕做出细微的变化，也需要很长的时间。因此，重要的信息，不要嫌麻烦，可以说三遍甚至更多；而当你好心给同学指出问题，也不要期望对方立刻接受并改变，很多时候他不做任何改变也是很正常的。但这也不是我们不做正确事情的理由，如果十个同学中有一两个因为你的指导，在职业生涯上突破了自己的一些瓶颈，那已经作为 TL 能实现的巨大成就了。</p>
<h1 id="六-延伸阅读"><a href="#六-延伸阅读" class="headerlink" title="六 延伸阅读"></a>六 延伸阅读</h1><p>杨绛有一句话我非常喜欢，她在一封回复青年学生的时候，写了这么一句话：</p>
<blockquote>
<p>你的问题主要在于读书不多而想得太多。</p>
</blockquote>
<p>作者：开发者小助手_LS<br>链接：<a href="https://developer.aliyun.com/article/781284?utm_content=g_1000232271">https://developer.aliyun.com/article/781284?utm_content=g_1000232271</a><br>来源：阿里云开发者社区<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>技术 编程 团队 管理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让你的 React 代码更简洁</title>
    <url>/2021/03/17/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%20React%20%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%AE%80%E6%B4%81/</url>
    <content><![CDATA[<p>简洁的代码具有更好的可读性，容易理解，且易于组织。</p>
<p>本篇文章介绍 6 个在 React 中写简洁代码的技巧。</p>
<a id="more"></a>

<ul>
<li><h3 id="1-条件渲染（一个条件时）"><a href="#1-条件渲染（一个条件时）" class="headerlink" title="1. 条件渲染（一个条件时）"></a><strong>1. 条件渲染（一个条件时）</strong></h3><p>当你要根据条件来判断，以渲染不同的组件时，比如条件满足（为 true) 时，就渲染组件，否则不渲染（渲染空内容），这种情况下<br>不要用三元运算符，而是要用 <code>&amp;&amp;</code> 这个操作符来处理，看下面的例子：</p>
<p><strong><em>\</em>不好的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConditionalRenderingWhenTrueBad = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showConditionalText, setShowConditionalText] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span></span><br><span class="line">    setShowConditionalText(<span class="function"><span class="params">showConditionalText</span> =&gt;</span> !showConditionalText)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Toggle the text&lt;/button&gt;</span><br><span class="line">      &#123;showConditionalText ? <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The condition must be true!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>\</em>改进后的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConditionalRenderingWhenTrueGood = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showConditionalText, setShowConditionalText] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span></span><br><span class="line">    setShowConditionalText(<span class="function"><span class="params">showConditionalText</span> =&gt;</span> !showConditionalText)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Toggle the text&lt;/button&gt;</span><br><span class="line">      &#123;showConditionalText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The condition must be true!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-条件渲染（不同的条件时）"><a href="#2-条件渲染（不同的条件时）" class="headerlink" title="2. 条件渲染（不同的条件时）"></a><strong>2. 条件渲染（不同的条件时）</strong></h3><p>跟上面的情况有点像，也是根据条件来判断渲染的组件，只是条件不满足时不再渲染空内容，而是渲染别的组件内容。</p>
<p>这个时候应该用三元运算符。</p>
<p><strong><em>\</em>不好的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConditionalRenderingBad = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showConditionOneText, setShowConditionOneText] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span></span><br><span class="line">    setShowConditionOneText(<span class="function"><span class="params">showConditionOneText</span> =&gt;</span> !showConditionOneText)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Toggle the text&lt;/button&gt;</span><br><span class="line">      &#123;showConditionOneText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The condition must be true!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">      &#123;!showConditionOneText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The condition must be false!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>\</em>改进后的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConditionalRenderingGood = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showConditionOneText, setShowConditionOneText] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span></span><br><span class="line">    setShowConditionOneText(<span class="function"><span class="params">showConditionOneText</span> =&gt;</span> !showConditionOneText)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Toggle the text&lt;/button&gt;</span><br><span class="line">      &#123;showConditionOneText ? (</span><br><span class="line">        &lt;p&gt;The condition must be <span class="literal">true</span>!&lt;/p&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;p&gt;The condition must be <span class="literal">false</span>!&lt;/p&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-布尔值属性"><a href="#3-布尔值属性" class="headerlink" title="3. 布尔值属性"></a><strong>3. 布尔值属性</strong></h3><p>我们经常会传一个布尔类型的属性 (props) 给组件，类似 <code>myTruthyProp=&#123;true&#125;</code> 这样的写法是没有必要的。</p>
<p><strong>不好的代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HungryMessage = <span class="function">(<span class="params">&#123; isHungry &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;span&gt;&#123;isHungry ? <span class="string">&#x27;I am hungry&#x27;</span> : <span class="string">&#x27;I am full&#x27;</span>&#125;&lt;/span&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BooleanPropBad = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;b&gt;This person is hungry: &lt;/b&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;HungryMessage isHungry=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;b&gt;This person is full: &lt;/b&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;HungryMessage isHungry=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong><em>\</em>改进后的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HungryMessage = <span class="function">(<span class="params">&#123; isHungry &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;span&gt;&#123;isHungry ? <span class="string">&#x27;I am hungry&#x27;</span> : <span class="string">&#x27;I am full&#x27;</span>&#125;&lt;/span&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BooleanPropGood = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;b&gt;This person is hungry: &lt;/b&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;HungryMessage isHungry /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;b&gt;This person is full: &lt;/b&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;HungryMessage isHungry=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样更简洁点，虽然只是一个小小技巧，但是可以从中看出你是不是一个有经验且优秀的程序员。</p>
<h3 id="4-字符串属性"><a href="#4-字符串属性" class="headerlink" title="4. 字符串属性"></a><strong>4. 字符串属性</strong></h3><p>跟上面的例子差不多，只是换成了字符串类型，这个时候，我们通常用双引号把字符串括起来，再加上花括号，如下面这样：</p>
<p><strong>不好的代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Greeting = <span class="function">(<span class="params">&#123; personName &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi, &#123;personName&#125;!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StringPropValuesBad = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Greeting personName=&#123;<span class="string">&quot;John&quot;</span>&#125; /&gt;</span><br><span class="line">    &lt;Greeting personName=&#123;<span class="string">&#x27;Matt&#x27;</span>&#125; /&gt;</span><br><span class="line">    &lt;Greeting personName=&#123;<span class="string">`Paul`</span>&#125; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong><em>*</em>*改进后的代码**：**</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Greeting = <span class="function">(<span class="params">&#123; personName &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi, &#123;personName&#125;!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StringPropValuesGood = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Greeting personName=<span class="string">&quot;John&quot;</span> /&gt;</span><br><span class="line">    &lt;Greeting personName=<span class="string">&quot;Matt&quot;</span> /&gt;</span><br><span class="line">    &lt;Greeting personName=<span class="string">&quot;Paul&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="5-事件绑定函数"><a href="#5-事件绑定函数" class="headerlink" title="5. 事件绑定函数"></a><strong>5. 事件绑定函数</strong></h3><p>我们经常会给一个组件绑定类似 <code>onClick</code> 或 <code>onChange</code> 这样的事件，比如我们可能会这样写：<code>onChange=&#123;e =&gt; handleChange(e)&#125;</code>，其实是没必要的，且看：</p>
<p><strong><em>\</em>不好的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnnecessaryAnonymousFunctionsBad = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [inputValue, setInputValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setInputValue(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;name&quot;</span>&gt;Name: &lt;/label&gt;</span><br><span class="line">      &lt;input id=<span class="string">&quot;name&quot;</span> value=&#123;inputValue&#125; onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> handleChange(e)&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>\</em>改进后的代码\</strong>：**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnnecessaryAnonymousFunctionsGood = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [inputValue, setInputValue] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setInputValue(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;name&quot;</span>&gt;Name: &lt;/label&gt;</span><br><span class="line">      &lt;input id=<span class="string">&quot;name&quot;</span> value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-组件属性"><a href="#6-组件属性" class="headerlink" title="6. 组件属性"></a>6. <strong>组件属性</strong></h2><p>跟上面的例子差不多，我们也可以把组件作为属性传给别的组件，这个时候，支持使用把组件包成函数来传递，但没有接任何参数的时候，这种是没有必要的，且看：</p>
<p><strong><em>\</em>不好的代码\</strong>：**</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CircleIcon = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;svg height=<span class="string">&quot;100&quot;</span> width=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">    &lt;circle cx=<span class="string">&quot;50&quot;</span> cy=<span class="string">&quot;50&quot;</span> r=<span class="string">&quot;40&quot;</span> stroke=<span class="string">&quot;black&quot;</span> stroke-width=<span class="string">&quot;3&quot;</span> fill=<span class="string">&quot;red&quot;</span> /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ComponentThatAcceptsAnIcon = <span class="function">(<span class="params">&#123; IconComponent &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Below is the icon component prop I was given:&lt;/p&gt;</span><br><span class="line">    &lt;IconComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnnecessaryAnonymousFunctionComponentsBad = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;ComponentThatAcceptsAnIcon IconComponent=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">CircleIcon</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>  <strong><em>*</em>*改进后的代码**：**</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CircleIcon = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;svg height=<span class="string">&quot;100&quot;</span> width=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">    &lt;circle cx=<span class="string">&quot;50&quot;</span> cy=<span class="string">&quot;50&quot;</span> r=<span class="string">&quot;40&quot;</span> stroke=<span class="string">&quot;black&quot;</span> stroke-width=<span class="string">&quot;3&quot;</span> fill=<span class="string">&quot;red&quot;</span> /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ComponentThatAcceptsAnIcon = <span class="function">(<span class="params">&#123; IconComponent &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Below is the icon component prop I was given:&lt;/p&gt;</span><br><span class="line">    &lt;IconComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnnecessaryAnonymousFunctionComponentsGood = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;ComponentThatAcceptsAnIcon IconComponent=&#123;CircleIcon&#125; /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>  有时候写代码我们并没有注意到，多写一行，或多写内容有什么问题，但是有时候是没有必要的，我们尽量避免这个，写出更好，更简洁的代码，这样别人能认为你是个有经验的程序员。</p>
]]></content>
      <tags>
        <tag>react 代码 简洁</tag>
      </tags>
  </entry>
  <entry>
    <title>异步流之 redux-saga</title>
    <url>/2018/06/10/%E5%BC%82%E6%AD%A5%E6%B5%81%E4%B9%8B%20redux-saga/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这里包含了两个信息：</p>
<p>首先，redux-saga 是一个 redux 的中间件，而中间件的作用是为 redux 提供额外的功能。</p>
<p>其次，我们都知道，在 reducers 中的所有操作都是同步的并且是纯粹的，即 reducer 都是纯函数，纯函数是指一个函数的返回结果只依赖于它的参数，并且在执行过程中不会对外部产生副作用，即给它传什么，就吐出什么。但是在实际的应用开发中，我们希望做一些异步的（如Ajax请求）且不纯粹的操作（如改变外部的状态），这些在函数式编程范式中被称为“副作用”。</p>
<p>Redux 的作者将这些副作用的处理通过提供中间件的方式让开发者自行选择进行实现。</p>
<blockquote>
<p>redux-saga 就是用来处理上述副作用（异步任务）的一个中间件。它是一个接收事件，并可能触发新事件的过程管理者，为你的应用管理复杂的流程。</p>
</blockquote>
<a id="more"></a>

<p><img src="https://i.imgur.com/5L5bsUy.png"></p>
<h1 id="先说一说-redux-thunk"><a href="#先说一说-redux-thunk" class="headerlink" title="先说一说 redux-thunk"></a>先说一说 redux-thunk</h1><p>redux-thunk 和 redux-saga 是 redux 应用中最常用的两种异步流处理方式。</p>
<blockquote>
<p>从异步的角度，Thunk 是指一切都就绪的会返回某些值的函数。你不用传任何参数，你只需调用它，它便会返回相应的值。—— Rethinking Asynchronous Javascript</p>
</blockquote>
<p>redux-thunk 的任务执行方式是从 UI 组件直接触发任务。</p>
<p><strong>举个栗子：</strong></p>
<p>假如当每次 Button 被点击的时候，我们想要从给定的 url 中获取数据，采用 redux-thunk， 我们会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fetchUrl 返回一个 thunk</span><br><span class="line">function fetchUrl(url) &#123;</span><br><span class="line">  return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: &#39;FETCH_REQUEST&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetch(url).then(data &#x3D;&gt; dispatch(&#123;</span><br><span class="line">      type: &#39;FETCH_SUCCESS&#39;,</span><br><span class="line">      data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 thunk 中间件正在运行的话，我们可以 dispatch 上述函数如下：</span><br><span class="line">dispatch(</span><br><span class="line">  fetchUrl(url)</span><br><span class="line">):</span><br></pre></td></tr></table></figure>
<p>redux-thunk 的主要思想是扩展 action，使得 action 从一个对象变成一个函数。</p>
<p><strong>另一个较完整的栗子：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; redux-thunk example</span><br><span class="line">import &#123;applyMiddleware, createStore&#125; from &#39;redux&#39;;</span><br><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line">import thunk from &#39;redux-thunk&#39;;</span><br><span class="line"></span><br><span class="line">const initialState &#x3D; &#123; fetching: false, fetched: false, users: [], error: null &#125;</span><br><span class="line">const reducer &#x3D; (state &#x3D; initialState, action) &#x3D;&gt; &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case &#39;FETCH_USERS_START&#39;: &#123;</span><br><span class="line">            return &#123;...state, fetching: true&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#39;FETCH_USERS_ERROR&#39;: &#123;</span><br><span class="line">            return &#123;...state, fetching: false, error: action.payload&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#39;RECEIVE_USERS&#39;: &#123;</span><br><span class="line">            return &#123;...state, fetching: false, fetched: true, users: action.payload&#125; </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return state;</span><br><span class="line">&#125;</span><br><span class="line">const middleware &#x3D; applyMiddleware(thunk);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; store.dispatch(&#123;type: &#39;FOO&#39;&#125;);</span><br><span class="line">&#x2F;&#x2F; redux-thunk 的作用即是将 action 从一个对象变成一个函数</span><br><span class="line">store.dispatch((dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    dispatch(&#123;type: &#39;FETCH_USERS_START&#39;&#125;);</span><br><span class="line">    &#x2F;&#x2F; do something async</span><br><span class="line">    axios.get(&#39;http:&#x2F;&#x2F;rest.learncode.academy&#x2F;api&#x2F;wstern&#x2F;users&#39;)</span><br><span class="line">        .then((response) &#x3D;&gt; &#123;</span><br><span class="line">            dispatch(&#123;type: &#39;RECEIVE_USERS&#39;, payload: response.data&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            dispatch(&#123;type: &#39;FECTH_USERS_ERROR&#39;, payload: err&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>redux-thunk 的缺点：<br>（1）action 虽然扩展了，但因此变得复杂，后期可维护性降低；<br>（2）thunks 内部测试逻辑比较困难，需要mock所有的触发函数；<br>（3）协调并发任务比较困难，当自己的 action 调用了别人的 action，别人的 action 发生改动，则需要自己主动修改；<br>（4）业务逻辑会散布在不同的地方：启动的模块，组件以及thunks内部。</p>
<h1 id="redux-saga-是如何工作的？"><a href="#redux-saga-是如何工作的？" class="headerlink" title="redux-saga 是如何工作的？"></a>redux-saga 是如何工作的？</h1><p>sages 采用 Generator 函数来 yield Effects（包含指令的文本对象）。Generator 函数的作用是可以暂停执行，再次执行的时候从上次暂停的地方继续执行。Effect 是一个简单的对象，该对象包含了一些给 middleware 解释执行的信息。你可以通过使用 effects API 如 fork，call，take，put，cancel 等来创建 Effect。（ redux-saga API 参考）</p>
<p>如 yield call(fetch, ‘/products’) 即 yield 了下面的对象，call 创建了一条描述结果的信息，然后，redux-saga middleware 将确保执行这些指令并将指令的结果返回给 Generator：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Effect -&gt; 调用 fetch 函数并传递 &#96;.&#x2F;products&#96; 作为参数</span><br><span class="line">&#123;</span><br><span class="line">  type: CALL,</span><br><span class="line">  function: fetch,</span><br><span class="line">  args: [&#39;.&#x2F;products&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 redux-thunk 不同的是，在 redux-saga 中，UI 组件自身从来不会触发任务，它们总是会 dispatch 一个 action 来通知在 UI 中哪些地方发生了改变，而不需要对 action 进行修改。redux-saga 将异步任务进行了集中处理，且方便测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispacth(&#123; type: &#39;FETCH_REQUEST&#39;, url: &#x2F;* ... *&#x2F;&#125; );</span><br></pre></td></tr></table></figure>
<p>所有的东西都必须被封装在 sagas 中。sagas 包含3个部分，用于联合执行任务：</p>
<ol>
<li>worker saga<br>做所有的工作，如调用 API，进行异步请求，并且获得返回结果</li>
<li>watcher saga<br>监听被 dispatch 的 actions，当接收到 action 或者知道其被触发时，调用 worker saga 执行任务</li>
<li>root saga<br>立即启动 sagas 的唯一入口</li>
</ol>
<h2 id="☀-如何使用？"><a href="#☀-如何使用？" class="headerlink" title="☀ 如何使用？"></a>☀ 如何使用？</h2><p>首先，我们得在文件入口中加入 saga 中间件，并且启动它，它会一直运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;...</span><br><span class="line">import &#123; createStore, applyMiddleware&#125; from &#39;redux&#39;;</span><br><span class="line">import createSagaMiddleware from &#39;redux-saga&#39;;</span><br><span class="line">import appReducer from &#39;.&#x2F;reducers&#39;;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line">const sagaMiddleware &#x3D; createSagaMiddleware();</span><br><span class="line">const middlewares &#x3D; [sagaMiddleware];</span><br><span class="line"></span><br><span class="line">const store &#x3D; createStore(appReducer, applyMiddleware(...middlewares));</span><br><span class="line">sagaMiddleware.run(rootSaga);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">    &lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">        &lt;App &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Provider&gt;,</span><br><span class="line">    document.getElementById(&#39;app&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>然后，就可以在 sagas 文件夹中集中写 saga 文件了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; example 1</span><br><span class="line">import &#123; take, fork, call, put &#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The worker: perform the requested task</span><br><span class="line">function* fetchUrl(url) &#123;</span><br><span class="line">  const data &#x3D; yield call(fetch, url);  &#x2F;&#x2F; 指示中间件调用 fetch 异步任务</span><br><span class="line">  yield put(&#123; type: &#39;FETCH_SUCCESS&#39;, data &#125;);  &#x2F;&#x2F; 指示中间件发起一个 action 到 Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The watcher: watch actions and coordinate worker tasks</span><br><span class="line">function* watchFetchRequests() &#123;</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    const action &#x3D; yield take(&#39;FETCH_REQUEST&#39;);  &#x2F;&#x2F; 指示中间件等待 Store 上指定的 action，即监听 action</span><br><span class="line">    yield fork(fetchUrl, action.url);  &#x2F;&#x2F; 指示中间件以无阻塞调用方式执行 fetchUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 redux-saga 中的基本概念就是：sagas 自身不真正执行副作用（如函数 call），但是会构造一个需要执行作用的描述。中间件会执行该副作用并把结果返回给 generator 函数</p>
<p><strong>对上述例子的说明：</strong></p>
<p>（1）引入的 redux-saga/effects 都是纯函数，每个函数构造一个特殊的对象，其中包含着中间件需要执行的指令，如：call(fetchUrl, url) 返回一个类似于 {type: CALL, function: fetchUrl, args: [url]} 的对象。</p>
<p>（2）在 watcher saga watchFetchRequests中：</p>
<p>首先 yield take(‘FETCH_REQUEST’) 来告诉中间件我们正在等待一个类型为 FETCH_REQUEST 的 action，然后中间件会暂停执行 wacthFetchRequests generator 函数，直到  FETCH_REQUEST action 被 dispatch。一旦我们获得了匹配的 action，中间件就会恢复执行 generator 函数。</p>
<p>下一条指令 fork(fetchUrl, action.url) 告诉中间件去无阻塞调用一个新的 fetchUrl 任务，action.url 作为 fetchUrl 函数的参数传递。中间件会触发 fetchUrl generator 并且不会阻塞 watchFetchRequests。当fetchUrl 开始执行的时候，watchFetchRequests 会继续监听其它的 watchFetchRequests actions。当然，JavaScript 是单线程的，redux-saga 让事情看起来是同时进行的。</p>
<p>（3）在 worker saga fetchUrl 中，call(fetch,url) 指示中间件去调用 fetch 函数，同时，会阻塞fetchUrl 的执行，中间件会停止 generator 函数，直到 fetch 返回的 Promise 被 resolved（或 rejected），然后才恢复执行 generator 函数。</p>
<p><strong>另一个栗子：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; example 2</span><br><span class="line">import &#123; takeEvery &#125; from &#39;redux-saga&#39;;</span><br><span class="line">import &#123; call, put &#125; from &#39;redux-saga&#x2F;effects&#39;;</span><br><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. our worker saga</span><br><span class="line">export function* createLessonAsync(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; effects(call, put): </span><br><span class="line">        &#x2F;&#x2F; trigger off the code that we want to call that is asynchronous </span><br><span class="line">        &#x2F;&#x2F; and also dispatched the result from that asynchrous code.</span><br><span class="line">        const response &#x3D; yield call(axios.post, &#39;http:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&#39;, &#123;section_id: action.sectionId&#125;);</span><br><span class="line">        yield put(&#123;type: &#39;lunchbox&#x2F;lessons&#x2F;CREATE_SUCCEEDED&#39;, response: response.data&#125;);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. our watcher saga: spawn a new task on each ACTION</span><br><span class="line">export function* watchCreateLesson() &#123;</span><br><span class="line">    &#x2F;&#x2F; takeEvery: </span><br><span class="line">    &#x2F;&#x2F; listen for certain actions that are going to be dispatched and take them and run through our worker saga.</span><br><span class="line">    yield takeEvery(&#39;lunchbox&#x2F;lessons&#x2F;CREATE&#39;, createLessonAsync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. our root saga: single entry point to start our sagas at once</span><br><span class="line">export default function* rootSaga() &#123;</span><br><span class="line">    &#x2F;&#x2F; combine all of our sagas that we create</span><br><span class="line">    &#x2F;&#x2F; and we want to provide all our Watchers sagas</span><br><span class="line">    yield watchCreateLesson()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，总结一下 redux-saga 的优点：</p>
<p>（1）声明式 Effects：所有的操作以JavaScript对象的方式被 yield，并被 middleware 执行。使得在 saga 内部测试变得更加容易，可以通过简单地遍历 Generator 并在 yield 后的成功值上面做一个 deepEqual 测试。<br>（2）高级的异步控制流以及并发管理：可以使用简单的同步方式描述异步流，并通过 fork 实现并发任务。<br>（3）架构上的优势：将所有的异步流程控制都移入到了 sagas，UI 组件不用执行业务逻辑，只需 dispatch action 就行，增强组件复用性。</p>
<h1 id="附上测试-demo"><a href="#附上测试-demo" class="headerlink" title="附上测试 demo"></a>附上测试 demo</h1><p><a href="https://github.com/RukiQ/redux-async-demo">redux-async-demo</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://survivejs.com/blog/redux-saga-interview/">redux-saga - Saga Middleware for Redux to Handle Side Effects - Interview with Yassine Elouafi</a></p>
<p><a href="https://redux-saga-in-chinese.js.org/docs/basics/index.html">redux-saga 基本概念</a></p>
<p><a href="http://blog.jakegardner.me/redux-thunk-vs-saga/">Redux: Thunk vs. Saga</a></p>
<p><a href="https://github.com/Pines-Cheng/blog/issues/9">从redux-thunk到redux-saga实践</a></p>
<p><a href="https://mingjiezhang.github.io/2017/02/06/React%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%B8%ADredux%E5%BC%82%E6%AD%A5%E6%B5%81%E7%9A%84%E9%80%89%E6%8B%A9/">React项目小结系列：项目中redux异步流的选择</a></p>
]]></content>
      <tags>
        <tag>redux saga 异步 generator react</tag>
      </tags>
  </entry>
  <entry>
    <title>快速了解 React Hooks 原理</title>
    <url>/2020/07/30/%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%20React%20Hooks%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>为了保证的可读性，本文采用意译而非直译。</strong></p>
<p>我们大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？</p>
<p>React 早期版本，类组件可以通过继承<code>PureComponent</code>来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 <code>React.memo</code>函数。</p>
<p><strong>React 16.8</strong> 新出来的<code>Hook</code>可以让React 函数组件具有状态，并提供类似 <code>componentDidMount</code>和<code>componentDidUpdate</code>等生命周期方法</p>
<a id="more"></a>

<h2 id="类被会替代吗？"><a href="#类被会替代吗？" class="headerlink" title="类被会替代吗？"></a>类被会替代吗？</h2><p><code>Hooks</code>不会替换类，它们只是一个你可以使用的新工具。React 团队表示他们没有计划在React中弃用类，所以如果你想继续使用它们，可以继续用。</p>
<p>我能体会那种总有新东西要学的感觉有多痛苦，不会就感觉咱们总是落后一样。<code>Hooks</code> 可以当作一个很好的新特性来使用。当然没有必要用 Hook 来重构原来的代码, React团队也建议不要这样做。</p>
<h2 id="Go-Go"><a href="#Go-Go" class="headerlink" title="Go Go"></a>Go Go</h2><p>来看看<strong>Hooks</strong>的例子,咱们先从最熟悉的开始:函数组件。</p>
<p>以下 OneTimeButton 是函数组件，所做的事情就是当我们点击的时候调用 <code>sayHi</code> 方法。</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; render &#125; from &#39;react-dom&#39;;</span><br><span class="line"></span><br><span class="line">function OneTimeButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick&#x3D;&#123;props.onClick&#125;&gt;</span><br><span class="line">        点我点我</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayHi() &#123;</span><br><span class="line">  console.log(&#39;yo&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;OneTimeButton onClick&#x3D;&#123;sayHi&#125;&#x2F;&gt;,</span><br><span class="line">  document.querySelector(&#39;#root&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们想让这个组件做的是，跟踪它是否被点击，如果被点击了，禁用按钮，就像一次性开关一样。</p>
<p>但它需要一个state，因为是一个函数，它不可能有状态(React 16.8之前)，所以需要重构成类。</p>
<p>函数组件转换为类组件的过程中大概有5个阶段：</p>
<p>*否认：也许它不需要是一个类，我们可以把 state 放到其它地方。</p>
<ul>
<li>实现： 废话，必须把它变成一个<code>class</code>，不是吗？</li>
<li>接受：好吧，我会改的。</li>
<li>努力加班重写：首先 写 <code>class Thing extends React.Component</code>，然后 实现 <code>render</code>等等 。</li>
<li>最后：添加state。</li>
</ul>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OneTimeButton extends React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    clicked: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.props.onClick();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ok, no more clicking.</span><br><span class="line">    this.setState(&#123; clicked: true &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick&#x3D;&#123;this.handleClick&#125;</span><br><span class="line">        disabled&#x3D;&#123;this.state.clicked&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        You Can Only Click Me Once</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是相当多的代码，组件的结构也发生了很大的变化， 我们需要多个小的功能，就需要改写很多。</p>
<h2 id="使用-Hook-轻松添加-State"><a href="#使用-Hook-轻松添加-State" class="headerlink" title="使用　Hook　轻松添加　State"></a>使用　Hook　轻松添加　State</h2><p>接下来，使用新的　<code>useState</code>　hook向普通函数组件添加状态：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function OneTimeButton(props) &#123;</span><br><span class="line">  const [clicked, setClicked] &#x3D; useState(false)</span><br><span class="line">  </span><br><span class="line">  function doClick() &#123;</span><br><span class="line">    props.onClick();</span><br><span class="line">    setClicked(true)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button</span><br><span class="line">      onClick&#x3D;&#123;clicked ? undefined : doClick&#125;</span><br><span class="line">      disabled&#x3D;&#123;clicked&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      点我点我</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="这段代码是如何工作的"><a href="#这段代码是如何工作的" class="headerlink" title="这段代码是如何工作的"></a>这段代码是如何工作的</h2><p>这段代码的大部分看起来像我们一分钟前写的普通函数组件，除了<code>useState</code>。</p>
<p><code>useState</code>是一个hook。 它的名字以<strong>“use”</strong>开头（这是<a href="https://daveceddia.com/intro-to-hooks/#rules-of-hooks">Hooks的规则</a>之一 - 它们的名字必须以“use”开头）。</p>
<p><code>useState</code> hook 的参数是 state 的初始值，返回一个包含两个元素的数组:当前state和一个用于更改state 的函数。</p>
<p>类组件有一个大的state对象，一个函数<code>this.setState</code>一次改变整个state对象。</p>
<p>函数组件根本没有状态，但<code>useState</code> hook允许我们在需要时添加很小的状态块。 因此，如果只需要一个布尔值，我们就可以创建一些状态来保存它。</p>
<p>由于<code>Hook</code>以某种特殊方式创建这些状态，并且在函数组件内也没有像<code>setState</code>函数来更改状态，因此 Hook 需要一个函数来更新每个状态。 所以 <code>useState</code> 返回是一对对应关系：一个值，一个更新该值函数。 当然，值可以是任何东西 - 任何JS类型 - 数字，布尔值，对象，数组等。</p>
<p>现在，你应该有很多疑问，如：</p>
<ul>
<li>当组件重新渲染时，每次都不会重新创建新的状态吗？ React如何知道旧状态是什么？</li>
<li>为什么hook 名称必须以<strong>“use”</strong>开头？ 这看起来很可疑。</li>
<li>如果这是一个命名规则，那是否意味着我可以自定义 Hook。</li>
<li>如何存储更复杂的状态，很多场景不单单只有一个状态值这么简单。</li>
</ul>
<h2 id="Hooks-的魔力"><a href="#Hooks-的魔力" class="headerlink" title="Hooks 的魔力"></a>Hooks 的魔力</h2><p>将有状态信息存储在看似无状态的函数组件中，这是一个奇怪的悖论。这是第一个关于钩子的问题，咱们必须弄清楚它们是如何工作的。</p>
<p>原作者得的第一个猜测是某种编译器的在背后操众。搜索代码<code>useWhatever</code>并以某种方式用有状态逻辑替换它。</p>
<p>然后再听说了调用顺序规则(它们每次必须以相同的顺序调用)，这让我更加困惑。这就是它的工作原理。</p>
<p>React第一次渲染函数组件时，它同时会创建一个对象与之共存，该对象是该组件实例的定制对象，而不是全局对象。只要组件存在于DOM中，这个组件的对象就会一直存在。</p>
<p>使用该对象，<code>React</code>可以跟踪属于组件的各种元数据位。</p>
<p>请记住，React组件甚至函数组件都从未进行过自渲染。它们不直接返回<code>HTML</code>。组件依赖于<code>React</code>在适当的时候调用它们，它们返回的对象结构<code>React</code>可以转换为<code>DOM</code>节点。</p>
<p>React有能力在调用每个组件之前做一些设置，这就是它设置这个<strong>状态</strong>的时候。</p>
<p>其中做的一件事设置 <strong>Hooks</strong> 数组。 它开始是空的, 每次调用一个<code>hook</code>时，React 都会向该数组添加该 <code>hook</code>。</p>
<h2 id="为什么顺序很重要"><a href="#为什么顺序很重要" class="headerlink" title="为什么顺序很重要"></a>为什么顺序很重要</h2><p>假设咱们有以下这个组件：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function AudioPlayer() &#123;</span><br><span class="line">  const [volume, setVolume] &#x3D; useState(80);</span><br><span class="line">  const [position, setPosition] &#x3D; useState(0);</span><br><span class="line">  const [isPlaying, setPlaying] &#x3D; useState(false);</span><br><span class="line"></span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为它调用<code>useState</code> 3次，React 会在第一次渲染时将这三个 hook 放入 Hooks 数组中。</p>
<p>下次渲染时，同样的<code>3</code>个<code>hooks</code>以相同的顺序被调用，所以<code>React</code>可以查看它的数组，并发现已经在位置<code>0</code>有一个<code>useState</code> hook ，所以<code>React</code>不会创建一个新状态，而是返回现有状态。</p>
<p>这就是React能够在多个函数调用中创建和维护状态的方式，即使变量本身每次都超出作用域。</p>
<h2 id="多个useState-调用示例"><a href="#多个useState-调用示例" class="headerlink" title="多个useState 调用示例"></a>多个useState 调用示例</h2><p>让咱们更详细地看看这是如何实现的，第一次渲染：</p>
<ol>
<li>React 创建组件时，它还没有调用函数。React 创建元数据对象和Hooks的空数组。假设这个对象有一个名为<code>nextHook</code>的属性，它被放到索引为<code>0</code>的位置上，运行的第一个hook将占用位置<code>0</code>。</li>
<li>React 调用你的组件（这意味着它知道存储<code>hooks</code>的元数据对象）。</li>
<li>调用<code>useState</code>，React创建一个新的状态，将它放在<code>hooks</code>数组的第<code>0</code>位，并返回<code>[volume，setVolume]</code>对，并将<code>volume</code> 设置为其初始值<code>80</code>，它还将<code>nextHook</code>索引递增1。</li>
<li>再次调用<code>useState</code>，React查看数组的第<code>1</code>位，看到它是空的，并创建一个新的状态。 然后它将<code>nextHook</code>索引递增为<code>2</code>，并返回<code>[position，setPosition]</code>。</li>
<li>第三次调用<code>useState</code>。 React看到位置<code>2</code>为空，同样创建新状态，将<code>nextHook</code>递增到<code>3</code>，并返回<code>[isPlaying，setPlaying]</code>。</li>
</ol>
<p>现在，<code>hooks</code> 数组中有<code>3</code>个hook，渲染完成。 下一次渲染会发生什么？</p>
<ol>
<li> <code>React</code>需要重新渲染组件, 由于 React 之前已经看过这个组件，它已经有了元数据关联。</li>
<li> <code>React</code>将<code>nextHook</code>索引重置为<code>0</code>，并调用组件。</li>
<li>调用<code>useState</code>，React查看索引<code>0</code>处的hooks数组，并发现它已经在该槽中有一个hook。，所以无需重新创建一个，它将<code>nextHook</code>推进到索引<code>1</code>并返回<code>[volume，setVolume]</code>，其中<code>volume</code>仍设置为<code>80</code>。</li>
<li>再次调用<code>useState</code>。 这次，<code>nextHook</code>为<code>1</code>，所以<code>React</code>检查数组的索引<code>1</code>。同样，hook 已经存在，所以它递增<code>nextHook</code>并返回<code>[position，setPosition]</code>。</li>
<li>第三次调用<code>useState</code>，我想你知道现在发生了什么。</li>
</ol>
<p>就是这样了，知道了原理，看起来也就不那么神奇了， 但它确实依赖于一些规则，所以才有使用 <strong>Hooks</strong> 规则。</p>
<h2 id="Hooks-的规则"><a href="#Hooks-的规则" class="headerlink" title="Hooks 的规则"></a>Hooks 的规则</h2><p><a href="https://daveceddia.com/custom-hooks/">自定义 hooks 函数</a>只需要遵守规则 3 ：它们的名称必须以<strong>“use”</strong>为前缀。</p>
<p>例如，我们可以从<code>AudioPlayer</code>组件中将3个状态提取到自己的自定义钩子中：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function AudioPlayer() &#123;</span><br><span class="line">  &#x2F;&#x2F; Extract these 3 pieces of state:</span><br><span class="line">  const [volume, setVolume] &#x3D; useState(80);</span><br><span class="line">  const [position, setPosition] &#x3D; useState(0);</span><br><span class="line">  const [isPlaying, setPlaying] &#x3D; useState(false);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &lt; beautiful audio player goes here &gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，咱们可以创建一个专门处理这些状态的新函数，并使用一些额外的方法返回一个对象，以便更容易启动和停止播放，例如：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function usePlayerState(lengthOfClip) &#123;</span><br><span class="line">  const [volume, setVolume] &#x3D; useState(80);</span><br><span class="line">  const [position, setPosition] &#x3D; useState(0);</span><br><span class="line">  const [isPlaying, setPlaying] &#x3D; useState(false);</span><br><span class="line"></span><br><span class="line">  const stop &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setPlaying(false);</span><br><span class="line">    setPosition(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const start &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setPlaying(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    volume,</span><br><span class="line">    position,</span><br><span class="line">    isPlaying,</span><br><span class="line">    setVolume,</span><br><span class="line">    setPosition,</span><br><span class="line">    start,</span><br><span class="line">    stop</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样提取状态的一个好处是可以将相关的逻辑和行为组合在一起。可以提取一组状态和相关事件处理程序以及其他更新逻辑，这不仅可以清理组件代码，还可以使这些逻辑和行为可重用。</p>
<p>另外，通过在自定义<code>hooks</code>中调用自定义<code>hooks</code>，可以将<code>hooks</code>组合在一起。hooks只是函数，当然，函数可以调用其他函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Hooks 提供了一种新的方式来处理React中的问题，其中的思想是很有意思且新奇的。</p>
<p>React团队整合了一组很棒的<a href="https://reactjs.org/docs/hooks-intro.html">文档</a>和一个常见<a href="https://reactjs.org/docs/hooks-faq.html">问题解答</a>，从是否需要重写所有的类组件到钩Hooks是否因为在渲染中创建函数而变慢? 以及两者之间的所有东西，所以一定要看看。</p>
<p>原文：<a href="https://segmentfault.com/a/1190000019966124">快速了解 React Hooks 原理</a></p>
]]></content>
      <tags>
        <tag>JavaScript React Hooks Hook 新技术 API</tag>
      </tags>
  </entry>
  <entry>
    <title>我在阿里收获的N个成长</title>
    <url>/2020/08/14/%E6%88%91%E5%9C%A8%E9%98%BF%E9%87%8C%E6%94%B6%E8%8E%B7%E7%9A%84N%E4%B8%AA%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>作者：樊飞，入职阿里6年，目前在负责支持618、双十一、双十二等淘系营销活动业务的会场页面搭建系统。</p>
</blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近在内网看到一个贴子《我在阿里学会的23件事》，描述了在阿里收获的成长和淡淡的鸡汤，给了我灵感。也把自己进阿里以来在做事、个人成长以及晋升方面的成长经验做个梳理，有碰壁总结也有良师箴言。</p>
<p>声明：这是一篇非常主观的成长总结，可能有所偏颇，但不涉及观点之争，观点内容也并未展开和深入，还请见谅。</p>
<a id="more"></a>

<h2 id="关于做事"><a href="#关于做事" class="headerlink" title="关于做事"></a>关于做事</h2><p>个人认为一个人的做事能力由三个方面决定：态度、天赋和方法。在阿里能拉开差距的通常是第三个方面，善于从工作中挖掘、总结并沉淀成自己的方法显得尤为重要。关于在职场如何工作的方法论，市面上书籍颇多，大体都离不开结构化和体系化思考，推荐书籍《金字塔原理》(来自世界顶尖咨询公司的高效工作法)。我这里主要分享下关于做事中常见的一些具体策略感悟：</p>
<h3 id="思考方面"><a href="#思考方面" class="headerlink" title="思考方面"></a>思考方面</h3><ul>
<li><strong>多运用3W1H分析法：</strong>一件事情为什么(Why)要做？用户(Who)是谁？要做是什么(What)？怎么做(How)？一件事情被想清楚了就完成了一半。</li>
<li><strong>多运用SMART分析法：</strong>制定目标要满足确定性（Specific) 、可度量性（Measurable）、可实现性（Attainable）、相关性（Relevant）和时效性（Time-based）；事情被想清楚后，清晰的目标拆解能保障事情更好的达成。</li>
<li><strong>要预想未来的变化，并留有余地：</strong>业务和工程代码都在不断的进化之中，如果只是想到当下，那会很快失去价值。小到工具，大到架构，都要有更宽广的视角去思考，考虑更多的因素，尤其是时间因素，太多的架构治理是由于时间拉长导致的(比如NPM包的依赖治理)。</li>
<li><strong>有时候“走一步算一步”并不是贬义词：</strong>当事情没有头绪，过于错综复杂的情况下，就拆解到当前能理清头绪，能执行的最小闭环，来落地，一边执行一边思考是更互联网+的思维</li>
<li><strong>先有判断，再有策略：</strong>事情正确性判断因背景和场景而异，大体原则是站在这个事情以及要解决的问题的角度，向有利于推动这个事情或者要解决的问题往更好的方向发展的角度，来做是与否，对与错，一或二(如果有多方案的情况下)的选择题判断，再然后根据这个判断做一个梳理，在时间、成本、执行等方面分别存在什么问题？再制定出短、中、长期策略，最终落地执行。</li>
<li><strong>因为相信所以看见：</strong>在做有关突破创新的规划和思考时，时常也会扪心自问：这个方向是否正确？是否真的是未来的趋势？后来我发现，这个问题不对，应该是你想让这个方向变成未来的趋势吗？没有人会笃定知道这个方向是趋势，但是有想让它变成趋势的人。</li>
</ul>
<h3 id="沟通方面"><a href="#沟通方面" class="headerlink" title="沟通方面"></a>沟通方面</h3><ul>
<li><strong>大部分场景下的沟通不畅问题都能通过换位思考解决：</strong>沟通的目的是为了达成一致，从TA的角度考虑，能找到沟通不畅的原因，进而更好的达成目的。这里举一个案例：一个涉及到两个板块的需求，导致两个板块负责人有争执。A考虑分工问题，B考虑成本问题。两个人的关注点不同，沟通中在意的点也就不同，如果一开始就把问题聚焦，先沟通技术方案再考虑各自人力分配，过程和结局都会更理想。</li>
<li><strong>书面的沟通记录比口头的沟通协议有保障：</strong>口头沟通协主要存在两个弊端：一、口头沟通可能存在信息偏差，表面协议达成一致，但对协议的理解上并不一致；二、口头的协议经不起时间的消磨，说秋后算账的，真到了秋后可能都忘了；所以把沟通内容的结论，书面化同步给所有参与人员，是对事情的负责。</li>
</ul>
<h3 id="执行方面"><a href="#执行方面" class="headerlink" title="执行方面"></a>执行方面</h3><ul>
<li><strong>敬畏墨菲定律：</strong>双十一的复杂场景下已经有太多的案例来证明，如果觉得一个点隐约存在问题，它早晚一定会变成问题。</li>
<li><strong>要有利他的心态：</strong>两个原因：一、更有凝聚力做成事；二、送人玫瑰，手有余香。</li>
<li><strong>权利&amp;义务需要对等：</strong>举例以项目负责人这个点，作为负责人要有推进项目正常运作上线的义务，也就有制定规则，建立项目成员协同机制的权利；要有解决风险和问题的义务，也就有制定规避风险预案协同机制的权利；涉及到跨团队协同的情况下，还需要能通过主管、项目子负责人等通道，建立跨团队协同机制的义务和权利；一旦权利和义务不对等，项目的运作的顺利与否就是看天吃饭，完全取决于成员的综合素质能力和项目的复杂程度。</li>
</ul>
<h2 id="关于成长"><a href="#关于成长" class="headerlink" title="关于成长"></a>关于成长</h2><p>成长应该都是伴随着阵痛的，疼痛程度因人而异，但成长的经验和思考却存在共性。</p>
<ul>
<li><strong>成长在于能踏出舒适区，做你认为对但又畏惧的事情：</strong>比如从读者变作者、比如从浅尝辄止到深入浅出，比如从参与项目到负责项目……</li>
<li><strong>不要把公司和产品的能力当成是自己的能力：</strong>ABMT等大厂待过，再出来面试面跪的也是一大把；镀一层金是有buff加成，但更重要的是自己为公司和产品做过什么，这才是你的能力。</li>
<li><strong>身上一定要有标签：</strong>可以是业务的也可以是技术的，比如营销活动、可视化搭建、微前端、web ide等等，能通过一个标签直接联想到你，如果确定了目标就努力吧，你的标签也就是你的个人品牌影响力。</li>
<li><strong>对驱动力的思考：</strong>工作中的驱动力无非两种，一种是外在驱动力，即奖罚并存的萝卜加大棒模式，再local化也就是KPI，通常被外在驱动力支配的同学未来的规划方向目标模糊，易迷茫易产生惰性，偶现一段时间的“鸡血”状态可能也是来源于主管的压力，大部分时间都是完成任务，鲜有亮点。另一种是内在驱动力，也就是内心有很强的目标来驱动，这类人通常不会烦恼于绩效，有方向有规划有思考，善沟通善分享，讲到这里你可能脑海里现在会浮现出一些人，这些你认同的同事，以及团队公认的明星或高潜员工在工作中基本都是第二种，内在驱动力最能激励和调动个人积极性，所以从自身看要挖掘自己的内在驱动力，从团队看要挖掘成员的内在驱动力。</li>
<li><strong>对靠谱的思考：</strong>通常通过不长的一段时间接触，就能初步判断一个人的靠谱程度，每个人周围其实都有四类不同靠谱程度的同学，需要识别并有针对性的策略来对待，也同时扪心自问下，你是哪一类？<ul>
<li>能力靠谱，态度靠谱：这类通常都是一个团队的明星和高潜成员；也是大家最容易相处的成员，不用多说就能合作无间。</li>
<li>能力不靠谱，态度靠谱：这类通常是经验不足，方法论没建立；这种情况，作为项目管理者和主管要及时跟进了解情况，CHECK到细节，给与辅导，能否成长就取决于他自己了，这类是有希望能成长为第一类的。</li>
<li>能力靠谱、态度不靠谱：个人认为，态度比能力更重要。之所以态度不靠谱，这里也有两类，一类是因为他对于这个事情的价值不了解不理解，或者与他的KPI没有关联。这种情况下，作为合作者和主管，需要沟通清楚事情价值，对客户、公司以及对他个人的价值，必要时捆绑KPI。往往态度纠正后这类小伙伴能让你对他会有极大的改观。另外还有一类是”惰性群体“，想过养老生活，细节不说，遇到过的自己应该能理解，如果萝卜加大棒也无法转变，就让时间来考核吧。</li>
<li>能力不靠谱，态度也不靠谱：目前还没遇到过，如果有的话应该属于招聘事故，列入黑名单吧。</li>
</ul>
</li>
<li><strong>对工作中的角色的思考：</strong>阿里的技术同学在工作中大体应该会经历三种角色状态：一个人就完全可以cover的单兵作战状态；需要联合不同职能成员，有周期性和确定性目标的项目作战状态；需要形成固定的团队组织结构，长期固定支撑一块或多块业务场景的团队作战状态。这三个状态可能会同时出现在一个人身上，在不同的状态下，一个人也就会有不同的角色，需要快速的完成角色切换，对角色有清晰的认知。<ul>
<li>单兵作战：这个状态角色是一个独当一面的普通员工，主要考虑的是从完成工作任务出发，考虑什么时间点应该给到什么东西；考虑如何确保合作伙伴们能跟自己亲密无间的按时保质完成工作任务。</li>
<li>项目作战：这个状态下的角色是带领横向虚拟团队来完成一个较复杂的工作的项目管理者，主要考虑的是从完成项目的角度考虑，考虑如何做项目拆解，谁合适做哪块的事情，他目前负责的事跟这个项目的关系，挖掘他在这个项目中的价值激发成员积极性，考虑如何能让项目成员形成合力来推动和完成项目。</li>
<li>团队作战：这个状态下的角色是作为带领实体团队来支撑业务的主管，主要考虑的是如何带领团队支撑业务更好的往前走，从业务目前现状和未来考虑要构建什么样的能力出发形成中长期的产品和项目。根据团队人的所处阶段、能力特征、重点人才、梯队分布等情况考虑组织团队的阵型，充分了解团队成员的状态、诉求、能力以及问题，头部成员给压力、腰部成员给辅导、尾部同学给希望，考虑支撑好业务的同时让团队能形成梯队良性成长。</li>
</ul>
</li>
</ul>
<h2 id="关于晋升"><a href="#关于晋升" class="headerlink" title="关于晋升"></a>关于晋升</h2><p>从P5入职，前后参加了三次晋升述职，其中有一次失败，应该属于普通的前端“成长”速度。可能是因为有失败也有成功，所以对晋升述职的感受还是非常深刻的。</p>
<ul>
<li><strong>表达&amp;分享是工作的一部分：</strong>我不善于表达，这也是我有一次失败的重要原因之一，但表达和分享确实是工作的一部分，往往还是很重要的一部分。我们都是团队作战，任何想法要让它更好的产生价值，都必须把它同步给团队中的每一个人。很多时候，“说”不是为了突出自己的个人秀，而是实实在在的工作，要推动一件事情，就要集合更多人的力量，要做到朴素而力求准确的表达，便于理解并引起共鸣。《人类简史》中提到现代人类在进化中之所以在远古智人中脱颖而出，就是因为我们更会“说”，交流才有了文化，才有了社会化大分工。在这个点上目前虽有成长但仍旧不足，希望能做到侃侃而谈，声入人心。</li>
<li><strong>晋升述职是自我总结和思考的最佳机会</strong>，应该很少人有时间真的静下来沉下来思考自己这一年做的事情，为什么做这些事情，价值是什么，有什么难点，怎么解决的，未来还需要做什么……现在回想还是个难忘的感觉，就像是在把玩一个自己做的手工，盘它！盘到闭着眼睛想象就能360°无死角的介绍它。不是在不停的自我反问中更清晰的缕清自己做的事情，就是在不停的自我否定中走入自我怀疑的误区。心情就像是过山车，会因为缕清一个思路而拍案而起，也会因为一个点的专研不深而自我怀疑，会因为缕清一个自认为清晰的80分ppt而杰克逊附体，也会因为老板的一顿灵魂拷问而觉得“指甲不够咬”，但最后当你走完这整个历程回过头看看，不管晋升结果如何……对于自我都是一次成长，对自己所做的事情、不足有更清晰的认知，对自己的定位更明确，犹如涅槃重生。这都是属于参加晋升面试的珍贵回忆。</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><strong>选择合适的团队和业务很重要：</strong>以业务为场景挖掘你的技术深度极限，来提高你职场的下限；同样是做页面的性能优化在双十一主会场里做和在普通活动页面做的差距显而易见。优秀的团队通常主管都非常重视对人才的培养，会投入更多的时间和精力，也会给与机会承担更加重要的角色和事情，来提高你职场的上限。一个优秀的团队氛围 + 一个足够当量的业务场景能创造一个相对稳定和优越的外在环境，最后能否快速成长就取决你自己了！</p>
<p><a href="https://segmentfault.com/a/1190000023606563">原文地址</a></p>
]]></content>
      <tags>
        <tag>阿里 分享 3W1H SMART</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个简单版本的Promise</title>
    <url>/2019/02/14/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E7%9A%84Promise/</url>
    <content><![CDATA[<h1 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h1><blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
</blockquote>
<blockquote>
<p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、resolved（已成功）和rejected（已失败）。一旦成功就不允许失败，一旦失败就不允许成功。</p>
</blockquote>
<a id="more"></a>

<h1 id="先把一个空架子搭出来"><a href="#先把一个空架子搭出来" class="headerlink" title="先把一个空架子搭出来"></a>先把一个空架子搭出来</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>; <span class="comment">// 实例对象</span></span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">// 默认值为null</span></span><br><span class="line">    self.status = PENDING; <span class="comment">// 初始状态为pending等待状态</span></span><br><span class="line">    self.resolvedCallbacks = []; <span class="comment">// 成功回调列表</span></span><br><span class="line">    self.rejectedCallbacks = []; <span class="comment">// 失败回调列表</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 成功的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rejecte</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 拒绝的方法</span></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject); <span class="comment">// 调用传入的函数，并传入resolve和reject方法为入参</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(self.value); <span class="comment">// 异常场景直接调用reject拒绝方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then(<span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"><a href="#因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法" class="headerlink" title="因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法"></a>因为new返回的是promise对象，初始化一个对象，完善该对象的属性和方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>; <span class="comment">// 实例对象</span></span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">// 默认值为null</span></span><br><span class="line">    self.status = PENDING; <span class="comment">// 初始状态为pending等待状态</span></span><br><span class="line">    self.resolvedCallbacks = []; <span class="comment">// 成功回调列表</span></span><br><span class="line">    self.rejectedCallbacks = []; <span class="comment">// 拒绝回调列表</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        self.status = RESOLVED; <span class="comment">// 把状态改为resolved</span></span><br><span class="line">        self.value = value;</span><br><span class="line">        self.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">// 分别执行成功回调列表里的方法，并传入value</span></span><br><span class="line">    &#125;; <span class="comment">// 成功的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        self.status = REJECTED; <span class="comment">// 把状态改为rejected</span></span><br><span class="line">        self.value = value;</span><br><span class="line">        self.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">//分别执行拒绝回调列表里的方法，并传入value</span></span><br><span class="line">    &#125;; <span class="comment">// 拒绝的方法</span></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject); <span class="comment">// 调用传入的函数，并传入resolve和reject方法为入参</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(self.value); <span class="comment">// 异常场景直接调用reject拒绝方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then(<span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="返回的promise具有then方法，并能获取到初始化数据"><a href="#返回的promise具有then方法，并能获取到初始化数据" class="headerlink" title="返回的promise具有then方法，并能获取到初始化数据"></a>返回的promise具有then方法，并能获取到初始化数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(self.status === PENDING) &#123; <span class="comment">// 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里</span></span><br><span class="line">        self.resolvedCallbacks.push(onFulfilled);</span><br><span class="line">        self.rejectedCallbacks.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化后再调用then方法根据初始化的状态分别执行对应的方法</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === RESOLVED) &#123;</span><br><span class="line">        onFulfilled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === REJECTED) &#123;</span><br><span class="line">        onRejected(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self; <span class="comment">// 链式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27; test &#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span> + value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果: resolve test </span></span><br></pre></td></tr></table></figure>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>; <span class="comment">// 实例对象</span></span><br><span class="line">    self.value = <span class="literal">null</span>; <span class="comment">// 默认值为null</span></span><br><span class="line">    self.status = PENDING; <span class="comment">// 初始状态为pending等待状态</span></span><br><span class="line">    self.resolvedCallbacks = []; <span class="comment">// 成功回调列表</span></span><br><span class="line">    self.rejectedCallbacks = []; <span class="comment">// 拒绝回调列表</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        self.status = RESOLVED; <span class="comment">// 把状态改为resolved</span></span><br><span class="line">        self.value = value;</span><br><span class="line">        self.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">// 分别执行成功回调列表里的方法，并传入value</span></span><br><span class="line">    &#125;; <span class="comment">// 成功的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        self.status = REJECTED; <span class="comment">// 把状态改为rejected</span></span><br><span class="line">        self.value = value;</span><br><span class="line">        self.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">//分别执行拒绝回调列表里的方法，并传入value</span></span><br><span class="line">    &#125;; <span class="comment">// 拒绝的方法</span></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject); <span class="comment">// 调用传入的函数，并传入resolve和reject方法为入参</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(self.value); <span class="comment">// 异常场景直接调用reject拒绝方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(self.status === PENDING) &#123; <span class="comment">// 初始化时为pending状态，此时把成功和拒绝的方法push进指定列表里</span></span><br><span class="line">        self.resolvedCallbacks.push(onFulfilled);</span><br><span class="line">        self.rejectedCallbacks.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化后再调用then方法根据初始化的状态分别执行对应的方法</span></span><br><span class="line">    <span class="keyword">if</span>(self.status === RESOLVED) &#123;</span><br><span class="line">        onFulfilled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(self.status === REJECTED) &#123;</span><br><span class="line">        onRejected(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self; <span class="comment">// 链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27; test &#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span> + value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;reject&#x27;</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>首先是利用构造函数模式初始化一个promise对象，在原型上绑定实例方法，注意初始化调用then方法的时候此时状态为pending，在执行传入的方法改变状态后再调用then方法会根据修改后的状态执行不同的逻辑</p>
</blockquote>
<blockquote>
<p>我觉得promise对象利用了构造函数设计模式解决了js异步回调嵌套的问题，完美解决了返回数据嵌套依赖的问题，也就是俗称的回调地狱。现在算是把长久以来关于promise的疑惑搞明白了，over！！！</p>
</blockquote>
]]></content>
      <tags>
        <tag>promise 异步 es6</tag>
      </tags>
  </entry>
  <entry>
    <title>数组reduce方法的高级技巧</title>
    <url>/2017/12/04/%E6%95%B0%E7%BB%84reduce%E6%96%B9%E6%B3%95%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<blockquote>
<p>这几天都在偷偷摸摸的研究数组的那几个迭代方法。使用下来，感觉确实妙用无穷，仿佛自己的逼格在无形中变得高大了一点点，哈哈。<br>这篇文章就是专门总结reduce方法的，这个方法大有可研究的地方，值得大家get它并去同手实践一下。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>从最简单的例子开始。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var  arr &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">sum &#x3D; arr.reduce(function(prev, cur, index, arr) &#123;</span><br><span class="line">    console.log(prevres, cur, index);</span><br><span class="line">    return prevres + cur;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr, sum);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">3 3 2</span><br><span class="line">6 4 3</span><br><span class="line">10 5 4</span><br><span class="line">[1, 2, 3, 4, 5] 15</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们先重新回顾一下reduce中回调函数的参数，这个回调函数中有4个参数，意思分别为</p>
</blockquote>
<ul>
<li>prev: 第一项的值或者上一次叠加的结果值</li>
<li>cur: 当前会参与叠加的项</li>
<li>index： 当前值的索引</li>
<li>arr: 数组本身</li>
</ul>
<blockquote>
<p>首先我们要区分prev与cur这2个参数的区别，刚开始的时候我以为他们是一种类型的，可是后来我发现我理解错了。prev表示每次叠加之后的结果，类型可能与数组中的每一项不同，而cur则表示数组中参与叠加的当前项。在后边我们可以结合实例来理解这个地方。</p>
</blockquote>
<blockquote>
<p>其次我们看到，上例中其实值遍历了4次，数组有五项。数组中的第一项被当做了prev的初始值，而遍历从第二项开始。</p>
</blockquote>
<blockquote>
<p>我们看下面一个例子。</p>
</blockquote>
<blockquote>
<p>某同学的期末成绩如下表示</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        subject: &#39;math&#39;,</span><br><span class="line">        score: 88</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: &#39;chinese&#39;,</span><br><span class="line">        score: 95</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        subject: &#39;english&#39;,</span><br><span class="line">        score: 80</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何求该同学的总成绩？</p>
</blockquote>
<blockquote>
<p>很显然，利用for循环可以很简单得出结论</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum &#x3D; 0;</span><br><span class="line">for(var i&#x3D;0; i&lt;result.length; i++) &#123;</span><br><span class="line">    sum +&#x3D; result[i].score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是我们的宗旨就是抛弃for循环，因此使用reduce来搞定这个问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum &#x3D; result.reduce(function(prev, cur) &#123;</span><br><span class="line">    return cur.score + prev;</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，我给reduce参数添加了第二个参数。通过打印我发现设置了这个参数之后，reduce遍历便已经从第一项开始了。</p>
</blockquote>
<blockquote>
<p>这第二个参数就是设置prev的初始类型和初始值，比如为0，就表示prev的初始值为number类型，值为0，因此，reduce的最终结果也会是number类型。</p>
</blockquote>
<blockquote>
<p>因为第二个参数为累计结果的初始值，因此假设该同学因为违纪被处罚在总成绩总扣10分，只需要将初始值设置为-10即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum &#x3D; result.reduce(function(prev, cur) &#123;</span><br><span class="line">    return cur.score + prev;</span><br><span class="line">&#125;, -10);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们来给这个例子增加一点难度。假如该同学的总成绩中，各科所占的比重不同，分别为50%，30%，20%，我们应该如何求出最终的权重结果呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dis &#x3D; &#123;</span><br><span class="line">    math: 0.5,</span><br><span class="line">    chinese: 0.3,</span><br><span class="line">    english: 0.2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum &#x3D; result.reduce(function(prev, cur) &#123;</span><br><span class="line">    console.log(prev);</span><br><span class="line">    return cur.score + prev;</span><br><span class="line">&#125;, -10);</span><br><span class="line"></span><br><span class="line">var qsum &#x3D; result.reduce(function(prev, cur) &#123;</span><br><span class="line">    var newSub &#x3D; &#123;</span><br><span class="line">        subject: cur.subject,</span><br><span class="line">        score: cur.score * dis[cur.subject]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (function(prev, cur) &#123;</span><br><span class="line">        return cur.score + prev;</span><br><span class="line">    &#125;)(prev, newSub)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">console.log(sum, qsum);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了计算出权重之后的总值，我们在回调函数内部修改了数组当前项，是使他和权重比例关联袭来，并重新返回一个一样的回调函数，将新修改的当前项传入，就和之前的例子是一样的了。</p>
</blockquote>
<blockquote>
<p>在segmentfault上看到一个面试题，问如何知道一串字符串中每个字母出现的次数？</p>
</blockquote>
<blockquote>
<p>我们可以运用reduce来解决这个问题。</p>
</blockquote>
<blockquote>
<p>我们在reduce的第二个参数里面初始了回调函数第一个参数的类型和值，将字符串转化为数组，那么迭代的结果将是一个对象，对象的每一项key值就是字符串的字母。运行感受一下吧。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arrString &#x3D; &#39;abcdaabc&#39;;</span><br><span class="line"></span><br><span class="line">arrString.split(&#39;&#39;).reduce(function(res, cur) &#123;</span><br><span class="line">    res[cur] ? res[cur] ++ : res[cur] &#x3D; 1</span><br><span class="line">    return res;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于可以通过第二参数设置叠加结果的类型初始值，因此这个时候reduce就不再仅仅只是做一个加法了，我们可以灵活的运用它来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组，大家可以动手去尝试一样</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2].reduce(function(res, cur) &#123; </span><br><span class="line">    res.push(cur + 1); </span><br><span class="line">    return res; </span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种特性使得reduce在实际开发中大有可为！但是需要注意点，在ie9一下的浏览器中，并不支持该方法！</p>
</blockquote>
]]></content>
      <tags>
        <tag>javascript js 数组 方法 reduce 高级 技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>新手使用vue-router传参时注意事项</title>
    <url>/2019/06/12/%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8vue-router%E4%BC%A0%E5%8F%82%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="新手使用vue-router传参时注意事项"><a href="#新手使用vue-router传参时注意事项" class="headerlink" title="新手使用vue-router传参时注意事项"></a>新手使用vue-router传参时注意事项</h1><p>vue-router里路由传参推荐用path和query的组合，或者是name和params的组合。其中name+params传参在刷新页面后路由参数会丢失，可以在路由配置时把参数配在url上，path+query的传参刷新页面后不会丢失，但是传参会拼接到url后，有长度的限制。具体用哪一种传参方式取决于业务的需要和实际的应用场景。</p>
<a id="more"></a>

<h1 id="使用name和params组合传参"><a href="#使用name和params组合传参" class="headerlink" title="使用name和params组合传参"></a>使用name和params组合传参</h1><blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;details&#x27;</span>, <span class="attr">params</span>: &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">233</span>&#125;&#125;)	</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/details&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;details&#x27;</span>,</span><br><span class="line">            component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../components/details&#x27;</span>], resolve)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.params.id <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
<h2 id="刷新参数丢失-显示-undefined"><a href="#刷新参数丢失-显示-undefined" class="headerlink" title="刷新参数丢失 显示 undefined"></a>刷新参数丢失 显示 undefined</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$route.params.id <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/11/mAXipSQHL8gsvJl.png" alt="图片"></p>
<p>注意：此方法第一次跳转是没有问题的，参数也可以传过去，但是刷新页面后，参数就没了 (ps: 这个地方其实还有一个问题，当你传递的参数是number类型，第一次是没有问题的，获取的时候也是number类型，但是当你刷新页面后，number变成string类型，如果涉及计算的建议先类型转换一下)</p>
<p>第一次是预期结果 // 234</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.params.id + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/11/vzsmtpFRihWk4Vd.png"></p>
<p>刷新页面后直接字符串拼接了 // 2331</p>
<p><img src="https://i.loli.net/2021/01/11/cvyWGVn2UJICtLe.png"></p>
<h2 id="参数丢失解决方案"><a href="#参数丢失解决方案" class="headerlink" title="参数丢失解决方案"></a>参数丢失解决方案</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/details/:id&#x27;</span>, <span class="comment">// 这里配置的要和你传递的参数名保持一致</span></span><br><span class="line">        name: <span class="string">&#x27;details&#x27;</span>,</span><br><span class="line">        component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../components/details&#x27;</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="path和query组合传参"><a href="#path和query组合传参" class="headerlink" title="path和query组合传参"></a>path和query组合传参</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;/details&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">id</span>: <span class="number">666</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">this</span>.$route.query.id <span class="comment">// 666</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/11/M9nGWtrxAuq27IE.png"></p>
<p>此方法参数会跟在问号后面 例如：/details?id=666，该方法刷新页面不会丢失参数</p>
<p>最后：根据自己的项目选择合适的传参方式</p>
]]></content>
      <tags>
        <tag>vue vue-router 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解React的子组件</title>
    <url>/2018/01/07/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3React%E7%9A%84%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>React的核心是组件。你可以像嵌套HTML标签一样来嵌套这些组件，这使得写JSX变得容易，因为他和标记语言很像。 当刚开始学习React的时候，我认为“会用<code>props.children</code>，我就知道了关于子组件的一切”。难道，我有错吗？ 因为我们在使用JavaScript，我们可以改变子组件。我们可以向他们发送特定的属性，决定我们是否希望它们显示，并且可以按照我们的意愿操作它们。让我们探究一下React中的子组件。</p>
<a id="more"></a>

<p>假设我们有一个可以包含若干组件的组件。你会像这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">  &lt;Row &#x2F;&gt;</span><br><span class="line">  &lt;Row &#x2F;&gt;</span><br><span class="line">  &lt;Row &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Grid&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/skCYXj1.png"></p>
<p>通过<code>props.children</code>，<code>Grid</code>组件可以获得这三个<code>Row</code>组件。父组件通过一个表现容器来渲染这些子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Grid extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;&#123;this.props.children&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父组件也可以决定不渲染任何子组件或者在渲染他们之前操控它们。比如说，下面这个组件就不渲染任何子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Fullstop extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不管你传递哪个组件给上面这个组件，它总是会只显示“Hello world！”。</p>
<blockquote>
<p>注意： 上面例子中的<code>Fullstop</code>组件（非常像HTML的原语），在渲染‘Hello World!’的情况下，不会渲染它的子组件。</p>
</blockquote>
<p>一切都可以是子组件</p>
<p>在React中，子组件没有必要必须是一个组件，他们可以是任意内容。比方说，我们可以给上面的<code>Grid</code>组件传递文本作为子组件且结果很完美。</p>
<p><img src="https://i.imgur.com/K4EdUB3.png"></p>
<p>JSX会自动清除每行开始和结束处的空格以及空白的行。它还将字符串文字中间的空行浓缩成一个空格。</p>
<p>这意味着下面这些示例都会渲染成相同的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Grid&gt;Hello world!&lt;&#x2F;Grid&gt;</span><br><span class="line"></span><br><span class="line">&lt;Grid&gt;</span><br><span class="line">  Hello world!</span><br><span class="line">&lt;&#x2F;Grid&gt;</span><br><span class="line"></span><br><span class="line">&lt;Grid&gt;</span><br><span class="line">  Hello</span><br><span class="line">  world!</span><br><span class="line">&lt;&#x2F;Grid&gt;</span><br><span class="line"></span><br><span class="line">&lt;Grid&gt;</span><br><span class="line"></span><br><span class="line">  Hello world!</span><br><span class="line">&lt;&#x2F;Grid&gt;</span><br></pre></td></tr></table></figure>
<p>你还可以很好地混合和搭配多种类型的子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">  Here is a row:</span><br><span class="line">  &lt;Row &#x2F;&gt;</span><br><span class="line">  Here is another row:</span><br><span class="line">  &lt;Row &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Grid&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/0AIrxKD.png"></p>
<h1 id="函数子组件"><a href="#函数子组件" class="headerlink" title="函数子组件"></a>函数子组件</h1><p>我们可以传递任何JavaScript表达式作为子组件，当然包括函数。</p>
<p>为了说明它看起来是什么样子，下面的组件渲染的就是一个传递给它的函数子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Executioner extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 请看我们如何调用一个函数子组件?</span><br><span class="line">    &#x2F;&#x2F;                        ↓</span><br><span class="line">    return this.props.children()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会像这样使用这个组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Executioner&gt;</span><br><span class="line">  &#123;() &#x3D;&gt; &lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;&#125;</span><br><span class="line">&lt;&#x2F;Executioner&gt;</span><br></pre></td></tr></table></figure>
<p>这个具体的例子当然没有什么用，但它说明了这个想法。</p>
<p>假设必须从服务器获取一些数据。你可能有多种方式做到这一点，但是通过下面的函数子组件也可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Fetch url&#x3D;&quot;api.myself.com&quot;&gt;</span><br><span class="line">  &#123;(result) &#x3D;&gt; &lt;p&gt;&#123;result&#125;&lt;&#x2F;p&gt;&#125;</span><br><span class="line">&lt;&#x2F;Fetch&gt;</span><br></pre></td></tr></table></figure>
<h1 id="操控子组件"><a href="#操控子组件" class="headerlink" title="操控子组件"></a>操控子组件</h1><p>如果你看过React的文档，你会发现它有说“子组件是一种不透明的数据结构”。他们本质上，是想告诉我们props.children可以是任意类型，比如数组、函数、对象等等，因为你可以传递任何内容，所以你永远也不能确定它。</p>
<p>React提供了一系列帮助函数，使操作子组件变得轻松和惬意。它们都在React.Children上适用。</p>
<h1 id="遍历子组件"><a href="#遍历子组件" class="headerlink" title="遍历子组件"></a>遍历子组件</h1><p>最明显的两个帮助类函数是<code>React.Children.map</code> 和 <code>React.Children.forEach</code>。它们和数组中的map及foreach工作完全相同，除了一点：当子组件是函数、对象或者任何内容时，它们仍能正常工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class IgnoreFirstChild extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const children &#x3D; this.props.children</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;React.Children.map(children, (child, i) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 忽略第一个子组件</span><br><span class="line">          if (i &lt; 1) return</span><br><span class="line">          return child</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>IgnoreFirstChild</code>组件遍历它所有的子组件，忽略掉第一个子组件，渲染剩余子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IgnoreFirstChild&gt;</span><br><span class="line">  &lt;h1&gt;First&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;h1&gt;Second&lt;&#x2F;h1&gt; &#x2F;&#x2F; &lt;- 只有这个被渲染</span><br><span class="line">&lt;&#x2F;IgnoreFirstChild&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/0iVe7O6.png"></p>
<p>在这种情况下，我们也可以使用<code>this.props.children.map</code>。但是，如果有人传进来一个函数子组件会发生什么？<code>this.props.children</code>将会是一个函数而不是数组，我们会看到一个报错！ 😱</p>
<p><img src="https://i.imgur.com/ovt61Qu.png"></p>
<p>然而使用<code>React.Children.map</code>函数，就不会发生这种问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IgnoreFirstChild&gt;</span><br><span class="line">  &#123;() &#x3D;&gt; &lt;h1&gt;First&lt;&#x2F;h1&gt;&#125; &#x2F;&#x2F; &lt;- 忽略掉 💪</span><br><span class="line">&lt;&#x2F;IgnoreFirstChild&gt;</span><br></pre></td></tr></table></figure>
<h1 id="统计子组件"><a href="#统计子组件" class="headerlink" title="统计子组件"></a>统计子组件</h1><p>由于<code>this.props.children</code>可以是任意类型，统计一个组件有多少子组件是一件很困难的事情。当传递的子组件是一个字符串或者函数时，使用<code>this.props.children.length</code>就会失效。比方说，我们有一个子组件，<code>&quot;Hello World!&quot;</code>，但是<code>.length</code>将会是12。</p>
<p>这就是为什么我们会有<code>React.Children.count</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChildrenCounter extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p&gt;React.Children.count(this.props.children)&lt;&#x2F;p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会返回子组件的数量，不管子组件的类型是什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Renders &quot;1&quot;</span><br><span class="line">&lt;ChildrenCounter&gt;</span><br><span class="line">  Second!</span><br><span class="line">&lt;&#x2F;ChildrenCounter&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Renders &quot;2&quot;</span><br><span class="line">&lt;ChildrenCounter&gt;</span><br><span class="line">  &lt;p&gt;First&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;ChildComponent &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;ChildrenCounter&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Renders &quot;3&quot;</span><br><span class="line">&lt;ChildrenCounter&gt;</span><br><span class="line">  &#123;() &#x3D;&gt; &lt;h1&gt;First!&lt;&#x2F;h1&gt;&#125;</span><br><span class="line">  Second!</span><br><span class="line">  &lt;p&gt;Third!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;ChildrenCounter&gt;</span><br></pre></td></tr></table></figure>
<h1 id="转换子组件为数组"><a href="#转换子组件为数组" class="headerlink" title="转换子组件为数组"></a>转换子组件为数组</h1><p>作为最后的手段，如果上面的方法都不满足你的的需求，你可以使用<code>React.Children.toArray</code>将你的子组件转换为一个数组。这将会很有用，如果你需要比方说将它们排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Sort extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const children &#x3D; React.Children.toArray(this.props.children)</span><br><span class="line">    &#x2F;&#x2F; 排序并渲染子组件</span><br><span class="line">    return &lt;p&gt;&#123;children.sort().join(&#39; &#39;)&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sort&gt;</span><br><span class="line">  &#x2F;&#x2F; 我们使用花括号来确保我们的字符串是作为三个子组件传入，</span><br><span class="line">  &#x2F;&#x2F; 而不是一个。</span><br><span class="line">  &#123;&#39;bananas&#39;&#125;&#123;&#39;oranges&#39;&#125;&#123;&#39;apples&#39;&#125;</span><br><span class="line">&lt;&#x2F;Sort&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子渲染出字符串，但是是排序后的：</p>
<p><img src="https://i.imgur.com/CvXLz2D.png"></p>
<h1 id="限制单一子组件"><a href="#限制单一子组件" class="headerlink" title="限制单一子组件"></a>限制单一子组件</h1><p>回想我们上面的<code>Executioner</code>组件，它只希望传递过来一个子组件，并且还必须是一个函数子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Executioner extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.props.children()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>proptypes</code>来控制，它看起来会像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Executioner.propTypes &#x3D; &#123;</span><br><span class="line">  children: React.PropTypes.func.isRequired,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将把信息记录到控制台，然而有些开发者可能会忽略掉这里的报警信息。因此，取而代之，我们可以在<code>render</code>方法中使用<code>React.Children.only</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Executioner extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return React.Children.only(this.props.children)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将返回<code>this.props.children</code>中唯一的子组件。如果多余一个子组件，它就会抛出一个错误，因此，可以降低我们应用变得不完美的风险，可以避免懒惰的开发者试图扰乱我们的组件。😎</p>
<h1 id="编辑子组件"><a href="#编辑子组件" class="headerlink" title="编辑子组件"></a>编辑子组件</h1><p>我们不仅可以通过子组件的方式，渲染任意组件，而且还可以通过父组件来控制它们，而不是在子组件内部。为了说明这点，假设我们有一个<code>RadioGroup</code>组件，这个组件中包含多个<code>RadioButton</code>组件（渲染一个单选框）。</p>
<p>这些<code>RadioButton</code>组件并不是在<code>RadioGroup</code>组件中渲染的，它们是作为子组件被渲染的。这意味着在我们应用的某个地方有这个组件的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;RadioGroup&gt;</span><br><span class="line">      &lt;RadioButton value&#x3D;&quot;first&quot;&gt;First&lt;&#x2F;RadioButton&gt;</span><br><span class="line">      &lt;RadioButton value&#x3D;&quot;second&quot;&gt;Second&lt;&#x2F;RadioButton&gt;</span><br><span class="line">      &lt;RadioButton value&#x3D;&quot;third&quot;&gt;Third&lt;&#x2F;RadioButton&gt;</span><br><span class="line">    &lt;&#x2F;RadioGroup&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里的代码有一个问题。这些<code>input</code>组件并没有被组合起来，这将会导致下面的结果：</p>
<p><img src="https://i.imgur.com/gwRdNAx.png"></p>
<p>要将<code>input</code>标签组合在一起，它们都需要具有相同的<code>name</code>属性。我们当然可以为每一个<code>RadioButton</code>组件指定一个<code>name</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;RadioGroup&gt;</span><br><span class="line">  &lt;RadioButton name&#x3D;&quot;g1&quot; value&#x3D;&quot;first&quot;&gt;First&lt;&#x2F;RadioButton&gt;</span><br><span class="line">  &lt;RadioButton name&#x3D;&quot;g1&quot; value&#x3D;&quot;second&quot;&gt;Second&lt;&#x2F;RadioButton&gt;</span><br><span class="line">  &lt;RadioButton name&#x3D;&quot;g1&quot; value&#x3D;&quot;third&quot;&gt;Third&lt;&#x2F;RadioButton&gt;</span><br><span class="line">&lt;&#x2F;RadioGroup&gt;</span><br></pre></td></tr></table></figure>
<p>但那是乏味和容易出错的。我们掌握了JavaScript的全部力量！我们能否使用它来告诉我们的<code>RadioGroup</code>组件，我们想要添加在所有子组件上的<code>name</code>属性，并让它自动添加呢？</p>
<p>改变子组件的属性<br>在<code>RadioGroup</code>组件中，我们将会增加一个新的叫<code>renderChildren</code>的方法，用这个方法，我们可以修改子组件的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RadioGroup extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    &#x2F;&#x2F; 将方法绑定到组件上下文</span><br><span class="line">    this.renderChildren &#x3D; this.renderChildren.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderChildren() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 修改所有子组件的name属性为this.props.name</span><br><span class="line">    return this.props.children</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;group&quot;&gt;</span><br><span class="line">        &#123;this.renderChildren()&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们以遍历所有的子组件，来获取到每一个单独的子组件开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">renderChildren() &#123;</span><br><span class="line">  return React.Children.map(this.props.children, child &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: 改变name属性为this.props.name</span><br><span class="line">    return child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而我们改如何编辑它们的属性呢？</p>
<h1 id="克隆元素"><a href="#克隆元素" class="headerlink" title="克隆元素"></a>克隆元素</h1><p>这就是今天最后一个帮助方法发挥作用的地方了。顾名思义，<code>React.cloneElement</code>会克隆一个元素。我们将要克隆的元素作为第一个参数传递给它，然后第二个参数，我们可以传递一个对象，这个对象中包含的就是我们希望在克隆元素上出现的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cloned &#x3D; React.cloneElement(element, &#123;</span><br><span class="line">  new: &#39;yes!&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个<code>cloned</code>元素现在就有了一个值为”yes!”的new属性。</p>
<p>这正是我们完成<code>RadioGroup</code>组件所需要的。我们克隆每一个子组件，并且把克隆子组件的<code>name</code>属性设置为<code>this.props.name</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">renderChildren() &#123;</span><br><span class="line">  return React.Children.map(this.props.children, child &#x3D;&gt; &#123;</span><br><span class="line">    return React.cloneElement(child, &#123;</span><br><span class="line">      name: this.props.name</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步是为<code>RadioGroup</code>组件设置一个唯一的<code>name</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;RadioGroup name&#x3D;&quot;g1&quot;&gt;</span><br><span class="line">  &lt;RadioButton value&#x3D;&quot;first&quot;&gt;First&lt;&#x2F;RadioButton&gt;</span><br><span class="line">  &lt;RadioButton value&#x3D;&quot;second&quot;&gt;Second&lt;&#x2F;RadioButton&gt;</span><br><span class="line">  &lt;RadioButton value&#x3D;&quot;third&quot;&gt;Third&lt;&#x2F;RadioButton&gt;</span><br><span class="line">&lt;&#x2F;RadioGroup&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/AwAip0N.png"></p>
<p>成功了！🎉 取代手动地去设置每一个<code>RadioButton</code>组件的<code>name</code>属性，我们只需要告诉<code>RadioGroup</code>组件我们想要的<code>name</code>属性值，它就会自动地去做好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>子组件使React组件看起来就像一系列的标记，而不是分割的个体。使用JavaScript和React的帮助类函数，我们可以创建声明类的API，让我们的开发更轻松。</p>
]]></content>
      <tags>
        <tag>react 组件 模块 javascript 框架 库</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 妙用Javascript中apply、call、bind</title>
    <url>/2017/07/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20%E5%A6%99%E7%94%A8Javascript%E4%B8%ADapply%E3%80%81call%E3%80%81bind/</url>
    <content><![CDATA[<blockquote>
<p>网上文章虽多，大多复制粘贴，且晦涩难懂，我希望能够通过这篇文章，能够清晰的提升对apply、call、bind的认识，并且列出一些它们的妙用加深记忆。</p>
</blockquote>
<a id="more"></a>

<h3 id="apply、call"><a href="#apply、call" class="headerlink" title="apply、call"></a>apply、call</h3><blockquote>
<p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
</blockquote>
<blockquote>
<p>先来一个栗子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fruits() &#123;&#125;</span><br><span class="line">fruits.prototype &#x3D; &#123;</span><br><span class="line">　　color: &quot;red&quot;,</span><br><span class="line">　　say: function() &#123;</span><br><span class="line">　　　　console.log(&quot;My color is &quot; + this.color);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">var apple &#x3D; new fruits;</span><br><span class="line">apple.say(); &#x2F;&#x2F;My color is red</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">banana &#x3D; &#123;</span><br><span class="line">　　color: &quot;yellow&quot;</span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana); &#x2F;&#x2F;My color is yellow</span><br><span class="line">apple.say.apply(banana); &#x2F;&#x2F;My color is yellow</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。</p>
</blockquote>
<h3 id="apply、call-的区别"><a href="#apply、call-的区别" class="headerlink" title="apply、call 的区别"></a>apply、call 的区别</h3><blockquote>
<p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func &#x3D; function(arg1, arg2) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就可以通过如下方式来调用：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func.call(this, arg1, arg2);</span><br><span class="line">func.apply(this, [arg1, arg2])</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</li>
<li>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。</li>
<li>而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。</li>
</ul>
<blockquote>
<p>为了巩固加深记忆，下面列举一些常用用法：</p>
</blockquote>
<ul>
<li>数组之间追加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array1 &#x3D; [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458]; </span><br><span class="line">var array2 &#x3D; [&quot;Doe&quot; , 555 , 100]; </span><br><span class="line">Array.prototype.push.apply(array1, array2); </span><br><span class="line">&#x2F;* array1 值为 [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] *&#x2F;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取数组中的最大值和最小值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var numbers &#x3D; [5, 458 , 120 , -215 ]; </span><br><span class="line">var maxInNumbers &#x3D; Math.max.apply(Math, numbers), &#x2F;&#x2F;458</span><br><span class="line"> maxInNumbers &#x3D; Math.max.call(Math,5, 458 , 120 , -215); &#x2F;&#x2F;458</span><br></pre></td></tr></table></figure>
<blockquote>
<p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p>
</blockquote>
<ul>
<li>验证是否是数组（前提是toString()方法没有被重写过）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">functionisArray(obj)&#123; </span><br><span class="line">　　return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39; ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类（伪）数组使用数组方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var domNodes &#x3D; Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。</p>
</blockquote>
<blockquote>
<p>但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p>
</blockquote>
<h3 id="深入理解运用apply、call"><a href="#深入理解运用apply、call" class="headerlink" title="深入理解运用apply、call"></a>深入理解运用apply、call</h3><blockquote>
<p>下面就借用一道面试题，来更深入的去理解下 apply 和 call 。<br>定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log(msg) &#123;</span><br><span class="line">　　console.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">log(1); &#x2F;&#x2F;1</span><br><span class="line">log(1,2); &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log()&#123;</span><br><span class="line">　　console.log.apply(console, arguments);</span><br><span class="line">&#125;;</span><br><span class="line">log(1); &#x2F;&#x2F;1</span><br><span class="line">log(1,2); &#x2F;&#x2F;1 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log(&quot;hello world&quot;); &#x2F;&#x2F;(app)hello world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log()&#123;</span><br><span class="line">　　var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">　　args.unshift(&#39;(app)&#39;); </span><br><span class="line">　　console.log.apply(console, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote>
<p>说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。<br>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">　　bar : 1,</span><br><span class="line">　　eventBind: function()&#123;</span><br><span class="line">　　　　var _this &#x3D; this;</span><br><span class="line">　　　　$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;</span><br><span class="line">　　　　　　console.log(_this.bar); &#x2F;&#x2F;1</span><br><span class="line">　　　　&#125;);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; &#123;</span><br><span class="line">　　bar : 1,</span><br><span class="line">　　eventBind: function()&#123;</span><br><span class="line">　　$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123;</span><br><span class="line">　　　　console.log(this.bar); &#x2F;&#x2F;1</span><br><span class="line">　　　　&#125;.bind(this));</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bar &#x3D; function()&#123;</span><br><span class="line">　　console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">　　x:3</span><br><span class="line">&#125;</span><br><span class="line">bar(); &#x2F;&#x2F; undefined</span><br><span class="line">var func &#x3D; bar.bind(foo);</span><br><span class="line">func(); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>
</blockquote>
<blockquote>
<p>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bar &#x3D; function()&#123;</span><br><span class="line">　　console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">　　x:3</span><br><span class="line">&#125;</span><br><span class="line">var sed &#x3D; &#123;</span><br><span class="line">　　x:4</span><br><span class="line">&#125;</span><br><span class="line">var func &#x3D; bar.bind(foo).bind(sed);</span><br><span class="line">func(); &#x2F;&#x2F;?</span><br><span class="line">var fiv &#x3D; &#123;</span><br><span class="line">　　x:5</span><br><span class="line">&#125;</span><br><span class="line">var func &#x3D; bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); &#x2F;&#x2F;?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p>
</blockquote>
<h3 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a>apply、call、bind比较</h3><blockquote>
<p>那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">　　x: 81,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">　　getX: function() &#123;</span><br><span class="line">　　　　return this.x;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">console.log(foo.getX.bind(obj)()); &#x2F;&#x2F;81</span><br><span class="line">console.log(foo.getX.call(obj)); &#x2F;&#x2F;81</span><br><span class="line">console.log(foo.getX.apply(obj)); &#x2F;&#x2F;81</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。<br>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p>
</blockquote>
<blockquote>
<p>再总结一下：</p>
</blockquote>
<ul>
<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>
<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>
<li>apply 、 call 、bind 三者都可以利用后续参数传参；</li>
<li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li>
</ul>
]]></content>
      <tags>
        <tag>javascript　js　深入浅出　apply　call　bind　this</tag>
      </tags>
  </entry>
  <entry>
    <title>用cssText批量修改样式</title>
    <url>/2017/07/29/%E7%94%A8cssText%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>一般情况下我们用js设置元素对象的样式会使用这样的形式：</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element&#x3D; document.getElementById(“id”);</span><br><span class="line">element.style.width&#x3D;”20px”;</span><br><span class="line">element.style.height&#x3D;”20px”;</span><br><span class="line">element.style.border&#x3D;”solid 1px red”;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。<br>js中有一个cssText的方法：<br>语法为：obj.style.cssText=”样式”;<br>上面的代码我们可以修改成：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.style.cssText&#x3D;”width:20px;height:20px;border:solid 1px red;”;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就可以尽量避免页面reflow，提高页面性能。</p>
</blockquote>
<blockquote>
<p>但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。<br>为了解决这个问题，可以采用cssText累加的方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.style.cssText +&#x3D; ‘width:100px;height:100px;top:100px;left:100px;’</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，<strong>cssText（假如不为空）在IE中最后一个分号会被删掉</strong>，比较BT….<br>因此，上面cssText累加的方法在IE中是无效的。<br>最后，可以在前面添加一个分号来解决这个问题：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.style.cssText +&#x3D; ‘;width:100px;height:100px;top:100px;left:100px;’</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>css cssText 批量 样式 修改 增加</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊ES5数组（Array）新增的那些方法</title>
    <url>/2017/08/14/%E8%81%8A%E4%B8%80%E8%81%8AES5%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89%E6%96%B0%E5%A2%9E%E7%9A%84%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天把ES5新增的一些数组的方法学习了一下，这个对于处理数据还是非常有用的。现在把自己的理解和心得记录下来，方便以后查阅。</p>
<p>ES5新增数组方法大致可以分为几类：</p>
<ul>
<li>索引方法：<code>indexOf()</code>和<code>lastIndexOf</code>；</li>
<li>迭代方法：<code>forEach()</code>、<code>map()</code>、<code>filter()</code>、<code>some()</code>、<code>every()</code>；</li>
<li>归并方法：<code>reduce()</code>和<code>reduceRight()</code>；</li>
</ul>
<p>↓↓↓↓↓↓↓↓↓↓↓↓该上代码啦↓↓↓↓↓↓↓↓↓↓↓↓</p>
<a id="more"></a>

<h1 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h1><p>索引方法包含indexOf()和lastIndexOf()两个方法，这两个方法都接收两个参数，第一个参数是要查找的项，第二个参数是查找起点位置的索引，该参数可选，如果缺省或是格式不正确，那么默认为0。两个方法都返回查找项在数组中的位置，如果没有找到，那么返回-1。<code>区别就是一个从前往后找，一个从后往前找。</code></p>
<p>先来看demo吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">console.log(arr.indexOf(7));  &#x2F;&#x2F;4</span><br><span class="line">console.log(arr.indexOf(4, 3)); &#x2F;&#x2F;3</span><br><span class="line">console.log(arr.lastIndexOf(6)); &#x2F;&#x2F;5</span><br><span class="line">console.log(arr.lastIndexOf(&#39;6&#39;)); &#x2F;&#x2F;-1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个demo纠结了半天，原因在于错认为<code>lastIndexOf方法</code>是从后往前找，所以理所当然的认为打印出来的索引也应该是从后往前的，后来查了资料才明白<code>indexOf()方法</code>和<code>lastIndexOf()方法</code>返回的位置都是从前开始计算索引的。<code>lastIndexOf()方法</code>第二个参数是起始位置，从后往前数的，但是在计算索引值的时候还是从前往后计算的。。算是踩了个坑，不过及时填上了。^-^</p>
</blockquote>
<h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><p>迭代方法包含<code>some()</code>、<code>every()</code>、<code>filter()</code>、<code>map()</code>和<code>forEach()</code>五个方法，这些方法都接收两个参数，第一个参数是一个函数，他接收三个参数，数组当前项的值、当前项在数组中的索引、数组对象本身。第二个参数是执行第一个函数参数的作用域对象，也就是上面说的函数中this所指向的值。<code>注意，这几种方法都不会改变原数组。</code></p>
<blockquote>
<p>every()方法和some()方法有些类似，前者是对数组中每一项执行指定方法，如果返回值都为真则返回true，有一个假就返回false；后者也是对数组中每一项执行指定方法，区别在于如果返回值有一个真就返回true，否则返回false。这让我想到了短路操作中的逻辑运算符&amp;&amp;和||了，有点那个意思吧。</p>
</blockquote>
<p>下面上demo了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">var res &#x3D; arr.every(function(v, i, arr) &#123;&#x2F;&#x2F;v当前项，i当前索引，arr原数组</span><br><span class="line">  return v &gt; 0 &amp;&amp; v &lt; 7;</span><br><span class="line">&#125;)</span><br><span class="line">var res2 &#x3D; arr.some(function(v, i, arr) &#123;</span><br><span class="line">  return v &gt; 6;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);  &#x2F;&#x2F;false</span><br><span class="line">console.log(res2);  &#x2F;true</span><br></pre></td></tr></table></figure>
<ul>
<li>而且值得注意的是，some方法会在数组中任一项执行函数返回true之后，不在进行循环。</li>
</ul>
<hr>
<blockquote>
<p>filter()方法对数组中每一项执行指定方法，生成返回值为true的新数组。利用这个方法可以对数组元素进行过滤筛选。</p>
</blockquote>
<ul>
<li>不过值得注意的是该方法支持的是弱等（==），而不是全等（===）。该上demo了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">var res3 &#x3D; arr.filter(function(v, i, arr) &#123;</span><br><span class="line">  return v &gt; &#39;3&#39;;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res3);  &#x2F;&#x2F;[4, 7, 6, 4]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map()方法对数组中的每一项执行指定方法，生成该方法返回值组成的新数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">var res4 &#x3D; arr.map(function(v, i, arr) &#123;</span><br><span class="line">  return v * i;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res4);  &#x2F;&#x2F;[0, 3, 2, 12, 28, 30, 24]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>forEach()方法对数组中的每一项执行指定方法，这个方法没有返回值。这个方法和for循环、jQuery中的each()方法一样。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">var res5 &#x3D; arr.forEach(function(v, i, arr) &#123;</span><br><span class="line">  console.log(v);  &#x2F;&#x2F;把原数组中每一项打印出来</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h1><p>归并方法包含reduce()和reduceRight()两个方法，这两个方法都会遍历数组中的每一项，然后生成一个最终的返回值。他们都接收两个参数，第一个参数的每一项调用的函数，<code>该函数接收4个参数：初始值，当前值，索引值和当前的数组</code>，函数的返回值会在下一次迭代中作为第一个参数也就是初始值。<code>第二个参数是迭代的初始值，参数可选</code>，如果缺省那么初始值为数组的第一项，缺省参数要比正常传值少一次运算。</p>
<blockquote>
<p>reduce()方法从数组的第一项开始，逐个遍历到最后一项，其中一个应用场景是数组求和或乘积。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [2, 3, 1, 4, 7, 6, 4];</span><br><span class="line">var res6 &#x3D; arr.reduce(function(prev, cur, index, arr) &#123;&#x2F;&#x2F;1.初始值，2.当前值，3.当前索引，4.原数组</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res6);  &#x2F;&#x2F;27</span><br><span class="line">var res7 &#x3D; arr.reduce(function(prev, cur, index, arr) &#123;&#x2F;&#x2F;1.初始值，2.当前值，3.当前索引，4.原数组</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;,5)</span><br><span class="line">console.log(res7);  &#x2F;&#x2F;32</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以看出，当设置了第二个参数。会把第二个参数作为初始值，参与方法的运算，这样会多执行一次。</li>
<li>利用这种方法可以快速的把二维数组转化为一维数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [[1,2],[3,4]];</span><br><span class="line">var newArr &#x3D; arr.reduce(function(prev, cur, index, arr)&#123;</span><br><span class="line">  return prev.concat(cur);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newArr);  &#x2F;&#x2F;[1,2,3,4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>refuceRight()方法就是从右到左，其他的和reduce()方法一样。</p>
</blockquote>
<h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><blockquote>
<p>ES5处理</p>
</blockquote>
<p>ES5里这些处理数组的新方法，在IE6-IE8浏览器还未得到支持，所以我们需要在IE这些低版本浏览器中引入这个es5-shim补丁，这样我们就可以使用它了。<a href="https://github.com/bingo-keith/es5-shim" title="补丁地址">https://github.com/bingo-keith/es5-shim</a></p>
]]></content>
      <tags>
        <tag>ES5 ECMAScript5 数组 Array 方法</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式和订阅发布模式是一样的吗？</title>
    <url>/2021/01/12/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E5%90%97%EF%BC%9F%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="观察者模式和订阅发布模式是一样的吗？"><a href="#观察者模式和订阅发布模式是一样的吗？" class="headerlink" title="观察者模式和订阅发布模式是一样的吗？"></a>观察者模式和订阅发布模式是一样的吗？</h2><p>看到一篇介绍关于观察者模式和订阅发布模式的区别的文章，看完后依然认为它们在概念和思想上是统一的，只是根据实现方式和使用场景的不同，叫法不一样，不过既然有区别，就来探究一番，加深理解。</p>
<a id="more"></a>

<p>先看图感受下两者表现出来的区别：</p>
<p><img src="https://i.loli.net/2021/01/12/BhV4MIkioQv7RGj.png" alt="watcher.png"></p>
<h3 id="两种模型概念"><a href="#两种模型概念" class="headerlink" title="两种模型概念"></a>两种模型概念</h3><p><strong>观察者模式</strong>的定义是在对象之间定义一个一对多的依赖，当对象自身状态改变的时候，会自动通知给关心该状态的观察者。</p>
<p>解决了主体对象与观察者之间功能的耦合，即一个对象状态改变给其他对象通知的问题。</p>
<p>这种对象与对象，有点像 <strong>商家-顾客</strong> 的关系，顾客对商家的某个商品感兴趣，就被商家记住，等有新品发布，便会直接通知顾客，相信加过微商微信会深有体会。</p>
<p>来张图直观感受：</p>
<p><img src="https://i.loli.net/2021/01/12/o6zbHi27aWTuEdp.png" alt="watcher2.png"></p>
<p>可以从图中看出来，这种模式是商家直接管理顾客。</p>
<p><strong>订阅发布模式</strong></p>
<p>该模式理解起来和观察者模式一样，也是定义一对多的依赖关系，对象状态改变后，通知给所有关心这个状态的订阅者。</p>
<p>订阅发布模式有订阅的动作，可以不和商家直接产生联系，只要能订阅上关心的状态即可，通常利用第三方媒介来做，而发布者也会利用三方媒介来通知订阅者。</p>
<p>这有点像 <strong>商家-APP-顾客</strong> 的关系，某个产品断货，顾客可以在APP上订阅上货通知，待上新，商家通过APP通知订阅的顾客。</p>
<p>在程序实现中，第三方媒介称之为 EventBus(事件总线)，可以理解为订阅事件的集合，它提供订阅、发布、取消等功能。订阅者订阅事件，和发布者发布事件，都通过事件总线进行交互。</p>
<p><img src="https://i.loli.net/2021/01/12/EVqbMzsGZxLImXD.png" alt="eventBus.png"></p>
<p><strong>两种模式的异同</strong></p>
<p>从概念上理解，两者没什么不同，都在解决对象之间解耦，通过事件的方式在某个时间点进行触发，监听这个事件的订阅者可以进行相应的操作。</p>
<p>在实现上有所不同，观察者模式对订阅事件的订阅者通过发布者自身来维护，后续的一些列操作都要通过发布者完成；订阅发布模式是订阅者和发布者中间会有一个事件总线，操作都要经过事件总线完成。</p>
<p>观察者模式的事件名称，通常由发布者指定发布的事件，当然也可以自定义，这样看是否提供自定义的功能。</p>
<p>在 <strong>DOM</strong> 中绑定事件，<strong>click、mouseover</strong> 这些，都是内置规定好的事件名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&#39;click&#39;,()&#x3D;&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>addEventListener</strong> 第一个参数就是绑定的时间名称；第二参数是一个函数，就是订阅者。</p>
<p>订阅发布模式的事件名称就比较随意，在事件总线中会维护一个事件对应的订阅者列表，当该事件触发时，会遍历列表通知所有的订阅者。</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 订阅</span><br><span class="line">EventBus.on(&#39;custom&#39;, () &#x3D;&gt; &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; 发布</span><br><span class="line">EventBus.emit(&#39;custom&#39;)</span><br></pre></td></tr></table></figure>
<p>事件名称为开发者自定义，当使用频繁时维护起来较为麻烦，尤其是改名字，多个对象或组件都要替换，通常会把事件名称在一个配置中统一管理。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>在 <strong>Javascript</strong> 中函数就是对象，订阅者对象可以直接由函数来充当，就跟绑定 <strong>DOM</strong> 使用的 <strong>addEventListener</strong> 方法，第二个参数就是订阅者，是一个函数。</p>
<p>我们从上面描述的概念中去实现 <strong>商家-顾客</strong>，这样可以更好的理解（或者迷糊）。</p>
<p>定义一个顾客类，需要有个方法，这个方法用来接收商家通知的消息，就跟顾客都留有手机号码一样，发布的消息都由手机来接收，顾客收消息的方式是统一的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 顾客</span><br><span class="line">class Customer &#123;</span><br><span class="line">  update(data)&#123;</span><br><span class="line">    console.log(&#39;拿到了数据&#39;, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义商家，商家提供订阅、取消订阅、发布功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 商家</span><br><span class="line">class Merchant &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.listeners &#x3D; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addListener(name, listener)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有，定义一个队列</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      this.listeners[name] &#x3D; []</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 放在队列中</span><br><span class="line">    this.listeners[name].push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">  removeListener(name, listener)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有队列，则不处理</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) return</span><br><span class="line">    &#x2F;&#x2F; 遍历队列，找到要移除的函数</span><br><span class="line">    const listeners &#x3D; this.listeners[name]</span><br><span class="line">    for(let i &#x3D; 0; i &lt; listeners.length; i++)&#123;</span><br><span class="line">      if(listeners[i] &#x3D;&#x3D;&#x3D; listener)&#123;</span><br><span class="line">        listeners.splice(i, 1)</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notifyListener(name, data)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有队列，则不处理</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) return</span><br><span class="line">    &#x2F;&#x2F; 遍历队列，依次执行函数</span><br><span class="line">    const listeners &#x3D; this.listeners[name]</span><br><span class="line">    for(let i &#x3D; 0; i &lt; listeners.length; i++)&#123;</span><br><span class="line">      if(typeof listeners[i] &#x3D;&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">        listeners[i].update(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 多名顾客</span><br><span class="line">const c1 &#x3D; new Customer()</span><br><span class="line">const c2 &#x3D; new Customer()</span><br><span class="line">const c3 &#x3D; new Customer()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 商家</span><br><span class="line">const m &#x3D; new Merchant()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 顾客订阅商家商品</span><br><span class="line">m.addListener(&#39;shoes&#39;, c1)</span><br><span class="line">m.addListener(&#39;shoes&#39;, c2)</span><br><span class="line">m.addListener(&#39;skirt&#39;, c3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 过了一天没来，取消订阅</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  m.removeListener(&#39;shoes&#39;, c2)</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 过了几天</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  m.notifyListener(&#39;shoes&#39;, &#39;来啊，购买啊&#39;)</span><br><span class="line">  m.notifyListener(&#39;skirt&#39;, &#39;降价了&#39;)</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>
<h4 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h4><p>订阅和发布的功能都在事件总线中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Observe &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.listeners &#x3D; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  on(name, fn)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有，定义一个队列</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      this.listeners[name] &#x3D; []</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 放在队列中</span><br><span class="line">    this.listeners[name].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  off(name, fn)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有队列，则不处理</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) return</span><br><span class="line">    &#x2F;&#x2F; 遍历队列，找到要移除的函数</span><br><span class="line">    const listeners &#x3D; this.listeners[name]</span><br><span class="line">    for(let i &#x3D; 0; i &lt; this.listeners.length; i++)&#123;</span><br><span class="line">      if(this.listeners[i] &#x3D;&#x3D;&#x3D; fn)&#123;</span><br><span class="line">        this.listeners.splice(i, 1)</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(name, data)&#123;</span><br><span class="line">    &#x2F;&#x2F; 事件没有队列，则不处理</span><br><span class="line">    if(this.listeners[name] &#x3D;&#x3D;&#x3D; undefined) return</span><br><span class="line">    &#x2F;&#x2F; 遍历队列，依次执行函数</span><br><span class="line">    const listenersEvent &#x3D; this.listeners[name]</span><br><span class="line">    for(let i &#x3D; 0; i &lt; listenersEvent.length; i++)&#123;</span><br><span class="line">      if(typeof listenersEvent[i] &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">        listenersEvent[i](data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const observe &#x3D; new Observe()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进行订阅</span><br><span class="line">observe.on(&#39;say&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;监听,拿到数据&#39;, data);</span><br><span class="line">&#125;)</span><br><span class="line">observe.on(&#39;say&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;监听2,拿到数据&#39;, data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发布</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  observe.emit(&#39;say&#39;, &#39;传过去数据啦&#39;)</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>
<p><strong>通过以上两种模式的实现上来看，观察者模式进一步抽象，能抽出公共代码就是事件总线，反过来说，如果一个对象要有观察者模式的功能，只需要继承事件总线。</strong></p>
<p><strong>node</strong> 中提供能了 <strong>events</strong> 模块可供我们灵活使用。</p>
<p>继承使用，都通过发布者调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;)</span><br><span class="line"></span><br><span class="line">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter()</span><br><span class="line"></span><br><span class="line">myEmitter.on(&#39;event&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;, data);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;, 1);</span><br></pre></td></tr></table></figure>
<p>直接使用，当做事件总线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;)</span><br><span class="line"></span><br><span class="line">const emitter &#x3D; new EventEmitter()</span><br><span class="line"></span><br><span class="line">emitter.on(&#39;custom&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;接收数据&#39;, data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">emitter.emit(&#39;custom&#39;, 2)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>观察者模式</strong>在很多场景中都在使用，除了上述中在 <strong>DOM</strong> 上监听事件外，还有最常用的是 <strong>Vue</strong> 组件中父子之间的通信。</p>
<p>父级代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父级&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;Child @custom&#x3D;&quot;customHandler&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      customHandler(data)&#123;</span><br><span class="line">        console.log(&#39;拿到数据，我要干点事&#39;, data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>子级代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;子级&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;clickHandler&quot;&gt;改变了&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickHandler()&#123;</span><br><span class="line">        this.$emit(&#39;custome&#39;, 123)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>子组件是一个通用的组件，内部不做业务逻辑处理，仅仅在点击时会发布一个自定义的事件 <strong>custom</strong>。子组件被使用在页面的任意地方，在不同的使用场景里，当点击按钮后子组件所在的场景会做相应的业务处理。如果关心子组件内部按钮点击这个状态的改变，只需要监听 <strong>custom</strong> 自定义事件。</p>
<p><strong>订阅发布模式</strong>在用 <strong>Vue</strong> 写业务也会使用到，应用场景是在跨多层组件通信时，如果利用父子组件通信一层层订阅发布，可维护性和灵活性很差，一旦中间某个环节出问题，整个传播链路就会瘫痪。这时采用独立出来的 <strong>EventBus</strong> 解决这类问题，只要能访问到 <strong>EventBus</strong> 对象，便可通过该对象订阅和发布事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; EventBus.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export default const EventBus &#x3D; new Vue()</span><br></pre></td></tr></table></figure>
<p>父级代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父级&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;Child&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import EventBus from &#39;.&#x2F;EventBus&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    &#x2F;&#x2F; 加载完就要监控</span><br><span class="line">    moutend()&#123;</span><br><span class="line">      EventBus.on(&#39;custom&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;拿到数据&#39;, data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;嵌套很深的子级&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;clickHandler&quot;&gt;改变了&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import EventBus from &#39;.&#x2F;EventBus&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickHandler()&#123;</span><br><span class="line">        EventBus.emit(&#39;custom&#39;, 123)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看出来订阅发布模式完全解耦两个组件，互相可以不知道对方的存在，只需要在恰当的时机订阅或发布自定义事件。</p>
<h4 id="订阅发布模式在-Vue2-源码中的使用"><a href="#订阅发布模式在-Vue2-源码中的使用" class="headerlink" title="订阅发布模式在 Vue2 源码中的使用"></a>订阅发布模式在 Vue2 源码中的使用</h4><p><strong>Vue2</strong> 中会通过拦截数据的获取进行依赖收集，收集的是一个个 <strong>Watcher</strong>。等待对数据进行变更时，要通知依赖的 <strong>Watcher</strong> 进行组件更新。可以通过一张图看到这个收集和通知过程。</p>
<p><img src="https://i.loli.net/2021/01/12/zr9OU6MV5WlgICn.png" alt="vue.png"></p>
<p>这些依赖存在了定义的 <strong>Dep</strong> 中，在这个类中实现了简单的订阅和发布功能，可以看做是一个 <strong>EventBus</strong>，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id &#x3D; uid++</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    &#x2F;&#x2F; stabilize the subscriber list first</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 <strong>Wather</strong> 就是订阅者，这些订阅者都实现一个叫做 <strong>update</strong> 的方法，当数据更改时便会遍历所有的 <strong>Wather</strong> 调用 <strong>update</strong> 方法。</p>
<p><strong>总结</strong></p>
<p>通过上述的表述，相信你对观察者模式和订阅发布模式有了重新的认识，可以说二者是相同的，它们的概念和解决的问题是一样的，致力于让两个对象解耦，只是叫法不一样；也可以说二者不一样，在使用方式和场景中不一样。</p>
]]></content>
      <tags>
        <tag>设计模式 观察者 订阅 发布 javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>这些高阶的函数技术，你掌握了么</title>
    <url>/2020/11/23/%E8%BF%99%E4%BA%9B%E9%AB%98%E9%98%B6%E7%9A%84%E5%87%BD%E6%95%B0%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%A0%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B9%88/</url>
    <content><![CDATA[<p>在 JavaScript 中，函数为一等公民（First Class），所谓的 “一等公民”，指的是函数与其他数据类型一样，处于平等地位，<strong>可以赋值给其他变量，也可以作为参数，传入另一个函数，或作为其它函数的返回值</strong>。</p>
<p><img src="https://i.loli.net/2021/01/11/XCID9RSUMHpf1gb.jpg"></p>
<p>接下来阿宝哥将介绍与函数相关的一些技术，阅读完本文，你将了解高阶函数、函数组合、柯里化、偏函数、惰性函数和缓存函数的相关知识。</p>
<a id="more"></a>

<h3 id="一、高阶函数"><a href="#一、高阶函数" class="headerlink" title="一、高阶函数"></a>一、高阶函数</h3><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p>
<ul>
<li>接受一个或多个函数作为输入；</li>
<li>输出一个函数。</li>
</ul>
<p>接收一个或多个函数作为输入，即函数作为参数传递。这种应用场景，相信很多人都不会陌生。比如常用的 <code>Array.prototype.map()</code> 和 <code>Array.prototype.filter()</code> 高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.map 高阶函数</span><br><span class="line">const array &#x3D; [1, 2, 3, 4];</span><br><span class="line">const map &#x3D; array.map(x &#x3D;&gt; x * 2); &#x2F;&#x2F; [2, 4, 6, 8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.filter 高阶函数</span><br><span class="line">const words &#x3D; [&#39;semlinker&#39;, &#39;kakuqo&#39;, &#39;lolo&#39;, &#39;abao&#39;];</span><br><span class="line">const result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 5); &#x2F;&#x2F; [&quot;semlinker&quot;, &quot;kakuqo&quot;]</span><br></pre></td></tr></table></figure>
<p>而输出一个函数，即调用高阶函数之后，会返回一个新的函数。我们日常工作中，常见的 <code>debounce</code> 和 <code>throttle</code> 函数就满足这个条件，因此它们也可以被称为高阶函数。</p>
<p><img src="https://i.loli.net/2021/01/11/VqJ4xpiZL6tzITh.jpg" alt="3293037746-a910317f8e79a938_articlex"></p>
<h3 id="二、函数组合"><a href="#二、函数组合" class="headerlink" title="二、函数组合"></a>二、函数组合</h3><p>函数组合就是将两个或两个以上的函数组合生成一个新函数的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compose &#x3D; function (f, g) &#123;</span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，<code>f</code> 和 <code>g</code> 都是函数，而 <code>x</code> 是组合生成新函数的参数。</p>
<h4 id="2-1-函数组合的作用"><a href="#2-1-函数组合的作用" class="headerlink" title="2.1 函数组合的作用"></a>2.1 函数组合的作用</h4><p>在项目开发过程中，为了实现函数的复用，我们通常会尽量保证函数的职责单一，比如我们定义了以下功能函数：</p>
<p><img src="https://i.loli.net/2021/01/11/nkDmPMZKs8RrbBj.jpg" alt="2154399478-b67021012a25e8a8_articlex"></p>
<p>在拥有以上功能函数的基础上，我们就可以自由地对函数进行组合，来实现特定的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function lowerCase(input) &#123;</span><br><span class="line">  return input &amp;&amp; typeof input &#x3D;&#x3D;&#x3D; &quot;string&quot; ? input.toLowerCase() : input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upperCase(input) &#123;</span><br><span class="line">  return input &amp;&amp; typeof input &#x3D;&#x3D;&#x3D; &quot;string&quot; ? input.toUpperCase() : input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function trim(input) &#123;</span><br><span class="line">  return typeof input &#x3D;&#x3D;&#x3D; &quot;string&quot; ? input.trim() : input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function split(input, delimiter &#x3D; &quot;,&quot;) &#123;</span><br><span class="line">  return typeof input &#x3D;&#x3D;&#x3D; &quot;string&quot; ? input.split(delimiter) : input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const trimLowerCaseAndSplit &#x3D; compose(trim, lowerCase, split);</span><br><span class="line">trimLowerCaseAndSplit(&quot; a,B,C &quot;); &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p>在以上的代码中，我们通过 <code>compose</code> 函数实现了一个 <code>trimLowerCaseAndSplit</code> 函数，该函数会对输入的字符串，先执行去空格处理，然后在把字符串中包含的字母统一转换为小写，最后在使用 <code>,</code> 分号对字符串进行拆分。利用函数组合的技术，我们就可以很方便的实现一个 <code>trimUpperCaseAndSplit</code> 函数。</p>
<h4 id="2-2-组合函数的实现"><a href="#2-2-组合函数的实现" class="headerlink" title="2.2 组合函数的实现"></a>2.2 组合函数的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(...funcs) &#123;</span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return funcs.reduce(function (arg, fn) &#123;</span><br><span class="line">      return fn(arg);</span><br><span class="line">    &#125;, x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上的代码中，我们通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce</a> 方法来实现组合函数的调度，对应的执行顺序是从左到右。这个执行顺序与 Linux 管道或过滤器的执行顺序是一致的。</p>
<p><img src="https://i.loli.net/2021/01/11/1l9vUHITjZEBoAM.jpg" alt="3124264727-3218e147ff39e19c_articlex"></p>
<p>不过如果你想从右往左开始执行的话，这时你就可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight">Array.prototype.reduceRight</a> 方法来实现。</p>
<p>其实每当看到 <code>compose</code> 函数，阿宝哥就情不自禁想到 <a href="https://mp.weixin.qq.com/s/wA2REzDU1R4tDs-N2REjZA">“如何更好地理解中间件和洋葱模型”</a> 这篇文章中介绍的 <code>compose</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function compose(middleware) &#123;</span><br><span class="line">  &#x2F;&#x2F; 省略部分代码</span><br><span class="line">  return function (context, next) &#123;</span><br><span class="line">    let index &#x3D; -1;</span><br><span class="line">    return dispatch(0);</span><br><span class="line">    function dispatch(i) &#123;</span><br><span class="line">      if (i &lt;&#x3D; index)</span><br><span class="line">        return Promise.reject(new Error(&quot;next() called multiple times&quot;));</span><br><span class="line">      index &#x3D; i;</span><br><span class="line">      let fn &#x3D; middleware[i];</span><br><span class="line">      if (i &#x3D;&#x3D;&#x3D; middleware.length) fn &#x3D; next;</span><br><span class="line">      if (!fn) return Promise.resolve();</span><br><span class="line">      try &#123;</span><br><span class="line">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用上述的 <code>compose</code> 函数，我们就可以实现以下通用的任务处理流程：</p>
<p><img src="https://i.loli.net/2021/01/11/JuqL1vnwhHXm7Of.jpg" alt="1123279384-19a89c5072b65d3c_articlex"></p>
<h3 id="三、柯里化"><a href="#三、柯里化" class="headerlink" title="三、柯里化"></a>三、柯里化</h3><p>柯里化（Currying）是一种处理函数中含有多个参数的方法，并在只允许单一参数的框架中使用这些函数。这种转变是现在被称为 “柯里化” 的过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数。当接收足够的参数后，会自动执行原函数。</p>
<p><strong>在理论计算机科学中，柯里化提供了简单的理论模型，比如：在只接受一个单一参数的 lambda 演算中，研究带有多个参数的函数的方式</strong>。与柯里化相反的是 Uncurrying，一种使用匿名单参数函数来实现多参数函数的方法。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const func &#x3D; function(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a * a + b * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(3)(4); &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>
<p>Uncurrying 不是本文的重点，接下来我们使用 <a href="https://lodash.com/">Lodash</a> 提供的 <code>curry</code> 函数来直观感受一下，对函数进行 “柯里化” 处理之后产生的变化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const abc &#x3D; function(a, b, c) &#123;</span><br><span class="line">  return [a, b, c];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const curried &#x3D; _.curry(abc);</span><br><span class="line"> </span><br><span class="line">curried(1)(2)(3); &#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</span><br><span class="line">curried(1, 2)(3); &#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</span><br><span class="line">curried(1, 2, 3); &#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>_.curry(func, [arity=func.length])</p>
<p>创建一个函数，该函数接收 <code>func</code> 的参数，要么调用<code>func</code>返回的结果，如果 <code>func</code> 所需参数已经提供，则直接返回 <code>func</code> 所执行的结果。或返回一个函数，接受余下的<code>func</code> 参数的函数，可以使用 <code>func.length</code> 设置需要累积的参数个数。</p>
<p>来源：<a href="https://www.lodashjs.com/docs/lodash.curry">https://www.lodashjs.com/docs…</a></p>
</blockquote>
<p><strong>这里需要特别注意的是，在数学和理论计算机科学中的柯里化函数，一次只能传递一个参数。而对于 JavaScript 语言来说，在实际应用中的柯里化函数，可以传递一个或多个参数</strong>。好的，介绍完柯里化的相关知识，接下来我们来介绍柯里化的作用。</p>
<h4 id="3-1-柯里化的作用"><a href="#3-1-柯里化的作用" class="headerlink" title="3.1 柯里化的作用"></a>3.1 柯里化的作用</h4><h5 id="3-1-1-参数复用"><a href="#3-1-1-参数复用" class="headerlink" title="3.1.1 参数复用"></a>3.1.1 参数复用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildUri(scheme, domain, path) &#123;</span><br><span class="line">  return &#96;$&#123;scheme&#125;:&#x2F;&#x2F;$&#123;domain&#125;&#x2F;$&#123;path&#125;&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const profilePath &#x3D; buildUri(&quot;https&quot;, &quot;github.com&quot;, &quot;semlinker&#x2F;semlinker&quot;);</span><br><span class="line">const awesomeTsPath &#x3D; buildUri(&quot;https&quot;, &quot;github.com&quot;, &quot;semlinker&#x2F;awesome-typescript&quot;);</span><br></pre></td></tr></table></figure>
<p>在以上代码中，首先我们定义了一个 <code>buildUri</code> 函数，该函数可用于构建 uri 地址。接着我们使用 <code>buildUri</code> 函数构建了阿宝哥 <a href="https://github.com/semlinker/semlinker">Github 个人主页</a> 和 <a href="https://github.com/semlinker/awesome-typescript">awesome-typescript</a> 项目的地址。对于上述的 uri 地址，我们发现 <code>https</code> 和 <code>github.com</code> 这两个参数值是一样的。</p>
<p>假如我们需要继续构建阿宝哥其他项目的地址，我们就需要重复设置相同的参数值。那么有没有办法简化这个流程呢？答案是有的，就是对 <code>buildUri</code> 函数执行柯里化处理，具体处理方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const _ &#x3D; require(&quot;lodash&quot;);</span><br><span class="line"></span><br><span class="line">const buildUriCurry &#x3D; _.curry(buildUri);</span><br><span class="line">const myGithubPath &#x3D; buildUriCurry(&quot;https&quot;, &quot;github.com&quot;);</span><br><span class="line">const profilePath &#x3D; myGithubPath(&quot;semlinker&#x2F;semlinker&quot;);</span><br><span class="line">const awesomeTsPath &#x3D; myGithubPath(&quot;semlinker&#x2F;awesome-typescript&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-延迟计算-运行"><a href="#3-1-2-延迟计算-运行" class="headerlink" title="3.1.2 延迟计算/运行"></a>3.1.2 延迟计算/运行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const add &#x3D; function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const curried &#x3D; _.curry(add);</span><br><span class="line">const plusOne &#x3D; curried(1);</span><br></pre></td></tr></table></figure>
<p>在以上代码中，通过对 <code>add</code> 函数执行 “柯里化” 处理，我们可以实现延迟计算。好的，简单介绍完柯里化的作用，我们来动手实现一个柯里化函数。</p>
<h4 id="3-2-柯里化的实现"><a href="#3-2-柯里化的实现" class="headerlink" title="3.2 柯里化的实现"></a>3.2 柯里化的实现</h4><p>现在我们已经知道了，当柯里化后的函数接收到足够的参数后，就会开始执行原函数。而如果接收到的参数不足的话，就会返回一个新的函数，用来接收余下的参数。基于上述的特点，我们就可以自己实现一个 <code>curry</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry(func) &#123;</span><br><span class="line">  return function curried(...args) &#123;</span><br><span class="line">    if (args.length &gt;&#x3D; func.length) &#123; &#x2F;&#x2F; 通过函数的length属性，来获取函数的形参个数</span><br><span class="line">      return func.apply(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return function (...args2) &#123;</span><br><span class="line">        return curried.apply(this, args.concat(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、偏函数应用"><a href="#四、偏函数应用" class="headerlink" title="四、偏函数应用"></a>四、偏函数应用</h3><p>在计算机科学中，偏函数应用（Partial Application）是指固定一个函数的某些参数，然后产生另一个更小元的函数。而所谓的元是指函数参数的个数，比如含有一个参数的函数被称为一元函数。</p>
<p>偏函数应用（Partial Application）很容易与函数柯里化混淆，它们之间的区别是：</p>
<ul>
<li>偏函数应用是固定一个函数的一个或多个参数，并返回一个可以接收剩余参数的函数；</li>
<li>柯里化是将函数转化为多个嵌套的一元函数，也就是每个函数只接收一个参数。</li>
</ul>
<p>了解完偏函数与柯里化的区别之后，我们来使用 <a href="https://lodash.com/">Lodash</a> 提供的 <code>partial</code> 函数来了解一下它如何使用。</p>
<h4 id="4-1-偏函数的使用"><a href="#4-1-偏函数的使用" class="headerlink" title="4.1 偏函数的使用"></a>4.1 偏函数的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function buildUri(scheme, domain, path) &#123;</span><br><span class="line">  return &#96;$&#123;scheme&#125;:&#x2F;&#x2F;$&#123;domain&#125;&#x2F;$&#123;path&#125;&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myGithubPath &#x3D; _.partial(buildUri, &quot;https&quot;, &quot;github.com&quot;);</span><br><span class="line">const profilePath &#x3D; myGithubPath(&quot;semlinker&#x2F;semlinker&quot;);</span><br><span class="line">const awesomeTsPath &#x3D; myGithubPath(&quot;semlinker&#x2F;awesome-typescript&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>_.partial(func, [partials])</p>
<p>创建一个函数。 该函数调用 <code>func</code>，并传入预设的 <code>partials</code> 参数。</p>
<p>来源：<a href="https://www.lodashjs.com/docs/lodash.partial">https://www.lodashjs.com/docs…</a></p>
</blockquote>
<h4 id="4-2-偏函数的实现"><a href="#4-2-偏函数的实现" class="headerlink" title="4.2 偏函数的实现"></a>4.2 偏函数的实现</h4><p>偏函数用于固定一个函数的一个或多个参数，并返回一个可以接收剩余参数的函数。基于上述的特点，我们就可以自己实现一个 <code>partial</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function partial(fn) &#123;</span><br><span class="line">  let args &#x3D; [].slice.call(arguments, 1);</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const newArgs &#x3D; args.concat([].slice.call(arguments));</span><br><span class="line">    return fn.apply(this, newArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-偏函数实现-vs-柯里化实现"><a href="#4-3-偏函数实现-vs-柯里化实现" class="headerlink" title="4.3 偏函数实现 vs 柯里化实现"></a>4.3 偏函数实现 vs 柯里化实现</h4><p><img src="https://i.loli.net/2021/01/11/vLcfQSoWJ1BpehD.jpg" alt="4208752765-1bb57ade66c2c444_articlex"></p>
<h3 id="五、惰性函数"><a href="#五、惰性函数" class="headerlink" title="五、惰性函数"></a>五、惰性函数</h3><p>由于不同浏览器之间存在一些兼容性问题，这导致了我们在使用一些 Web API 时，需要进行判断，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addHandler(element, type, handler) &#123;</span><br><span class="line">  if (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(type, handler, false);</span><br><span class="line">  &#125; else if (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    element[&quot;on&quot; + type] &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们实现了不同浏览器 <strong>添加事件监听</strong> 的处理。代码实现起来也很简单，但存在一个问题，即每次调用的时候都需要进行判断，很明显这是不合理的。对于上述这个问题，我们可以通过惰性载入函数来解决。</p>
<h4 id="5-1-惰性载入函数"><a href="#5-1-惰性载入函数" class="headerlink" title="5.1 惰性载入函数"></a>5.1 惰性载入函数</h4><p>所谓的惰性载入就是当第 1 次根据条件执行函数后，在第 2 次调用函数时，就不再检测条件，直接执行函数。要实现这个功能，我们可以在第 1 次条件判断的时候，在满足判断条件的分支中覆盖掉所调用的函数，具体的实现方式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addHandler(element, type, handler) &#123;</span><br><span class="line">  if (element.addEventListener) &#123;</span><br><span class="line">    addHandler &#x3D; function (element, type, handler) &#123;</span><br><span class="line">      element.addEventListener(type, handler, false);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else if (element.attachEvent) &#123;</span><br><span class="line">    addHandler &#x3D; function (element, type, handler) &#123;</span><br><span class="line">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    addHandler &#x3D; function (element, type, handler) &#123;</span><br><span class="line">      element[&quot;on&quot; + type] &#x3D; handler;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 保证首次调用能正常执行监听</span><br><span class="line">  return addHandler(element, type, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用以上的方式，我们也可以利用自执行函数来实现惰性载入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const addHandler &#x3D; (function () &#123;</span><br><span class="line">  if (document.addEventListener) &#123;</span><br><span class="line">    return function (element, type, handler) &#123;</span><br><span class="line">      element.addEventListener(type, handler, false);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else if (document.attachEvent) &#123;</span><br><span class="line">    return function (element, type, handler) &#123;</span><br><span class="line">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function (element, type, handler) &#123;</span><br><span class="line">      element[&quot;on&quot; + type] &#x3D; handler;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>通过自执行函数，在代码加载阶段就会执行一次条件判断，然后在对应的条件分支中返回一个新的函数，用来实现对应的处理逻辑。</p>
<h3 id="六、缓存函数"><a href="#六、缓存函数" class="headerlink" title="六、缓存函数"></a>六、缓存函数</h3><p>缓存函数是将函数的计算结果缓存起来，当下次以同样的参数调用该函数时，直接返回已缓存的结果，而无需再次执行函数。这是一种常见的以空间换时间的性能优化手段。</p>
<p>要实现缓存函数的功能，我们可以把经过序列化的参数作为 <code>key</code>，在把第 1 次调用后的结果作为 <code>value</code> 存储到对象中。在每次执行函数调用前，都先判断缓存中是否含有对应的 <code>key</code>，如果有的话，直接返回该 <code>key</code> 对应的值。分析完缓存函数的实现思路之后，接下来我们来看一下具体如何实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function memorize(fn) &#123;</span><br><span class="line">  const cache &#x3D; Object.create(null); &#x2F;&#x2F; 存储缓存数据的对象</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    const _args &#x3D; JSON.stringify(args);</span><br><span class="line">    return cache[_args] || (cache[_args] &#x3D; fn.apply(fn, args));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义完 <code>memorize</code> 缓存函数之后，我们就可以这样来使用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let complexCalc &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行复杂的计算</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let memoCalc &#x3D; memorize(complexCalc);</span><br><span class="line">memoCalc(666, 888);</span><br><span class="line">memoCalc(666, 888); &#x2F;&#x2F; 从缓存中获取</span><br></pre></td></tr></table></figure>
<h3 id="七、参考资源"><a href="#七、参考资源" class="headerlink" title="七、参考资源"></a>七、参考资源</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">维基百科 - 高阶函数</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">维基百科 - 柯里化</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/javascript-functional-programming-explained-partial-application-and-currying">javascript-functional-programming-explained-partial-application-and-currying</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript 函数 高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：说说你对JavaScript中事件循环的理解</title>
    <url>/2021/04/16/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9JavaScript%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/04/16/jcTO7aIvdwD5z9e.png" alt="1"></p>
<a id="more"></a>

<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>JavaScript</code> 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p>
<p>为什么要这么设计，跟<code>JavaScript</code>的应用场景有关</p>
<p><code>JavaScript</code> 初期作为一门浏览器脚本语言，通常用于操作 <code>DOM</code> ，如果是多线程，一个线程进行了删除 <code>DOM</code> ，另一个添加 <code>DOM</code>，此时浏览器该如何处理？</p>
<p>为了解决单线程运行阻塞问题，<code>JavaScript</code>用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p>
<h4 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h4><p>在<code>JavaScript</code>中，所有的任务都可以分为</p>
<p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p>
<p>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</p>
<p>同步任务与异步任务的运行流程图如下：</p>
<p><img src="https://i.loli.net/2021/04/16/mPVI6EB4a5WMfLu.png" alt="2"></p>
<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环</p>
<h2 id="二、宏任务与微任务"><a href="#二、宏任务与微任务" class="headerlink" title="二、宏任务与微任务"></a>二、宏任务与微任务</h2><p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>
<ul>
<li>console.log(1)，同步任务，主线程中执行</li>
<li>setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中</li>
<li>new Promise ，同步任务，主线程直接执行</li>
<li>.then ，异步任务，放到 Event Table</li>
<li>console.log(3)，同步任务，主线程执行</li>
</ul>
<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>&#39;new Promise&#39;</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>&#39;then&#39;</code></p>
<p>但是实际结果是：<code>1</code>=&gt;<code>&#39;new Promise&#39;</code>=&gt; <code>3</code> =&gt; <code>&#39;then&#39;</code> =&gt; <code>2</code></p>
<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>
<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>
<p>原因在于异步任务还可以细分为微任务与宏任务</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout/setInterval</li>
<li>UI rendering/UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I/O（Node.js）</li>
</ul>
<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>
<p><img src="https://i.loli.net/2021/04/16/xNe7sqVIoSJu9lZ.png" alt="3"></p>
<p>按照这个流程，它的执行机制是：</p>
<ul>
<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>
<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>
</ul>
<p>回到上面的题目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>流程如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到定时器，属于新的宏任务，留着后面执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>
<p>三、async与await</p>
<p><code>async</code> 是异步的意思，<code>await</code>则可以理解为等待</p>
<p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asyncF is equivalent to f!</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>
<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>
<h2 id="四、流程分析"><a href="#四、流程分析" class="headerlink" title="四、流程分析"></a>四、流程分析</h2><p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>
<p>这里直接上代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>分析过程：</p>
<ol>
<li>执行整段代码，遇到 console.log(‘script start’) 直接打印结果，输出 script start</li>
<li>遇到定时器了，它是宏任务，先放着不执行</li>
<li>遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>
<li>跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行</li>
<li>最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end</li>
<li>继续执行下一个微任务，即执行 then 的回调，打印 promise2</li>
<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout</li>
</ol>
<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>
]]></content>
      <tags>
        <tag>JavaScript 事件循环 面试</tag>
      </tags>
  </entry>
  <entry>
    <title>高质量的缺陷分析：让自己少写 bug</title>
    <url>/2020/11/11/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E7%BC%BA%E9%99%B7%E5%88%86%E6%9E%90%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E5%B0%91%E5%86%99%20bug/</url>
    <content><![CDATA[<p><strong>简介：</strong> 缺陷分析做得好，bug 写得少。阿里资深技术专家和你分享如何进行高质量的缺陷分析，总结了 5 个要点，通过缺陷分析消除开发中的各种盲点，打造一个学习型的团队。</p>
<p>作者 | 嵩华</p>
<blockquote>
<p><strong>导读</strong>：缺陷分析做得好，bug 写得少。阿里资深技术专家和你分享如何进行高质量的缺陷分析，总结了 5 个要点，通过缺陷分析消除开发中的各种盲点，打造一个学习型的团队。</p>
</blockquote>
<a id="more"></a>

<hr>
<ol>
<li><p>软件开发中的缺陷隐含着极高的价值，但是许多组织都仅仅忍受了缺陷带来的成本和后果，却让价值白白溜掉了。</p>
<p>缺陷的价值是其触发的学习和成长的机会。把握缺陷带来的学习机会，可以快速提高组织的能力，未来的缺陷更少，成本更低，更容易成功。但同时，有效的缺陷分析和跟踪行动需要有效的方法和相应的组织的支持。</p>
<h2 id="缺陷隐含着极高的价值"><a href="#缺陷隐含着极高的价值" class="headerlink" title="缺陷隐含着极高的价值"></a>缺陷隐含着极高的价值</h2><p>最近我们做了一次关于缺陷分析的工作坊。</p>
<blockquote>
<p>“发生缺陷是一件好事吗？” 在工作坊开始的时候，我这么问参与的同学。<br>“那当然是一件坏事了。”<br>“不管是不是好事，它就在那儿。我觉得无所谓好不好，这是一件正常的事情。”<br> “这么说好像也对，但是缺陷很麻烦，我没法喜欢缺陷。”</p>
</blockquote>
<p>是的，没有人喜欢缺陷，它消耗研发成本，影响开发周期，但同时，缺陷又和软件开发如影随形，无论多少，始终都在。这是为什么呢？</p>
<p>看下面的这张图：</p>
</li>
</ol>
<p>   软件开发是消除不确定性的过程</p>
<p>   软件开发和工业生产完全不同。工业生产通过消除过程中的各种可变性，能够逐步逼近零缺陷的目标。所以，六西格玛方法在工业生产中非常行之有效。</p>
<p>   软件开发的过程则恰恰相反。每一次开发，都是不确定的，我们往往都是在项目临近结束的时候，对整个项目的各种问题和细节才变得清晰。在这种假设下，与其追求零缺陷，倒不如说是我们应该追求降低缺陷的影响，比如，在缺陷产生的第一时间（注入时间甚至注入之前）就发现缺陷——因为这时候缺陷的成本几乎为零，这也就可以等价为“零缺陷”了吧。</p>
<p>   如果说工业生产中的六西格玛方法来自于对生产系统的打造，那么，在软件开发中，“零缺陷”对应的系统是什么呢？它当然包含软件研发的流程和工具，但是，在我看来，最重要的，应该是打造软件的核心主体——人。通过缺陷分析来持续学习，才能不浪费缺陷所消耗的成本。</p>
<h2 id="为什么会重复踩坑"><a href="#为什么会重复踩坑" class="headerlink" title="为什么会重复踩坑"></a>为什么会重复踩坑</h2><p>   有不少团队是有缺陷原因分析的。我曾经仔细分析过一个团队的缺陷原因分析，发现了下面这些缺陷原因的高频词：</p>
<ul>
<li><p>编码有问题，下次写代码的时候想的更仔细一些。</p>
</li>
<li><p>代码评审做的不好。下次代码评审要充分。</p>
</li>
<li><p>业务场景分析不全面，下次分析的更全面一些。</p>
</li>
<li><p>……</p>
<p>我相信，写下上述原因分析的同学，内心一定是很真诚的，也是真心觉得自己当时代码写的不够好，业务场景分析的不全面，代码评审不够充分。但是，这个分析带来的行动，却往往是不可达成的。是真的想的不仔细吗，还是就是想不到？这次评审做的不好，下次就肯定能做好了吗？这次场景分析不全，那么怎么才能更全呢?</p>
<p>这种原因分析过于宽泛了，以至于很难产生实际有效的改进行动，下次往往还是会在同样的地方跌倒——大家只要看一下在既往的原因分析中，有多少次类似的答案？每一次重复，就是一次新的踩坑。</p>
<p>还有一类原因分析，恰恰相反，又过于具体化了，具体化到了没有学习价值的层面上。例如，这是当时设计的不对，A 服务就不该调用 B 服务，A 服务应该考虑到B服务调用中的异常场景，等等。好吧，缺陷现在已经修复了，A 服务调用 B 服务出现的异常场景已经固化在代码中了，下一次如果是 C 服务调用 D 服务的异常场景应该怎么办呢？</p>
<p>最合适的缺陷原因应该基于这样的标准：这些原因需要形成系统化的可行动的结果。这个标准的检验方式是：下一次如果发生某某场景，我们的应对方案是否有效?</p>
<h2 id="做好缺陷分析的-5-个要点"><a href="#做好缺陷分析的-5-个要点" class="headerlink" title="做好缺陷分析的 5 个要点"></a>做好缺陷分析的 5 个要点</h2><p>在实践中，我们总结了 5 个要点，来最大化出于学习目的的缺陷分析的实践操作。它们是：</p>
</li>
<li><p>及时总结，设置卡点</p>
</li>
<li><p>结对分析，小组总结</p>
</li>
<li><p>负面清单支持下的全量分析</p>
</li>
<li><p>可操作的结果</p>
</li>
<li><p>团体学习，机制建设</p>
<h2 id="及时总结，设置卡点"><a href="#及时总结，设置卡点" class="headerlink" title="及时总结，设置卡点"></a>及时总结，设置卡点</h2><blockquote>
<p>“缺陷分析很重要，但是研发同学都太忙了，我们两个月集中做一次怎么样？”</p>
</blockquote>
<p>别那么紧张——及时才是最节约的方式。要从忙碌中解放出来，每次花 15 分钟，做一次有效的缺陷分析，时间已经妥妥的啦。</p>
<p>缺陷分析的最好时间是缺陷修复完成的时间。此时记忆最新鲜、也能早收益。如果一个缺陷已经过去了两个月，那么缺陷分析的成本就变高了，得找回原来的记忆和当时的上下文，这个记忆准确不准确还是另一回事。</p>
<p>怎样才能保证及时地做，从而保证这些重要而不紧急的事情发生呢？一个比较有效的方式，是设置流程中的卡点：当缺陷被设定为已修复状态、或者设定为已关闭状态时，强制把缺陷分析设定为一个流程卡点，这样就能形成比较好的驱动。</p>
<h2 id="结对分析，小组总结"><a href="#结对分析，小组总结" class="headerlink" title="结对分析，小组总结"></a>结对分析，小组总结</h2><p>谁来负责缺陷分析？是让具体这个缺陷的同学来做，还是召集整个团队一起？</p>
<p>召集整个团队来做缺陷分析，有时候代价过于高昂。即使仅仅分析比较后期的线上问题，即使每个缺陷仅仅分析 15 分钟：100 个缺陷，每个团队 8 个人，乘积就是 12,000分钟，合 200 个小时，也是一个惊人的数字，投入产出不成比例。</p>
<p>解决缺陷的同学确实是对这个缺陷理解最好。但是，这会不会形成“单点问题”，降低问题分析的有效性？</p>
<p>我们的方案是：</p>
</li>
</ul>
<ol>
<li>把结对分析作为制度</li>
</ol>
<hr>
<p>   让解决缺陷的同学担任负责人，搭配上一个小伙伴。结对既形成了知识方面的互补，一定程度上消除了思维盲点，也通过结对形成了更深入的讨论，也提前进行结果的“验收”，提高分析的质量。如果有必要，结对的小组可以自主决定是否引入其他人参与。</p>
<ol>
<li>团队定期讨论学习</li>
</ol>
<hr>
<p>   团队定期对重要的缺陷分析结果进行讨论，既是对小组成果的验收，更有利于在团队成员间形成传播，互相学习。</p>
<h2 id="负面清单支持下的全量分析"><a href="#负面清单支持下的全量分析" class="headerlink" title="负面清单支持下的全量分析"></a>负面清单支持下的全量分析</h2><p>   缺陷分析的目的是提升，所以，重在解决那些“未知的未知”的问题。显然不是每个缺陷都应该深入分析。但是，如果我们针对每个缺陷都定义它该不该分析，又会导致决策成本过高，而且质量也不可靠。所以，我们的做法是在默认全量的基础上，使用负面清单进行过滤。凡是负面清单不存在的，都进行缺陷分析。负面清单是团队级别的。每个团队都应该维护自己的列表，例如：</p>
<ul>
<li><p>偶发问题</p>
</li>
<li><p>已经列在改进项中的问题（不断扩充）</p>
<p>这个事情和淘金有些类似，明确不要什么，能更高效地避免那些真正值得做的事情不被淹没。事实上，每次缺陷分析都会扩充负面清单的长度，所需的缺陷分析数量将越来越少，问题越来越聚焦，时间也越来越节省。</p>
<h2 id="可操作的结果"><a href="#可操作的结果" class="headerlink" title="可操作的结果"></a>可操作的结果</h2><p>缺陷分析应该产生有价值的洞见，足够的深度是重点。在如何产生深度洞见方面已经有非常多成熟的方法，最典型的是 5 Whys，此外还有鱼骨图等著名工具可用。为了控制篇幅，本文略去对这些方法的介绍，只通过一个实例来说明在实际的缺陷分析中，我们是如何产生深度洞见的。</p>
<p>某缺陷描述了如下的场景（该实例在不影响问题说明的情况下做了适度抽象）：</p>
<p>用户持有某个虚拟设备，该设备有一些附属资源，当用户删除设备时，该设备的附属资源应该被释放。但是，发现在一种特殊场景下，这个附属资源并没有得到释放。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void releaseResources (resoure_id)&#123;    </span><br><span class="line">    if (failedOfHardwareResourceRelease(resource_id))&#123;        </span><br><span class="line">        writeLog(&quot;resource release failed&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是关于这个问题的对话：</p>
<blockquote>
<p>“原因是什么？”<br>“我们没有在需求分析阶段考虑到这种释放不成功的场景。”<br>“OK。需求分析是问题，这是一个改进点。——但是更重要的：最后发现这个问题的最直接的机会点是哪个时间点？”<br>“写代码的时候。”<br>“写代码的时候我们注意到这个问题了吗？”<br>“注意到了啊，所以写了 log，但是没仔细想应该怎么处理。这说明我们对这段代码的职责定义不清晰。”<br>“也许我们可以在编程规范中加入一条：出现异常场景时不应该只记录 log，而应该和负责人澄清场景和处理方案。在未来，当出现了仅仅出现写错误 log，但是没有其他处理的时候，我们就能注意到这一点。”</p>
</blockquote>
<p>检验分析深度是否足够，最直接的指标就是产生的结果是否是“可行动的”。如果一个结果是不可行动的，往往意味着深度或者抽象不够。</p>
<h2 id="团体学习，机制建设"><a href="#团体学习，机制建设" class="headerlink" title="团体学习，机制建设"></a>团体学习，机制建设</h2><p>学习型组织并不总是容易建立。除了上述心智模型和操作方法之外，组织机制往往是成功的重点。我们总结了如下几点：</p>
</li>
<li><p>是长期存在的团队</p>
</li>
<li><p>建立持续学习的心智模型</p>
</li>
<li><p>持续维护和利用本组织的智力资产</p>
<p>这几点似乎都毋需多言。但是关于智力资产，还是要多强调一下：分析结果最后可能会是流程改进、编程习惯和编程规范、代码评审的检查单、设计能力的提升、引入某些新的工程实践如实例化需求等，不外乎有两类：</p>
</li>
</ul>
<ol>
<li>短期的行动</li>
</ol>
<hr>
<p>   例如引入实例化需求实践、 建设自动化测试机制等。对于这类具体行动，要定义责任人和结束日期，并且把它们和管理需求等工作项同等管理起来，确保其发生。</p>
<ol>
<li>长期的规则</li>
</ol>
<hr>
<p>   这类是需要持续关注的东西，例如代码评审的常见问题列表、采纳某种设计思想如契约式设计、防御式编程等。对于这类问题，由于需要持续关注，需要维护它们，并把它们作为团队资产的一部分。当然了，如果技术上可行，还是要把其中的一部分尽早做成工具，减少记忆负担，提升可操作性。</p>
<p>   这种资产维护的越多，就会发现未来需要继续分析的缺陷越少——当然了，这也是一切资产的共性所在。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   现实情况纷繁复杂，统一的方法往往并不存在。但是心智模型和一定的规律、思路还是存在的。本文聚焦于通过缺陷分析进行学习。</p>
<p>   通过适当的方法，它可以在可控的时间投入下，为组织积累宝贵的财富，并且在未来的开发中得到数倍、数十倍上百倍的回报。忙碌不是理由，在未来少掉一个新 bug，就赚回来了。</p>
<p>   通过缺陷分析，我们可以形成如下的产出：</p>
<ul>
<li><p>建立团队关于需求分析、软件设计、编程、测试、运维等方面的共同心智</p>
</li>
<li><p>形成常见问题的检查单</p>
</li>
<li><p>采用或者开发新的工具</p>
</li>
<li><p>改进既有流程</p>
</li>
<li><p>形成针对特定问题的行动计划</p>
<p>最最重要的，通过消除各种盲点，我们的能力也就越来越强，开发也就越来越顺畅，距离零缺陷的目标，就越来越近了。</p>
</li>
</ul>
<p><a href="https://developer.aliyun.com/article/778038?utm_content=g_1000202459">原文链接</a></p>
]]></content>
      <tags>
        <tag>JavaScript 质量 前端 编码 缺陷 bug</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript工具方法</title>
    <url>/2017/08/05/JavaScript%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="工作和平时收集整理的一些实用的工具方法，保存下来，以备不时之需。"><a href="#工作和平时收集整理的一些实用的工具方法，保存下来，以备不时之需。" class="headerlink" title="工作和平时收集整理的一些实用的工具方法，保存下来，以备不时之需。"></a>工作和平时收集整理的一些实用的工具方法，保存下来，以备不时之需。</h3><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> myTools = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [trim 去除空格]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str  [原始字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>type [1-所有空格  2-前后空格  3-前空格 4-后空格]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>      </span>[返回处理后的值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  trim: <span class="function"><span class="keyword">function</span>(<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [changeCase 字母大小写切换]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str  [原始字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>type [1-首字母大写  2-首页母小写  3-大小写转换  4-全部大写  5-全部小写]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>      </span>[返回处理后的值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">changeCase</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ToggleCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> itemText = <span class="string">&quot;&quot;</span></span><br><span class="line">      str.split(<span class="string">&quot;&quot;</span>).forEach(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="regexp">/^([a-z]+)/</span>.test(item)) &#123;</span><br><span class="line">            itemText += item.toUpperCase();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^([A-Z]+)/</span>.test(item)) &#123;</span><br><span class="line">            itemText += item.toLowerCase();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            itemText += item;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span> itemText;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/^(\w)(\w+)/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v, v1, v2</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> v1.toUpperCase() + v2.toLowerCase();</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/^(\w)(\w+)/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v, v1, v2</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> v1.toLowerCase() + v2.toUpperCase();</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> ToggleCase(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [repeatStr 字符串循环复制]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str   [原始字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>count [次数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>       </span>[返回处理后的值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">repeatStr</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        text += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//字符串替换</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [replaceAll 字符串替换]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str              [原始字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string RegExp]&#125;</span> </span>AFindText [查找字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>ARepText         [替换字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>                  </span>[返回处理后的值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">replaceAll</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, AFindText, ARepText</span>) </span>&#123;　　　</span><br><span class="line">    raRegExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(AFindText, <span class="string">&quot;g&quot;</span>);　　　</span><br><span class="line">    <span class="keyword">return</span> str.replace(raRegExp, ARepText);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [replaceStr 替换指定字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str             [字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>regArr           [字符格式]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>type            [替换方式]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>ARepText        [替换的字符(默认*)]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>                 </span>[返回处理后的值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">replaceStr</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, regArr, type, ARepText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regtext = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        Reg = <span class="literal">null</span>,</span><br><span class="line">        replaceText = ARepText || <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="comment">//replaceStr(&#x27;18819322663&#x27;,[3,5,3],0)</span></span><br><span class="line">    <span class="comment">//188*****663</span></span><br><span class="line">    <span class="comment">//repeatStr是在上面定义过的（字符串循环复制），大家注意哦</span></span><br><span class="line">    <span class="keyword">if</span> (regArr.length === <span class="number">3</span> &amp;&amp; type === <span class="number">0</span>) &#123;</span><br><span class="line">      regtext = <span class="string">&#x27;(\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;)\\w&#123;&#x27;</span> + regArr[<span class="number">1</span>] + <span class="string">&#x27;&#125;(\\w&#123;&#x27;</span> + regArr[<span class="number">2</span>] + <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">      Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">      <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> str.replace(Reg, <span class="string">&#x27;$1&#x27;</span> + replaceCount + <span class="string">&#x27;$2&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//replaceStr(&#x27;asdasdasdaa&#x27;,[3,5,3],1)</span></span><br><span class="line">    <span class="comment">//***asdas***</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">3</span> &amp;&amp; type === <span class="number">1</span>) &#123;</span><br><span class="line">      regtext = <span class="string">&#x27;\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;(\\w&#123;&#x27;</span> + regArr[<span class="number">1</span>] + <span class="string">&#x27;&#125;)\\w&#123;&#x27;</span> + regArr[<span class="number">2</span>] + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">      Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">      <span class="keyword">var</span> replaceCount1 = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">var</span> replaceCount2 = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">return</span> str.replace(Reg, replaceCount1 + <span class="string">&#x27;$1&#x27;</span> + replaceCount2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//replaceStr(&#x27;1asd88465asdwqe3&#x27;,[5],0)</span></span><br><span class="line">    <span class="comment">//*****8465asdwqe3</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">1</span> &amp;&amp; type == <span class="number">0</span>) &#123;</span><br><span class="line">      regtext = <span class="string">&#x27;(^\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">      Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">      <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span> str.replace(Reg, replaceCount)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//replaceStr(&#x27;1asd88465asdwqe3&#x27;,[5],1,&#x27;+&#x27;)</span></span><br><span class="line">    <span class="comment">//&quot;1asd88465as+++++&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (regArr.length === <span class="number">1</span> &amp;&amp; type == <span class="number">1</span>) &#123;</span><br><span class="line">      regtext = <span class="string">&#x27;(\\w&#123;&#x27;</span> + regArr[<span class="number">0</span>] + <span class="string">&#x27;&#125;$)&#x27;</span></span><br><span class="line">      Reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regtext);</span><br><span class="line">      <span class="keyword">var</span> replaceCount = <span class="built_in">this</span>.repeatStr(replaceText, regArr[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span> str.replace(Reg, replaceCount)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [checkType 检测字符串类型]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str  [检测的字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>type [检测类型:email,phone,tel,number,english,chinese,lower,upper]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[boolean]&#125;</span>     </span>[返回布尔值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">checkType</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;email&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;phone&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;tel&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[0-9]$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;english&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]+$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;chinese&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[\u4E00-\u9FA5]+$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;lower&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[a-z]+$/</span>.test(str);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;upper&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^[A-Z]+$/</span>.test(str);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [checkPwd 检测密码强度]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str [检测的密码]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[number]&#125;</span>     </span>[返回密码强度，最大为4]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">checkPwd</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowLv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nowLv</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[0-9]/</span>.test(str)) &#123;</span><br><span class="line">      nowLv++</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[a-z]/</span>.test(str)) &#123;</span><br><span class="line">      nowLv++</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[A-Z]/</span>.test(str)) &#123;</span><br><span class="line">      nowLv++</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[\.|-|_]/</span>.test(str)) &#123;</span><br><span class="line">      nowLv++</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> nowLv;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [countStr 查找字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>str      [原始字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>strSplit [查询的字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[number]&#125;</span>          </span>[出现的次数]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">countStr</span>: <span class="function"><span class="keyword">function</span>(<span class="params">str, strSplit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(strSplit).length-<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [unique 数组去重]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span>  </span>array       [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;Boolean&#125;</span> </span>isSorted     [是否已排过序]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[function]&#125;</span>  </span>iteratee [重新计算，根据结果去重]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>              </span>[新数组]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">unique</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> seen = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = array[i];</span><br><span class="line">        <span class="keyword">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || seen !== value) &#123;</span><br><span class="line">                res.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">            seen = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.indexOf(computed) === -<span class="number">1</span>) &#123;</span><br><span class="line">                seen.push(computed);</span><br><span class="line">                res.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res.indexOf(value) === -<span class="number">1</span>) &#123;</span><br><span class="line">            res.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [sortUnique 数字类型数组排序去重 ES5]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>     </span>[新数组]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">sortUnique</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.concat().sort(<span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;).filter(<span class="function"><span class="keyword">function</span>(<span class="params"> v, i, arr </span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !i || v != arr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [unique2 数组去重 ES6]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>     </span>[新数组]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">unique2</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [upsetArr 数组乱序]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>     </span>[新数组]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">upsetArr</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getMax 数组求最大值]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr         [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string number]&#125;</span>     </span>[最大的元素]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getMax</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getMax 数组求最小值]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr         [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string number]&#125;</span>     </span>[最小的元素]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getMin</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getSum 数组求和]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[num]&#125;</span>       </span>[和]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getSum</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getAverage 数组求平均值]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[number]&#125;</span>    </span>[平均值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getAverage</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="built_in">this</span>.getSum(arr);</span><br><span class="line">    <span class="keyword">var</span> average = sum / arr.length;</span><br><span class="line">    <span class="keyword">return</span> average;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getRandom 数组中随机获取元素]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array]&#125;</span> </span>arr         [原始数组]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string number]&#125;</span>     </span>[随机元素]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getRandomElement</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getEleCount 数组(字符串)元素出现的次数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array string]&#125;</span> </span>obj   [原始数组或字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string number]&#125;</span> </span>ele  [指定元素]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[number]&#125;</span>             </span>[出现的次数]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getEleCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ele == obj[i]) &#123;</span><br><span class="line">        num++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getCount 数组(字符串)出现最多的几次元素和出现次数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[array string]&#125;</span> </span>arr      [原始数组或字符串]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span>       </span>rank     [长度，默认为数组长度]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span>       </span>ranktype [排序方式，默认降序]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>                 </span>[元素和次数的数组对象]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arr, rank, ranktype</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;, k, arr1 = [];</span><br><span class="line">    <span class="comment">//记录每一元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      k = arr[i];</span><br><span class="line">      <span class="keyword">if</span> (obj[k]) &#123;</span><br><span class="line">          obj[k]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          obj[k] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存结果&#123;el-&#x27;元素&#x27;，count-出现次数&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      arr1.push(&#123;<span class="attr">el</span>: o, <span class="attr">count</span>: obj[o]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序（降序）</span></span><br><span class="line">    arr1.sort(<span class="function"><span class="keyword">function</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> n2.count - n1.count</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//如果ranktype为1，则为升序，反转数组</span></span><br><span class="line">    <span class="keyword">if</span> (ranktype === <span class="number">1</span>) &#123;</span><br><span class="line">      arr1 = arr1.reverse();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> rank1 = rank || arr1.length;</span><br><span class="line">    <span class="keyword">return</span> arr1.slice(<span class="number">0</span>,rank1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [upDigit 现金额大写转换函数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>n [数字金额]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>   </span>[大写金额]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">upDigit</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fraction = [<span class="string">&#x27;角&#x27;</span>, <span class="string">&#x27;分&#x27;</span>, <span class="string">&#x27;厘&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> digit = [<span class="string">&#x27;零&#x27;</span>, <span class="string">&#x27;壹&#x27;</span>, <span class="string">&#x27;贰&#x27;</span>, <span class="string">&#x27;叁&#x27;</span>, <span class="string">&#x27;肆&#x27;</span>, <span class="string">&#x27;伍&#x27;</span>, <span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>, <span class="string">&#x27;捌&#x27;</span>, <span class="string">&#x27;玖&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> unit = [[<span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;万&#x27;</span>, <span class="string">&#x27;亿&#x27;</span>],[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;拾&#x27;</span>, <span class="string">&#x27;佰&#x27;</span>, <span class="string">&#x27;仟&#x27;</span>]];</span><br><span class="line">    <span class="keyword">var</span> head = n &lt; <span class="number">0</span> ? <span class="string">&#x27;欠人民币&#x27;</span> : <span class="string">&#x27;人民币&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fraction.length; i++) &#123;</span><br><span class="line">      s += (digit[<span class="built_in">Math</span>.floor(n * <span class="number">10</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, i)) % <span class="number">10</span>] + fraction[i]).replace(<span class="regexp">/零./</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || <span class="string">&#x27;整&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; n &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> p = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">        p = digit[n % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//s = p.replace(/(零.)*零$/, &#x27;&#x27;).replace(/^$/, &#x27;零&#x27;)+ unit[0][i] + s;</span></span><br><span class="line">      s = p + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replace(<span class="regexp">/(零.)*零元/</span>, <span class="string">&#x27;元&#x27;</span>).replace(<span class="regexp">/(零.)+/g</span>, <span class="string">&#x27;零&#x27;</span>).replace(<span class="regexp">/^整$/</span>, <span class="string">&#x27;零元整&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getUrlPrmt 获取url参数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>url [url地址]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[object]&#125;</span>     </span>[json数据]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getUrlPrmt</span>: <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    url = url ? url : <span class="built_in">window</span>.location.href;</span><br><span class="line">    <span class="keyword">let</span> _pa = url.substring(url.indexOf(<span class="string">&#x27;?&#x27;</span>) + <span class="number">1</span>),</span><br><span class="line">        _arrS = _pa.split(<span class="string">&#x27;&amp;&#x27;</span>),</span><br><span class="line">        _rs = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, _len = _arrS.length; i &lt; _len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pos = _arrS[i].indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (pos == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对 encodeURIComponent() 函数编码的 URI 进行解码。</span></span><br><span class="line">      <span class="keyword">let</span> name = _arrS[i].substring(<span class="number">0</span>, pos),</span><br><span class="line">          value = <span class="built_in">window</span>.decodeURIComponent(_arrS[i].substring(pos + <span class="number">1</span>));</span><br><span class="line">      _rs[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [setUrlPrmt 设置url参数]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;[object]&#125;</span> </span>obj [json对象]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">setUrlPrmt</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _rs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj[p] != <span class="literal">null</span> &amp;&amp; obj[p] != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        _rs.push(p + <span class="string">&#x27;=&#x27;</span> + obj[p])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rs.join(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [randomNumber 随机返回一个范围的数字]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>n1 [起始值]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[number]&#125;</span> </span>n2 [目标值]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[number]&#125;</span>    </span>[随机值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getRandomNumber</span>: <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round(n1 + <span class="built_in">Math</span>.random() * (n2 - n1));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * n1)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getRandomColor 随机颜色]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[type]&#125;</span> </span>[色值]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getRandomColor</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>+<span class="built_in">Math</span>.random().toString(<span class="number">16</span>).substring(<span class="number">2</span>).substr(<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getEndTime 时间倒计时]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;[string]&#125;</span> </span>endTime [目标时间如&#x27;2018/7/22 16:0:0&#x27;]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[string]&#125;</span>         </span>[剩余时间]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getEndTime</span>: <span class="function"><span class="keyword">function</span>(<span class="params">endTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//开始时间，当前时间</span></span><br><span class="line">    <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>(endTime); <span class="comment">//结束时间，需传入时间参数</span></span><br><span class="line">    <span class="keyword">var</span> t = endDate.getTime() - startDate.getTime(); <span class="comment">//时间差的毫秒数</span></span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">0</span>,h = <span class="number">0</span>,m = <span class="number">0</span>,s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      d = <span class="built_in">Math</span>.floor(t / <span class="number">1000</span> / <span class="number">3600</span> / <span class="number">24</span>);</span><br><span class="line">      h = <span class="built_in">Math</span>.floor(t / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> % <span class="number">24</span>);</span><br><span class="line">      m = <span class="built_in">Math</span>.floor(t / <span class="number">1000</span> / <span class="number">60</span> % <span class="number">60</span>);</span><br><span class="line">      s = <span class="built_in">Math</span>.floor(t / <span class="number">1000</span> % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;剩余时间&quot;</span> + d + <span class="string">&quot;天 &quot;</span> + h + <span class="string">&quot;小时 &quot;</span> + m + <span class="string">&quot; 分钟&quot;</span> + s + <span class="string">&quot; 秒&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [getFontSize 适配rem]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;[type]&#125;</span> </span>[比如在iphone6(屏幕宽度：375)上，375/750*100=50px;就是1rem=50px]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ,<span class="attr">getFontSize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc=<span class="built_in">document</span>,win=<span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">        <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px</span></span><br><span class="line">        <span class="keyword">if</span>(clientWidth&gt;<span class="number">750</span>)&#123; clientWidth = <span class="number">750</span> &#125;</span><br><span class="line">        <span class="comment">//设置根元素font-size大小</span></span><br><span class="line">        docEl.style.fontSize = <span class="number">100</span> * ( clientWidth / <span class="number">750</span> ) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//屏幕大小改变，或者横竖屏切换时，触发函数</span></span><br><span class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//文档加载完成时，触发函数</span></span><br><span class="line">    doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 功能：序列化form表单元素</span></span><br><span class="line"><span class="comment">  * 1.同名的name属性，值会被序列化为数组，例如checkbox等控件</span></span><br><span class="line"><span class="comment">  * 2.可以嵌套对象，name和value会被序列化为嵌套的json对象格式</span></span><br><span class="line"><span class="comment">  * 3.可以嵌套对象列表，name和value会被序列化成嵌套的json数组对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  $.fn.serializeNestedObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> arrObj = <span class="built_in">this</span>.serializeArray();</span><br><span class="line">    $.each(arrObj, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对重复的name属性，会将对应的众多值存储成json数组</span></span><br><span class="line">      <span class="keyword">if</span> (json[<span class="built_in">this</span>.name]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!json[<span class="built_in">this</span>.name].push) &#123;</span><br><span class="line">          json[<span class="built_in">this</span>.name] = [json[<span class="built_in">this</span>.name]];</span><br><span class="line">        &#125;</span><br><span class="line">        json[<span class="built_in">this</span>.name].push(<span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有嵌套的属性，用&#x27;.&#x27;分隔的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.name.indexOf(<span class="string">&#x27;.&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> pos = <span class="built_in">this</span>.name.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">          <span class="keyword">var</span> key = <span class="built_in">this</span>.name.substring(<span class="number">0</span>, pos);</span><br><span class="line">          <span class="comment">// 判断此key是否已存在json数据中，不存在则新建一个对象出来</span></span><br><span class="line">          <span class="keyword">if</span> (!existKeyInJSON(key, json)) &#123;</span><br><span class="line">            json[key] = &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">var</span> subKey = <span class="built_in">this</span>.name.substring(pos + <span class="number">1</span>);</span><br><span class="line">          json[key][subKey] = <span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普通属性</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          json[<span class="built_in">this</span>.name] = <span class="built_in">this</span>.value || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 处理那些值应该属于数组的元素，即带&#x27;[number]&#x27;的key-value对</span></span><br><span class="line">    <span class="keyword">var</span> resultJson = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> json) &#123;</span><br><span class="line">      <span class="comment">// 数组元素</span></span><br><span class="line">      <span class="keyword">if</span> (key.indexOf(<span class="string">&#x27;[&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> pos = key.indexOf(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> realKey = key.substring(<span class="number">0</span>, pos);</span><br><span class="line">        <span class="comment">// 判断此key是否已存在json数据中，不存在则新建一个数组出来</span></span><br><span class="line">        <span class="keyword">if</span> (!existKeyInJSON(realKey, resultJson)) &#123;</span><br><span class="line">          resultJson[realKey] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        resultJson[realKey].push(json[key]);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 单元素</span></span><br><span class="line">        resultJson[key] = json[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：判断key在Json结构中是否存在</span></span><br><span class="line"><span class="comment">     * 存在，返回true; 否则，返回false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">existKeyInJSON</span>(<span class="params">key, json</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="literal">null</span> || key == <span class="string">&#x27;&#x27;</span> || $.isEmptyObject(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> exist = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> json) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === k) &#123;</span><br><span class="line">          exist = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultJson;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myTools.trim(<span class="string">&#x27;  fsggdagdafd  fdsafsa  &#x27;</span>, <span class="number">1</span>));<span class="comment">//fsggdagdafdfdsafsa</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.changeCase(<span class="string">&#x27;gdagrtew11&#x27;</span>, <span class="number">1</span>));<span class="comment">//Gdagrtew11</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.repeatStr(<span class="string">&#x27;asd&#x27;</span>, <span class="string">&#x27;2&#x27;</span>));<span class="comment">//asdasd</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.replaceAll(<span class="string">&#x27;asdfghjkl&#x27;</span>, <span class="string">&#x27;asd&#x27;</span>, <span class="string">&#x27;ssss&#x27;</span>));<span class="comment">//ssssfghjkl</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.replaceStr(<span class="string">&#x27;18819322663&#x27;</span>,[<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>],<span class="number">0</span>));<span class="comment">//188*****663</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.checkType(<span class="string">&#x27;11@qq.com&#x27;</span>,<span class="string">&#x27;email&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.checkPwd(<span class="string">&#x27;1111111aA.&#x27;</span>));<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.countStr(<span class="string">&#x27;fewqtreytreiynhtdagdsacsrqewgtrjytjngfbffdgfdgfdagd&#x27;</span>, <span class="string">&#x27;f&#x27;</span>));<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.unique([<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="literal">false</span>, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> item == <span class="string">&#x27;string&#x27;</span> ? item.toLowerCase() : item</span><br><span class="line">&#125;)); <span class="comment">// [1, &quot;a&quot;, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.sortUnique([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.unique2([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//[3, 2, 6, 8, 0, 1, 5, 4, 7, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.upsetArr([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//[1, 6, 0, 2, 6, 3, 4, 8, 2, 7, 8, 9, 5, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getMax([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getMin([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getSum([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//64</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getAverage([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]));<span class="comment">//4.571428571428571</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getEleCount([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],<span class="number">3</span>));<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getCount([<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]));<span class="comment">//array[object]</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.upDigit(<span class="number">432153132.432</span>));<span class="comment">//人民币肆亿叁仟贰佰壹拾伍万叁仟壹佰叁拾贰元肆角叁分贰厘</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getUrlPrmt(<span class="string">&#x27;segmentfault.com/write?draftId=122&amp;id=4314&#x27;</span>));<span class="comment">//json格式参数</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.setUrlPrmt(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;));<span class="comment">//a=1&amp;b=2</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getRandomNumber(<span class="number">2</span>,<span class="number">20</span>));<span class="comment">//15</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getRandomColor());<span class="comment">//#6728f2</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getEndTime(<span class="string">&#x27;2018/7/22 16:0:0&#x27;</span>));<span class="comment">//剩余时间350天 22小时 39 分钟12 秒</span></span><br><span class="line"><span class="built_in">console</span>.log(myTools.getFontSize());<span class="comment">//clientWidth &gt; 750px ==&gt; 1rem = 100px</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width:1rem;height:2rem;background:red;&quot;</span>&gt;</span><br><span class="line">  <span class="number">11111</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript　js　工具 方法 前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript概念整理</title>
    <url>/2017/12/11/JavaScript%E6%9D%83%E5%A8%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章的目的是汇集 JavaScript 相关概念。有了这篇文章，你就可以在一个地方温故一下你需要了解的关于 JavaScript 的所有知识点。</p>
</blockquote>
<a id="more"></a>

<h1 id="类型及其转换"><a href="#类型及其转换" class="headerlink" title="类型及其转换"></a>类型及其转换</h1><p>JavaScript 内置了7种类型：<code>null</code>, <code>undefined</code> , <code>boolean</code>, <code>number</code>, <code>string</code>, <code>object</code>以及 <code>symbol (ES6)</code>.</p>
<p>除了 object 以外，这几种类型都可以归类为<strong>原始类型（基本类型）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 0              &#x2F;&#x2F; number</span><br><span class="line">typeof true           &#x2F;&#x2F; boolean</span><br><span class="line">typeof &#39;Hello&#39;        &#x2F;&#x2F; string</span><br><span class="line">typeof Math           &#x2F;&#x2F; object</span><br><span class="line">typeof null           &#x2F;&#x2F; object  !!</span><br><span class="line">typeof Symbol(&#39;Hi&#39;)   &#x2F;&#x2F; symbol (New ES6) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Null 与 Undefined</li>
</ul>
<p><code>Undefined</code> 表示尚未定义。它被用作表示未初始化变量，未提供的函数参数，对象缺少的属性的默认值。当函数没有返回值时也会默认返回 undefined .</p>
<p><code>Null</code> 则表示空值。它可以被赋值给一个变量来表示的“没有值”。</p>
<ul>
<li>隐式类型转换</li>
</ul>
<p>让我们来看下面这个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Joey&#39;;</span><br><span class="line">if (name) &#123;</span><br><span class="line">  console.log(name + &quot; doesn&#39;t share food!&quot;)  &#x2F;&#x2F; Joey doesn’t share food!</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在这种情况下，字符串变量 <code>name</code> 会被转换为 <code>true</code> ，所以我们能够在命令行里输出这段话。那我们到底要如何确定这些真假值的转换呢？</p>
<p>Falsy 类型的值是指在强制类型转换时会被转换为布尔 <code>false</code> 的值。</p>
<p>Falsy 类型值包括：<code>&quot;&quot;</code>, <code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>false</code>.</p>
<p>除了 Falsy 类型值以外的都被称为 truthy 类型值，它们会被转换为 <code>true</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean(null)         &#x2F;&#x2F; false</span><br><span class="line">Boolean(&#39;hello&#39;)      &#x2F;&#x2F; true </span><br><span class="line">Boolean(&#39;0&#39;)          &#x2F;&#x2F; true </span><br><span class="line">Boolean(&#39; &#39;)          &#x2F;&#x2F; true </span><br><span class="line">Boolean([])           &#x2F;&#x2F; true </span><br><span class="line">Boolean(function()&#123;&#125;) &#x2F;&#x2F; true </span><br></pre></td></tr></table></figure>
<p>没错。你可能注意到了。空的数组，对象和函数布尔值也会被转换为 <code>true</code> ！</p>
<ul>
<li>String &amp; Number 运算</li>
</ul>
<p>你需要注意的第一件事是 + 操作符。这是一个棘手的操作符，因为它同时适用于数值运算和字符串连接。</p>
<p>但是，<code>*</code>，<code>/</code>和<code>-</code>操作符都是数字运算专用的。当这些运算符与字符串一起使用时，会强制转换字符串为数字类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + &quot;2&quot; &#x3D; &quot;12&quot;</span><br><span class="line">&quot;&quot; + 1 + 0 &#x3D; &quot;10&quot;</span><br><span class="line">&quot;&quot; - 1 + 0 &#x3D; -1</span><br><span class="line">&quot;-9\n&quot; + 5 &#x3D; &quot;-9\n5&quot;</span><br><span class="line">&quot;-9\n&quot; - 5 &#x3D; -14</span><br><span class="line">&quot;2&quot; * &quot;3&quot; &#x3D; 6</span><br><span class="line">4 + 5 + &quot;px&quot; &#x3D; &quot;9px&quot;</span><br><span class="line">&quot;$&quot; + 4 + 5 &#x3D; &quot;$45&quot;</span><br><span class="line">&quot;4&quot; - 2 &#x3D; 2</span><br><span class="line">&quot;4px&quot; - 2 &#x3D; NaN</span><br><span class="line">null + 1 &#x3D; 1</span><br><span class="line">undefined + 1 &#x3D; NaN </span><br></pre></td></tr></table></figure>
<ul>
<li>== 与 ===</li>
</ul>
<p>对此大多数人的理解肯定是 <code>==</code> 只比较值相等，而 <code>===</code> 在比较的同时还会检查类型。不过这种解释其实是错误的。</p>
<p>事实上，<code>==</code> 是比较强制类型转换之后的结果，而 <code>===</code> 则是直接比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &#x3D;&#x3D; &#39;2&#39;            &#x2F;&#x2F; True</span><br><span class="line">2 &#x3D;&#x3D;&#x3D; &#39;2&#39;           &#x2F;&#x2F; False</span><br><span class="line">undefined &#x3D;&#x3D; null   &#x2F;&#x2F; True</span><br><span class="line">undefined &#x3D;&#x3D;&#x3D; null  &#x2F;&#x2F; False </span><br></pre></td></tr></table></figure>
<p>强制类型转换有时候会造成一些混乱，我们来看下面这个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#39;0&#39;;</span><br><span class="line">console.log(Boolean(a)); &#x2F;&#x2F; True</span><br><span class="line">let b &#x3D; false;</span><br><span class="line">console.log(Boolean(b)); &#x2F;&#x2F; False </span><br></pre></td></tr></table></figure>
<p>好，根据以上结果，请告诉我下面这此比较的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a &#x3D;&#x3D; b); &#x2F;&#x2F;(1) </span><br></pre></td></tr></table></figure>
<p>上述代码事实上返回了 True，那么这是为什么呢？</p>
<p>在 JavaScript 的机制中，当你拿一个其它类型的值和 <code>boolean</code> 类型进行比较时，JavaScript 会将这个布尔值转换为 <code>number</code> 类型再进行比较。（2）</p>
<p>此时这个问题就变成了 <code>number</code> 和 <code>string</code> 类型值之间的比较。根据我们之前所说的，JavaScript 会把 <code>string</code> 类型转换为 <code>number</code> 类型再比较两个数字。（3）</p>
<p>所以最后的表达式被转换为了 <code>0 == 0</code>，结果理所当然是 True.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;0&#39; &#x3D;&#x3D; false   &#x2F;&#x2F;(1)</span><br><span class="line">&#39;0&#39; &#x3D;&#x3D; 0       &#x2F;&#x2F;(2)</span><br><span class="line"> 0  &#x3D;&#x3D; 0       &#x2F;&#x2F;(3) </span><br></pre></td></tr></table></figure>
<p>如果你想全面理解这种比较是如何进行的，可以查阅ES5文档。</p>
<p>这里也有一个 JavaScript 当中各种类型值对比结果的参照表。</p>
<p>下面是一些特殊比较的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false &#x3D;&#x3D; &quot;&quot;  &#x2F;&#x2F; true</span><br><span class="line">false &#x3D;&#x3D; []  &#x2F;&#x2F; true</span><br><span class="line">false &#x3D;&#x3D; &#123;&#125;  &#x2F;&#x2F; false</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; 0      &#x2F;&#x2F; true</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; []     &#x2F;&#x2F; true</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; &#123;&#125;     &#x2F;&#x2F; false</span><br><span class="line">0 &#x3D;&#x3D; []      &#x2F;&#x2F; true</span><br><span class="line">0 &#x3D;&#x3D; &#123;&#125;      &#x2F;&#x2F; false</span><br><span class="line">0 &#x3D;&#x3D; null    &#x2F;&#x2F; false </span><br></pre></td></tr></table></figure>
<h1 id="赋值与引用"><a href="#赋值与引用" class="headerlink" title="赋值与引用"></a>赋值与引用</h1><p>简单值（或者称为原始值 primitives）均是 <code>null</code>, <code>undefined</code> , <code>boolean</code>, <code>number</code>, <code>string</code>, 以及 <code>symbol (ES6)</code>类型的赋值。</p>
<p>复合值则是对 <code>object</code>，包含 <code>array</code> 以及 <code>function</code> 在内的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 2;        &#x2F;&#x2F; &#39;a&#39; hold a copy of the value 2.</span><br><span class="line">var b &#x3D; a;        &#x2F;&#x2F; &#39;b&#39; is always a copy of the value in &#39;a&#39;</span><br><span class="line">b++;</span><br><span class="line">console.log(a);   &#x2F;&#x2F; 2</span><br><span class="line">console.log(b);   &#x2F;&#x2F; 3</span><br><span class="line">var c &#x3D; [1,2,3];</span><br><span class="line">var d &#x3D; c;        &#x2F;&#x2F; &#39;d&#39; is a reference to the shared value</span><br><span class="line">d.push( 4 );      &#x2F;&#x2F; Mutates the referenced value (object)</span><br><span class="line">console.log(c);   &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">console.log(d);   &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">&#x2F;* Compound values are equal by reference *&#x2F;</span><br><span class="line">var e &#x3D; [1,2,3,4];</span><br><span class="line">console.log(c &#x3D;&#x3D;&#x3D; d);  &#x2F;&#x2F; true</span><br><span class="line">console.log(c &#x3D;&#x3D;&#x3D; e);  &#x2F;&#x2F; false </span><br></pre></td></tr></table></figure>
<p>当你想要复制一份复合值的时候，你需要通过一些方法对其进行<strong>拷贝</strong>（这里区分浅拷贝及深拷贝）。这样引用才不会指向同一个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const copy &#x3D; c.slice()    &#x2F;&#x2F; &#39;copy&#39; references to a new value</span><br><span class="line">console.log(c);           &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">console.log(copy);        &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">console.log(c &#x3D;&#x3D;&#x3D; copy);  &#x2F;&#x2F; false </span><br></pre></td></tr></table></figure>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是指代码执行时的上下文，它定义了变量以及函数生效的范围。</p>
<p><strong>全局作用域</strong>指的是最外层的作用域。所有在函数外部声明的变量都会在全局作用域当中，可以在任何地方访问到。在浏览器当中，window 对象就属于全局作用域。</p>
<p><strong>局部作用域</strong>是指例如在某个函数内部的范围。在局部作用域中声明的变量只能够在其内部被访问到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">  let a &#x3D; 1;</span><br><span class="line">  function inner() &#123;</span><br><span class="line">    let b &#x3D; 2;</span><br><span class="line">    function innermost() &#123;</span><br><span class="line">      let c &#x3D; 3;</span><br><span class="line">      console.log(a, b, c);   &#x2F;&#x2F; 1 2 3</span><br><span class="line">    &#125;</span><br><span class="line">    innermost();</span><br><span class="line">    console.log(a, b);        &#x2F;&#x2F; 1 2 — &#39;c&#39; is not defined</span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">  console.log(a);             &#x2F;&#x2F; 1 — &#39;b&#39; and &#39;c&#39; are not defined</span><br><span class="line">&#125;</span><br><span class="line">outer(); </span><br></pre></td></tr></table></figure>
<p>为了便于理解，你可以把作用域想象为一扇扇从大到小排列的门。最矮的人（上述代码1，2，3表示高矮）可以进入最小的门（innermost 的作用域），同时也能通过最大的门（outer 的作用域）。</p>
<p>而个子高的人在通过门时则会被卡住（也就是在外部访问不到内部定义的变量）。</p>
<h1 id="变量提升-Hoisting"><a href="#变量提升-Hoisting" class="headerlink" title="变量提升 Hoisting"></a>变量提升 Hoisting</h1><p>在编译过程中，JavaScript 会自动把 <code>var</code> 和 <code>function</code> 声明移动到顶部的行为被称为 <strong>hoisting</strong>.</p>
<p>函数声明会被完整地提升。这就意味着你在编写代码时可以在声明一个函数之前就调用它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(toSquare(3));  &#x2F;&#x2F; 9</span><br><span class="line"></span><br><span class="line">function toSquare(n)&#123;</span><br><span class="line">  return n*n;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>变量只会被部分提升。例如只有 <code>var</code> 的声明会被提升，而赋值则不会。</p>
<p><code>let</code> 以及 <code>const</code> 也不会被提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  &#x2F;* Original code *&#x2F;</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; undefined</span><br><span class="line">  var i &#x3D; 10</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  &#x2F;* Compilation phase *&#x2F;</span><br><span class="line">  var i;</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; undefined</span><br><span class="line">  i &#x3D; 10</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ES6 let &amp; const</span><br><span class="line">&#123;</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; ReferenceError: i is not defined</span><br><span class="line">  const i &#x3D; 10</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; ReferenceError: i is not defined</span><br><span class="line">  let i &#x3D; 10</span><br><span class="line">  console.log(i);  &#x2F;&#x2F; 10</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="函数表达式-与-函数声明"><a href="#函数表达式-与-函数声明" class="headerlink" title="函数表达式 与 函数声明"></a>函数表达式 与 函数声明</h1><ul>
<li>函数表达式</li>
</ul>
<p>函数表达式只有被执行之后才可用，它不会被提升（相当于赋值函数表达式给变量）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum &#x3D; function(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>函数声明</li>
</ul>
<p>函数声明则可以在定义前后被任意调用，因为它最终会被提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量声明方式：var-let-cost"><a href="#变量声明方式：var-let-cost" class="headerlink" title="变量声明方式：var let cost"></a>变量声明方式：var let cost</h1><p>在 ES6 之前，只有 <code>var</code> 一种声明变量的方法。在某一函数内部声明的变量和方法只能在其函数作用域内部访问到。</p>
<p>一些在例如 <code>if</code> 或者 <code>for</code> 语句的块作用域内声明的变量，能够在其包含的大括号外被访问到。</p>
<p>注意：未使用 <code>var</code>，<code>let</code> 或 <code>const</code> 关键字声明的变量会自动变成全局变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function greeting() &#123;</span><br><span class="line">  console.log(s) &#x2F;&#x2F; undefined</span><br><span class="line">  if(true) &#123;</span><br><span class="line">    var s &#x3D; &#39;Hi&#39;;</span><br><span class="line">    undeclaredVar &#x3D; &#39;I am automatically created in global scope&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(s) &#x2F;&#x2F; &#39;Hi&#39;</span><br><span class="line">&#125;</span><br><span class="line">console.log(s);  &#x2F;&#x2F; Error — ReferenceError: s is not defined</span><br><span class="line">greeting();</span><br><span class="line">console.log(undeclaredVar) &#x2F;&#x2F; &#39;I am automatically created in global scope&#39; </span><br></pre></td></tr></table></figure>
<p>ES6 中我们有了 <code>let</code> 和 <code>const</code> 这两个新的关键字。它们不会被提升，且可以在块级作用域内生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g1 &#x3D; &#39;global 1&#39;</span><br><span class="line">let g2 &#x3D; &#39;global 2&#39;</span><br><span class="line">&#123;   &#x2F;* Creating a new block scope *&#x2F;</span><br><span class="line">  g1 &#x3D; &#39;new global 1&#39;</span><br><span class="line">  let g2 &#x3D; &#39;local global 2&#39;</span><br><span class="line">  console.log(g1)   &#x2F;&#x2F; &#39;new global 1&#39;</span><br><span class="line">  console.log(g2)   &#x2F;&#x2F; &#39;local global 2&#39;</span><br><span class="line">  console.log(g3)   &#x2F;&#x2F; ReferenceError: g3 is not defined</span><br><span class="line">  let g3 &#x3D; &#39;I am not hoisted&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(g1)    &#x2F;&#x2F; &#39;new global 1&#39;</span><br><span class="line">console.log(g2)    &#x2F;&#x2F; &#39;global 2&#39; </span><br></pre></td></tr></table></figure>
<p>另外有一个普遍的误解是 <code>const</code> 是不可变的。事实上它只是不能被重新赋值，但其指向的值是可以被操作的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tryMe &#x3D; &#39;initial assignment&#39;;</span><br><span class="line">tryMe &#x3D; &#39;this has been reassigned&#39;;  &#x2F;&#x2F; TypeError: Assignment to constant variable.</span><br><span class="line">&#x2F;&#x2F; You cannot reassign but you can change it…</span><br><span class="line">const array &#x3D; [&#39;Ted&#39;, &#39;is&#39;, &#39;awesome!&#39;];</span><br><span class="line">array[0] &#x3D; &#39;Barney&#39;;</span><br><span class="line">array[3] &#x3D; &#39;Suit up!&#39;;</span><br><span class="line">console.log(array);     &#x2F;&#x2F; [“Barney”, “is”, “awesome!”, “Suit up!”]</span><br><span class="line">const airplane &#x3D; &#123;&#125;;</span><br><span class="line">airplane.wings &#x3D; 2;</span><br><span class="line">airplane.passengers &#x3D; 200;</span><br><span class="line">console.log(airplane);   &#x2F;&#x2F; &#123;passengers: 200, wings: 2&#125; </span><br></pre></td></tr></table></figure>
<h1 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 Closure"></a>闭包 Closure</h1><p>闭包是一个函数及其词法环境的组合。闭包可以让我们在一个函数的作用范围外访问其内部的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHi(name)&#123;</span><br><span class="line">  var message &#x3D; &#96;Hi $&#123;name&#125;!&#96;;</span><br><span class="line">  function greeting() &#123;</span><br><span class="line">    console.log(message)</span><br><span class="line">  &#125;</span><br><span class="line">  return greeting</span><br><span class="line">&#125;</span><br><span class="line">var sayHiToJon &#x3D; sayHi(&#39;Jon&#39;);</span><br><span class="line">console.log(sayHiToJon)     &#x2F;&#x2F; ƒ() &#123; console.log(message) &#125;</span><br><span class="line">console.log(sayHiToJon())   &#x2F;&#x2F; &#39;Hi Jon!&#39; </span><br></pre></td></tr></table></figure>
<ol>
<li>获取变量到外部作用域。</li>
</ol>
<p>返回的 <code>greeting</code> 方法访问了其内部作用域的 <code>message</code> 变量。</p>
<ol start="2">
<li>即使在外部函数返回之后也能访问到作用域外的变量。</li>
</ol>
<p><code>sayHiToJon</code> 是在调用 <code>sayHi</code> 方法时对 <code>greeting</code> 的引用。这样我们就能够通过 <code>greeting</code> 访问到作用域外的 <code>message</code> 变量。</p>
<p>闭包比较有用的地方在于我们可以用它来实现<strong>数据封装</strong>。有一些理念认为，有些数据不应该直接暴露在外，我们举个栗子来说明：</p>
<p>例如在下面这段代码当中，我们只能过通过 <code>elementary</code> 的实例来访问和操作 <code>SpringfieldSchool</code> 内部的 <code>staff</code> 变量，而不用担心其在其他地方被改动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SpringfieldSchool() &#123;</span><br><span class="line">  let staff &#x3D; [&#39;Seymour Skinner&#39;, &#39;Edna Krabappel&#39;];</span><br><span class="line">  return &#123;</span><br><span class="line">    getStaff: function() &#123; console.log(staff) &#125;,</span><br><span class="line">    addStaff: function(name) &#123; staff.push(name) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let elementary &#x3D; SpringfieldSchool()</span><br><span class="line">console.log(elementary)        &#x2F;&#x2F; &#123; getStaff: ƒ, addStaff: ƒ &#125;</span><br><span class="line">console.log(staff)             &#x2F;&#x2F; ReferenceError: staff is not defined</span><br><span class="line">&#x2F;* Closure allows access to the staff variable *&#x2F;</span><br><span class="line">elementary.getStaff()          &#x2F;&#x2F; [&quot;Seymour Skinner&quot;, &quot;Edna Krabappel&quot;]</span><br><span class="line">elementary.addStaff(&#39;Otto Mann&#39;)</span><br><span class="line">elementary.getStaff()          &#x2F;&#x2F; [&quot;Seymour Skinner&quot;, &quot;Edna Krabappel&quot;, &quot;Otto Mann&quot;] </span><br></pre></td></tr></table></figure>
<p>我们接着再来用闭包解决一个面试中最常见的问题吧：</p>
<p>下面这段代码存在什么问题？如何输出我们想要的结果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 12, 15, 21];</span><br><span class="line">for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&#96;The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;&#96;);</span><br><span class="line">  &#125;, (i+1) * 1000);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这段代码执行的输出结果中，每次 <code>i</code> 都等于4.这是因为 <code>setTimeout</code> 方法执行的时候，循环早已运行结束。</p>
<p>我们可以通过立即执行函数 IIFE 来解决这个问题，它可以创建出独立的作用域来存储每次传入 <code>i</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 12, 15, 21];</span><br><span class="line">for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(&#96;The value $&#123;arr[j]&#125; is at index: $&#123;j&#125;&#96;);</span><br><span class="line">    &#125;, j * 1000);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>另外一个更简洁的答案是使用 <code>let</code> 关键字来声明变量 <code>i</code>，也能够得到相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 12, 15, 21];</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&#96;The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;&#96;);</span><br><span class="line">  &#125;, (i) * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式 IIFE"></a>立即执行函数表达式 IIFE</h1><p>正如其名，立即执行函数在定义时就会被执行。我们通常在创建一个新的变量作用域时使用到它。</p>
<p>表达式外的括号用来和函数声明作以区分。</p>
<p>结尾的括号表示对函数的调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result &#x3D; [];</span><br><span class="line">for (var i&#x3D;0; i &lt; 5; i++) &#123;</span><br><span class="line">  result.push( function() &#123; return i &#125; );</span><br><span class="line">&#125;</span><br><span class="line">console.log( result[1]() ); &#x2F;&#x2F; 5</span><br><span class="line">console.log( result[3]() ); &#x2F;&#x2F; 5</span><br><span class="line">result &#x3D; [];</span><br><span class="line">for (var i&#x3D;0; i &lt; 5; i++) &#123;</span><br><span class="line">  (function () &#123;</span><br><span class="line">    var j &#x3D; i; &#x2F;&#x2F; copy current value of i</span><br><span class="line">    result.push( function() &#123; return j &#125; );</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">console.log( result[1]() ); &#x2F;&#x2F; 1</span><br><span class="line">console.log( result[3]() ); &#x2F;&#x2F; 3 </span><br></pre></td></tr></table></figure>
<p>通过使用IIFE你可以：</p>
<ul>
<li><p>使你能过添加私有数据到一个方法中</p>
</li>
<li><p>创建新的作用环境</p>
</li>
<li><p>防止污染全局命名空间</p>
</li>
</ul>
<h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>上下文的概念经常会同作用域之间混淆。为了保持条理清晰，我们需要注意以下两条：</p>
<ul>
<li>上下文是在函数被调用时确定的。它通常指的是你的代码当中某一部分的值。</li>
<li></li>
<li>作用域值的则是变量能过被访问到的范围。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 作用域</span><br><span class="line">var param &#x3D; 1;      &#x2F;&#x2F; global scope</span><br><span class="line">function myScope()&#123;</span><br><span class="line">    var param &#x3D; 2;     &#x2F;&#x2F; local scope</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 上下文</span><br><span class="line">this.prop &#x3D; 1;      &#x2F;&#x2F; global context</span><br><span class="line">function myContext()&#123;</span><br><span class="line">    this.prop &#x3D; 2;   &#x2F;&#x2F; local context</span><br><span class="line">&#125;</span><br><span class="line">var myInstance &#x3D; new myContext(); </span><br></pre></td></tr></table></figure>
<p>例如上述实例当中调用 <code>this</code> 的位置不同，<code>this</code> 的指向也是不同的，也就表示着不同的上下文；而作用域则是我们在编写代码时使用 <code>var</code> 关键字来确定的。</p>
<h1 id="函数调用方式：call-apply-bind"><a href="#函数调用方式：call-apply-bind" class="headerlink" title="函数调用方式：call apply bind"></a>函数调用方式：call apply bind</h1><p>这三种方法可以改变函数调用时 <code>this</code> 的指向，区别则在于函数调用的时候。</p>
<ul>
<li><p><code>.call()</code> 会立即调用函数，并要求你按次序一个个传入参数。</p>
</li>
<li><p><code>.apply()</code> 也会立即调用函数，不过你需要以数组的形式传参。</p>
</li>
<li><p><code>.call()</code> 和 <code>.apply()</code> 效用几乎是相同的，它们都可以用来调用对象中的某个方法，具体怎么使用取决于你的使用场景里如何传参更方便。</p>
</li>
</ul>
<p>应用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Snow &#x3D; &#123;surename: &#39;Snow&#39;&#125;</span><br><span class="line">const char &#x3D; &#123;</span><br><span class="line">  surename: &#39;Stark&#39;,</span><br><span class="line">  knows: function(arg, name) &#123;</span><br><span class="line">    console.log(&#96;You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">char.knows(&#39;something&#39;, &#39;Bran&#39;);              &#x2F;&#x2F; You know something, Bran Stark</span><br><span class="line">char.knows.call(Snow, &#39;nothing&#39;, &#39;Jon&#39;);      &#x2F;&#x2F; You know nothing, Jon Snow</span><br><span class="line">char.knows.apply(Snow, [&#39;nothing&#39;, &#39;Jon&#39;]);   &#x2F;&#x2F; You know nothing, Jon Snow </span><br></pre></td></tr></table></figure>
<p>注意： 如果你在使用 <code>.call()</code> 时传入了数组形式的参数，它会把整个数组当作一个参数使用。</p>
<p>不过在 ES6 里你倒是可以试试展开操作符的方法进行传参：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char.knows.call(Snow, ...[&quot;nothing&quot;, &quot;Jon&quot;]);  &#x2F;&#x2F; You know nothing, Jon Snow </span><br></pre></td></tr></table></figure>
<p><code>.bind()</code> 不会直接触发某个方法，而是根据你传入的参数和上下文返回一个新的方法。当你想要在程序之后的某些上下文环境中调用一个方法时可以使用 <code>.bind()</code> 这种方式。</p>
<p>这在我们使用一些异步操作或者事件处理函数时非常有用。<code>.bind()</code> 的传参形式则类似于 <code>.call()</code> 你需要讲参数以逗号分隔传入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Snow &#x3D; &#123;surename: &#39;Snow&#39;&#125;</span><br><span class="line">const char &#x3D; &#123;</span><br><span class="line">  surename: &#39;Stark&#39;,</span><br><span class="line">  knows: function(arg, name) &#123;</span><br><span class="line">    console.log(&#96;You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;&#96;);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">const whoKnowsNothing &#x3D; char.knows.bind(Snow, &#39;nothing&#39;);</span><br><span class="line">whoKnowsNothing(&#39;Jon&#39;);  &#x2F;&#x2F; You know nothing, Jon Snow </span><br></pre></td></tr></table></figure>
<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>JavaScript 当中的 <code>this</code> 理解起来算比较复杂的。</p>
<p><code>this</code> 具体指向什么是由函数的执行上下文决定的（其实上一节已经有很多栗子了）。</p>
<p>关键字 <code>this</code> 类似于一个占位符。它会指向具体调用某个方法的对象。</p>
<p>下面这个检查表用来确定 <code>this</code> 的顺位规则：</p>
<ul>
<li><strong>new binding</strong> 当使用 <code>new</code> 关键字调用某个函数时，<code>this</code> 会被绑定到新构造的对象上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D;age;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">const Rachel &#x3D; new Person(&#39;Rachel&#39;, 30);   &#x2F;&#x2F; &#123; age: 30, name: &#39;Rachel&#39; &#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>显式绑定</strong> 当使用 <code>call</code> 或者 <code>apply</code> 方法调用函数时，<code>this</code> 会指向我们传入的对象。<code>bind</code> 我们在前面已经介绍过了，返回的是一个新的函数而不是直接调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var agent &#x3D; &#123;id: &#39;007&#39;&#125;;</span><br><span class="line">fn.call(agent);    &#x2F;&#x2F; &#123; id: &#39;007&#39; &#125;</span><br><span class="line">fn.apply(agent);   &#x2F;&#x2F; &#123; id: &#39;007&#39; &#125;</span><br><span class="line">var boundFn &#x3D; fn.bind(agent);</span><br><span class="line">boundFn();         &#x2F;&#x2F; &#123; id: &#39;007&#39; &#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>隐式绑定</strong> 当我们在某一具体上下文中调用一个函数时，<code>this</code> 会指向这个函数所属的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var building &#x3D; &#123;</span><br><span class="line">  floors: 5,</span><br><span class="line">  printThis: function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">building.printThis();  &#x2F;&#x2F; &#123; floors: 5, printThis: function() &#123;…&#125; &#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>默认绑定</strong> 如果函数在调用时不遵从上述所有规则，那么 <code>this</code> 会被绑定在全局对象上（在浏览器里，这个全局对象就是 <code>window</code>）。</li>
</ul>
<p>这种情况会在我们定义独立函数时出现，如果一个函数在定义时不属于任何对象，它就会默认成为全局对象的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function printWindow() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">printWindow();  &#x2F;&#x2F; window object </span><br></pre></td></tr></table></figure>
<p>注意： 即使是在不同的作用域下，调用这种独立函数也不会改变其 <code>this</code> 的指向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dinosaur(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  inner();</span><br><span class="line">  function inner() &#123;</span><br><span class="line">    alert(this);        &#x2F;&#x2F; window object — the function has overwritten the &#39;this&#39; context</span><br><span class="line">    console.log(self);  &#x2F;&#x2F; &#123;name: &#39;Dino&#39;&#125; — referencing the stored value from the outer context</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myDinosaur &#x3D; new Dinosaur(&#39;Dino&#39;); </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>语法绑定</strong> 当你以 <code>=&gt;</code> 箭头函数的形式调用某一方法时，相当于为其传入了当前执行上下文的 <code>this</code> 值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Cat(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  console.log(this);   &#x2F;&#x2F; &#123; name: &#39;Garfield&#39; &#125;</span><br><span class="line">  ( () &#x3D;&gt; console.log(this) )();   &#x2F;&#x2F; &#123; name: &#39;Garfield&#39; &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myCat &#x3D; new Cat(&#39;Garfield&#39;); </span><br></pre></td></tr></table></figure>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>我们可以通过使用<code>&quot;use strict&quot;</code>指令来启用 JavaScript 的严格模式。它会为你的代码添加更多的限制及错误处理。</p>
<p>使用严格模式的好处有：</p>
<ul>
<li><p>更方便调试 你能够看到更多的报错，例如在你试图为只读的全局对象或属性赋值时。</p>
</li>
<li><p>防止意外产生全局变量 对未声明的变量进行赋值时会报错。</p>
</li>
<li><p>禁止无效的删除操作 尝试删除变量、函数、不可删除的属性时会报错。</p>
</li>
<li><p>禁止重复的属性名及参数 如果有命名重复的属性名或者参数值就会报错。</p>
</li>
<li><p>让 eval() 的调用更加安全 在 eval() 方法内部定义的变量及函数不会污染其他作用域。</p>
</li>
<li><p>禁止 this 指向全局对象 当 this 的值为 null 或者 undefined 时不会再默认指向到全局对象。这也就意味着在函数内部的 this 不会再默认指向 window 对象了。</p>
</li>
</ul>
<h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><p>关键字 <code>new</code> 是一种非常特殊的调用函数的方法，被通过 <code>new</code> 关键字调用的函数被称为<strong>构造函数</strong>。</p>
<p>所以 <code>new</code> 到底进行了哪些操作呢？</p>
<ul>
<li><p>创建了一个新的对象。</p>
</li>
<li><p>新对象的原型继承自构造函数的原型。</p>
</li>
<li><p>以新对象的 <code>this</code> 执行构造函数。</p>
</li>
<li><p>返回新的对象。如果构造函数返回了一个对象，那么这个对象会取代整个 <code>new</code> 出来的结果。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; In order to better understand what happens under the hood, lets build the new keyword </span><br><span class="line">function myNew(constructor) &#123;</span><br><span class="line">  var obj &#x3D; &#123;&#125;</span><br><span class="line">  Object.setPrototypeOf(obj, constructor.prototype);</span><br><span class="line">  return constructor.apply(obj, [...arguments].slice(1)) || obj</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>那么在调用函数时使用 <code>new</code> 关键字与否到底有什么区别呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Bird() &#123;</span><br><span class="line">  this.wings &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* invoking as a normal function *&#x2F;</span><br><span class="line">let fakeBird &#x3D; Bird();</span><br><span class="line">console.log(fakeBird);    &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;* invoking as a constructor function *&#x2F;</span><br><span class="line">let realBird&#x3D; new Bird();</span><br><span class="line">console.log(realBird)     &#x2F;&#x2F; &#123; wings: 2 &#125; </span><br></pre></td></tr></table></figure>
<h1 id="原型与继承"><a href="#原型与继承" class="headerlink" title="原型与继承"></a>原型与继承</h1><p>原型是 JavaScript 当中最容易造成困惑的一个概念。原因之一是因为<strong>原型</strong>这个词会在两个语境下使用：</p>
<ul>
<li>原型关系</li>
</ul>
<p>每个对象都有自己的原型对象，并会继承它原型的所有属性。</p>
<p>你可以通过 <code>.__proto__</code> 这种非标准的机制来获取一个对象的原型（在ES6中，在 ES5 标准里还可以通过 <code>Object.getPrototypeOf() </code>方法来获取）。</p>
<p>一般的对象还会继承一个叫做 <code>.constructor</code> 的属性指向其构造函数。当你使用构造函数生成一个对象时，其 <code>.__proto__</code> 属性会指向构造函数的 <code>.prototype</code> 属性。</p>
<ul>
<li>原型属性</li>
</ul>
<p>每个被定义的函数都有一个名为 <code>.prototype</code> 的属性。</p>
<p>它是一个继承了原型链上所有属性的对象。这个对象也默认包括一个 <code>.constructor</code> 属性，指向原始的构造函数。</p>
<p>所有用构造函数生成的对象也会继承一个指向这个函数的 <code>.constructor</code> 属性（用控制台把对象打出来会比较好理解，也可以看下面的示例）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dog(breed, name)&#123;</span><br><span class="line">  this.breed &#x3D; breed,</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.describe &#x3D; function() &#123;</span><br><span class="line">  console.log(&#96;$&#123;this.name&#125; is a $&#123;this.breed&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line">const rusty &#x3D; new Dog(&#39;Beagle&#39;, &#39;Rusty&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;* .prototype property points to an object which has constructor and attached </span><br><span class="line">properties to be inherited by objects created by this constructor. *&#x2F;</span><br><span class="line">console.log(Dog.prototype)  &#x2F;&#x2F; &#123; describe: ƒ , constructor: ƒ &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Object created from Dog constructor function *&#x2F;</span><br><span class="line">console.log(rusty)   &#x2F;&#x2F;  &#123; breed: &quot;Beagle&quot;, name: &quot;Rusty&quot; &#125;</span><br><span class="line">&#x2F;* Object inherited properties from constructor function&#39;s prototype *&#x2F;</span><br><span class="line">console.log(rusty.describe())   &#x2F;&#x2F; &quot;Rusty is a Beagle&quot;</span><br><span class="line">&#x2F;* .__proto__ property points to the .prototype property of the constructor function *&#x2F; </span><br><span class="line">console.log(rusty.__proto__)    &#x2F;&#x2F; &#123; describe: ƒ , constructor: ƒ &#125;</span><br><span class="line">&#x2F;* .constructor property points to the constructor of the object *&#x2F;</span><br><span class="line">console.log(rusty.constructor)  &#x2F;&#x2F; ƒ Dog(breed, name) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链描述了对象之间相互引用的关系。</p>
<p>当获取一个对象的属性时，JavaScript 引擎会先从这个对象本身开始查找。如果没有找到，就会转向其原型上的属性，直到第一次找到这个属性为止。原型链上的最后一个对象是内置的 <code>Object.prototype</code> 而它的原型则是 <code>null</code>（也就是所谓原型链的终点）。JavaScript 引擎在查找属性到这一层还是没有找到时就会返回 <code>undefined</code>.</p>
<h2 id="自有属性与继承属性"><a href="#自有属性与继承属性" class="headerlink" title="自有属性与继承属性"></a>自有属性与继承属性</h2><p>对象的属性分为自有和继承两种。</p>
<p>自有属性也就是在对象内部定义的属性。</p>
<p>继承属性则是通过原型链获得的属性。继承属性是不可枚举的（也就是在 <code>for/in</code> 循环里看不到的）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Car() &#123; &#125;</span><br><span class="line">Car.prototype.wheels &#x3D; 4;</span><br><span class="line">Car.prototype.airbags &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var myCar &#x3D; new Car();</span><br><span class="line">myCar.color &#x3D; &#39;black&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*  Check for Property including Prototype Chain:  *&#x2F;</span><br><span class="line">console.log(&#39;airbags&#39; in myCar)  &#x2F;&#x2F; true</span><br><span class="line">console.log(myCar.wheels)        &#x2F;&#x2F; 4</span><br><span class="line">console.log(myCar.year)          &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;*  Check for Own Property:  *&#x2F;</span><br><span class="line">console.log(myCar.hasOwnProperty(&#39;airbags&#39;))  &#x2F;&#x2F; false — Inherited</span><br><span class="line">console.log(myCar.hasOwnProperty(&#39;color&#39;))    &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><strong>Object.create(obj)</strong> 方法可以指定原型来创建对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dog &#x3D; &#123; legs: 4 &#125;;</span><br><span class="line">var myDog &#x3D; Object.create(dog);</span><br><span class="line"></span><br><span class="line">console.log(myDog.hasOwnProperty(&#39;legs&#39;))  &#x2F;&#x2F; false</span><br><span class="line">console.log(myDog.legs)                    &#x2F;&#x2F; 4</span><br><span class="line">console.log(myDog.__proto__ &#x3D;&#x3D;&#x3D; dog)       &#x2F;&#x2F; true </span><br></pre></td></tr></table></figure>
<h2 id="通过引用继承"><a href="#通过引用继承" class="headerlink" title="通过引用继承"></a>通过引用继承</h2><p>继承属性是原型对象上属性的一份引用拷贝。</p>
<p>如果对象在原型上的属性被改变了，继承这一属性的对象也会受到相同的影响。但假如属性被整个替换掉了，则不会影响到继承的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var objProt &#x3D; &#123; text: &#39;original&#39; &#125;;</span><br><span class="line">var objAttachedToProt &#x3D; Object.create(objProt);</span><br><span class="line">console.log(objAttachedToProt.text)   &#x2F;&#x2F; original</span><br><span class="line"></span><br><span class="line">objProt.text &#x3D; &#39;prototype property changed&#39;;</span><br><span class="line">console.log(objAttachedToProt.text)   &#x2F;&#x2F; prototype property changed</span><br><span class="line"></span><br><span class="line">objProt &#x3D; &#123; text: &#39;replacing property&#39; &#125;;</span><br><span class="line">console.log(objAttachedToProt.text)   &#x2F;&#x2F; prototype property changed </span><br></pre></td></tr></table></figure>
<h2 id="类继承与原型继承"><a href="#类继承与原型继承" class="headerlink" title="类继承与原型继承"></a>类继承与原型继承</h2><p>在类继承模式当中，对象继承自各式各样的类。就好像为对象设置好了一些模版和描述，并创建出了子类关系。我们可以通过 <code>new</code> 关键字从构造函数中创建这样的对象。</p>
<p>但类继承模式有以下这些缺点：</p>
<ul>
<li><p>死板的层级关系</p>
</li>
<li><p>高度耦合</p>
</li>
<li><p>基类薄弱</p>
</li>
<li><p>代码重复</p>
</li>
<li><p>以及传说中的大猩猩/香蕉问题——“What you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle.”</p>
</li>
</ul>
<p>在原型继承模式中，一个对象可以直接继承另一个对象。我们可以通过 <code>Object.create()</code> 或者其他对象方法及工厂函数来创建对象。</p>
<p>下面是三种不同的原型继承的形式：</p>
<ul>
<li><p>原型代理 我们通常称那些用来给其他对象提供模型的对象为代理原型。当你继承一个代理原型时，新的对象可以获取对代理原型属性的引用。这种操作通常使用 Object.create() 来完成。</p>
</li>
<li><p>拼接继承 通过拷贝一个对象的属性来进行继承，不会产生引用关系，这种操作通常使用 Object.assign() 来进行。</p>
</li>
<li><p>函数继承 这种方法是通过工厂函数（工厂函数是指不通过 new 关键字创建并返回对象的函数）来创建对象，然后直接将新的属性添加到对象上。这种形式的好处是我们可以使用闭包进行数据封装。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; function(name) &#123;</span><br><span class="line">  const message &#x3D; &#96;Hello! My name is $&#123;name&#125;&#96;;</span><br><span class="line">  return &#123; greeting: () &#x3D;&gt; console.log(message) &#125;</span><br><span class="line">&#125;</span><br><span class="line">const will &#x3D; person(&quot;Will&quot;);</span><br><span class="line">will.greeting();     &#x2F;&#x2F; Hello! My name is Will </span><br></pre></td></tr></table></figure>
<h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><p>开发者都公认在大多数情况下应该避免使用类继承。因为在这种模式下，你需要很清楚地定义设计你的代码它们是什么。</p>
<p>而另一方面，组合的模式则允许你从你的代码要做什么的角度来定义，从而提高你代码的灵活度和可复用性（React组件就是一个非常好的栗子）。</p>
<h1 id="JavaScript-异步"><a href="#JavaScript-异步" class="headerlink" title="JavaScript 异步"></a>JavaScript 异步</h1><p>JavaScript 是一种单线程编程语言。这意味着 JavaScript 引擎一次只能处理一段代码。其主要影响之一是，当 JavaScript 遇到一段需要很长时间处理的代码时，它会阻塞后续的代码运行。</p>
<p>JavaScript 使用了一种存储运行函数信息的数据结构叫做<strong>调用栈</strong>。你可以吧调用栈想象为一摞书。每本放上去的书都会在之前的一摞书上面。最后放上去的书会最早被拿走，最先放上去的书则到最后才会被拿走（LIFO）。</p>
<p>用来解决大段代码非阻塞执行的方法叫做异步回调函数。这类函数可以推迟执行。</p>
<p>异步过程从一个放入堆或内存中的异步回调函数开始。你可以将堆视为一个<strong>事件管理器（事件队列）</strong>。调用栈可以访问事件管理器只在某个事件发生时才执行特定的函数。当某个事件发生后，事件管理器就会将该函数移至回调用队列。<em>注意：当事件管理器处理一个函数时，之后的代码不会被阻塞并且能继续执行</em>。</p>
<p>调用栈会不断检查其是否空闲。当它空闲时，如果有一个等待被调用的函数，则会检查调用队列。当有函数在等待执行时，队列中的第一个函数被压入调用栈并执行。这一过程被称为事件循环当中的一次执行循环.</p>
<p>我们还是用一个栗子来解释吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const first &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;First message&#39;)</span><br><span class="line">&#125;</span><br><span class="line">const second &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;Second message&#39;)</span><br><span class="line">&#125;</span><br><span class="line">const third &#x3D; function() &#123;</span><br><span class="line">  console.log(&#39;Third message&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">setTimeout(second, 0);</span><br><span class="line">third();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">  &#x2F;&#x2F; First message</span><br><span class="line">  &#x2F;&#x2F; Third message</span><br><span class="line">  &#x2F;&#x2F; Second message </span><br></pre></td></tr></table></figure>
<ol>
<li><p>初始化浏览器的控制台，清空调用栈及事件管理器。</p>
</li>
<li><p>first() 加入调用栈。</p>
</li>
<li><p>console.log(“First message”) 加入调用栈。</p>
</li>
<li><p>console.log(“First message”) 被执行并在浏览器控制台打印出”First message”.</p>
</li>
<li><p>console.log(“First message”) 被移出调用栈。</p>
</li>
<li><p>first() 被移出调用栈。</p>
</li>
<li><p>setTimeout(second, 0) 加入调用栈。</p>
</li>
<li><p>setTimeout(second, 0) 被执行并由事件管理器管理。0ms 之后事件管理器将 second() 移入调用队列。</p>
</li>
<li><p>setTimeout(second, 0) 完成执行并被移出调用栈。</p>
</li>
<li><p>third() 加入调用栈。</p>
</li>
<li><p>console.log(“Third message”) 加入调用栈。</p>
</li>
<li><p>console.log(“Third message”) 被执行并在浏览器控制台打印出”Third message”.</p>
</li>
<li><p>console.log(“Third message”) 被移出调用栈。</p>
</li>
<li><p>third() 被移出调用栈。</p>
</li>
<li><p>调用栈空闲，second() 在调用队列中等待执行。</p>
</li>
<li><p>事件管理器将 second() 从调用队列中移入调用栈。</p>
</li>
<li><p>console.log(“Second message”) 加入调用栈。</p>
</li>
<li><p>console.log(“Second message”) 被执行并在浏览器控制台打印出”Second message”.</p>
</li>
<li><p>console.log(“Second message”) 被移出调用栈。</p>
</li>
<li><p>second() 被移出调用栈。</p>
</li>
</ol>
<p><em>注意：你为 setTimeout 方法传入的时间参数并不是 second() 延迟执行的时间，而是<strong>事件管理器（事件队列）</strong>将函数移入调用栈的等待时间。</em></p>
]]></content>
      <tags>
        <tag>Javascript 概念 理论</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件间通讯</title>
    <url>/2018/10/22/React%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p>作者： From 淘宝前端团队</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p>
<p><img src="http://img.alicdn.com/tfs/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png"></p>
<a id="more"></a>

<p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p>
<p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p>
<p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p>
<p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p>
<h1 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h1><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg: &#39;end&#39;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Child_1 msg&#x3D;&#123;this.state.msg&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p&gt;&#123;this.props.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 … 运算符（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 … 运算符 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息</span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.props.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Child_1_1 &#123;...this.props&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p&gt;&#123;this.props.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h1><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;p&gt;child msg: &#123;this.state.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;Child_1 transferMsg &#x3D; &#123;msg &#x3D;&gt; this.transferMsg(msg)&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      this.props.transferMsg(&#39;end&#39;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用了 箭头函数，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 this 仍指向父组件。</p>
<p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 … 运算符，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p>
<h1 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h1><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Parent update&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child_1 transferMsg &#x3D; &#123;msg &#x3D;&gt; this.transferMsg(msg)&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child_2 msg &#x3D; &#123;this.state.msg&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      this.props.transferMsg(&#39;end&#39;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Child_1 update&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Child_2 update&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2 component: &#123;this.props.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Child_2_1 &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2_1 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Child_2_1 update&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2_1 component&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p>
<p><img src="https://img.alicdn.com/tfs/TB1VjpZNVXXXXcIXXXXXXXXXXXX-268-152.png"></p>
<p>有没有更好的解决方式来进行兄弟组件间的通讯，甚至是父子组件层级较深的通讯的呢？</p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>在传统的前端解耦方面，观察者模式作为比较常见一种设计模式，大量使用在各种框架类库的设计当中。即使我们在写 React，在写 JSX，我们核心的部分还是 JavaScript。</p>
<p>观察者模式也叫 发布者-订阅者模式，发布者发布事件，订阅者监听事件并做出反应，对于上面的代码，我们引入一个小模块，使用观察者模式进行改造。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import eventProxy from &#39;..&#x2F;eventProxy&#39;</span><br><span class="line"></span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child_1&#x2F;&gt;</span><br><span class="line">        &lt;Child_2&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; componentDidUpdate 与 render 方法与上例一致</span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 发布 msg 事件</span><br><span class="line">      eventProxy.trigger(&#39;msg&#39;, &#39;end&#39;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; componentDidUpdate 方法与上例一致</span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">  	&#x2F;&#x2F; 监听 msg 事件</span><br><span class="line">    eventProxy.on(&#39;msg&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        msg</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2 component: &#123;this.state.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;Child_2_1 &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在 child_2 组件的 componentDidMount 中订阅了 msg 事件，并在 child_1 componentDidMount 中，在 1s 后发布了 msg 事件，child_2 组件对 msg 事件做出相应，更新了自身的 state，我们可以看到，由于在整个通讯过程中，只改变了 child_2 的 state，因而只有 child_2 和 child_2_1 出发了一次更新的生命周期。</p>
<p><img src="https://img.alicdn.com/tfs/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png"></p>
<p>而上面代码中，神奇的 eventProxy.js 究竟是怎样的一回事呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; eventProxy.js</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">const eventProxy &#x3D; &#123;</span><br><span class="line">  onObj: &#123;&#125;,</span><br><span class="line">  oneObj: &#123;&#125;,</span><br><span class="line">  on: function(key, fn) &#123;</span><br><span class="line">    if(this.onObj[key] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      this.onObj[key] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.onObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  one: function(key, fn) &#123;</span><br><span class="line">    if(this.oneObj[key] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">      this.oneObj[key] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.oneObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  off: function(key) &#123;</span><br><span class="line">    this.onObj[key] &#x3D; [];</span><br><span class="line">    this.oneObj[key] &#x3D; [];</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger: function() &#123;</span><br><span class="line">    let key, args;</span><br><span class="line">    if(arguments.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    key &#x3D; arguments[0];</span><br><span class="line">    args &#x3D; [].concat(Array.prototype.slice.call(arguments, 1));</span><br><span class="line"></span><br><span class="line">    if(this.onObj[key] !&#x3D;&#x3D; undefined</span><br><span class="line">      &amp;&amp; this.onObj[key].length &gt; 0) &#123;</span><br><span class="line">      for(let i in this.onObj[key]) &#123;</span><br><span class="line">        this.onObj[key][i].apply(null, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(this.oneObj[key] !&#x3D;&#x3D; undefined</span><br><span class="line">      &amp;&amp; this.oneObj[key].length &gt; 0) &#123;</span><br><span class="line">      for(let i in this.oneObj[key]) &#123;</span><br><span class="line">        this.oneObj[key][i].apply(null, args);</span><br><span class="line">        this.oneObj[key][i] &#x3D; undefined;</span><br><span class="line">      &#125;</span><br><span class="line">      this.oneObj[key] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default eventProxy;</span><br></pre></td></tr></table></figure>
<p>eventProxy 中，总共有 on、one、off、trigger 这 4 个函数：</p>
<ul>
<li><p>on、one：on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</p>
</li>
<li><p>trigger：trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</p>
</li>
<li><p>off：用于解除所有订阅了某个事件的所有函数。</p>
</li>
</ul>
<h1 id="Flux-与-Redux"><a href="#Flux-与-Redux" class="headerlink" title="Flux 与 Redux"></a>Flux 与 Redux</h1><p>Flux 作为 Facebook 发布的一种应用架构，他本身是一种模式，而不是一种框架，基于这个应用架构模式，在开源社区上产生了众多框架，其中最受欢迎的就是我们即将要说的 Redux。更多关于 Flux 和 Redux 的介绍这里就不一一展开，有兴趣的同学可以好好看看 Flux 官方介绍、Flux 架构入门教程–阮一峰等相关资料。<br>下面将来好好聊聊 Redux 在组件间通讯的方式。</p>
<p>Flux 需要四大部分组成：Dispatcher、Stores、Views/Controller-Views、Actions，其中的 Views/Controller-Views 可以理解为我们上面所说的 Parent 组件，其作用是从 state 当中获取到相应的数据，并将其传递给他的子组件（descendants）。而另外 3 个部分，则是由 Redux 来提供了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 该例子主要对各组件的 componentDidMount 进行改造，其余部分一致</span><br><span class="line">import &#123;createStore&#125; from &#39;redux&#39;</span><br><span class="line"></span><br><span class="line">function reducer(state &#x3D; &#123;&#125;, action) &#123;</span><br><span class="line">  return action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let store &#x3D; createStore(reducer);</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: &#39;child_2&#39;,</span><br><span class="line">        data: &#39;hello&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: &#39;child_2_1&#39;,</span><br><span class="line">        data: &#39;bye&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Child_2 update&#39;, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">      let state &#x3D; store.getState();</span><br><span class="line">      if (state.type &#x3D;&#x3D;&#x3D; &#39;child_2&#39;) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2_1 extends Component&#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    msg: &#39;start&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;Child_2_1 update&#39;, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">      let state &#x3D; store.getState();</span><br><span class="line">      if (state.type &#x3D;&#x3D;&#x3D; &#39;child_2_1&#39;) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2_1 component: &#123;this.state.msg&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们将一个名为 reducer 的函数作为参数，生成我们所需要的 store，reducer 接受两个参数，一个是存储在 store 里面的 state，另一个是每一次调用 dispatch 所传进来的 action。reducer 的作用，就是对 dispatch 传进来的 action 进行处理，并将结果返回。而里面的 state 可以通过 store 里面的 getState 方法进行获得，其结果与最后一次通过 reducer 处理后的结果保持一致。</p>
<p>在 child_1 组件中，我们每隔 1s 通过 store 的 dispatch 方法，向 store 传入包含有 type 字段的 action，reducer 直接将 action 进行返回。</p>
<p>而在 child_2 与 child_2_1 组件中，通过 store 的 subscribe 方法，监听 store 的变化，触发 dispatch 后，所有通过 subscribe 进行监听的函数都会作出相应，根据当前通过 store.getState() 获取到的结果进行处理，对当前组件的 state 进行设置。所以我们可以在控制台上看到各个组件更新及存储在 store 中 state 的情况：</p>
<p><img src="https://img.alicdn.com/tfs/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png"></p>
<p>在 Redux 中，store 的作用，与 MVC 中的 Model 类似，可以将我们项目中的数据传递给 store，交给 store 进行处理，并可以实时通过 store.getState() 获取到存储在 store 中的数据。我们对上面例子的 reducer 及各个组件的 componentDidMount 做点小修改，看看 store 的这一个特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore&#125; from &#39;redux&#39;</span><br><span class="line"></span><br><span class="line">function reducer(state &#x3D; &#123;&#125;, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;child_2&#39;:</span><br><span class="line">      state.child_2 &#x3D; action.data + &#39; child_2&#39;;</span><br><span class="line">      return state;</span><br><span class="line">    case &#39;child_2_1&#39;:</span><br><span class="line">      state.child_2_1 &#x3D; action.data + &#39; child_2_1&#39;;</span><br><span class="line">      return state;</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let store &#x3D; createStore(reducer);</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: &#39;child_2&#39;,</span><br><span class="line">        data: &#39;hello&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: &#39;child_2_1&#39;,</span><br><span class="line">        data: &#39;bye&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">      let state &#x3D; store.getState();</span><br><span class="line"></span><br><span class="line">      if (state.hasOwnProperty(&#39;child_2&#39;)) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">      let state &#x3D; store.getState();</span><br><span class="line"></span><br><span class="line">      if (state.hasOwnProperty(&#39;child_2_1&#39;)) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          msg: state.child_2_1</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对创建 store 时所传进去的 reducer 进行修改。reducer 中，其参数 state 为当前 store 的值，我们对不同的 action 进行处理，并将处理后的结果存储在 state 中并进行返回。此时，通过 store.getState() 获取到的，就是我们处理完成后的 state。</p>
<p><img src="https://img.alicdn.com/tfs/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png"></p>
<p>Redux 内部的实现，其实也是基于观察者模式的，reducer 的调用结果，存储在 store 内部的 state 中，并在每一次 reducer 的调用中并作为参数传入。所以在 child_1 组件第 2s 的 dispatch 后，child_2 与 child_2_1 组件通过 subscribe 监听的函数，其通过 getState 获得的值，都包含有 child_2 与 child_2_1 字段的，这就是为什么第 2s 后的响应，child_2 也进行了一次生命周期。所以在对 subscribe 响应后的处理，最好还是先校对通过 getState() 获取到的 state 与当前组件的 state 是否相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; child_2</span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">      let state &#x3D; store.getState();</span><br><span class="line"></span><br><span class="line">      if (state.hasOwnProperty(&#39;child_2&#39;)</span><br><span class="line">        &amp;&amp; state.child_2 !&#x3D;&#x3D; this.state.msg) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>加上这样的校验，各个组件的生命周期的触发就符合我们的预期了。</p>
<p><img src="https://img.alicdn.com/tfs/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redux 对于组件间的解耦提供了很大的便利，如果你在考虑该不该使用 Redux 的时候，社区里有一句话说，“当你不知道该不该使用 Redux 的时候，那就是不需要的”。Redux 用起来一时爽，重构或者将项目留给后人的时候，就是个大坑，Redux 中的 dispatch 和 subscribe 方法遍布代码的每一个角落。刚刚的例子不是最好的，Flux 设计中的 Controller-Views 概念就是为了解决这个问题出发的，将所有的 subscribe 都置于 Parent 组件（Controller-Views），由最上层组件控制下层组件的表现，然而，这不就是我们所说的 子组件向父组件通讯 这种方式了。</p>
]]></content>
      <tags>
        <tag>react 组件 通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery核心代码详细解析</title>
    <url>/2018/02/20/jQuery%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>一直以来，工作中用到的工具就是jquery，之前也看过源码，但是没有对jquery系统地学习、总结过，虽然现在前端新的技术层出不穷，但jquery里的设计思想和编码技巧还是需要学习、借鉴的，这次趁着过年的时间抽空把jquery源码系统地学习了一遍，由于时间不是很充裕，所以只是把核心源码分析了一下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">( function ( window, undefined )&#123;&#x2F;&#x2F;沙箱模式</span><br><span class="line">  &#x2F;&#x2F;在ie中undefined可以被重写，所以形参把undefined传进来实参不传，以保证undefined本身不会被重写</span><br><span class="line"></span><br><span class="line">  var  arr &#x3D; [], push &#x3D; arr.push, slice &#x3D; arr.slice;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;调用原型的init方法，返回DOM元素伪数组</span><br><span class="line">  function $ ( html )&#123;</span><br><span class="line">    return new $.fn.init( html );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;给原型添加init方法，伪数组</span><br><span class="line">  &#x2F;&#x2F;给prototype取个别名fn</span><br><span class="line">  $.fn &#x3D; $.prototype &#x3D; &#123;</span><br><span class="line">    constructor: $,&#x2F;&#x2F;替换原型要手动添加constructor</span><br><span class="line">    length: 0,</span><br><span class="line">    selector: &#39;&#39;,</span><br><span class="line">    type: &#39;$&#39;,</span><br><span class="line">    init: function( html )&#123;&#x2F;&#x2F;初始化</span><br><span class="line">      &#x2F;&#x2F;如果参数为空  null undefined</span><br><span class="line">      if ( html &#x3D;&#x3D; null || html &#x3D;&#x3D;&#x3D; &#39;&#39; ) &#123;</span><br><span class="line">        this.events &#x3D; &#123;&#125;;</span><br><span class="line">        return;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;如果参数是函数(入口函数)</span><br><span class="line">      if ( typeof html &#x3D;&#x3D;&#x3D; &#39;function&#39; ) &#123;</span><br><span class="line">        var oldFn &#x3D; window.onload;</span><br><span class="line">        if ( typeof oldFn &#x3D;&#x3D;&#x3D; &#39;function&#39; ) &#123;</span><br><span class="line">          window.onload &#x3D; function()&#123;</span><br><span class="line">            oldFn();</span><br><span class="line">            html();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          window.onload &#x3D; html;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;如果参数是字符串</span><br><span class="line">      if ( $.isString( html )) &#123;</span><br><span class="line">        if ( &#x2F;^&lt;&#x2F;.test( html )) &#123;</span><br><span class="line">          push.apply( this, parseHTML( html ));</span><br><span class="line">        &#125;else&#123;&#x2F;&#x2F;如果是标签选择器</span><br><span class="line">          push.apply( this, $.select( html ));</span><br><span class="line">          this.selector &#x3D; html;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;如果是$对象,将传入的$对象所有元素都加到this中</span><br><span class="line">      if ( html &amp;&amp; html.type &#x3D;&#x3D;&#x3D; &#39;$&#39; ) &#123;</span><br><span class="line">        push.apply( this, html );</span><br><span class="line">        this.selector &#x3D; html.selector;</span><br><span class="line">        this.events &#x3D; html.events;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;如果是DOM对象</span><br><span class="line">      if ( html.nodeType ) &#123;</span><br><span class="line">        this[ 0 ] &#x3D; html;</span><br><span class="line">        push.call( this[ 0 ], html );</span><br><span class="line">      &#125;;</span><br><span class="line">      this.events &#x3D; &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    toArray: function()&#123;</span><br><span class="line">      return slice.call( this, 0 );</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function( index )&#123;</span><br><span class="line">      if ( index &#x3D;&#x3D;&#x3D; undefined ) &#123;</span><br><span class="line">        return this.toArray();</span><br><span class="line">      &#125;;</span><br><span class="line">      return this[ index ];</span><br><span class="line">    &#125;,</span><br><span class="line">    eq: function( num )&#123;</span><br><span class="line">      var dom;</span><br><span class="line">      if ( num &gt;&#x3D; 0 ) &#123;</span><br><span class="line">        dom &#x3D; this.get( num );</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        dom &#x3D; this.get( this.length + num );</span><br><span class="line">      &#125;</span><br><span class="line">      return $( dom );</span><br><span class="line">      &#x2F;&#x2F; return this.constructor( dom );&#x2F;&#x2F;包装成一个$对象</span><br><span class="line">    &#125;,</span><br><span class="line">    each: function( func )&#123;</span><br><span class="line">      return $.each( this, func );</span><br><span class="line">    &#125;,</span><br><span class="line">    map: function( func )&#123;</span><br><span class="line">      return $.map( this, func );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F;让init拥有$.prototype的方法，就让原型与$.prototype的指向相同</span><br><span class="line">  &#x2F;&#x2F;这样就有appendTo方法</span><br><span class="line">  $.fn.init.prototype &#x3D; $.fn;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;添加自定义可扩展的方法extend(混入式继承)</span><br><span class="line">  $.extend &#x3D; $.fn.extend &#x3D; function ( obj )&#123;</span><br><span class="line">    for ( var k in obj )&#123;</span><br><span class="line">      this[ k ] &#x3D; obj[ k ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;自己封装的基本、并集、后代选择器引擎</span><br><span class="line">  var select3 &#x3D; (function()&#123;</span><br><span class="line">    &#x2F;&#x2F;尝试用数组自带push方法，如果没有的话就自己定义一个</span><br><span class="line">    try &#123;</span><br><span class="line">      var div &#x3D; document.createElement( &#39;div&#39; );</span><br><span class="line">      div.innerHTML &#x3D; &#39;&lt;p&gt;&lt;&#x2F;p&gt;&#39;;</span><br><span class="line">      var arr &#x3D; [];</span><br><span class="line">      push.apply( arr, div.getElementsByTagName( &#39;p&#39; ));</span><br><span class="line">    &#125;catch ( e )&#123;&#x2F;&#x2F;如果不支持push方法就自己定义</span><br><span class="line">      push &#x3D; &#123;</span><br><span class="line">        apply: function ( array1, array2 )&#123;</span><br><span class="line">          for (var i &#x3D; 0; i &lt; array2.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;把array2添加到array1中</span><br><span class="line">            array1[ array1.length++ ] &#x3D; array2[ i ];</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;正则表达式</span><br><span class="line">    var rnative &#x3D; &#x2F;\&#123;\s*\[native&#x2F;;&#x2F;&#x2F;匹配浏览器支持就返回&#123; [native code] &#125;</span><br><span class="line">    var rtrim &#x3D; &#x2F;^\s+|\s+$&#x2F;;&#x2F;&#x2F;匹配字符串两端空格</span><br><span class="line">    &#x2F;&#x2F;        ?:匹配但不捕获      id:1      class:2   *:3  tag:4</span><br><span class="line">    var rbaseselector &#x3D; &#x2F;^(?:\#([\w\-]+)|\.([\w\-]+)|(\*)|(\w+))$&#x2F;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;浏览器能力检测</span><br><span class="line">    var support &#x3D; &#123;&#125;;</span><br><span class="line">    support.qsa &#x3D; rnative.test( document.querySelectorAll + &#39;&#39;);&#x2F;&#x2F;转换字符串</span><br><span class="line">    support.getElementsByClassName &#x3D; rnative.test( document.getElementsByClassName + &#39;&#39;);</span><br><span class="line">    support.trim &#x3D; rnative.test( String.prototype.trim + &#39;&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过类名获取元素的兼容性写法</span><br><span class="line">    function getByClassName( className, node )&#123;</span><br><span class="line">      node &#x3D; node || document;</span><br><span class="line">      var allElem, res &#x3D; [], i;</span><br><span class="line">      if ( support.getElementsByClassName )&#123;&#x2F;&#x2F;如果浏览器支持</span><br><span class="line">        return node.getElementsByClassName( className );</span><br><span class="line">      &#125;else&#123;&#x2F;&#x2F;不支持</span><br><span class="line">        allElem &#x3D; document.getElementsByTagName( &#39;*&#39; );</span><br><span class="line">        for (i &#x3D; 0; i &lt; allElem.length; i++) &#123;</span><br><span class="line">          if (( &#39; &#39; + allElem[ i ].className + &#39; &#39; ).indexOf( &#39; &#39; + className + &#39; &#39; ) &gt; -1 ) &#123;</span><br><span class="line">            res.push( allElem[ i ] );</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        return res;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自定义实现trim方法(去两端空格)</span><br><span class="line">    function myTrim( str )&#123;</span><br><span class="line">      if ( support.trim ) &#123;</span><br><span class="line">        return str.trim();</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return str.replace( rTrim, &#39; &#39; );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自定义indexOf方法</span><br><span class="line">    function myIndexOf ( array, search, startIndex )&#123;</span><br><span class="line">      startIndex &#x3D; startIndex || 0;&#x2F;&#x2F;设置开始查找索引默认值</span><br><span class="line">      if ( support.indexOf ) &#123;</span><br><span class="line">        return array.IndexOf( search, startIndex );</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">          if ( array[ i ] &#x3D;&#x3D;&#x3D; search ) &#123;</span><br><span class="line">            return i;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组去重</span><br><span class="line">    var unique &#x3D; function( array )&#123;</span><br><span class="line">      var resArray &#x3D; [], i &#x3D; 0;</span><br><span class="line">      for (; i &lt; array.length; i++) &#123;</span><br><span class="line">        if ( myIndexOf( resArray, array[ i ]) &#x3D;&#x3D;&#x3D; -1 ) &#123;</span><br><span class="line">          resArray.push( array[ i ]);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return resArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;基本选择器</span><br><span class="line">    function basicSelect( selector, node )&#123;</span><br><span class="line">      node &#x3D; node || document;</span><br><span class="line">      var m, res;</span><br><span class="line">      if ( m &#x3D; rbaseselector.exec( selector )) &#123;</span><br><span class="line">        if ( m[ 1 ]) &#123;&#x2F;&#x2F;id</span><br><span class="line">          res &#x3D; document.getElementById( m[ 1 ] );</span><br><span class="line">          return res ? [ res ] : [];&#x2F;&#x2F;如果没获取到就返回空数组</span><br><span class="line">        &#125;else if ( m[ 2 ]) &#123;&#x2F;&#x2F;class</span><br><span class="line">          return getByClassName( m[ 2 ], node );</span><br><span class="line">        &#125;else if ( m[ 3 ]) &#123;&#x2F;&#x2F;*</span><br><span class="line">          return node.getElementsByTagName( m[ 3 ] );</span><br><span class="line">        &#125;else&#123;&#x2F;&#x2F;tag</span><br><span class="line">          return node.getElementsByTagName( m[ 4 ] );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;后代选择器</span><br><span class="line">    function select2( selector, results )&#123;</span><br><span class="line">      results &#x3D; results || [];&#x2F;&#x2F;如果没传该参数就默认为[]</span><br><span class="line">      var selectors &#x3D; selector.split( &#39; &#39; );&#x2F;&#x2F;分割成数组</span><br><span class="line">      var arr &#x3D; [], node &#x3D; [ document ], i, j;</span><br><span class="line">    &#x2F;**假设&#39;div p .c&#39; 外层循环控制选择器的迭代次数(3次),node &#x3D; arr控制内层循环的次数</span><br><span class="line">     *第一次在document下查找div并把数组添加到node中</span><br><span class="line">     *arr.push.apply(arr,basicSelect(&#39;div&#39;,&#39;document&#39;));</span><br><span class="line">     *&#x3D;&#x3D;&gt;arr:[&#39;div&#39;]&#x3D;&#x3D;&gt;node:[&#39;div&#39;]&#x3D;&#x3D;&gt;arr:[]</span><br><span class="line">     *第二次在node成员div下查找p并把p添加到node中</span><br><span class="line">     *arr.push.apply(arr,basicSelect(&#39;p&#39;,&#39;div&#39;));</span><br><span class="line">     *&#x3D;&#x3D;&gt;arr:[&#39;p&#39;]&#x3D;&#x3D;&gt;node:[&#39;p&#39;]&#x3D;&#x3D;&gt;arr:[]</span><br><span class="line">     *第三次在node成员div或者p下查找.c并把.c添加到node中</span><br><span class="line">     *arr.push.apply(arr,basicSelect(&#39;.c&#39;,&#39;p&#39;));</span><br><span class="line">     *&#x3D;&#x3D;&gt;arr:[&#39;.c&#39;]&#x3D;&#x3D;&gt;node:[&#39;.c&#39;]&#x3D;&#x3D;&gt;arr:[]</span><br><span class="line">     *&#x2F;</span><br><span class="line">      for (i &#x3D; 0; i &lt; selectors.length; i++) &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt; node.length; j++) &#123;</span><br><span class="line">          arr.push.apply( arr, basicSelect( selectors[ i ], node[ j ] ));</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;下面重置的两句代码的位置影响到性能问题</span><br><span class="line">        node &#x3D; arr;&#x2F;&#x2F;把当前获取的元素保存到node中</span><br><span class="line">        arr &#x3D; [];&#x2F;&#x2F;初始化arr</span><br><span class="line">      &#125;;</span><br><span class="line">      results.push.apply( results, node );&#x2F;&#x2F;把获取的元素添加到结果中</span><br><span class="line">      return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;核心功能</span><br><span class="line">    function select( selector, results )&#123;</span><br><span class="line">      results &#x3D; results || [];</span><br><span class="line">      var m, temp, selectors, subSelector, i;</span><br><span class="line">      &#x2F;&#x2F;如果实参不是字符串</span><br><span class="line">      if ( typeof selector !&#x3D; &#39;string&#39; ) return results;</span><br><span class="line">      &#x2F;&#x2F;判断是否支持qsa</span><br><span class="line">      if ( support.qsa ) &#123;</span><br><span class="line">        results.push.apply( results, document.querySelectorAll( selector ) );</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        selectors &#x3D; selector.splitL( &#39;,&#39; );&#x2F;&#x2F;用逗号分割传入的参数</span><br><span class="line">        for (i &#x3D; 0; i &lt; selectors.length; i++) &#123;&#x2F;&#x2F;遍历选择器</span><br><span class="line">          subSelector &#x3D; myTrim( selectors[ i ]);&#x2F;&#x2F;去掉两端空格</span><br><span class="line">          if ( rbaseselector.test( subSelector )) &#123;&#x2F;&#x2F;如果参数是基本选择器</span><br><span class="line">            &#x2F;&#x2F;通过匹配捕获把获取到的元素添加到数组中</span><br><span class="line">            results.push.apply( results, basicSelect( subSelector ));</span><br><span class="line">          &#125;else&#123;&#x2F;&#x2F;如果是后代选择器</span><br><span class="line">            select2( subSelector, results );&#x2F;&#x2F;执行后代选择器</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      return unique( results );&#x2F;&#x2F;把获取的重复的元素去掉</span><br><span class="line">    &#125;</span><br><span class="line">    return select;&#x2F;&#x2F;返回select方法体，供函数外部使用</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;把选择器引擎里的核心函数API暴露出来，在需要的时候可以使用第三方的选择器引擎</span><br><span class="line">  &#x2F;&#x2F;给$对象添加自定义属性select指向已声明的选择器引擎</span><br><span class="line">  $.select &#x3D; select3;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;给构造函数$添加静态方法。 实例方法</span><br><span class="line">  $.extend(&#123;</span><br><span class="line">    getStyle: function()&#123;</span><br><span class="line">      if ( o.currentStyle ) &#123;</span><br><span class="line">        return o.currentStyle[ name ];</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return window.getComputedStyle( o )[ name ];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isString: function( data )&#123;</span><br><span class="line">      return typeof data &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line">    &#125;,</span><br><span class="line">    each: function( arr, func )&#123;</span><br><span class="line">      var i;</span><br><span class="line">      &#x2F;&#x2F;在es5中还引入了Array.isArray的方法专门来判断数组</span><br><span class="line">      if ( arr instanceof Array || arr.length &gt;&#x3D; 0 ) &#123;</span><br><span class="line">        for ( i &#x3D; 0; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">          func.call( arr[ i ], i, arr[ i ] );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        for ( i in arr )&#123;</span><br><span class="line">          func.call( arr[ i ], i, arr[ i ] );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr;&#x2F;&#x2F;返回，链式编程</span><br><span class="line">    &#125;,</span><br><span class="line">    map: function( arr, func )&#123;</span><br><span class="line">      var res &#x3D; [], i, tmp;</span><br><span class="line">      if ( arr instanceof Array || arr.length &gt;&#x3D; 0 ) &#123;</span><br><span class="line">         for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            tmp &#x3D; func.call( arr[ i ], arr[ i ], i );</span><br><span class="line">            if ( tmp !&#x3D; null ) &#123;</span><br><span class="line">               res.push( tmp );</span><br><span class="line">            &#125;;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         for ( i in arr )&#123;</span><br><span class="line">            tmp &#x3D; func.call( arr[ i ], arr[ i ], i );</span><br><span class="line">            if ( tmp !&#x3D; null ) &#123;</span><br><span class="line">               res.push( tmp );</span><br><span class="line">            &#125;;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;,</span><br><span class="line">    prependChild: function ( parent, element )&#123;</span><br><span class="line">      parent.insertBefore( element, parent.firstChid );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;DOM操作的方法，将字符串转换为DOM对象的函数</span><br><span class="line">  var parseHTML &#x3D; (function()&#123;</span><br><span class="line">    var div &#x3D; document.createElement( &#39;div&#39; );</span><br><span class="line">    function parseHTML ( html )&#123;</span><br><span class="line">      div.innerHTML &#x3D; html;</span><br><span class="line">      var res &#x3D; [], i;</span><br><span class="line">      for ( i &#x3D; 0; i &lt; div.childNodes.length; i++ ) &#123;</span><br><span class="line">        res.push( div.childNodes[ i ] );</span><br><span class="line">      &#125;;</span><br><span class="line">      div.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return parseHTML;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;给构造函数$添加静态方法</span><br><span class="line">  $.extend(&#123;</span><br><span class="line">    isString: function( data )&#123;</span><br><span class="line">      return typeof data &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line">    &#125;,</span><br><span class="line">    each: function( arr, func )&#123;</span><br><span class="line">      var i;</span><br><span class="line">      &#x2F;&#x2F; 在 ES5 中还引入了 Array.isArray 的方法专门来判断数组</span><br><span class="line">      if ( arr instanceof Array || arr.length &gt;&#x3D; 0 ) &#123;</span><br><span class="line">         for ( i &#x3D; 0; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">            func.call( arr[ i ], i, arr[ i ] );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         for ( i in arr )&#123;</span><br><span class="line">            func.call( arr[ i ], i, arr[ i ] );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr;&#x2F;&#x2F;返回原数组&#x2F;对象</span><br><span class="line">    &#125;,</span><br><span class="line">    map: function( arr, func )&#123;</span><br><span class="line">      var res &#x3D; [], i, tmp;</span><br><span class="line">      if ( arr instanceof Array || arr.length &gt;&#x3D; 0 ) &#123;</span><br><span class="line">         for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            tmp &#x3D; func.call( arr[ i ], arr[ i ], i );</span><br><span class="line">            if ( tmp !&#x3D; null ) &#123;</span><br><span class="line">               res.push( tmp );</span><br><span class="line">            &#125;;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         for ( i in arr )&#123;</span><br><span class="line">            tmp &#x3D; func.call( arr[ i ], arr[ i ], i );</span><br><span class="line">            if ( tmp !&#x3D; null ) &#123;</span><br><span class="line">               res.push( tmp );</span><br><span class="line">            &#125;;</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;,</span><br><span class="line">    prependChild: function ( parent, element )&#123;</span><br><span class="line">      parent.insertBefore( element, parent.firstChild );</span><br><span class="line">    &#125;,</span><br><span class="line">    getStyle: function( o, name )&#123;</span><br><span class="line">      if ( o.currentStyle ) &#123;</span><br><span class="line">        return o.currentStyle[ name ];</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return window.getComputedStyle( o )[ name ];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;DOM操作的方法，将字符串转换为DOM对象的函数</span><br><span class="line">  var parseHTML &#x3D; (function ()&#123;</span><br><span class="line">    var div &#x3D; document.createElement( &#39;div&#39; );</span><br><span class="line">    function parseHTML ( html ) &#123;</span><br><span class="line">      div.innerHTML &#x3D; html;</span><br><span class="line">      var res &#x3D; [];&#x2F;&#x2F;保存到数组中方便调取各个节点</span><br><span class="line">      for (var i &#x3D; 0; i &lt; div.childNodes.length; i++) &#123;</span><br><span class="line">        res.push( div.childNodes[ i ] );</span><br><span class="line">      &#125;;</span><br><span class="line">      div.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return parseHTML;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;实例方法</span><br><span class="line">  $.fn.extend(&#123;</span><br><span class="line">    appendTo: function ( selector )&#123;</span><br><span class="line">      &#x2F;&#x2F;把selector包装成$对象（伪数组）</span><br><span class="line">      var iObj &#x3D; this.constructor( selector );</span><br><span class="line">      &#x2F;&#x2F;利用新对象保存数据然后改变this指向</span><br><span class="line">      var newObj &#x3D; this.constructor();</span><br><span class="line">      console.log(this);&#x2F;&#x2F;指向前面添加的的span元素(伪数组)</span><br><span class="line">      &#x2F;&#x2F; A appendTo B     this指向A</span><br><span class="line">      for ( var i &#x3D; 0; i &lt; this.length; i++ ) &#123;</span><br><span class="line">        for ( var j &#x3D; 0; j &lt; iObj.length; j++ ) &#123;</span><br><span class="line">          &#x2F;&#x2F;最后一次会多克隆一次，所以最后一次就不克隆</span><br><span class="line">          var temp &#x3D;</span><br><span class="line">            i &#x3D;&#x3D; this.length - 1 &amp;&amp; j &#x3D;&#x3D; iObj.length - 1</span><br><span class="line">              ? this[ i ]</span><br><span class="line">              : this[ i ].cloneNode( true );</span><br><span class="line">          &#x2F;&#x2F;改变this指向实现链式编程</span><br><span class="line">          [].push.call( newObj, temp );</span><br><span class="line">          iObj[ j ].appendChild( temp );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return newObj;</span><br><span class="line">    &#125;,</span><br><span class="line">    append: function ( selector )&#123;</span><br><span class="line">      &#x2F;&#x2F;$( selector ).appendTo( this );&#x2F;&#x2F;简化版</span><br><span class="line">      var iObj &#x3D; this.constructor( selector );</span><br><span class="line">      &#x2F;&#x2F; B append A this 的指向B</span><br><span class="line">      for (var i &#x3D; 0; i &lt; iObj.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D; 0; j &lt; this.length; j++) &#123;</span><br><span class="line">          var temp &#x3D;</span><br><span class="line">            i &#x3D;&#x3D; this.length - 1 &amp;&amp; j &#x3D;&#x3D; iObj.length - 1</span><br><span class="line">              ? iObj[ i ]</span><br><span class="line">              : iObj[ i ].cloneNode( true );</span><br><span class="line">          this[ j ].appendChild( temp );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    prependTo: function ( selector )&#123;</span><br><span class="line">      &#x2F;&#x2F;把selector包装成$对象（伪数组）</span><br><span class="line">      var iObj &#x3D; this.constructor( selector );</span><br><span class="line">      &#x2F;&#x2F;利用新对象保存数据然后改变this指向</span><br><span class="line">      var newObj &#x3D; this.constructor();&#x2F;&#x2F;$.fn.constructor也行</span><br><span class="line">      for (var i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        for (var j &#x3D; 0; j &lt; iObj.length; j++) &#123;</span><br><span class="line">          &#x2F;&#x2F;最后一次会多克隆一次，所以最后一次就不克隆</span><br><span class="line">          var temp &#x3D;</span><br><span class="line">            i &#x3D;&#x3D; this.length - 1 &amp;&amp; j &#x3D;&#x3D; iObj.length - 1</span><br><span class="line">              ? this[ i ]</span><br><span class="line">              : this[ i ].cloneNode( true );</span><br><span class="line">          &#x2F;&#x2F;改变this指向实现链式编程</span><br><span class="line">          [].push.call( newObj, temp );</span><br><span class="line">          prependChild( iObj[ j ], temp );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return newObj;</span><br><span class="line">    &#125;,</span><br><span class="line">    prepend: function ( selector )&#123;</span><br><span class="line">      this.constructor( selector ).prependTo( this );</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    on: function( type, fn )&#123;</span><br><span class="line">      if ( !this.events[ type ]) &#123;&#x2F;&#x2F;如果事件对象不存在就置空</span><br><span class="line">        this.events[ type ] &#x3D; [];</span><br><span class="line">        var that &#x3D; this;&#x2F;&#x2F;指向的是该数组</span><br><span class="line">        this.each( function() &#123;</span><br><span class="line">          var self &#x3D; this;&#x2F;&#x2F;this指向每一个DOM对象</span><br><span class="line">          var f &#x3D; function ( e )&#123;</span><br><span class="line">            &#x2F;&#x2F;把事件对象e传进每个绑定的事件里</span><br><span class="line">            for (var i &#x3D; 0; i &lt; that.events[ type ].length; i++) &#123;</span><br><span class="line">              that.events[ type ][ i ].call( self, e );</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          if ( this.addEventListener ) &#123;</span><br><span class="line">            this.addEventListener( type, f );</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            this.attachEvent( &#39;on&#39; + type, f );&#x2F;&#x2F;兼容ie6，7，8浏览器</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.events[ type ].push( fn );&#x2F;&#x2F;给events对象type属性(数组)添加传入的事件</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    off: function( type, fn)&#123;</span><br><span class="line">      var arr &#x3D; this.events[ type ];&#x2F;&#x2F;事件数组</span><br><span class="line">      if ( arr ) &#123;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">          if ( arr[ i ] &#x3D;&#x3D; fn ) &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        if ( i !&#x3D; arr.length ) &#123;</span><br><span class="line">          arr.aplice( i, 1 );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    css: function( option )&#123;</span><br><span class="line">      var len &#x3D; arguments.length, args &#x3D; arguments;</span><br><span class="line">      if ( len &#x3D;&#x3D;&#x3D; 2 ) &#123;&#x2F;&#x2F;两个参数</span><br><span class="line">        if ( $.isString( args[ 0 ] ) &amp;&amp; $.isString( args[ 1 ] ) ) &#123;</span><br><span class="line">          return this.each( function()&#123;</span><br><span class="line">            this.style[ args[ 0 ] ] &#x3D; args[ 1 ];</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;else if ( len &#x3D;&#x3D;&#x3D; 1 ) &#123;&#x2F;&#x2F;一个参数</span><br><span class="line">        if ( $.isString( option ) ) &#123;&#x2F;&#x2F;参数为字符串</span><br><span class="line">          return this[ 0 ].style[ option ] || $.getStyle( this[ 0 ], option );</span><br><span class="line">        &#125;else if ( typeof option &#x3D;&#x3D; &#39;object&#39;) &#123;&#x2F;&#x2F;参数为对象</span><br><span class="line">          return this.each( function()&#123;</span><br><span class="line">            for ( var k in option )&#123;</span><br><span class="line">              this.style[ k ] &#x3D; option[ k ];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    addClass: function( name )&#123;</span><br><span class="line">      return this.each( function ()&#123;</span><br><span class="line">        var classTxt &#x3D; this.className;</span><br><span class="line">        if ( classTxt ) &#123;</span><br><span class="line">          if ( ( &#39; &#39; + classTxt + &#39; &#39; ).indexOf( &#39; &#39; + name + &#39; &#39; ) &#x3D;&#x3D;&#x3D; -1 ) &#123;</span><br><span class="line">            this.className +&#x3D; &#39; &#39; + name;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          this.className &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    removeClass: function ( name )&#123;</span><br><span class="line">      return this.each( function()&#123;</span><br><span class="line">        var classTxt &#x3D; &#39; &#39; + this.className + &#39; &#39;;</span><br><span class="line">        var rclassName &#x3D; new RegExp( &#39; &#39; + name + &#39; &#39;, &#39;g&#39; );</span><br><span class="line">        this.className &#x3D; classTxt.replace( rclassName, &#39; &#39; ).replace( &#x2F;\s+&#x2F;g, &#39; &#39; ).trim();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    hasClass: function( name )&#123;</span><br><span class="line">      for ( var i &#x3D; 0; i &lt; this.length; i++ ) &#123;</span><br><span class="line">        if ( ( &#39; &#39; + this[ i ].className + &#39; &#39; ).indexOf( &#39; &#39; + name + &#39; &#39; ) !&#x3D; -1 ) &#123;</span><br><span class="line">          return true;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;,</span><br><span class="line">    toggleClass: function( name )&#123;</span><br><span class="line">      if ( this.hasClass( name )) &#123;</span><br><span class="line">        this.removeClass( name );</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        this.addClass( name );</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    attr: function ( name, value )&#123;</span><br><span class="line">      if ( value ) &#123;&#x2F;&#x2F;设置属性</span><br><span class="line">        if ( $.isString( name ) &amp;&amp; $.isString( value ) ) &#123;</span><br><span class="line">          return this.each( function()&#123;</span><br><span class="line">            this.setAttribute( name, value );</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;else&#123;&#x2F;&#x2F;获取属性</span><br><span class="line">        if ( $.isString( name ) ) &#123;</span><br><span class="line">          return this[ 0 ].getAttribute( name );</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    prop: function ( name, value )&#123;</span><br><span class="line">      if ( value ) &#123;</span><br><span class="line">        if ( $.isString( name ) &amp;&amp; $.isString( value ) ) &#123;</span><br><span class="line">          return this.each( function()&#123;</span><br><span class="line">            this[ name ] &#x3D; value;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        if ( $.isString( name ) ) &#123;</span><br><span class="line">          return this[ 0 ][ name ];</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    val: function( value )&#123;</span><br><span class="line">      return this.attr( &#39;value&#39;, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    html: function( html )&#123;</span><br><span class="line">      return this.prop( &#39;innerHTML&#39;, html );</span><br><span class="line">    &#125;,</span><br><span class="line">    text: function( txt )&#123;</span><br><span class="line">      if ( txt ) &#123;</span><br><span class="line">        return this.each( function()&#123;</span><br><span class="line">          this.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">          this.appendChild( document.createTextNode( txt + &#39;&#39; ));</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        var arr &#x3D; [];</span><br><span class="line">        getTxt( this[ 0 ], arr );</span><br><span class="line">        return arr.join( &#39; &#39; );</span><br><span class="line">      &#125;</span><br><span class="line">      return this;</span><br><span class="line"></span><br><span class="line">      function getTxt( node, list )&#123;</span><br><span class="line">        var arr &#x3D; node.childNodes;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">          if ( arr[ i ].nodeType &#x3D;&#x3D;&#x3D; 3 ) &#123;</span><br><span class="line">            list.push( arr[ i ].nodeValue );</span><br><span class="line">          &#125;;</span><br><span class="line">          if ( arr[ i ].nodeType &#x3D;&#x3D;&#x3D; 1 ) &#123;</span><br><span class="line">            getTxt( arr[ i ], list );</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;直接绑定事件的封装</span><br><span class="line">  $.each(( &quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +</span><br><span class="line">  &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +</span><br><span class="line">  &quot;change select submit keydown keypress keyup error contextmenu&quot; ).split( &#39; &#39; ), function( i, v )&#123;&#x2F;&#x2F;v表示事件的名称</span><br><span class="line">    $.fn[ v ] &#x3D; function( fn )&#123;</span><br><span class="line">      this.on( v, fn );</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">window.$ &#x3D; $;&#x2F;&#x2F;暴露$</span><br><span class="line"></span><br><span class="line">&#125; )( window );</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>jquery 源码 框架 库 源代码 学习</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop</title>
    <url>/2020/07/21/setTimeout%E5%92%8CsetImmediate%E5%88%B0%E5%BA%95%E8%B0%81%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%9C%AC%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Event%20Loop/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>笔者以前面试的时候经常遇到写一堆<code>setTimeout``setImmediate``setImmediate``setTimeout(fn, 0)``setTimeout(fn, 0)``setImmediate``setTimeout``setImmediate``Promise``process.nextTick</code></li>
</ul>
<a id="more"></a>

<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步异步简单理解就是，同步的代码都是按照书写顺序执行的，异步的代码可能跟书写顺序不一样，写在后面的可能先执行。下面来看个例子：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const syncFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const time &#x3D; new Date().getTime();</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    if(new Date().getTime() - time &gt; 2000) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(1);</span><br><span class="line">syncFunc();</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>
<p>上述代码会先打印出1，然后调用<code>syncFunc</code>，<code>syncFunc</code>里面while循环会运行2秒，然后打印出2，最后打印出3。所以这里代码的执行顺序跟我们的书写顺序是一致，他是同步代码：</p>
<p><img src="https://i.loli.net/2021/01/11/lhTAjK7qnyUMHEQ.png" alt="image-20200320144654281"></p>
<p>再来看个异步例子：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const asyncFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(1);</span><br><span class="line">asyncFunc();</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>
<p>上述代码的输出是：</p>
<p><img src="https://i.loli.net/2021/01/11/Ge4AFiMLEWRvJCq.png" alt="image-20200320145012565"></p>
<p>可以看到我们中间调用的<code>asyncFunc</code>里面的2却是最后输出的，这是因为<code>setTimeout</code>是一个异步方法。他的作用是设置一个定时器，等定时器时间到了再执行回调里面的代码。所以异步就相当于做一件事，但是并不是马上做，而是你先给别人打了个招呼，说xxx条件满足的时候就干什么什么。就像你晚上睡觉前在手机上设置了一个第二天早上7天的闹钟，就相当于给了手机一个异步事件，触发条件是时间到达早上7点。<strong>使用异步的好处是你只需要设置好异步的触发条件就可以去干别的事情了，所以异步不会阻塞主干上事件的执行。特别是对于JS这种只有一个线程的语言，如果都像我们第一个例子那样去<code>while(true)</code>，那浏览器就只有一直卡死了，只有等这个循环运行完才会有响应</strong>。</p>
<h2 id="JS异步是怎么实现的"><a href="#JS异步是怎么实现的" class="headerlink" title="JS异步是怎么实现的"></a>JS异步是怎么实现的</h2><p>我们都知道JS是单线程的，那单线程是怎么实现异步的呢？事实上所谓的”JS是单线程的”只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的：</p>
<p><img src="https://i.loli.net/2021/01/11/36JFrcsxwBUE9iT.png" alt="image-20200320151227013"></p>
<p>上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个选项卡崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。</p>
<p>对于前端工程师来说，主要关心的还是渲染进程，下面来分别看下里面每个线程是做什么的。</p>
<h3 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h3><p>GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。</p>
<h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h3><p>这个线程就是负责执行JS的主线程，前面说的”JS是单线程的”就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。<strong>需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的<code>while(true)</code>这样长时间的同步代码在真正开发时是绝对不允许的</strong>。</p>
<h3 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h3><p>前面异步例子的<code>setTimeout</code>其实就运行在这里，他跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步。JS的定时器方法还有<code>setInterval</code>，也是在这个线程。</p>
<h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><p>定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。</p>
<h3 id="异步HTTP请求线程"><a href="#异步HTTP请求线程" class="headerlink" title="异步HTTP请求线程"></a>异步HTTP请求线程</h3><p>这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。</p>
<p><strong>所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行</strong>。这个流程我们多次提到了任务队列，这其实就是Event Loop，下面我们详细来讲解下。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>所谓Event Loop，就是事件循环，其实就是JS管理事件执行的一个流程，具体的管理办法由他具体的运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。这两个环境的Event Loop还有点区别，我们会分开来讲。</p>
<h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p>事件循环就是一个循环，是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，这就是事件队列。各个异步线程执行完后，通过事件触发线程将回调事件放到事件队列，主线程每次干完手上的活儿就来看看这个队列有没有新活儿，有的话就取出来执行。画成一个流程图就是这样：</p>
<p><img src="https://i.loli.net/2021/01/11/69Dub2okKmqTJBs.png" alt="image-20200320161732238"></p>
<p>流程讲解如下:</p>
<blockquote>
<ol>
<li>主线程每次执行时，先看看要执行的是同步任务，还是异步的API</li>
<li>同步任务就继续执行，一直执行完</li>
<li>遇到异步API就将它交给对应的异步线程，自己继续执行同步任务</li>
<li>异步线程执行异步API，执行完后，将异步回调事件放入事件队列上</li>
<li>主线程手上的同步任务干完后就来事件队列看看有没有任务</li>
<li>主线程发现事件队列有任务，就取出里面的任务执行</li>
<li>主线程不断循环上述流程</li>
</ol>
</blockquote>
<h3 id="定时器不准"><a href="#定时器不准" class="headerlink" title="定时器不准"></a>定时器不准</h3><p>Event Loop的这个流程里面其实还是隐藏了一些坑的，最典型的问题就是总是先执行同步任务，然后再执行事件队列里面的回调。这个特性就直接影响了定时器的执行，我们想想我们开始那个2秒定时器的执行流程：</p>
<blockquote>
<ol>
<li>主线程执行同步代码</li>
<li>遇到<code>setTimeout</code>，将它交给定时器线程</li>
<li>定时器线程开始计时，2秒到了通知事件触发线程</li>
<li>事件触发线程将定时器回调放入事件队列，异步流程到此结束</li>
<li>主线程如果有空，将定时器回调拿出来执行，如果没空这个回调就一直放在队列里。</li>
</ol>
</blockquote>
<p>上述流程我们可以看出，如果主线程长时间被阻塞，定时器回调就没机会执行，即使执行了，那时间也不准了，我们将开头那两个例子结合起来就可以看出这个效果：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const syncFunc &#x3D; (startTime) &#x3D;&gt; &#123;</span><br><span class="line">  const time &#x3D; new Date().getTime();</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    if(new Date().getTime() - time &gt; 5000) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const offset &#x3D; new Date().getTime() - startTime;</span><br><span class="line">  console.log(&#96;syncFunc run, time offset: $&#123;offset&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const asyncFunc &#x3D; (startTime) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    const offset &#x3D; new Date().getTime() - startTime;</span><br><span class="line">    console.log(&#96;asyncFunc run, time offset: $&#123;offset&#125;&#96;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const startTime &#x3D; new Date().getTime();</span><br><span class="line"></span><br><span class="line">asyncFunc(startTime);</span><br><span class="line"></span><br><span class="line">syncFunc(startTime);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img src="https://i.loli.net/2021/01/11/IHsDUJPqaoTi284.png" alt="image-20200320163640760"></p>
<p>通过结果可以看出，虽然我们先调用的<code>asyncFunc</code>，虽然<code>asyncFunc</code>写的是2秒后执行，但是<code>syncFunc</code>的执行时间太长，达到了5秒，<code>asyncFunc</code>虽然在2秒的时候就已经进入了事件队列，但是主线程一直在执行同步代码，一直没空，所以也要等到5秒后，同步代码执行完毕才有机会执行这个定时器回调。<strong>所以再次强调，写代码时一定不要长时间占用主线程</strong>。</p>
<h3 id="引入微任务"><a href="#引入微任务" class="headerlink" title="引入微任务"></a>引入微任务</h3><p>前面的流程图我为了便于理解，简化了事件队列，其实事件队列里面的事件还可以分两类：宏任务和微任务。微任务拥有更高的优先级，当事件循环遍历队列时，先检查微任务队列，如果里面有任务，就全部拿来执行，执行完之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。所以完整的流程图如下：</p>
<p><img src="https://i.loli.net/2021/01/11/jkS6LOoqeiWVHFA.png" alt="image-20200322201434386"></p>
<p>上图需要注意以下几点：</p>
<blockquote>
<ol>
<li>一个Event Loop可以有一个或多个事件队列，但是只有一个微任务队列。</li>
<li>微任务队列全部执行完会重新渲染一次</li>
<li>每个宏任务执行完都会重新渲染一次</li>
<li>requestAnimationFrame处于渲染阶段，不在微任务队列，也不在宏任务队列</li>
</ol>
</blockquote>
<p>所以想要知道一个异步API在哪个阶段执行，我们得知道他是宏任务还是微任务。</p>
<p>常见宏任务有：</p>
<blockquote>
<ol>
<li> <code>script</code> (可以理解为外层同步代码)</li>
<li><code>setTimeout/setInterval</code></li>
<li> <code>setImmediate</code>(Node.js)</li>
<li>I/O</li>
<li>UI事件</li>
<li><code>postMessage</code></li>
</ol>
</blockquote>
<p>常见微任务有：</p>
<blockquote>
<ol>
<li><code>Promise</code></li>
<li> <code>process.nextTick</code>(Node.js)</li>
<li><code>Object.observe</code></li>
<li><code>MutaionObserver</code></li>
</ol>
</blockquote>
<p>上面这些事件类型中要注意<code>Promise</code>，他是微任务，也就是说他会在定时器前面运行，我们来看个例子:</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;1&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;2&#39;);</span><br><span class="line">&#125;,0);</span><br><span class="line">Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;5&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;3&#39;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;4&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码的输出是<code>1,3,5,4,2</code>。因为：</p>
<blockquote>
<ol>
<li>先输出1，这个没什么说的，同步代码最先执行</li>
<li> <code>console.log(&#39;2&#39;);</code>在<code>setTimeout</code>里面，<code>setTimeout</code>是宏任务，“2”进入宏任务队列</li>
<li> <code>console.log(&#39;5&#39;);</code>在<code>Promise.then</code>里面，进入微任务队列</li>
<li> <code>console.log(&#39;3&#39;);</code>在Promise构造函数的参数里面，这其实是同步代码，直接输出</li>
<li> <code>console.log(&#39;4&#39;);</code>在then里面，他会进入微任务队列，检查事件队列时先执行微任务</li>
<li>同步代码运行结果是“1，3”</li>
<li>然后检查微任务队列，输出“5，4”</li>
<li>最后执行宏任务队列，输出“2”</li>
</ol>
</blockquote>
<h3 id="Node-js的Event-Loop"><a href="#Node-js的Event-Loop" class="headerlink" title="Node.js的Event Loop"></a>Node.js的Event Loop</h3><p>Node.js是运行在服务端的js，虽然他也用到了V8引擎，但是他的服务目的和环境不同，导致了他API与原生JS有些区别，他的Event Loop还要处理一些I/O，比如新的网络连接等，所以与浏览器Event Loop也是不一样的。Node的Event Loop是分阶段的，如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/11/HBLTwqUcSoatM5b.png" alt="image-20200322203318743"></p>
<blockquote>
<ol>
<li>timers: 执行<code>setTimeout</code>和<code>setInterval</code>的回调</li>
<li>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调</li>
<li>idle, prepare: 仅系统内部使用</li>
<li>poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li>
<li>check: <code>setImmediate</code>在这里执行</li>
<li>close callbacks: 一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code> </li>
</ol>
</blockquote>
<p>每个阶段都有一个自己的先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。在每次事件循环之间，Node.js都会检查它是否在等待任何一个I/O或者定时器，如果没有的话，程序就关闭退出了。我们的直观感受就是，如果一个Node程序只有同步代码，你在控制台运行完后，他就自己退出了。</p>
<p>还有个需要注意的是<code>poll</code>阶段，他后面并不一定每次都是<code>check</code>阶段，<code>poll</code>队列执行完后，如果没有<code>setImmediate</code>但是有定时器到期，他会绕回去执行定时器阶段：</p>
<p><img src="https://i.loli.net/2021/01/11/oDqC6GZAa8LBlei.png" alt="image-20200322205308151"></p>
<h4 id="setImmediate和setTimeout"><a href="#setImmediate和setTimeout" class="headerlink" title="setImmediate和setTimeout"></a><code>setImmediate</code>和<code>setTimeout</code></h4><p>上面的这个流程说简单点就是<strong>在一个异步流程</strong>里，<code>setImmediate</code>会比定时器先执行，我们写点代码来试试：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;outer&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;setImmediate&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>
<p>上述代码运行如下:</p>
<p><img src="https://i.loli.net/2021/01/11/eLPpAKRvhJQ9WZ7.png" alt="image-20200322210304757"></p>
<p>和我们前面讲的一样，<code>setImmediate</code>先执行了。我们来理一下这个流程：</p>
<blockquote>
<ol>
<li>外层是一个<code>setTimeout</code>，所以执行他的回调的时候已经在<code>timers</code>阶段了</li>
<li>处理里面的<code>setTimeout</code>，因为本次循环的<code>timers</code>正在执行，所以他的回调其实加到了下个<code>timers</code>阶段</li>
<li>处理里面的<code>setImmediate</code>，将它的回调加入<code>check</code>阶段的队列</li>
<li>外层<code>timers</code>阶段执行完，进入<code>pending callbacks</code>，<code>idle, prepare</code>，<code>poll</code>，这几个队列都是空的，所以继续往下</li>
<li>到了<code>check</code>阶段，发现了<code>setImmediate</code>的回调，拿出来执行</li>
<li>然后是<code>close callbacks</code>，队列是空的，跳过</li>
<li>又是<code>timers</code>阶段，执行我们的<code>console</code> </li>
</ol>
</blockquote>
<p>但是请注意我们上面<code>console.log(&#39;setTimeout&#39;)</code>和<code>console.log(&#39;setImmediate&#39;)</code>都包在了一个<code>setTimeout</code>里面，如果直接写在最外层会怎么样呢？代码改写如下:</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;outer&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setImmediate&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们来运行下看看效果：</p>
<p><img src="https://i.loli.net/2021/01/11/A2hbacyXSOLBUse.png" alt="image-20200322214105295"></p>
<p>好像是<code>setTimeout</code>先输出来，我们多运行几次看看:</p>
<p><img src="https://i.loli.net/2021/01/11/czaOdleGETAnWmQ.png" alt="image-20200322214148090"></p>
<p>怎么<code>setImmediate</code>又先出来了，这代码是见鬼了还是啥？这个世界上是没有鬼怪的，所以事情都有原因的，我们顺着之前的Event Loop再来理一下。在理之前，需要告诉大家一件事情，node.js里面<code>setTimeout(fn, 0)</code>会被强制改为<code>setTimeout(fn, 1)</code>,<a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args">这在官方文档中有说明</a>。(说到这里顺便提下，HTML 5里面<code>setTimeout</code>最小的时间限制是4ms)。原理我们都有了，我们来理一下流程：</p>
<blockquote>
<ol>
<li>外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段</li>
<li>遇到<code>setTimeout</code>，虽然设置的是0毫秒触发，但是被node.js强制改为1毫秒，塞入<code>times</code>阶段</li>
<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>
<li>同步代码执行完毕，进入Event Loop</li>
<li>先进入<code>times</code>阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过1毫秒，跳过</li>
<li>跳过空的阶段，进入check阶段，执行<code>setImmediate</code>回调</li>
</ol>
</blockquote>
<p>通过上述流程的梳理，我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，<code>setTimeout</code>执行，如果1毫秒还没到，就先执行了<code>setImmediate</code>。每次我们运行脚本时，机器状态可能不一样，导致运行时有1毫秒的差距，一会儿<code>setTimeout</code>先执行，一会儿<code>setImmediate</code>先执行。但是这种情况只会发生在还没进入<code>timers</code>阶段的时候。像我们第一个例子那样，因为已经在<code>timers</code>阶段，所以里面的<code>setTimeout</code>只能等下个循环了，所以<code>setImmediate</code>肯定先执行。同理的还有其他<code>poll</code>阶段的API也是这样的，比如：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;setTimeout&#39;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;setImmediate&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里<code>setTimeout</code>和<code>setImmediate</code>在<code>readFile</code>的回调里面，由于<code>readFile</code>回调是I/O操作，他本身就在<code>poll</code>阶段，所以他里面的定时器只能进入下个<code>timers</code>阶段，但是<code>setImmediate</code>却可以在接下来的<code>check</code>阶段运行，所以<code>setImmediate</code>肯定先运行，他运行完后，去检查<code>timers</code>，才会运行<code>setTimeout</code>。</p>
<p>类似的，我们再来看一段代码，如果他们两个不是在最外层，而是在<code>setImmediate</code>的回调里面，其实情况跟外层一样，结果也是随缘的，看下面代码:</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;outer&#39;);</span><br><span class="line"></span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;setImmediate&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>原因跟写在最外层差不多，因为<code>setImmediate</code>已经在<code>check</code>阶段了，里面的循环会从<code>timers</code>阶段开始，会先看<code>setTimeout</code>的回调，如果这时候已经过了1毫秒，就执行他，如果没过就执行<code>setImmediate</code>。</p>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h4><p><code>process.nextTick()</code>是一个特殊的异步API，他不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进行，会马上停下来执行<code>process.nextTick()</code>，这个执行完后才会继续Event Loop。我们写个例子来看下：</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;setTimeout&#39;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;setImmediate&#39;);</span><br><span class="line">        </span><br><span class="line">        process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">          console.log(&#39;nextTick 2&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    process.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;nextTick 1&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的打印如下：</p>
<p><img src="https://i.loli.net/2021/01/11/opsvwenPyJtDGbT.png" alt="image-20200322221221927"></p>
<p>我们还是来理一下流程:</p>
<blockquote>
<ol>
<li>我们代码基本都在<code>readFile</code>回调里面，他自己执行时，已经在<code>poll</code>阶段</li>
<li>遇到<code>setTimeout(fn, 0)</code>，其实是<code>setTimeout(fn, 1)</code>，塞入后面的<code>timers</code>阶段</li>
<li>遇到<code>setImmediate</code>，塞入后面的<code>check</code>阶段</li>
<li>遇到<code>nextTick</code>，立马执行，输出’nextTick 1’</li>
<li>到了<code>check</code>阶段，输出’setImmediate’,又遇到个<code>nextTick</code>,立马输出’nextTick 2’</li>
<li>到了下个<code>timers</code>阶段，输出’setTimeout’</li>
</ol>
</blockquote>
<p>这种机制其实类似于我们前面讲的微任务，但是并不完全一样,比如同时有<code>nextTick</code>和<code>Promise</code>的时候，肯定是<code>nextTick</code>先执行，原因是<code>nextTick</code>的队列比<code>Promise</code>队列优先级更高。来看个例子:</p>
<p>​                        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; Promise.resolve()</span><br><span class="line">setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setImmediate&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;promise&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;nextTick&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<p><img src="https://i.loli.net/2021/01/11/Sn3JW5M9etNpcCb.png" alt="image-20200323094907234"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从异步基本概念出发一直讲到了浏览器和Node.js的Event Loop，现在我们再来总结一下：</p>
<ol>
<li>JS所谓的“单线程”只是指主线程只有一个，并不是整个运行环境都是单线程</li>
<li>JS的异步靠底层的多线程实现</li>
<li>不同的异步API对应不同的实现线程</li>
<li>异步线程与主线程通讯靠的是Event Loop</li>
<li>异步线程完成任务后将其放入任务队列</li>
<li>主线程不断轮询任务队列，拿出任务执行</li>
<li>任务队列有宏任务队列和微任务队列的区别</li>
<li>微任务队列的优先级更高，所有微任务处理完后才会处理宏任务</li>
<li> <code>Promise</code>是微任务</li>
<li>Node.js的Event Loop跟浏览器的Event Loop不一样，他是分阶段的</li>
<li> <code>setImmediate</code>和<code>setTimeout(fn, 0)</code>哪个回调先执行，需要看他们本身在哪个阶段注册的，如果在定时器回调或者I/O回调里面，<code>setImmediate</code>肯定先执行。如果在最外层或者<code>setImmediate</code>回调里面，哪个先执行取决于当时机器状况。</li>
<li> <code>process.nextTick</code>不在Event Loop的任何阶段，他是一个特殊API，他会立即执行，然后才会继续执行Event Loop</li>
</ol>
<p>作者：蒋鹏飞<br>        链接：<a href="https://segmentfault.com/a/1190000023315304">https://segmentfault.com/a/1190000023315304</a><br>        来源：SegmentFault 思否<br>        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>前端 javaScript node.js eventloop</tag>
      </tags>
  </entry>
  <entry>
    <title>「译」编写更好的 JavaScript 条件式和匹配条件的技巧</title>
    <url>/2019/06/26/%E3%80%8C%E8%AF%91%E3%80%8D%E7%BC%96%E5%86%99%E6%9B%B4%E5%A5%BD%E7%9A%84%20JavaScript%20%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ol start="10">
<li>原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria</li>
</ol>
<ul>
<li>原文作者：Milos Protic</li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。</p>
<p>正如我在另一篇文章 <a href="https://devinduct.com/blogpost/22/javascript-clean-code-best-practices">JavaScript 整洁代码的最佳实践</a>里提到的，你写的代码不单单是给机器看的，还是给“<b>未来的自己</b>”以及“<b>其他人</b>”看的。</p>
<p>从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。</p>
<a id="more"></a>

<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>以下是关于如何构造 <code>if...else</code> 语句以及如何用更少的代码实现更多功能的技巧。阅读愉快！</p>
<h2 id="1-要事第一。小细节，但很重要"><a href="#1-要事第一。小细节，但很重要" class="headerlink" title="1. 要事第一。小细节，但很重要"></a>1. 要事第一。小细节，但很重要</h2><p>不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 <code>boolean</code> 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。</p>
<p>不好的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmailNotVerified = <span class="function">(<span class="params">email</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isEmailNotVerified(email)) &#123;</span><br><span class="line">    <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isVerified === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmailVerified = <span class="function">(<span class="params">email</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEmailVerified(email)) &#123;</span><br><span class="line">    <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isVerified) &#123;</span><br><span class="line">    <span class="comment">// 做一些事...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，理清了上面的事情后，我们就可以开始了。</p>
<h2 id="2-对于多个条件，使用-Array-includes"><a href="#2-对于多个条件，使用-Array-includes" class="headerlink" title="2. 对于多个条件，使用 Array.includes"></a>2. 对于多个条件，使用 <code>Array.includes</code></h2><p>假设我们想要在函数中检查汽车模型是 <code>renault</code> 还是 <code>peugeot</code>。那么代码可能是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCarModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(model === <span class="string">&#x27;renault&#x27;</span> || model === <span class="string">&#x27;peugeot&#x27;</span>) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;model valid&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkCarModel(<span class="string">&#x27;renault&#x27;</span>); <span class="comment">// 输出 &#x27;model valid&#x27;</span></span><br></pre></td></tr></table></figure>
<p>考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 <code>or</code> 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCarModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>([<span class="string">&#x27;peugeot&#x27;</span>, <span class="string">&#x27;renault&#x27;</span>].includes(model)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;model valid&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkCarModel(<span class="string">&#x27;renault&#x27;</span>); <span class="comment">// 输出 &#x27;model valid&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCarModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> models = [<span class="string">&#x27;peugeot&#x27;</span>, <span class="string">&#x27;renault&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(models.includes(model)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;model valid&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkCarModel(<span class="string">&#x27;renault&#x27;</span>); <span class="comment">// 输出 &#x27;model valid&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 <code>models</code> 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。</p>
<h2 id="3-匹配所有条件，使用-Array-every-或者-Array-find"><a href="#3-匹配所有条件，使用-Array-every-或者-Array-find" class="headerlink" title="3. 匹配所有条件，使用 Array.every 或者 Array.find"></a>3. 匹配所有条件，使用 <code>Array.every</code> 或者 <code>Array.find</code></h2><p>在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;renault&#x27;</span>, <span class="attr">year</span>: <span class="number">1956</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;peugeot&#x27;</span>, <span class="attr">year</span>: <span class="number">1968</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span>, <span class="attr">year</span>: <span class="number">1977</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkEveryModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> isValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> car <span class="keyword">of</span> cars) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid = car.model === model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkEveryModel(<span class="string">&#x27;renault&#x27;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 <code>Array.every</code> 或者 <code>Array.find</code> 来达到相同的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkEveryModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cars.every(<span class="function"><span class="params">car</span> =&gt;</span> car.model === model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkEveryModel(<span class="string">&#x27;renault&#x27;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>Array.find</code> 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 <code>falsy</code> 项时立即返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkEveryModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cars.find(<span class="function"><span class="params">car</span> =&gt;</span> car.model !== model) === <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkEveryModel(<span class="string">&#x27;renault&#x27;</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<h2 id="4-匹配部分条件，使用-Array-some"><a href="#4-匹配部分条件，使用-Array-some" class="headerlink" title="4. 匹配部分条件，使用 Array.some"></a>4. 匹配部分条件，使用 <code>Array.some</code></h2><p><code>Array.every</code> 匹配所有条件，这个方法则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。</p>
<p>我们可以通过编写一个类似的 <code>for...loop</code> 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;renault&#x27;</span>, <span class="attr">year</span>: <span class="number">1956</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;peugeot&#x27;</span>, <span class="attr">year</span>: <span class="number">1968</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span>, <span class="attr">year</span>: <span class="number">1977</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkForAnyModel = <span class="function">(<span class="params">model</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cars.some(<span class="function"><span class="params">car</span> =&gt;</span> car.model === model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkForAnyModel(<span class="string">&#x27;renault&#x27;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<h2 id="5-提前返回而不是使用-if-else-分支"><a href="#5-提前返回而不是使用-if-else-分支" class="headerlink" title="5. 提前返回而不是使用 if...else 分支"></a>5. 提前返回而不是使用 <code>if...else</code> 分支</h2><p>当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 <code>if...else</code> 嵌套将会让我们感到很痛苦。</p>
<p>另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。</p>
<p>举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkModel = <span class="function">(<span class="params">car</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result; <span class="comment">// 首先，定义一个 result 变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查是否有车</span></span><br><span class="line">  <span class="keyword">if</span>(car) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有车的模型</span></span><br><span class="line">    <span class="keyword">if</span> (car.model) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查是否有车的年份</span></span><br><span class="line">      <span class="keyword">if</span>(car.year) &#123;</span><br><span class="line">        result = <span class="string">`Car model: <span class="subst">$&#123;car.model&#125;</span>; Manufacturing year: <span class="subst">$&#123;car.year&#125;</span>;`</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="string">&#x27;No car year&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="string">&#x27;No car model&#x27;</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="string">&#x27;No car&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 我们的单独的返回语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkModel()); <span class="comment">// 输出 &#x27;No car&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">year</span>: <span class="number">1988</span> &#125;)); <span class="comment">// 输出 &#x27;No car model&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span> &#125;)); <span class="comment">// 输出 &#x27;No car year&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span>, <span class="attr">year</span>: <span class="number">1988</span> &#125;)); <span class="comment">// 输出 &#x27;Car model: ford; Manufacturing year: 1988;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 <code>if...else</code> 语句。</p>
<p>我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 <code>&amp;&amp;</code> 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkModel = <span class="function">(<span class="params">&#123;model, year&#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!model &amp;&amp; !year) <span class="keyword">return</span> <span class="string">&#x27;No car&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(!model) <span class="keyword">return</span> <span class="string">&#x27;No car model&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(!year) <span class="keyword">return</span> <span class="string">&#x27;No car year&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以任意操作模型或年份</span></span><br><span class="line">  <span class="comment">// 确保它们存在</span></span><br><span class="line">  <span class="comment">// 无需更多检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// doSomething(model);</span></span><br><span class="line">  <span class="comment">// doSomethingElse(year);</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Car model: <span class="subst">$&#123;model&#125;</span>; Manufacturing year: <span class="subst">$&#123;year&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkModel()); <span class="comment">// 输出 &#x27;No car&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">year</span>: <span class="number">1988</span> &#125;)); <span class="comment">// 输出 &#x27;No car model&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span> &#125;)); <span class="comment">// 输出 &#x27;No car year&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(checkModel(&#123; <span class="attr">model</span>: <span class="string">&#x27;ford&#x27;</span>, <span class="attr">year</span>: <span class="number">1988</span> &#125;)); <span class="comment">// 输出 &#x27;Car model: ford; Manufacturing year: 1988;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 <code>undefined</code> 时有可用于解构的值。注意，如果传入 <code>null</code> ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 null 的时候会输出 <code>&#39;No car&#39;</code>。</p>
<p>对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。</p>
<p>根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 <code>if...else</code> 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。</p>
<h2 id="6-使用索引或者映射，而不是-switch-语句"><a href="#6-使用索引或者映射，而不是-switch-语句" class="headerlink" title="6. 使用索引或者映射，而不是 switch 语句"></a>6. 使用索引或者映射，而不是 <code>switch</code> 语句</h2><p>假设我们想要基于给定的国家获取汽车模型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getCarsByState = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;usa&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Ford&#x27;</span>, <span class="string">&#x27;Dodge&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;france&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Renault&#x27;</span>, <span class="string">&#x27;Peugeot&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;italy&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Fiat&#x27;</span>];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState()); <span class="comment">// 输出 []</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;usa&#x27;</span>)); <span class="comment">// 输出 [&#x27;Ford&#x27;, &#x27;Dodge&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;italy&#x27;</span>)); <span class="comment">// 输出 [&#x27;Fiat&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>上诉代码可以重构，完全去除 <code>switch</code> 语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;usa&#x27;</span>, [<span class="string">&#x27;Ford&#x27;</span>, <span class="string">&#x27;Dodge&#x27;</span>])</span><br><span class="line">  .set(<span class="string">&#x27;france&#x27;</span>, [<span class="string">&#x27;Renault&#x27;</span>, <span class="string">&#x27;Peugeot&#x27;</span>])</span><br><span class="line">  .set(<span class="string">&#x27;italy&#x27;</span>, [<span class="string">&#x27;Fiat&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getCarsByState = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cars.get(state) || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState()); <span class="comment">// 输出 []</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;usa&#x27;</span>)); <span class="comment">//输出 [&#x27;Ford&#x27;, &#x27;Dodge&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;italy&#x27;</span>)); <span class="comment">// 输出 [&#x27;Fiat&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> carState = &#123;</span><br><span class="line">  usa: [<span class="string">&#x27;Ford&#x27;</span>, <span class="string">&#x27;Dodge&#x27;</span>],</span><br><span class="line">  france: [<span class="string">&#x27;Renault&#x27;</span>, <span class="string">&#x27;Peugeot&#x27;</span>],</span><br><span class="line">  italy: [<span class="string">&#x27;Fiat&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getCarsByState = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> carState[state] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState()); <span class="comment">// 输出 []</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;usa&#x27;</span>)); <span class="comment">// 输出 [&#x27;Ford&#x27;, &#x27;Dodge&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(getCarsByState(<span class="string">&#x27;france&#x27;</span>)); <span class="comment">// 输出 [&#x27;Renault&#x27;, &#x27;Peugeot&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="7-使用自判断链接和空合并"><a href="#7-使用自判断链接和空合并" class="headerlink" title="7. 使用自判断链接和空合并"></a>7. 使用自判断链接和空合并</h2><p>到了这一小节，我终于可以说“最后”了。在我看来，这两个功能对于 JavaScript 语言来说是非常有用的。作为一个来自 C# 世界的人，可以说我经常使用它们。</p>
<p>在写这篇文章的时候，这些还没有得到完全的支持。因此，对于以这种方式编写的代码，你需要使用 Babel 进行编译。你可以在自判断链接这里以及在空合并这里查阅。</p>
<p>自判断链接允许我们在没有显式检查中间节点是否存在的时候处理树形结构，空合并可以确保节点不存在时会有一个默认值，配合自判断链接使用会有不错的效果。</p>
<p>让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model: <span class="string">&#x27;Fiesta&#x27;</span>,</span><br><span class="line">  manufacturer: &#123;</span><br><span class="line">    name: <span class="string">&#x27;Ford&#x27;</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">      street: <span class="string">&#x27;Some Street Name&#x27;</span>,</span><br><span class="line">      number: <span class="string">&#x27;5555&#x27;</span>,</span><br><span class="line">      state: <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取汽车模型</span></span><br><span class="line"><span class="keyword">const</span> model = car &amp;&amp; car.model || <span class="string">&#x27;default model&#x27;</span>;</span><br><span class="line"><span class="comment">// 获取厂商地址</span></span><br><span class="line"><span class="keyword">const</span> street = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.street || <span class="string">&#x27;default street&#x27;</span>;</span><br><span class="line"><span class="comment">// 请求一个不存在的属性</span></span><br><span class="line"><span class="keyword">const</span> phoneNumber = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.phoneNumber;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(model) <span class="comment">// 输出 &#x27;Fiesta&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(street) <span class="comment">// 输出 &#x27;Some Street Name&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(phoneNumber) <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure>
<p>因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCarManufacturerState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.state === <span class="string">&#x27;USA&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Is from USA&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkCarManufacturerState() <span class="comment">// 输出 &#x27;Is from USA&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我无需再赘述如果对象结构更加复杂的话，代码会多么混乱了。许多库，例如 lodash，有自己的函数作为替代方案。不过这不是我们想要的，我们想要的是在原生 js 中也能做同样的事。我们来看一下新的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取汽车模型</span></span><br><span class="line"><span class="keyword">const</span> model = car?.model ?? <span class="string">&#x27;default model&#x27;</span>;</span><br><span class="line"><span class="comment">// 获取厂商地址</span></span><br><span class="line"><span class="keyword">const</span> street = car?.manufacturer?.address?.street ?? <span class="string">&#x27;default street&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查汽车厂商是否来自 USA</span></span><br><span class="line"><span class="keyword">const</span> checkCarManufacturerState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(car?.manufacturer?.address?.state === <span class="string">&#x27;USA&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Is from USA&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来更加漂亮和简洁，对我来说，非常符合逻辑。如果你想知道为什么应该使用 <code>??</code> 而不是 <code>||</code> ，只需想一想什么值可以当做 <code>true</code> 或者 <code>false</code>，你将可能有意想不到的输出。</p>
<p>顺便说句题外话。自判断链接同样支持 DOM API，这非常酷，意味着你可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input#user-name&#x27;</span>)?.value;</span><br></pre></td></tr></table></figure>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><blockquote>
<p>对于编码过程中的面条式代码和嵌套式的if/else判断深恶痛绝，但又无可奈何，最近看了一些技术文章，专门提到过javascript复杂判断的优雅写法，深入地学习了一下，现在总算知道一些复杂场景导致复杂的判断如何优雅地编码了，以后尽量不要再写if/else了，都是有更好的解决方案的。以下是自己学习中写的demo，记录一下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span>(status === <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(status)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(status)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(status)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="number">4</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(status)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(status)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch写法</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">1</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> status);</span><br><span class="line"> <span class="keyword">switch</span>(status - <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用对象实现多分支判断</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">3</span></span><br><span class="line"> <span class="keyword">const</span> actions1 = &#123;</span><br><span class="line">   <span class="number">1</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;,</span><br><span class="line">   <span class="number">2</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">   <span class="number">3</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">3</span>) &#125;,</span><br><span class="line">   <span class="number">4</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">4</span>) &#125;,</span><br><span class="line">   <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">5</span>) &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> actions1[status] ? actions1[status]() : actions1[<span class="string">&#x27;default&#x27;</span>]() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用es6的Map对象封装逻辑</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">2</span></span><br><span class="line"> <span class="keyword">const</span> actions = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">   [<span class="number">1</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>)],</span><br><span class="line">   [<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)],</span><br><span class="line">   [<span class="number">3</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>)],</span><br><span class="line">   [<span class="number">4</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>)],</span><br><span class="line">   [<span class="string">&#x27;default&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;default&#x27;</span>)],</span><br><span class="line"> ])</span><br><span class="line"> actions.get(status - <span class="number">0</span>) ? actions.get(status - <span class="number">0</span>)() : actions.get(<span class="string">&#x27;default&#x27;</span>)() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元判断</span></span><br><span class="line"> <span class="keyword">var</span> identify = <span class="string">&#x27;guest3&#x27;</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">2</span></span><br><span class="line"> <span class="keyword">var</span> actions = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&#x27;guest1_1&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest_1&#x27;</span>)],</span><br><span class="line">     [<span class="string">&#x27;guest2_2&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest_2&#x27;</span>)],</span><br><span class="line">     [<span class="string">&#x27;guest3_3&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest_3&#x27;</span>)],</span><br><span class="line">     [<span class="string">&#x27;guest4_4&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest_4&#x27;</span>)],</span><br><span class="line">     [<span class="string">&#x27;default&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;default&#x27;</span>)]</span><br><span class="line"> ])</span><br><span class="line"> actions.get(<span class="string">`<span class="subst">$&#123;identify&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>) ? actions.get(<span class="string">`<span class="subst">$&#123;identify&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>)() : actions.get(<span class="string">&#x27;default&#x27;</span>)() <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用对象也可以作二元判断</span></span><br><span class="line"> <span class="keyword">var</span> identify = <span class="string">&#x27;guest2&#x27;</span></span><br><span class="line"> <span class="keyword">var</span> status = <span class="number">3</span></span><br><span class="line"> <span class="keyword">var</span> actions = &#123;</span><br><span class="line">     <span class="string">&#x27;guest1_1&#x27;</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest1_1&#x27;</span>),</span><br><span class="line">     <span class="string">&#x27;guest2_2&#x27;</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest2_2&#x27;</span>),</span><br><span class="line">     <span class="string">&#x27;guest3_3&#x27;</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest3_3&#x27;</span>),</span><br><span class="line">     <span class="string">&#x27;guest4_4&#x27;</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;guest4_4&#x27;</span>),</span><br><span class="line">     <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;default&#x27;</span>),</span><br><span class="line"> &#125;</span><br><span class="line"> actions[<span class="string">`<span class="subst">$&#123;identify&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>] ? actions[<span class="string">`<span class="subst">$&#123;identify&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>]() : actions[<span class="string">&#x27;default&#x27;</span>]() <span class="comment">//  default</span></span><br></pre></td></tr></table></figure>
<h2 id="关于多元判断的解决方案如下："><a href="#关于多元判断的解决方案如下：" class="headerlink" title="关于多元判断的解决方案如下："></a>关于多元判断的解决方案如下：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> status1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> status2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> actions = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;11&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;12&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;13&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;13&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;21&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;21&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;22&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;22&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;23&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;23&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;31&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;31&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;32&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;32&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;33&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;33&#x27;</span>)],</span><br><span class="line">  [<span class="string">&#x27;default&#x27;</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;default&#x27;</span>)]</span><br><span class="line">])</span><br><span class="line">actions.get(<span class="string">`<span class="subst">$&#123;status1&#125;</span><span class="subst">$&#123;status2&#125;</span>`</span>) ? actions.get(<span class="string">`<span class="subst">$&#123;status1&#125;</span><span class="subst">$&#123;status2&#125;</span>`</span>)() : actions.get(<span class="string">&#x27;default&#x27;</span>)() <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript 代码 风格 编码 技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>前端代码质量的思考与实践</title>
    <url>/2020/03/16/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="前端代码质量的思考与实践"><a href="#前端代码质量的思考与实践" class="headerlink" title="前端代码质量的思考与实践"></a>前端代码质量的思考与实践</h1><p>编写可读的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是能够被阅读，其次才是能够被正确执行。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结，除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p>
<p>JavaScript 是动态和弱类型的语言，使用起来比较轻松随意，在IE6那个刀耕火种的时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端工程化技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p>
<a id="more"></a>

<h1 id="分享与共勉"><a href="#分享与共勉" class="headerlink" title="分享与共勉"></a>分享与共勉</h1><blockquote>
<ol>
<li><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.      —— Martin Fowler</p>
</li>
<li><p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, “How can I improve the code so that this comment isn’t needed?”               ——Steve McConnell</p>
</li>
<li><p>Programs must be written for people to read, and only incidentally for machines to execute.   —— Harold Abelson</p>
</li>
</ol>
</blockquote>
<h2 id="HTML中的实践"><a href="#HTML中的实践" class="headerlink" title="HTML中的实践"></a>HTML中的实践</h2><p><img src="https://i.loli.net/2021/01/11/LZCdnG8DuAh6y9e.png"></p>
<ul>
<li><p>使用语义化标签</p>
</li>
<li><p>清晰、简洁的层级嵌套结构</p>
</li>
<li><p>尽可能少地使用无意义的标签，如div和span</p>
</li>
<li><p>语义不明显，可以用p也可以用div，优先用p标签</p>
</li>
<li><p>在无法用标签表明语义的场景下增加适当的注释</p>
<p><img src="https://i.loli.net/2021/01/11/EpSoftGBArU8Lau.png"></p>
</li>
</ul>
<h2 id="CSS中的实践"><a href="#CSS中的实践" class="headerlink" title="CSS中的实践"></a>CSS中的实践</h2><p><img src="https://i.loli.net/2021/01/11/NR45eSn2cDjhgVK.png"></p>
<ul>
<li>引入sass或其他css预处理器</li>
<li>命名可以参考借鉴BEM命名法和中划线命名法</li>
<li>根节点用id选择器，其它用类选择器，子代替代后代</li>
<li>css属性书写采用约定的顺序</li>
<li>类命名中划线分隔不超过4级，超过了从0开始</li>
<li>尽量避免使用float，position，采用flex布局和grid布局</li>
<li>如果只能直接编写css，也可以参考上述体现的思路</li>
<li>如果无法直接引入sass，可用IDE或终端进行手动转译</li>
</ul>
<h2 id="javascript和jQuery的实践"><a href="#javascript和jQuery的实践" class="headerlink" title="javascript和jQuery的实践"></a>javascript和jQuery的实践</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>　　变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p>
<p>　　命名必须传递足够的信息，形如 getData 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 fetchUserInfoAsync 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 Async 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p>
<ul>
<li>命名的基础。用名词命名对象，用动词命名函数，用复数表示集合，也可以加上List或Map后缀来显示地表示出来，使代码接近于自然语言。变量命名建议用小驼峰，类建议用大驼峰。</li>
<li>命名规范。时刻按照某种规则来命名变量和函数，不用担心变量污染和能够见名知意了。如：fetch或async代表异步，get代表获取，set代表设置，is、has、can代表一个布尔值，handle代表普通函数等。.</li>
<li>命名的上下文。变量都是处在上下文（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。</li>
<li>匈牙利命名法。基本原则：变量名=属性+类型+描述。其中每一个对象的名称都要求有明确含义，可以取对象全称或简写。例如：sUserName，代表用户姓名的字符串。拥有一定的学习成本，自行取舍。.</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/lbQpEYNGVrvZnjX.png"></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>　　在ECMAScript 6之前，JavaScript中并没有真正的常量的概念。然而，这并不能组织开发者将变量用作常量。为了区分普通的变量（变量的值是可变的）和常量（常量的值初始化之后就不能变了），一种通用的命名约定应运而生。这个约定源自于C语言，它使用大写字母和下划线来命名，下划线用以分隔单词。</p>
<ul>
<li>约定命名。变量名全部用大写字母，多个单词用下划线分隔</li>
<li>魔术常量。同一个常量（值）在不同的上下文中可能代表着不同的含义。引申到js中，就是要使用有意义的变量名代替魔术常量，以提高代码的维护性和可读性。</li>
<li>避免硬编码。对于代码中重复使用次数较多、未来可能会变动的数据，最好抽离成变量或配置项，实现代码逻辑和业务松耦合，增强维护性。</li>
<li>常量的声明。按关键字优先使用顺序：const =&gt; let =&gt; var。能用const和let的尽量不要用var，var声明有副作用。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/SMd9V5kzeZlCAs8.png"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>　　何时添加注释是具有争议的一个话提。代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p>
<ul>
<li>难于理解的代码。逻辑比较复杂或特殊的业务逻辑时都应当加注释。关键是让其他人更容易读懂这段代码。</li>
<li>可能被错误理解的代码。在团队开发中，当自己写的代码可能会被其他同事认为有错误时，需要添加注释。</li>
<li>浏览器特性hack。兼容性代码会让人看不明白，此时应当添加适当的注释解释其用途。</li>
<li>文档注释。对于工具类等公共方法，添加文档注释，解释其用途、参数和返回值，让人看注释就能明白使用方法，而不用关心方法内部的实现。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/na9uHh6RTb7P8kN.png"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>　　JS是一种多范式编程语言。函数式编程是一种编程范式，一种构建计算机程序结构和元素的方式，将计算视为数学函数的评估并避免改变状态和可变数据。它使你能够构建无副作用的功能，而函数式编程的一些优点，也使得系统变得更加容易维护。</p>
<ul>
<li><p>纯函数。给出相同的参数，它返回相同的结果（确定性）；不会引起任何可观察到的副作用；容易测试。</p>
</li>
<li><p>闭包。通过闭包可以在函数外部能访问到函数内部的变量，过度地使用闭包会造成内存泄露。</p>
</li>
<li><p>单一原则。如果一个方法承担了过多的职责，在需求发生变化的过程中，需要改写这个方法的可能性就越大。</p>
</li>
<li><p>面向切面编程。非侵入性的改造函数。保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用现有功能模块。</p>
</li>
<li><p>健壮性。web开发安全守则：永远不要相信用户的输入。对数据最好做异常处理，增强其健壮性。例如XSS。</p>
</li>
<li><p>参数。形参越少越好，不超过3个，超过3的用对象代替，这样可以极大地减少该方法的UT自测场景。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000014277519">注：尾调用和尾递归</a></p>
</li>
</ul>
<h2 id="前端异常的处理"><a href="#前端异常的处理" class="headerlink" title="前端异常的处理"></a>前端异常的处理</h2><p>  　　前端异常的处理也属于代码健壮性的一部分。JavaScript不像Java一样，有专门的语法去定义和实现异常处理，前端代码是离用户最近的代码，异常的处理更多的是从用户体验和代码健壮性出发的，后端代码异常的处理更多的是从业务角度和数据安全性出发的。所以JavaScript的异常处理方法主要是对页面内容（用户输入和接口输入）的校验上，在异常的时候能给出用户能看懂的提示，另一方面，从代码角度来上来说，研发也能够从页面的提示上快速地定位问题、修复问题，提升解决问题的效率。</p>
<h2 id="使用全等-替代相等-（副作用）"><a href="#使用全等-替代相等-（副作用）" class="headerlink" title="使用全等===替代相等==（副作用）"></a>使用全等===替代相等==（副作用）</h2><p>　　javascript具有强制类型转换机制，判断相等的操作是很微妙的。对于某些运算来说，为了得到成功的结果，强制类型转换会驱使某种类型的变量自动转换成其他不同类型，这种情形往往会造成意想不到的结果。</p>
<p>　　发生强制类型转换最常见的场景就是，使用了判断相等运算符==和!=的时候。当要比较的两个值的类型不同时，这两个运算符都会有强制类型转换。但在很多实际情况中，代码并不按照我所期望的方式运行。Crockford的编程规范、jQuery核心风格指南、SproutCore编程风格指南推荐使用===和!==。</p>
<p><img src="https://i.loli.net/2021/01/11/Vjcohgs8LkPfAiy.png"></p>
<p><img src="https://i.loli.net/2021/01/11/GHN2p7PqVFgcUlf.png"></p>
<h2 id="jQuery效率提升建议"><a href="#jQuery效率提升建议" class="headerlink" title="jQuery效率提升建议"></a>jQuery效率提升建议</h2><ul>
<li><p>正确使用选择器。Id &gt; tag &gt; class &gt; 属性和伪类</p>
</li>
<li><p>层级选择器尽量使用find方法，效率较高</p>
</li>
<li><p>缓存 jQuery 对象</p>
</li>
<li><p>链式调用</p>
</li>
<li><p>事件委托</p>
</li>
<li><p>少改动DOM</p>
<p><img src="https://i.loli.net/2021/01/11/YtzPvUJbx5q6mOS.png"></p>
</li>
</ul>
<h2 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h2><p>　　设计模式是在软件设计过程中针对特定问题的简洁而优雅的解决方案。《parctical common lisp》的作者曾说，如果你需要一种模式，那一定是哪里出了问题。他所说的问题是指因为语言的天生缺陷，不得不去寻求和总结一种通用的解决方案。不管是弱类型或强类型，静态或动态语言，命令式或说明式语言、每种语言都有天生的优缺点。</p>
<p>　　单例模式比较好理解，它是一个对象，我们创建这个对象的目地是为了系统管理代码中的一些公用的变量，对象，函数，避免出现变量污染，一般我们声明一些变量和函数的时候，我们是在封闭的函数中，一般不会造成变量污染情况，但是以防万一，原因是在js中，全局变量和局部变量的关系比较复杂（有时候还夹杂着一部分变量提升问题），不少coder经常会因为此问题出现bug老半天找不到原因，创建好这个对象以后我们只是对外暴露一个对象入口，使用里面的变量时我们可以以object.变量名的形式来调用变量，其实也是为了实现js代码块的划分命名空间来设计的。</p>
<p>　　我之前写了几年的php和jQuery，经过了项目中不断地摸索与总结，得出了一个结论：在jquery技术栈的实际项目开发中，近乎95%的需求都可以通过单例模式来满足实现。</p>
<p><img src="https://i.loli.net/2021/01/11/ATF15n6EuKrsNRU.png"></p>
<h2 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h2><p>　　适配器模式是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。</p>
<p>　　适用场景：</p>
<ul>
<li><p>使用一个已经存在的对象，但其方法或属性接口不符合你的要求</p>
</li>
<li><p>你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作</p>
</li>
<li><p>想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性</p>
<p><img src="https://i.loli.net/2021/01/11/SO2P5wqVYLQ1mid.png"></p>
</li>
</ul>
<h2 id="推荐ES6，其次ES5，最后ES3"><a href="#推荐ES6，其次ES5，最后ES3" class="headerlink" title="推荐ES6，其次ES5，最后ES3"></a>推荐ES6，其次ES5，最后ES3</h2><ul>
<li>使用const，let，不使用var</li>
<li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号</li>
<li>使用数组成员对变量赋值时，优先使用解构赋值</li>
<li>立即执行函数可以写成箭头函数的形式。</li>
<li>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</li>
<li>使用扩展运算符（…）拷贝数组。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/qtz2ZOuwU5oBNkQ.png"></p>
<h1 id="VUE中的实践"><a href="#VUE中的实践" class="headerlink" title="VUE中的实践"></a><strong>VUE中的实践</strong></h1><h2 id="大道至简，通俗易懂"><a href="#大道至简，通俗易懂" class="headerlink" title="大道至简，通俗易懂"></a>大道至简，通俗易懂</h2><ul>
<li>语义化的标签，可以配合类名实现</li>
<li>层次结构清晰、简洁，用最少的嵌套实现最复杂的结构</li>
<li>充分利用sass的作用域，样式私有化，把css样式影响范围最小化</li>
<li>使用大众化的写法，减少学习的成本</li>
<li>尽量多使用类选择器，少用标签选择器，实现复用</li>
<li>CSS样式属性的顺序可以参考前面章节《CSS中的实践》</li>
<li>把视图展示的部分放在template中，视图层主要负责展示</li>
<li>把数据（entity）放在data和computed中，数据层主要负责声明（interface, abstract）</li>
<li>把逻辑放在methods和其他几个api里，控制层主要负责实现</li>
<li>单向数据流的思想。数据改变可记录、可跟踪，源头易追溯；数据只有唯一入口和出口，更直观更容易理解，提高可维护性。</li>
<li>注：95%的业务场景最多只需要使用到3-4个生命周期，如果超过了，检查一下自己的代码</li>
<li>代码风格可参考：<a href="https://cn.vuejs.org/v2/style-guide/">https://cn.vuejs.org/v2/style-guide/</a></li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/jPyDREwCSoO4B3r.png"></p>
<p><img src="https://i.loli.net/2021/01/11/SVcNgnZLvq2hUDJ.png"></p>
<h1 id="前端发展的各个阶段"><a href="#前端发展的各个阶段" class="headerlink" title="前端发展的各个阶段"></a>前端发展的各个阶段</h1><p><img src="https://i.loli.net/2021/01/11/OVl5WuTqCDB6xMi.png"></p>
<h1 id="前端框架的对比"><a href="#前端框架的对比" class="headerlink" title="前端框架的对比"></a>前端框架的对比</h1><p><img src="https://i.loli.net/2021/01/11/IhlA4fxGRbTsNSU.png"></p>
<h1 id="常用设计模式与代码的结合"><a href="#常用设计模式与代码的结合" class="headerlink" title="常用设计模式与代码的结合"></a>常用设计模式与代码的结合</h1><p><img src="https://i.loli.net/2021/01/11/gEShZou87kaRzVl.png"></p>
<h1 id="JavaScript语言的特点"><a href="#JavaScript语言的特点" class="headerlink" title="JavaScript语言的特点"></a>JavaScript语言的特点</h1><ul>
<li>声明提升。代码在执行的时候，js解析器会先把funtion声明和var声明放在前面，然后顺序执行对应的语句。推荐用es6的const，其次let，不推荐用var。</li>
<li>私有变量。可以通过闭包来实现私有变量的声明，但闭包会让私有变量常驻内存，滥用闭包会造成内存泄露，所以要谨慎使用闭包。</li>
<li>for-in。对象可以采用传统for-in循环遍历，但该方式会遍历出原型链上的属性，产生意想不到的结果。推荐使用ES6的Object.keys和Object.values结合数组的api。</li>
<li>多态。JS没有多态，某种意义上说多态与函数的单一原则是对立的，所以建议多类型参数执行的是同一类逻辑的时候用多态。参考：jquery源码的Sizzle引擎。</li>
<li>单线程。通过异步解决单线程的弊端。但传统异步解决方案通过回调实现，大量嵌套的回调会造成回调地狱的现象，代码可读性很差，不利于维护。推荐使用ES6的Promise和async/await。</li>
<li>副作用。全面拥抱函数式编程，避免使用有副作用的代码，如ES3中var的声明提升，for-in的副作用，==的隐式转换， BOM中alert的阻塞效果等。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/VaXusiRzoY9McSE.png"></p>
<h1 id="书籍以及社区"><a href="#书籍以及社区" class="headerlink" title="书籍以及社区"></a>书籍以及社区</h1><ul>
<li><p>《JavaScript权威指南》：犀牛书可以先大致通读几遍，也可以把其当作工具书，时时翻阅。 </p>
</li>
<li><p>《JavaScript高级程序设计》：红宝书虽然号称高级，但其实是帮助入门的。小红书配合犀牛书，相互印证。 </p>
</li>
<li><p>《你不知道的JavaScript 上中下》：这本绝对是神书，让你了解JavaScript不为人知的另一面，把闭包、异步这些讲得很通透。 </p>
</li>
<li><p>《ES6 标准入门（第3版）》阮老师的书，ES6入门书籍。</p>
</li>
<li><p>《锋利的jQuery》循序渐进地对jQuery的各种API进行了介绍</p>
</li>
<li><p>《 JavaScript模式》陈新 译，系统地讲解了编写高质量代码的技巧和开发过程中最常用的几种设计模式。</p>
</li>
<li><p>《重构-改善既有代码的设计》一些写代码的思想层次的东西。</p>
</li>
<li><p>《编写可维护的JavaScript 》包括具体风格和原则的介绍，也包括示例和技巧说明</p>
</li>
<li><p><a href="http://www.segmentfault.com/">思否社区</a>：中国版<a href="http://www.stackoverflow.com/">stackoverflow</a></p>
</li>
</ul>
<h1 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h1><p>　　软件bug的修改是需要成本的，并且这项成本总是在不断地增加，特别是对于已经广泛发布的产品代码而言，更是如此。最好的情况是当我们一发现bug，立刻就可以修改它，这种情况只发生在刚写完这些代码后不久。否则转移到新的任务上，忘记了这部分代码，就需要重新阅读这些代码。</p>
<p>　　对于大型项目而言，还存在着另一个问题，就是最终修改代码的人，往往并不是当初写代码的人，也不是发现bug的人。因此，减少理解自己以前写的代码的时间，或者减少理解团队中他人写的代码的时间，就变得非常关键。</p>
<p>　　另外一个事实在于，软件开发人员通常读代码比写代码更耗时间。通常的情形是，当我们专注于某个问题时，会坐下来花一下午的时间编写出大量的代码。这些代码可能当天就可运行，但要想成为一项成熟的应用，需要我们对代码进行重新检查、重新校正、重新调整。</p>
<p>　　编写高质量的代码是十分重要的，不仅对于成功地完成项目十分有利，而且有利于开发者与开发团队的其他人员进行交流。提高代码的质量，可能最初只是几小时工时写出来的代码，最终需要花费几周的工时来阅读。这就是为什么编写易维护的高质量的代码对项目具有举足轻重的作用。</p>
<p>　　代码的质量从某种意义上来说就是一个系统的生命线，任何上线的系统都是通过了测试的，但代码的质量决定了这个系统能走多远！我在新闻上听说过有人删库跑路的，也见过有人接手老项目后马上离职的，其中有一些就和老代码的质量问题有着必然的联系。</p>
<p>　　代码质量和效率之间有着天然的矛盾，怎么去平衡值得我们去思考，下面是我的一点心得与体会：1、代码风格；2、code review；3、抽离、封装、复用；4、持续学习和持续实践；5、开发周期与代码质量的平衡。</p>
]]></content>
      <tags>
        <tag>代码 质量 实践 思考 可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>写给工程师的十条精进原则</title>
    <url>/2018/09/13/%E5%86%99%E7%BB%99%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%8D%81%E6%9D%A1%E7%B2%BE%E8%BF%9B%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>作者： 云鹏 From 美团技术团队</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>时间回到8年前，我人生中的第一份实习工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。</p>
<p>这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。</p>
<p>8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。</p>
<p>“追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。</p>
<a id="more"></a>

<h1 id="原则一：Owner意识"><a href="#原则一：Owner意识" class="headerlink" title="原则一：Owner意识"></a>原则一：Owner意识</h1><p>“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。</p>
<p><strong>认真负责是工作的底线。</strong>首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD的工程交付质量，还会对协同工作的RD、QA、PM等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。</p>
<p><strong>积极主动是“Owner意识”更高一级的要求。</strong>RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。</p>
<p>积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。</p>
<h1 id="原则二：时间观念"><a href="#原则二：时间观念" class="headerlink" title="原则二：时间观念"></a>原则二：时间观念</h1><p>相信大家都有时间观念，但是真正能执行到位的可能并没有那么多。互联网是一个快速发展的行业，RD的研发效率是一个公司硬实力的重要体现。项目的按期交付是一项很重要的执行能力，在很大程度上决定着领导和同事对自己靠谱程度的评价。大家可能会问：难度几乎相同的项目，为什么有的同学经常Delay，而有的同学每次都能按时上线？一个很重要的原因，就是这些按时交付的同学往往具备如下两个特质：<strong>做事有计划，工作分主次。</strong></p>
<p><strong>工作安排要有计划性。</strong>通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。</p>
<p>此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。</p>
<p><strong>工作安排要分清楚主次。</strong>我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。</p>
<h1 id="原则三：以终为始"><a href="#原则三：以终为始" class="headerlink" title="原则三：以终为始"></a>原则三：以终为始</h1><p>“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：<strong>先想清楚目标，然后努力实现。</strong></p>
<p>在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现的尤为明显。</p>
<p>例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，<strong>所以要根据问题设定目标，再进行优化。</strong></p>
<p>“以终为始”，这一原则还可以作用于我们的学习中。很多同学看过很多技术文章，但是总是感觉自己依然一无所知。很重要的一个原因，就是没有<strong>带着目标去学习。</strong>在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把Redis的持久化原理搞清楚，还是把Redis的主从同步机制弄明白，亦或是想学习整个Redis Cluster的架构体系。如果我们能够带着问题与目标，再进行相关的资料搜集与学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好很多。</p>
<h1 id="原则四：闭环思维"><a href="#原则四：闭环思维" class="headerlink" title="原则四：闭环思维"></a>原则四：闭环思维</h1><p>你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。</p>
<p>之前看过一句话：<strong>一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，</strong>如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。</p>
<p>例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的To Do进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入“沟通-发现问题-再沟通-再发现问题”的恶性循环中。</p>
<p><strong>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。</strong></p>
<p><strong>“闭环思维”还要求能够定期主动进行阶段性的反馈。</strong>刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。</p>
<p>这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。</p>
<h1 id="原则五：保持敬畏"><a href="#原则五：保持敬畏" class="headerlink" title="原则五：保持敬畏"></a>原则五：保持敬畏</h1><p>“君子之心，常怀敬畏”，保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。</p>
<p><strong>当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。</strong>以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。</p>
<p>类似的问题，还包括对上线流程的不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。</p>
<p>保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，<strong>让规范与约定与时俱进，也是另一种形式的敬畏。</strong></p>
<h1 id="原则六：事不过二"><a href="#原则六：事不过二" class="headerlink" title="原则六：事不过二"></a>原则六：事不过二</h1><p>“事不过二”，是我们团队一贯坚持的原则，它可以解读为两层含义。</p>
<p>一层含义是“<strong>所有的评审与问题讨论，不要超过两次</strong>”。之所以有这样的要求，是因为我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。</p>
<p>同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此我们团队规定：<strong>所有的评审最多两次</strong>。通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够大大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。</p>
<p>“事不过二”原则的另一层含义，是“<strong>同样的错误不能犯第二次</strong>”。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。</p>
<h1 id="原则七：设计优先"><a href="#原则七：设计优先" class="headerlink" title="原则七：设计优先"></a>原则七：设计优先</h1><p>“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。”</p>
<p><strong>架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。</strong>很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计的足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。<strong>无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。</strong>因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。</p>
<p><strong>“设计优先”这一原则，要求写别人看得懂的设计。</strong>我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。</p>
<h1 id="原则八：P-PC平衡"><a href="#原则八：P-PC平衡" class="headerlink" title="原则八：P/PC平衡"></a>原则八：P/PC平衡</h1><p>“P/PC平衡”原则，即产出与产能平衡原则。伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。<strong>产出与产能必须平衡，才能达到真正的高效能。</strong>为了让大家更清晰的了解这一原则，本文举两个例子。</p>
<p>从系统的角度看，每一个系统都是通过持续不断地叠加功能，来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。</p>
<p>再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P/PC不平衡的体现。<strong>如果能在做项目的过程中，通过学习总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。</strong></p>
<p>“P/PC平衡”原则还适用于很多其他的领域，例如团队、家庭等，我本人也非常推崇这一原则。希望大家也能将其作为自身的一项基本原则，努力寻找到产出与产能的平衡点。</p>
<h1 id="原则九：善于提问"><a href="#原则九：善于提问" class="headerlink" title="原则九：善于提问"></a>原则九：善于提问</h1><p>“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，<strong>只有在争辩中，才可能诞生最好的主意和最好的决定。</strong></p>
<p>在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。</p>
<p><strong>“善于提问”，还要懂得如何提问。</strong>为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：这就是批判性思维。</p>
<p>批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。</p>
<h1 id="原则十：空杯心态"><a href="#原则十：空杯心态" class="headerlink" title="原则十：空杯心态"></a>原则十：空杯心态</h1><p>“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。</p>
<p><strong>保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。</strong>在工作中，多去跟不同级别的同学聊一聊，或者做一个360度评估，这有助于我们更加客观地评价自己。在横向对比中，多向那些优秀的同学看齐，学习他人的优点。很多同学在设计评审或者代码Review过程中，针对别人提出的问题与建议，往往都采用一种对立的态度。错误地认为别人是在挑刺，是在针对自己。诚然，在某些方面，我们可能确实比其他人想得深入，但是这不代表在所有方面都能考虑周全。对于别人的建议，建议使用“善于提问”原则里提到的批判性思维仔细分析一下，虚心地吸取那些好的建议。</p>
<p>工作学习就像“练级打怪”，技能储备的越多，就越容易走到最后。保持空杯心态，可以让我们发现很多以前注意不到的新能力，我们要做的就是努力学习它，将它们转化为自己能力库的一部分。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，是我总结的工作与学习的十条基本原则。其中有的侧重于个人做事情的方法，如“Owner意识”、“时间观念”、“以终为始”、”闭环思维”；有的侧重于团队工作标准规范，如“保持敬畏”、“事不过二”、“设计优先”；有的侧重于团队或个人效能提升，如“P/PC平衡”、“善于提问”、“空杯心态”。这些原则是我多年在工作与学习中，不断总结得来的经验。希望在大家面临选择时，这些原则能够起到一定的帮助和指导作用。</p>
<p>以原则为中心地工作与生活，让自己与团队变得更加强大。</p>
<h1 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h1><p>云鹏，2014年加入美团，先后参与了美团酒店供应链体系、分布式调度系统的建设，现在负责美团旅行客户关系管理系统、基础信息服务的建设工作。</p>
]]></content>
      <tags>
        <tag>开发 原则 流程 编程 工程师</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github和工作中总结出来的工程师代码书写习惯</title>
    <url>/2018/11/28/%E5%9F%BA%E4%BA%8Egithub%E5%92%8C%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93%E5%87%BA%E6%9D%A5%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<h1 id="最佳原则"><a href="#最佳原则" class="headerlink" title="最佳原则"></a>最佳原则</h1><p>虽然这些细节是小事，不会有体验或者性能上的优化，但是却体现了一个coder和团队的专业程度 团队的愿景：成为业界卓越的Web团队！</p>
<p>坚持制定好的代码规范。</p>
<p>所以不管团队有多少人，代码风格都应该师出同门！</p>
<a id="more"></a>

<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h2><p>全部采用小写方式， 以下划线分隔。</p>
<p>例：my_project_name</p>
<h2 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h2><p>参照项目命名规则；</p>
<p>有复数结构时，要采用复数命名法。</p>
<p>例：scripts, styles, images, data_models</p>
<h2 id="JS文件命名"><a href="#JS文件命名" class="headerlink" title="JS文件命名"></a>JS文件命名</h2><p>参照项目命名规则。</p>
<p>例：account_model.js</p>
<h2 id="CSS-SCSS文件命名"><a href="#CSS-SCSS文件命名" class="headerlink" title="CSS, SCSS文件命名"></a>CSS, SCSS文件命名</h2><p>参照项目命名规则；</p>
<p>例：retina_sprites.css</p>
<h2 id="HTML文件命名"><a href="#HTML文件命名" class="headerlink" title="HTML文件命名"></a>HTML文件命名</h2><p>参照项目命名规则。</p>
<p>例：error_report.html</p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>缩进使用soft tab（4个空格）；</li>
<li>嵌套的节点应该缩进；</li>
<li>在属性上，使用双引号，不要使用单引号；</li>
<li>属性名全小写，用中划线做分隔符；</li>
<li>不要在自动闭合标签结尾处使用斜线（HTML5 规范 指出他们是可选的）；（<a href="https://www.oschina.net/news/49775/html-tag-to-close-or-not-to-close" title="作者注：有待考证">作者注：有待考证</a>）</li>
<li>不要忽略可选的关闭标签，例：<code>&lt;/li&gt;</code> 和 <code>&lt;/body&gt;</code>。</li>
</ul>
<h2 id="HTML5-doctype"><a href="#HTML5-doctype" class="headerlink" title="HTML5 doctype"></a>HTML5 doctype</h2><p>在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现；</p>
<p>虽然doctype不区分大小写，但是按照惯例，doctype大写 （<a href="https://stackoverflow.com/questions/15594877/is-there-any-benefits-to-use-uppercase-or-lowercase-letters-with-html5-tagname" title="关于html属性，大写还是小写">关于html属性，大写还是小写</a>）。</p>
<h2 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h2><p>根据HTML5规范：</p>
<p><em>应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。</em></p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为’UTF-8’。</p>
<h2 id="IE兼容模式"><a href="#IE兼容模式" class="headerlink" title="IE兼容模式"></a>IE兼容模式</h2><p>用 ·<meta>· 标签可以指定页面应该用什么版本的IE来渲染；</p>
<h2 id="引入CSS-JS"><a href="#引入CSS-JS" class="headerlink" title="引入CSS, JS"></a>引入CSS, JS</h2><p>根据HTML5规范, 通常在引入CSS和JS时不需要指明<code>type</code>，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是他们的默认值。</p>
<h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><p>属性应该按照特定的顺序出现以保证易读性；</p>
<ul>
<li>class</li>
<li>id</li>
<li>name</li>
<li>data-*</li>
<li>src, for, type, href, value , max-length, max, min, pattern</li>
<li>placeholder, title, alt</li>
<li>aria-*, role</li>
<li>required, readonly, disabled</li>
</ul>
<p>class是为高可复用组件设计的，所以应处在第一位；</p>
<p>id更加具体且应该尽量少使用，所以将它放在第二位。</p>
<h2 id="boolean属性"><a href="#boolean属性" class="headerlink" title="boolean属性"></a>boolean属性</h2><p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; disabled&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;1&quot; checked&gt;</span><br><span class="line"></span><br><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;1&quot; selected&gt;1&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="JS生成标签"><a href="#JS生成标签" class="headerlink" title="JS生成标签"></a>JS生成标签</h2><p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。</p>
<h2 id="减少标签数量"><a href="#减少标签数量" class="headerlink" title="减少标签数量"></a>减少标签数量</h2><p>在编写HTML代码时，需要尽量避免多余的父节点；</p>
<p>很多时候，需要通过迭代和重构来使HTML变得更少。</p>
<h2 id="实用高于完美"><a href="#实用高于完美" class="headerlink" title="实用高于完美"></a>实用高于完美</h2><p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；</p>
<p>任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p>
<h1 id="CSS-SCSS"><a href="#CSS-SCSS" class="headerlink" title="CSS, SCSS"></a>CSS, SCSS</h1><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>使用soft tab（4个空格）。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>每个属性声明末尾都要加分号。</p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>以下几种情况不需要空格：</p>
<ul>
<li>属性名后</li>
<li>多个规则的分隔符’,’前</li>
<li>!important ‘!’后</li>
<li>属性值中’(‘后和’)’前</li>
<li>行末不要有多余的空格</li>
</ul>
<p>以下几种情况需要空格：</p>
<ul>
<li>属性值前</li>
<li>选择器’&gt;’, ‘+’, ‘~’前后</li>
<li>‘{‘前</li>
<li>!important ‘!’前</li>
<li>@else 前后</li>
<li>属性值中的’,’后</li>
<li>注释’/<em>‘后和’</em>/‘前</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    color :red! important;</span><br><span class="line">    background-color: rgba(0,0,0,.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    color: red !important;</span><br><span class="line">    background-color: rgba(0, 0, 0, .5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element ,</span><br><span class="line">.dialog&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element,</span><br><span class="line">.dialog &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element&gt;.dialog&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &gt; .dialog&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">@if&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;@else&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">@if &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>以下几种情况需要空行：</p>
<ul>
<li>文件最后保留一个空行</li>
<li>‘}’后最好跟一个空行，包括scss中嵌套的规则</li>
<li>属性之间需要适当的空行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">.dialog &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    &amp;:after &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.dialog &#123;</span><br><span class="line">    color: red;</span><br><span class="line"></span><br><span class="line">    &amp;:after &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>以下几种情况不需要换行：</p>
<ul>
<li>‘{‘前</li>
</ul>
<p>以下几种情况需要换行：</p>
<ul>
<li>‘{‘后和’}’前</li>
<li>每个属性独占一行</li>
<li>多个规则的分隔符’,’后</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element</span><br><span class="line">&#123;color: red; background-color: black;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element, .dialog &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element,</span><br><span class="line">.dialog &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释统一用’/* */‘（scss中也不要用’//‘），具体参照下边的写法；</p>
<p>缩进与下一行代码保持一致；</p>
<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Modal header *&#x2F;</span><br><span class="line">.modal-header &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Modal header</span><br><span class="line"> *&#x2F;</span><br><span class="line">.modal-header &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.modal-header &#123;</span><br><span class="line">    &#x2F;* 50px *&#x2F;</span><br><span class="line">    width: 50px;</span><br><span class="line"></span><br><span class="line">    color: red; &#x2F;* color red *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>最外层统一使用双引号；</p>
<p>url的内容要用引号；</p>
<p>属性选择器中的属性值需要引号。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul>
<li>类名使用小写字母，以中划线分隔</li>
<li>id采用驼峰式命名</li>
<li>scss中的变量、函数、混合、placeholder采用驼峰式命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* class *&#x2F;</span><br><span class="line">.element-content &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* id *&#x2F;</span><br><span class="line">#myDialog &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 变量 *&#x2F;</span><br><span class="line">$colorBlack: #000;</span><br><span class="line"></span><br><span class="line">&#x2F;* 函数 *&#x2F;</span><br><span class="line">@function pxToRem($px) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 混合 *&#x2F;</span><br><span class="line">@mixin centerBlock &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* placeholder *&#x2F;</span><br><span class="line">%myDialog &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性声明顺序"><a href="#属性声明顺序" class="headerlink" title="属性声明顺序"></a>属性声明顺序</h2><p>相关的属性声明按右边的顺序做分组处理，组之间需要有一个空行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.declaration-order &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    float: right;</span><br><span class="line"></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    z-index: 100;</span><br><span class="line"></span><br><span class="line">    border: 1px solid #e5e5e5;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line"></span><br><span class="line">    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">    text-align: center;</span><br><span class="line"></span><br><span class="line">    color: #333;</span><br><span class="line">    background-color: #f5f5f5;</span><br><span class="line"></span><br><span class="line">    opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下面是推荐的属性的顺序</span><br><span class="line">[</span><br><span class="line">    [</span><br><span class="line">        &quot;display&quot;,</span><br><span class="line">        &quot;visibility&quot;,</span><br><span class="line">        &quot;float&quot;,</span><br><span class="line">        &quot;clear&quot;,</span><br><span class="line">        &quot;overflow&quot;,</span><br><span class="line">        &quot;overflow-x&quot;,</span><br><span class="line">        &quot;overflow-y&quot;,</span><br><span class="line">        &quot;clip&quot;,</span><br><span class="line">        &quot;zoom&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;table-layout&quot;,</span><br><span class="line">        &quot;empty-cells&quot;,</span><br><span class="line">        &quot;caption-side&quot;,</span><br><span class="line">        &quot;border-spacing&quot;,</span><br><span class="line">        &quot;border-collapse&quot;,</span><br><span class="line">        &quot;list-style&quot;,</span><br><span class="line">        &quot;list-style-position&quot;,</span><br><span class="line">        &quot;list-style-type&quot;,</span><br><span class="line">        &quot;list-style-image&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;-webkit-box-orient&quot;,</span><br><span class="line">        &quot;-webkit-box-direction&quot;,</span><br><span class="line">        &quot;-webkit-box-decoration-break&quot;,</span><br><span class="line">        &quot;-webkit-box-pack&quot;,</span><br><span class="line">        &quot;-webkit-box-align&quot;,</span><br><span class="line">        &quot;-webkit-box-flex&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;position&quot;,</span><br><span class="line">        &quot;top&quot;,</span><br><span class="line">        &quot;right&quot;,</span><br><span class="line">        &quot;bottom&quot;,</span><br><span class="line">        &quot;left&quot;,</span><br><span class="line">        &quot;z-index&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;margin&quot;,</span><br><span class="line">        &quot;margin-top&quot;,</span><br><span class="line">        &quot;margin-right&quot;,</span><br><span class="line">        &quot;margin-bottom&quot;,</span><br><span class="line">        &quot;margin-left&quot;,</span><br><span class="line">        &quot;-webkit-box-sizing&quot;,</span><br><span class="line">        &quot;-moz-box-sizing&quot;,</span><br><span class="line">        &quot;box-sizing&quot;,</span><br><span class="line">        &quot;border&quot;,</span><br><span class="line">        &quot;border-width&quot;,</span><br><span class="line">        &quot;border-style&quot;,</span><br><span class="line">        &quot;border-color&quot;,</span><br><span class="line">        &quot;border-top&quot;,</span><br><span class="line">        &quot;border-top-width&quot;,</span><br><span class="line">        &quot;border-top-style&quot;,</span><br><span class="line">        &quot;border-top-color&quot;,</span><br><span class="line">        &quot;border-right&quot;,</span><br><span class="line">        &quot;border-right-width&quot;,</span><br><span class="line">        &quot;border-right-style&quot;,</span><br><span class="line">        &quot;border-right-color&quot;,</span><br><span class="line">        &quot;border-bottom&quot;,</span><br><span class="line">        &quot;border-bottom-width&quot;,</span><br><span class="line">        &quot;border-bottom-style&quot;,</span><br><span class="line">        &quot;border-bottom-color&quot;,</span><br><span class="line">        &quot;border-left&quot;,</span><br><span class="line">        &quot;border-left-width&quot;,</span><br><span class="line">        &quot;border-left-style&quot;,</span><br><span class="line">        &quot;border-left-color&quot;,</span><br><span class="line">        &quot;-webkit-border-radius&quot;,</span><br><span class="line">        &quot;-moz-border-radius&quot;,</span><br><span class="line">        &quot;border-radius&quot;,</span><br><span class="line">        &quot;-webkit-border-top-left-radius&quot;,</span><br><span class="line">        &quot;-moz-border-radius-topleft&quot;,</span><br><span class="line">        &quot;border-top-left-radius&quot;,</span><br><span class="line">        &quot;-webkit-border-top-right-radius&quot;,</span><br><span class="line">        &quot;-moz-border-radius-topright&quot;,</span><br><span class="line">        &quot;border-top-right-radius&quot;,</span><br><span class="line">        &quot;-webkit-border-bottom-right-radius&quot;,</span><br><span class="line">        &quot;-moz-border-radius-bottomright&quot;,</span><br><span class="line">        &quot;border-bottom-right-radius&quot;,</span><br><span class="line">        &quot;-webkit-border-bottom-left-radius&quot;,</span><br><span class="line">        &quot;-moz-border-radius-bottomleft&quot;,</span><br><span class="line">        &quot;border-bottom-left-radius&quot;,</span><br><span class="line">        &quot;-webkit-border-image&quot;,</span><br><span class="line">        &quot;-moz-border-image&quot;,</span><br><span class="line">        &quot;-o-border-image&quot;,</span><br><span class="line">        &quot;border-image&quot;,</span><br><span class="line">        &quot;-webkit-border-image-source&quot;,</span><br><span class="line">        &quot;-moz-border-image-source&quot;,</span><br><span class="line">        &quot;-o-border-image-source&quot;,</span><br><span class="line">        &quot;border-image-source&quot;,</span><br><span class="line">        &quot;-webkit-border-image-slice&quot;,</span><br><span class="line">        &quot;-moz-border-image-slice&quot;,</span><br><span class="line">        &quot;-o-border-image-slice&quot;,</span><br><span class="line">        &quot;border-image-slice&quot;,</span><br><span class="line">        &quot;-webkit-border-image-width&quot;,</span><br><span class="line">        &quot;-moz-border-image-width&quot;,</span><br><span class="line">        &quot;-o-border-image-width&quot;,</span><br><span class="line">        &quot;border-image-width&quot;,</span><br><span class="line">        &quot;-webkit-border-image-outset&quot;,</span><br><span class="line">        &quot;-moz-border-image-outset&quot;,</span><br><span class="line">        &quot;-o-border-image-outset&quot;,</span><br><span class="line">        &quot;border-image-outset&quot;,</span><br><span class="line">        &quot;-webkit-border-image-repeat&quot;,</span><br><span class="line">        &quot;-moz-border-image-repeat&quot;,</span><br><span class="line">        &quot;-o-border-image-repeat&quot;,</span><br><span class="line">        &quot;border-image-repeat&quot;,</span><br><span class="line">        &quot;padding&quot;,</span><br><span class="line">        &quot;padding-top&quot;,</span><br><span class="line">        &quot;padding-right&quot;,</span><br><span class="line">        &quot;padding-bottom&quot;,</span><br><span class="line">        &quot;padding-left&quot;,</span><br><span class="line">        &quot;width&quot;,</span><br><span class="line">        &quot;min-width&quot;,</span><br><span class="line">        &quot;max-width&quot;,</span><br><span class="line">        &quot;height&quot;,</span><br><span class="line">        &quot;min-height&quot;,</span><br><span class="line">        &quot;max-height&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;font&quot;,</span><br><span class="line">        &quot;font-family&quot;,</span><br><span class="line">        &quot;font-size&quot;,</span><br><span class="line">        &quot;font-weight&quot;,</span><br><span class="line">        &quot;font-style&quot;,</span><br><span class="line">        &quot;font-variant&quot;,</span><br><span class="line">        &quot;font-size-adjust&quot;,</span><br><span class="line">        &quot;font-stretch&quot;,</span><br><span class="line">        &quot;font-effect&quot;,</span><br><span class="line">        &quot;font-emphasize&quot;,</span><br><span class="line">        &quot;font-emphasize-position&quot;,</span><br><span class="line">        &quot;font-emphasize-style&quot;,</span><br><span class="line">        &quot;font-smooth&quot;,</span><br><span class="line">        &quot;line-height&quot;,</span><br><span class="line">        &quot;text-align&quot;,</span><br><span class="line">        &quot;-webkit-text-align-last&quot;,</span><br><span class="line">        &quot;-moz-text-align-last&quot;,</span><br><span class="line">        &quot;-ms-text-align-last&quot;,</span><br><span class="line">        &quot;text-align-last&quot;,</span><br><span class="line">        &quot;vertical-align&quot;,</span><br><span class="line">        &quot;white-space&quot;,</span><br><span class="line">        &quot;text-decoration&quot;,</span><br><span class="line">        &quot;text-emphasis&quot;,</span><br><span class="line">        &quot;text-emphasis-color&quot;,</span><br><span class="line">        &quot;text-emphasis-style&quot;,</span><br><span class="line">        &quot;text-emphasis-position&quot;,</span><br><span class="line">        &quot;text-indent&quot;,</span><br><span class="line">        &quot;-ms-text-justify&quot;,</span><br><span class="line">        &quot;text-justify&quot;,</span><br><span class="line">        &quot;letter-spacing&quot;,</span><br><span class="line">        &quot;word-spacing&quot;,</span><br><span class="line">        &quot;-ms-writing-mode&quot;,</span><br><span class="line">        &quot;text-outline&quot;,</span><br><span class="line">        &quot;text-transform&quot;,</span><br><span class="line">        &quot;text-wrap&quot;,</span><br><span class="line">        &quot;-ms-text-overflow&quot;,</span><br><span class="line">        &quot;text-overflow&quot;,</span><br><span class="line">        &quot;text-overflow-ellipsis&quot;,</span><br><span class="line">        &quot;text-overflow-mode&quot;,</span><br><span class="line">        &quot;-ms-word-wrap&quot;,</span><br><span class="line">        &quot;word-wrap&quot;,</span><br><span class="line">        &quot;-ms-word-break&quot;,</span><br><span class="line">        &quot;word-break&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;color&quot;,</span><br><span class="line">        &quot;background&quot;,</span><br><span class="line">        &quot;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&quot;,</span><br><span class="line">        &quot;background-color&quot;,</span><br><span class="line">        &quot;background-image&quot;,</span><br><span class="line">        &quot;background-repeat&quot;,</span><br><span class="line">        &quot;background-attachment&quot;,</span><br><span class="line">        &quot;background-position&quot;,</span><br><span class="line">        &quot;-ms-background-position-x&quot;,</span><br><span class="line">        &quot;background-position-x&quot;,</span><br><span class="line">        &quot;-ms-background-position-y&quot;,</span><br><span class="line">        &quot;background-position-y&quot;,</span><br><span class="line">        &quot;-webkit-background-clip&quot;,</span><br><span class="line">        &quot;-moz-background-clip&quot;,</span><br><span class="line">        &quot;background-clip&quot;,</span><br><span class="line">        &quot;background-origin&quot;,</span><br><span class="line">        &quot;-webkit-background-size&quot;,</span><br><span class="line">        &quot;-moz-background-size&quot;,</span><br><span class="line">        &quot;-o-background-size&quot;,</span><br><span class="line">        &quot;background-size&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;outline&quot;,</span><br><span class="line">        &quot;outline-width&quot;,</span><br><span class="line">        &quot;outline-style&quot;,</span><br><span class="line">        &quot;outline-color&quot;,</span><br><span class="line">        &quot;outline-offset&quot;,</span><br><span class="line">        &quot;opacity&quot;,</span><br><span class="line">        &quot;filter:progid:DXImageTransform.Microsoft.Alpha(Opacity&quot;,</span><br><span class="line">        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.Alpha&quot;,</span><br><span class="line">        &quot;-ms-interpolation-mode&quot;,</span><br><span class="line">        &quot;-webkit-box-shadow&quot;,</span><br><span class="line">        &quot;-moz-box-shadow&quot;,</span><br><span class="line">        &quot;box-shadow&quot;,</span><br><span class="line">        &quot;filter:progid:DXImageTransform.Microsoft.gradient&quot;,</span><br><span class="line">        &quot;-ms-filter:\\&#39;progid:DXImageTransform.Microsoft.gradient&quot;,</span><br><span class="line">        &quot;text-shadow&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;-webkit-transition&quot;,</span><br><span class="line">        &quot;-moz-transition&quot;,</span><br><span class="line">        &quot;-ms-transition&quot;,</span><br><span class="line">        &quot;-o-transition&quot;,</span><br><span class="line">        &quot;transition&quot;,</span><br><span class="line">        &quot;-webkit-transition-delay&quot;,</span><br><span class="line">        &quot;-moz-transition-delay&quot;,</span><br><span class="line">        &quot;-ms-transition-delay&quot;,</span><br><span class="line">        &quot;-o-transition-delay&quot;,</span><br><span class="line">        &quot;transition-delay&quot;,</span><br><span class="line">        &quot;-webkit-transition-timing-function&quot;,</span><br><span class="line">        &quot;-moz-transition-timing-function&quot;,</span><br><span class="line">        &quot;-ms-transition-timing-function&quot;,</span><br><span class="line">        &quot;-o-transition-timing-function&quot;,</span><br><span class="line">        &quot;transition-timing-function&quot;,</span><br><span class="line">        &quot;-webkit-transition-duration&quot;,</span><br><span class="line">        &quot;-moz-transition-duration&quot;,</span><br><span class="line">        &quot;-ms-transition-duration&quot;,</span><br><span class="line">        &quot;-o-transition-duration&quot;,</span><br><span class="line">        &quot;transition-duration&quot;,</span><br><span class="line">        &quot;-webkit-transition-property&quot;,</span><br><span class="line">        &quot;-moz-transition-property&quot;,</span><br><span class="line">        &quot;-ms-transition-property&quot;,</span><br><span class="line">        &quot;-o-transition-property&quot;,</span><br><span class="line">        &quot;transition-property&quot;,</span><br><span class="line">        &quot;-webkit-transform&quot;,</span><br><span class="line">        &quot;-moz-transform&quot;,</span><br><span class="line">        &quot;-ms-transform&quot;,</span><br><span class="line">        &quot;-o-transform&quot;,</span><br><span class="line">        &quot;transform&quot;,</span><br><span class="line">        &quot;-webkit-transform-origin&quot;,</span><br><span class="line">        &quot;-moz-transform-origin&quot;,</span><br><span class="line">        &quot;-ms-transform-origin&quot;,</span><br><span class="line">        &quot;-o-transform-origin&quot;,</span><br><span class="line">        &quot;transform-origin&quot;,</span><br><span class="line">        &quot;-webkit-animation&quot;,</span><br><span class="line">        &quot;-moz-animation&quot;,</span><br><span class="line">        &quot;-ms-animation&quot;,</span><br><span class="line">        &quot;-o-animation&quot;,</span><br><span class="line">        &quot;animation&quot;,</span><br><span class="line">        &quot;-webkit-animation-name&quot;,</span><br><span class="line">        &quot;-moz-animation-name&quot;,</span><br><span class="line">        &quot;-ms-animation-name&quot;,</span><br><span class="line">        &quot;-o-animation-name&quot;,</span><br><span class="line">        &quot;animation-name&quot;,</span><br><span class="line">        &quot;-webkit-animation-duration&quot;,</span><br><span class="line">        &quot;-moz-animation-duration&quot;,</span><br><span class="line">        &quot;-ms-animation-duration&quot;,</span><br><span class="line">        &quot;-o-animation-duration&quot;,</span><br><span class="line">        &quot;animation-duration&quot;,</span><br><span class="line">        &quot;-webkit-animation-play-state&quot;,</span><br><span class="line">        &quot;-moz-animation-play-state&quot;,</span><br><span class="line">        &quot;-ms-animation-play-state&quot;,</span><br><span class="line">        &quot;-o-animation-play-state&quot;,</span><br><span class="line">        &quot;animation-play-state&quot;,</span><br><span class="line">        &quot;-webkit-animation-timing-function&quot;,</span><br><span class="line">        &quot;-moz-animation-timing-function&quot;,</span><br><span class="line">        &quot;-ms-animation-timing-function&quot;,</span><br><span class="line">        &quot;-o-animation-timing-function&quot;,</span><br><span class="line">        &quot;animation-timing-function&quot;,</span><br><span class="line">        &quot;-webkit-animation-delay&quot;,</span><br><span class="line">        &quot;-moz-animation-delay&quot;,</span><br><span class="line">        &quot;-ms-animation-delay&quot;,</span><br><span class="line">        &quot;-o-animation-delay&quot;,</span><br><span class="line">        &quot;animation-delay&quot;,</span><br><span class="line">        &quot;-webkit-animation-iteration-count&quot;,</span><br><span class="line">        &quot;-moz-animation-iteration-count&quot;,</span><br><span class="line">        &quot;-ms-animation-iteration-count&quot;,</span><br><span class="line">        &quot;-o-animation-iteration-count&quot;,</span><br><span class="line">        &quot;animation-iteration-count&quot;,</span><br><span class="line">        &quot;-webkit-animation-direction&quot;,</span><br><span class="line">        &quot;-moz-animation-direction&quot;,</span><br><span class="line">        &quot;-ms-animation-direction&quot;,</span><br><span class="line">        &quot;-o-animation-direction&quot;,</span><br><span class="line">        &quot;animation-direction&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;content&quot;,</span><br><span class="line">        &quot;quotes&quot;,</span><br><span class="line">        &quot;counter-reset&quot;,</span><br><span class="line">        &quot;counter-increment&quot;,</span><br><span class="line">        &quot;resize&quot;,</span><br><span class="line">        &quot;cursor&quot;,</span><br><span class="line">        &quot;-webkit-user-select&quot;,</span><br><span class="line">        &quot;-moz-user-select&quot;,</span><br><span class="line">        &quot;-ms-user-select&quot;,</span><br><span class="line">        &quot;user-select&quot;,</span><br><span class="line">        &quot;nav-index&quot;,</span><br><span class="line">        &quot;nav-up&quot;,</span><br><span class="line">        &quot;nav-right&quot;,</span><br><span class="line">        &quot;nav-down&quot;,</span><br><span class="line">        &quot;nav-left&quot;,</span><br><span class="line">        &quot;-moz-tab-size&quot;,</span><br><span class="line">        &quot;-o-tab-size&quot;,</span><br><span class="line">        &quot;tab-size&quot;,</span><br><span class="line">        &quot;-webkit-hyphens&quot;,</span><br><span class="line">        &quot;-moz-hyphens&quot;,</span><br><span class="line">        &quot;hyphens&quot;,</span><br><span class="line">        &quot;pointer-events&quot;</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>颜色16进制用小写字母；</p>
<p>颜色16进制尽量用简写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    color: #ABCDEF;</span><br><span class="line">    background-color: #001122;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    color: #abcdef;</span><br><span class="line">    background-color: #012;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p>
<p>margin 和 padding 相反，需要使用简写；</p>
<p>常见的属性简写包括：</p>
<ul>
<li>font</li>
<li>background</li>
<li>transition</li>
<li>animation</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* not good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    transition: opacity 1s linear 2s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* good *&#x2F;</span><br><span class="line">.element &#123;</span><br><span class="line">    transition-delay: 2s;</span><br><span class="line">    transition-timing-function: linear;</span><br><span class="line">    transition-duration: 1s;</span><br><span class="line">    transition-property: opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p>
<h2 id="SCSS相关"><a href="#SCSS相关" class="headerlink" title="SCSS相关"></a>SCSS相关</h2><p>提交的代码中不要有 @debug；</p>
<p>声明顺序：</p>
<ul>
<li>@extend</li>
<li>不包含 @content 的 @include</li>
<li>包含 @content 的 @include</li>
<li>自身属性</li>
<li>嵌套规则</li>
</ul>
<p><code>@import</code> 引入的文件不需要开头的’_’和结尾的’.scss’；</p>
<p>嵌套最多不能超过5层；</p>
<p><code>@extend</code> 中使用placeholder选择器；</p>
<p>去掉不必要的父级引用符号’&amp;’。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>不允许有空的规则；</p>
<p>元素选择器用小写字母；</p>
<p>去掉小数点前面的0；</p>
<p>去掉数字中不必要的小数点和末尾的0；</p>
<p>属性值’0’后面不要加单位；</p>
<p>同个属性不同前缀的写法需要在垂直方向保持对齐；</p>
<p>无前缀的标准属性应该写在有前缀的属性后面；</p>
<p>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</p>
<p>不要在一个文件里出现两个相同的规则；</p>
<p>用 border: 0; 代替 border: none;；</p>
<p>选择器不要超过4层（在scss中如果超过4层应该考虑用嵌套的方式来写）；</p>
<p>发布的代码中不要有 @import；</p>
<p>尽量少用’*’选择器。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h2><p>使用soft tab（4个空格）。</p>
<h2 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h2><p>不要超过80，但如果编辑器开启word wrap可以不考虑单行长度。</p>
<h2 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h2><p>以下几种情况后需加分号：</p>
<ul>
<li>变量声明</li>
<li>表达式</li>
<li>return</li>
<li>throw</li>
<li>break</li>
<li>continue</li>
<li>do-while</li>
</ul>
<h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><p>以下几种情况不需要空格：</p>
<ul>
<li>对象的属性名后</li>
<li>前缀一元运算符后</li>
<li>后缀一元运算符前</li>
<li>函数调用括号前</li>
<li>无论是函数声明还是函数表达式，’(‘前不要空格</li>
<li>数组的’[‘后和’]’前</li>
<li>对象的’{‘后和’}’前（有待考证）</li>
<li>运算符’(‘后和’)’前</li>
</ul>
<p>以下几种情况需要空格：</p>
<ul>
<li>二元运算符前后</li>
<li>三元运算符’?:’前后</li>
<li>代码块’{‘前</li>
<li>下列关键字前：else, while, catch, finally</li>
<li>下列关键字后：if, else, for, while, do, switch, case, try, catch, finally, with, return, typeof</li>
<li>单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后</li>
<li>对象的属性值前</li>
<li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格</li>
<li>无论是函数声明还是函数表达式，’{‘前一定要有空格</li>
<li>函数的参数之间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">    b :1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">    b: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">++ x;</span><br><span class="line">y ++;</span><br><span class="line">z &#x3D; x?1:2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">z &#x3D; x ? 1 : 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">var a &#x3D; [ 1, 2 ];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">var a &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">var a &#x3D; ( 1+2 )*3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">var a &#x3D; (1 + 2) * 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; no space before &#39;(&#39;, one space before &#39;&#123;&#39;, one space between function parameters</span><br><span class="line">var doSomething &#x3D; function(a, b, c) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; no space before &#39;(&#39;</span><br><span class="line">doSomething(item);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">for(i&#x3D;0;i&lt;6;i++)&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">for (i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h2><p>以下几种情况需要空行：</p>
<ul>
<li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）</li>
<li>注释前（当注释在代码块的第一行时，则无需空行）</li>
<li>代码块后（在函数调用、数组、对象中则无需空行）(有待考证)</li>
<li>文件最后保留一个空行</li>
</ul>
<h2 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h2><p>换行的地方，行末必须有’,’或者运算符；</p>
<p>以下几种情况不需要换行：</p>
<ul>
<li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li>
<li>代码块’{‘前</li>
</ul>
<p>以下几种情况需要换行：</p>
<ul>
<li>代码块’{‘后和’}’前</li>
<li>变量赋值后</li>
</ul>
<h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>双斜线后，必须跟一个空格；</p>
<p>缩进与下一行代码保持一致；</p>
<p>可位于一个代码行的末尾，与代码间隔一个空格。</p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>最少三行, ‘*’后跟一个空格；</p>
<p>建议在以下情况下使用：</p>
<ul>
<li>难于理解的代码段</li>
<li>可能存在错误的代码段</li>
<li>浏览器特殊的HACK代码</li>
<li>业务逻辑强相关的代码</li>
</ul>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>各类标签@param, @method等请参考<a href="http://usejsdoc.org/" title="usejsdoc">usejsdoc</a>和<a href="http://yuri4ever.github.io/jsdoc/" title="JSDoc Guide">JSDoc Guide</a>；</p>
<p>建议在以下情况下使用：</p>
<ul>
<li>所有常量</li>
<li>所有函数</li>
<li>所有类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @func</span><br><span class="line"> * @desc 一个带参数的函数</span><br><span class="line"> * @param &#123;string&#125; a - 参数a</span><br><span class="line"> * @param &#123;number&#125; b&#x3D;1 - 参数b默认值为1</span><br><span class="line"> * @param &#123;string&#125; c&#x3D;1 - 参数c有两种支持的取值&lt;&#x2F;br&gt;1—表示x&lt;&#x2F;br&gt;2—表示xx</span><br><span class="line"> * @param &#123;object&#125; d - 参数d为一个对象</span><br><span class="line"> * @param &#123;string&#125; d.e - 参数d的e属性</span><br><span class="line"> * @param &#123;string&#125; d.f - 参数d的f属性</span><br><span class="line"> * @param &#123;object[]&#125; g - 参数g为一个对象数组</span><br><span class="line"> * @param &#123;string&#125; g.h - 参数g数组中一项的h属性</span><br><span class="line"> * @param &#123;string&#125; g.i - 参数g数组中一项的i属性</span><br><span class="line"> * @param &#123;string&#125; [j] - 参数j是一个可选参数</span><br><span class="line"> *&#x2F;</span><br><span class="line">function foo(a, b, c, d, g, j) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引号-1"><a href="#引号-1" class="headerlink" title="引号"></a>引号</h2><p>最外层统一使用单引号。</p>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul>
<li>标准变量采用小驼峰式命名（除了对象的属性外，主要是考虑到cgi返回的数据）</li>
<li>‘ID’在变量名中全大写</li>
<li>‘URL’在变量名中全大写</li>
<li>‘Android’在变量名中大写第一个字母</li>
<li>‘iOS’在变量名中小写第一个，大写后两个字母</li>
<li>常量全大写，用下划线连接</li>
<li>构造函数，大写第一个字母（大驼峰式命名）</li>
<li>jquery对象必须以’$’开头命名</li>
</ul>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格；</p>
<p>函数调用括号前不需要空格；</p>
<p>立即执行函数外必须包一层括号；</p>
<p>不要给inline function命名；</p>
<p>参数之间用’, ‘分隔，注意逗号后有一个空格。</p>
<h2 id="数组、对象"><a href="#数组、对象" class="headerlink" title="数组、对象"></a>数组、对象</h2><p>对象属性名不需要加引号；</p>
<p>对象以缩进的形式书写，不要写在一行；</p>
<p>数组、对象最后不要有逗号。（作者注：最新ES6语法允许最后加逗号）</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>适用场景：</p>
<ul>
<li>初始化一个将来可能被赋值为对象的变量</li>
<li>与已经初始化的变量做比较</li>
<li>作为一个参数为对象的函数的调用传参</li>
<li>作为一个返回对象的函数的返回值</li>
</ul>
<p>不适用场景：</p>
<ul>
<li>不要用null来判断函数调用时有无传参</li>
<li>不要与未初始化的变量做比较</li>
</ul>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>永远不要直接使用undefined进行变量判断；</p>
<p>使用typeof和字符串’undefined’对变量进行判断。</p>
<h2 id="jshint"><a href="#jshint" class="headerlink" title="jshint"></a>jshint</h2><p>用’===’, ‘!==’代替’==’, ‘!=’；（作者注：具体场景具体分析）</p>
<p>for-in里一定要有hasOwnProperty的判断；</p>
<p>不要在内置对象的原型上添加方法，如Array, Date；</p>
<p>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</p>
<p>变量不要先使用后声明；</p>
<p>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</p>
<p>不要在同个作用域下声明同名变量；</p>
<p>不要在一些不需要的地方加括号，例：delete(a.b)；</p>
<p>不要使用未声明的变量（全局变量需要加到.jshintrc文件的globals属性里面）；</p>
<p>不要声明了变量却不使用；</p>
<p>不要在应该做比较的地方做赋值；</p>
<p>debugger不要出现在提交的代码里；</p>
<p>数组中不要存在空元素；</p>
<p>不要在循环内部声明函数；</p>
<p>不要像这样使用构造函数，例：<code>new function () &#123; ... &#125;</code>, <code>new Object</code>；</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>不要混用tab和space；</p>
<p>不要在一处使用多个tab或space；</p>
<p>换行符统一用’LF’；</p>
<p>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名；</p>
<p>行尾不要有空白字符；</p>
<p>switch的falling through和no default的情况一定要有注释特别说明；</p>
<p>不允许有空的代码块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; not good</span><br><span class="line">var a   &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">    &#x2F;&#x2F; not good</span><br><span class="line">    var me &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; good</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; good</span><br><span class="line">    var that &#x3D; this;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; good</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">switch (condition) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:</span><br><span class="line">        ...</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        ...</span><br><span class="line">    &#x2F;&#x2F; why fall through</span><br><span class="line">    case 4</span><br><span class="line">        ...</span><br><span class="line">        break;</span><br><span class="line">    &#x2F;&#x2F; why no default</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; not good with empty block</span><br><span class="line">if (condition) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编辑器配置和构建检查"><a href="#编辑器配置和构建检查" class="headerlink" title="编辑器配置和构建检查"></a>编辑器配置和构建检查</h1><h1 id="sublime3插件"><a href="#sublime3插件" class="headerlink" title="sublime3插件"></a>sublime3插件</h1><h3 id="安装node包"><a href="#安装node包" class="headerlink" title="安装node包"></a>安装node包</h3><ul>
<li>jscs npm install jscs -g</li>
<li>jshint npm install jshint -g</li>
<li>csscomb npm install csscomb -g</li>
<li>csslint npm install csslint -g</li>
</ul>
<h3 id="安装gem包"><a href="#安装gem包" class="headerlink" title="安装gem包"></a>安装gem包</h3><ul>
<li>scss-lint gem install scss_lint</li>
</ul>
<h3 id="安装sublime3-Package-Control"><a href="#安装sublime3-Package-Control" class="headerlink" title="安装sublime3 Package Control"></a>安装sublime3 Package Control</h3><ul>
<li><p>按下 ctrl+`</p>
</li>
<li><p>复制粘贴以下代码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h &#x3D; &#39;eb2297e1a458f27d836c04bb0cbaf282&#39; + &#39;d0e7a3098092775ccb37ca9d6b2e4b7d&#39;; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by &#x3D; urllib.request.urlopen( &#39;http:&#x2F;&#x2F;packagecontrol.io&#x2F;&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh &#x3D; hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh !&#x3D; h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</span><br></pre></td></tr></table></figure>
<h3 id="安装sublime3插件"><a href="#安装sublime3插件" class="headerlink" title="安装sublime3插件"></a>安装sublime3插件</h3></li>
<li><p>按下 <code>ctrl+shift+p</code>，输入’ip’（Install Package）</p>
</li>
<li><p>输入以下插件的名字，按顺序逐个进行安装：</p>
</li>
<li><p>EditorConfig</p>
</li>
<li><p>Sass</p>
</li>
<li><p>SublimeLinter</p>
</li>
<li><p>SublimeLinter-jscs</p>
</li>
<li><p>SublimeLinter-jshint</p>
</li>
<li><p>SublimeLinter-csslint</p>
</li>
<li><p>SublimeLinter-contrib-scss-lint</p>
</li>
<li><p>JSFormat</p>
</li>
<li><p>CSScomb</p>
</li>
</ul>
<p>本文参考【<a href="http://alloyteam.github.io/CodeGuide/" title="通过分析github代码库总结出来的工程师代码书写习惯">通过分析github代码库总结出来的工程师代码书写习惯</a>】</p>
]]></content>
      <tags>
        <tag>github 代码 规范 编码 习惯 前端 开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何制定企业级代码规范与静态检查</title>
    <url>/2021/01/19/%E5%A6%82%E4%BD%95%E5%88%B6%E5%AE%9A%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%8E%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何作出项目的亮点？</p>
<ol>
<li>项目中遇到了什么问题？</li>
<li>解决问题的过程并且如何思考？</li>
<li>思考之后通过什么方式解决</li>
<li>最后这一个任务你学到了什么，给团队带来了什么价值，解决了哪些痛点。</li>
</ol>
<p>就从我的题目说起，本篇文章告诉你针对定制代码规范和检查这个小需求如何做出亮点？看完本文后回顾上面提到的 4 点，感觉下。</p>
<h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>目标不是一次全部定出来的，在实践和调研过程中会添加一些</p>
<ol>
<li>去掉项目中原有的 <code>TSLint</code> ，统一使用 <code>ESLint</code>，但是在 <code>ESLint</code> 中加入 <code>TSLint</code> 检测插件</li>
<li><code>Prettier</code> 支持的格式化规则全部使用 <code>Prettier</code>，不提供的使用 <code>ESLint</code>，以免冲突（个人认为 <code>Prettier</code> 提供的格式化规则可以满足开发者）。</li>
<li>代码保存时，支持自动 <code>fix</code>，只对自己控制范围内的 <code>fix</code>，范围外的内容依靠开发者配置或 <code>vscode</code> 自动配置。</li>
<li>格式化和 <code>ESLint</code> 纳入项目级 <code>git</code> 跟踪，所有开发者统一。</li>
<li>除了上面的规范与检查实现，了解一些原理，比如 <code>rules</code> 原理？为什么 <code>Prettier</code> 和 <code>ESLint</code> 冲突？<code>Prettier</code> 原理？</li>
</ol>
<a id="more"></a>

<h2 id="开篇一张图"><a href="#开篇一张图" class="headerlink" title="开篇一张图"></a>开篇一张图</h2><p><img src="https://i.loli.net/2021/01/19/NpQ65BsMZU1mzTt.png" alt="640_看图王.web"></p>
<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p><code>ESLint</code> 的原理就是一款插件化的javascript代码静态检查工具，其核心是对代码解析得到的 <code>AST （Abstract Syntax Tree 抽象语法树</code>）进行模式匹配，定位不符合约定规范的代码。<code>ESLint</code> 是完全插件化的。每一个规则都是一个插件并且可以在运行时添加更多的规则。</p>
<p>社区比较知名的代码规范</p>
<ul>
<li>eslint-config-airbnb</li>
<li>eslint-config-standard</li>
<li>eslint-config-alloy</li>
</ul>
<p>如果想降低配置成本，可以直接接入上面的开源配置方案，好多开发者是继承它们的规范，然后在原有基础进行部分修改。我们目前选择的方式不是继承，挑选出了一些适合我们的 <code>ESLint</code> 规则(因为是在原有代码重新建立规范，防止改动过大)。</p>
<h3 id="ESLint-集成"><a href="#ESLint-集成" class="headerlink" title="ESLint 集成"></a>ESLint 集成</h3><p><code>ESLint</code> 使用并不复杂，简单说下 <code>ESLint</code> 的集成。</p>
<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add eslint -D</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>
<p>这个时候在项目中会出现一个 <code>.eslintrc.js</code> 的文件。</p>
<h4 id="eslint-自定义配置文件"><a href="#eslint-自定义配置文件" class="headerlink" title="eslint 自定义配置文件"></a>eslint 自定义配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: &#123;&#125;,  <span class="comment">//定义ESLint的解析器</span></span><br><span class="line">  <span class="keyword">extends</span>: [], <span class="comment">// 定义文件继承的子规范</span></span><br><span class="line">  plugins: [], <span class="comment">// 定义了该eslint文件所依赖的插件</span></span><br><span class="line">  env: &#123;&#125;,</span><br><span class="line">  rules: &#123;&#125;    <span class="comment">// 规则</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h5><p>定义 <code>parser</code> 的解析器，我们常用的解析器应该是 <code>@typescript-eslint/parser</code>。</p>
<h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p>通过 <code>env</code> 配置需要启动的环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">env: &#123;</span><br><span class="line">   es6: <span class="literal">true</span>, <span class="comment">//  支持新的 ES6 全局变量，同时自动启用 ES6 语法支持</span></span><br><span class="line">   node: <span class="literal">true</span>, <span class="comment">// 启动 node 环境</span></span><br><span class="line">   mocha: <span class="literal">true</span>,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<h5 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h5><p><code>extend</code> 提供的是 <code>eslint</code> 现有规则的一系列预设。</p>
<blockquote>
<p>这里注意的是，“extends”除了可以引入推荐规则，还可以以文件形式引入其它的自定义规则，然后在这些自定义规则的基础上用rules去定义个别规则，从而覆盖掉”extends”中引入的规则。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;./node_modules/coding-standard/eslintDefaults.js&quot;</span>,</span><br><span class="line">        <span class="comment">// Override eslintDefaults.js</span></span><br><span class="line">        <span class="string">&quot;./node_modules/coding-standard/.eslintrc-es6&quot;</span>,</span><br><span class="line">        <span class="comment">// Override .eslintrc-es6</span></span><br><span class="line">        <span class="string">&quot;./node_modules/coding-standard/.eslintrc-jsx&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// Override any settings from the &quot;parent&quot; configuration</span></span><br><span class="line">        <span class="string">&quot;eqeqeq&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了在配置文件中指定规则外，还可以在代码中指定规则，代码文件内以注释配置的规则会覆盖配置文件里的规则，即优先级要更高。平时我们常用的就是 <code>eslint-disable-next-line</code>。</p>
<p><strong>忽略检查</strong>可以通过在项目目录下建立 <code>.eslintignore</code> 文件，并在其中配置忽略掉对哪些文件的检查。需要注意的是，不管你有没有在 <code>.eslintignore</code> 中进行配置，<code>eslint</code> 都会默认忽略掉对 <code>/node_modules/**</code> 的检查。也可以在 <code>package.json</code> 文件的 <code>eslintIgnore</code> 字段进行配置。</p>
<h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p><code>plugin</code> 则提供了除预设之外的自定义规则，当你在 <code>ESlint</code> 的规则里找不到合适的的时候就可以借用插件来实现了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析器</span></span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&quot;./.eslintRules.js&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;prettier&quot;</span>,<span class="comment">// 优先 prettier 中的样式规范</span></span><br><span class="line">    <span class="string">&#x27;prettier/@typescript-eslint&#x27;</span>,</span><br><span class="line">  ], <span class="comment">// 继承的规则</span></span><br><span class="line">  plugins: [<span class="string">&#x27;@typescript-eslint&#x27;</span>], <span class="comment">// 插件</span></span><br></pre></td></tr></table></figure>
<h3 id="ESLint-重要特性"><a href="#ESLint-重要特性" class="headerlink" title="ESLint 重要特性"></a>ESLint 重要特性</h3><h4 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h4><p><code>rules</code> 对应的规则，小伙伴可以去官网查看。找到符合自己项目的规则。</p>
<p><a href="http://eslint.cn/docs/rules/">ESLint 规则官网地址</a></p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li>在整理总结规则的时候有些是自动检测的规则，就可以不用总结进去了。</li>
<li><code>ESLint</code> 规则的三种级别</li>
</ol>
<ul>
<li>“off”或者0，不启用这个规则</li>
<li>“warn”或者1，出现问题会有警告</li>
<li>“error”或者2，出现问题会报错</li>
</ul>
<h5 id="rules-工作原理"><a href="#rules-工作原理" class="headerlink" title="rules 工作原理`"></a>rules 工作原理`</h5><p>首先来看看 <code>eslin</code> t源码中关于 <code>rules</code> 的编写。<code>eslint</code> 中的 <code>rules</code>源码存在于 <code>lib/rules</code> 下。每一个 <code>rules</code> 都是一个 <code>node</code> 模块，用 <code>module.exports</code> 导出一个 <code>meta</code> 对象及一个<code>create</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123;</span><br><span class="line">        type: <span class="string">&quot;suggestion&quot;</span>,</span><br><span class="line"></span><br><span class="line">        docs: &#123;</span><br><span class="line">            description: <span class="string">&quot;disallow unnecessary semicolons&quot;</span>,</span><br><span class="line">            category: <span class="string">&quot;Possible Errors&quot;</span>,</span><br><span class="line">            recommended: <span class="literal">true</span>,</span><br><span class="line">            url: <span class="string">&quot;https://eslint.org/docs/rules/no-extra-semi&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        fixable: <span class="string">&quot;code&quot;</span>,</span><br><span class="line">        schema: [] <span class="comment">// no options</span></span><br><span class="line">    &#125;,</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// callback functions</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>meta</code> 代表了这条规则的 <code>元数据</code>，如这条规则的类别，文档，可接收的参数 <code>schema</code> 等等。<code>create</code> 返回一个对象，其中定义了一些在 <code>AST</code> 遍历访问到对应节点需要执行的方法等等。函数接受一个 <code>context</code> 对象作为参数，里面包含了例如可以报告错误或者警告的 <code>context.report()</code>、可以获取源代码的 <code>context.getSourceCode()</code> 等方法，可以简化规则的编写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkLastSegment</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// report problem for function if last code path segment is reachable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123; ... &#125;,</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// declare the state of the rule</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ReturnStatement: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 在AST从上向下遍历到ReturnStatement node 时执行</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 在AST 从下向上遍历到 function expression node 时执行:</span></span><br><span class="line">            <span class="string">&quot;FunctionExpression:exit&quot;</span>: checkLastSegment,</span><br><span class="line">            <span class="string">&quot;ArrowFunctionExpression:exit&quot;</span>: checkLastSegment,</span><br><span class="line">            onCodePathStart: <span class="function"><span class="keyword">function</span> (<span class="params">codePath, node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 在分析代码路径开始时执行</span></span><br><span class="line">            &#125;,</span><br><span class="line">            onCodePathEnd: <span class="function"><span class="keyword">function</span>(<span class="params">codePath, node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 在分析代码路径结束时执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遍历 <code>AST</code> 的过程中会以“从上至下”再“从下至上”的顺序经过节点两次，<code>selector</code> 默认会在下行的过程中执行对应的访问函数，如果需要再上行的过程中执行，则需要添加<code>:exit</code>。</p>
<h2 id="TSLint-迁移到-ESLint-集成"><a href="#TSLint-迁移到-ESLint-集成" class="headerlink" title="TSLint 迁移到 ESLint 集成"></a>TSLint 迁移到 ESLint 集成</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在这里会有读者问有现成的 <code>TSLint</code> 不用，为什么要迁移到 <code>ESLint</code> 中集成？</p>
<p>解答下：由于性能问题，<code>TypeScript</code> 官方决定全面采用 <code>ESLint</code>，甚至把仓库<code>（Repository）</code>作为测试平台，而 <code>ESLint</code> 的 <code>TypeScript</code> 解析器也成为独立项目，专注解决双方兼容性问题。</p>
<p><code>JavaScript</code> 代码检测工具 <code>ESLint</code> 在 <code>TypeScript</code> 团队发布全面采用 <code>ESLint</code> 之后，发布<code>typescript-eslint</code> 项目，以集中解决<code>TypeScript</code> 与 <code>ESLint</code> 兼容性问题。而 <code>ESLint</code> 不再维护 <code>typescript-eslint-parser</code>，也不会在 <code>npm</code> 上做任何发布。<code>TypeScript</code> 解析器转移至 <code>Github</code> 的 <code>typescript-eslint/parser</code>。</p>
<p>官方都放弃了我们也没必要太坚持,而且通过 <code>ESLint</code> 加上 <code>ts</code> 插件都可以完成检查</p>
<h3 id="集成过程"><a href="#集成过程" class="headerlink" title="集成过程"></a>集成过程</h3><p>首先安装依赖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add @typescript-eslint/parser @typescript-eslint/eslint-plugin -D</span><br></pre></td></tr></table></figure>
<p>这两个依赖分别是：</p>
<ul>
<li><code>@typescript-eslint/parser</code>：<code>ESLint</code> 的解析器，用于解析 <code>typescript</code>，从而检查和规范 <code>Typescript</code> 代码。</li>
<li><code>@typescript-eslint/eslint-plugin</code>：这是一个 <code>ESLint</code> 插件，包含了各类定义好的检测 <code>Typescript</code> 代码的规范。</li>
</ul>
<p>安装好<code>2</code>个依赖之后，修改之前创建的<code>.eslintrc.js</code>文件,在该文件中加入 <code>TSLint</code> 配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    parser:  <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">//定义ESLint的解析器</span></span><br><span class="line">    <span class="keyword">extends</span>: [<span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>],<span class="comment">//定义文件继承的子规范</span></span><br><span class="line">    plugins: [<span class="string">&#x27;@typescript-eslint&#x27;</span>],<span class="comment">//定义了该 eslint 文件所依赖的插件</span></span><br><span class="line">    env:&#123;                        </span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">        node: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析 .ts 文件</span></span><br><span class="line">        ecmaVersion: <span class="number">2019</span>,</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">        ecmaFeatures: &#123;</span><br><span class="line">            modules: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>typescript</code> 项目中必须执行解析器为<code>@typescript-eslint/parser</code>，才能正确的检测和规范 <code>typescript</code> 代码</li>
<li><code>env</code> 环境变量配置，形如 <code>console</code> 属性只有在 <code>browser</code> 环境下才会存在，如果没有设置支持 <code>browser</code> ,那么可能报 <code>console is undefined</code> 的错误。</li>
<li>上面的配置中 <code>extends</code> 中定义了了文件继承的子规范，使用的 <code>typescript-eslint</code> 默认的推荐规范</li>
<li><code>parserOptions</code> 解析器相关条件配置。</li>
</ul>
<h3 id="使用自定义的-typescript-规范"><a href="#使用自定义的-typescript-规范" class="headerlink" title="使用自定义的 typescript 规范"></a>使用自定义的 typescript 规范</h3><p>上面 <code>extends</code> 中 <code>plugin:@typescript-eslint/recommended</code> 使用的是插件默认推荐的 <code>typescript</code> 规范。但是会不会有同学不想使用推荐的规范，制定自己或者在推荐的规范中进行一些修改(比如一些老项目，加入规范，改动大，可能暂时忽略某些规范)</p>
<p>使用方式：如果想使用推荐，然后在推荐的基础上进行规范修改，可以直接在<code>.eslintrc.js</code> 文件中的rules对象中添加。</p>
<p>举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules:&#123;</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/adjacent-overload-signatures&#x27;</span>: <span class="number">2</span>, <span class="comment">// 要求成员重载是连续的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体想修改那些自定义规范，可以去官网查看，这里给出官网地址。</p>
<ul>
<li><a href="https://blog.csdn.net/yunfeng482/article/details/86722756">TSLint rule</a></li>
</ul>
<h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><blockquote>
<p>无法确定一个让所有人都满意的方案，就很难执行下去!</p>
</blockquote>
<p><code>Prettier</code> 中文的意思是<strong>漂亮的、美丽</strong>的，是一个流行的代码格式化的工具。</p>
<p>我们都知道 <code>ESLint</code> 本身就带有格式化检查的，我们为什么要是使用它？它有什么优点？使用它要注意那些问题？</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>Perriter</code> 官网列出几个特点：</p>
<ul>
<li>An opinionated code formatter （译：固执己见的代码格式化程序）</li>
<li>Supports many languages（译：支持多种语言）</li>
<li>Integrates with most editors（译：与大多数编辑器集成）</li>
<li>Has few options（译：没有什么选择）</li>
</ul>
<p>其中最核心的点是 <code>opinionated</code> ，<code>google</code> 翻译过来是固执己见的，在 <code>Pertiter</code> 中，就是说：<strong>你必须认同我的观点，按照我说的做。否则你就别用我，硬着头皮用就会处处不爽！</strong></p>
<h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><ol>
<li>使用 <code>Prettier</code> 如何避免与 <code>ESLint</code> 和 <code>TSLint</code> 的格式化冲突?</li>
<li><code>Prettier</code> 中不提供的格式化规则，<code>ESLint</code> 中提供的可以兼容一起使用吗？</li>
</ol>
<p>带着两个问题继续往下看</p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><h4 id="安装模块包"><a href="#安装模块包" class="headerlink" title="安装模块包"></a>安装模块包</h4><p>我们来看如何结合 <code>ESLint</code> 来使用。首先我们需要安装三个依赖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add prettier eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure>
<p>对每个依赖进行说明：</p>
<ol>
<li><code>prettier</code>：<code>Prettier</code>插件的核心代码。</li>
<li><code>eslint-config-prettier</code>：解决<code>ESLint</code>中的样式规范和<code>Prettier</code>中样式规范的冲突，以 <code>Prettier</code> 的样式规范为准，使 <code>ESLint</code> 中的样式规范自动失效。</li>
<li><code>eslint-plugin-prettier</code>：将 <code>prettier</code> 作为 <code>ESLint</code> 规范来使用。</li>
</ol>
<h4 id="创建-prettierrc-文件"><a href="#创建-prettierrc-文件" class="headerlink" title="创建 .prettierrc 文件"></a>创建 .prettierrc 文件</h4><p>在项目的根目录下创建 <code>.prettierrc.js</code> 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =  &#123;</span><br><span class="line">    <span class="string">&quot;printWidth&quot;</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bracketSpacing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;jsxBracketSameLine&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;insertPragma&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;tabWidth&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;useTabs&quot;</span>: <span class="literal">false</span>  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>每个属性的含义可以去 <code>Prettier</code> 中查看。</p>
<h4 id="修改-eslintrc-js-文件，引入-Prettier"><a href="#修改-eslintrc-js-文件，引入-Prettier" class="headerlink" title="修改 .eslintrc.js 文件，引入 Prettier"></a>修改 .eslintrc.js 文件，引入 Prettier</h4><p>在 <code>extends</code> 中添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extends</span>:[ </span><br><span class="line">   <span class="string">&#x27;./.eslintRules.js&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;prettier&#x27;</span>, <span class="comment">// 优先 prettier 中的样式规范</span></span><br><span class="line">   <span class="string">&#x27;prettier/@typescript-eslint&#x27;</span>,</span><br><span class="line">   <span class="comment">// 这里可以加一些prettier不支持，eslint支持的格式化规则，但是个人认为prettier的格式化规则够用了</span></span><br><span class="line">   ],</span><br></pre></td></tr></table></figure>
<h3 id="关于-Prettier-配置时特殊说明-重点看下"><a href="#关于-Prettier-配置时特殊说明-重点看下" class="headerlink" title="关于 Prettier 配置时特殊说明(重点看下)"></a>关于 Prettier 配置时特殊说明(重点看下)</h3><p>网上好多在 <code>ESLint</code> 中加入的 <code>Prettier</code>的文章，但是很少有讲清楚的，好多就是把配置文件写一下，然后很多小伙伴配置时候发现 <code>Prettier</code> 的格式化还是和 <code>ESLint</code>中的格式化冲突，<code>ctrl+s</code> 保存的时候甚至出现来回切换格式的冲突，不知道小伙伴们遇到过这种情况没。</p>
<p>所以还是知道下原理，<code>extends</code> 中为什么那么写，格式冲突和顺序有什么关系没？</p>
<ol>
<li><code>eslint-config-prettier</code> 源码可以看出，它的代码很简单，它实际就是关闭了 <code>eslint</code> 的所有格式化规则。</li>
</ol>
<blockquote>
<p>源码地址：<a href="https://github.com/prettier/eslint-config-prettier/tree/master/bin">https://github.com/prettier/eslint-config-prettier/tree/master/bin</a></p>
</blockquote>
<ol>
<li>我们 <code>yarn add</code> 插件的时候 <code>eslint-config-prettier</code> 模块实际是为 <code>eslint-plugin-prettier</code> 插件服务的，在 <code>eslint-plugin-prettier</code> 的源码中调用了 <code>eslint-config-prettier</code> 中相关的配置，然后执行插件中的代码。</li>
<li>看 <code>eslint-config-prettier</code> 中 <code>recommended</code>部分 的源码，源码中也有使用到 <code>eslint-config-prettier</code>（把已有格式化配置关掉），然后自己制定了基础的 <code>recommended</code> 版本，讲到这应该明白为什么在 <code>eslint-plugin-prettier</code> 中有一段最重要的话，需要把它(eslint-config-prettier)放在所有格式化配置的后面。</li>
</ol>
<p><img src="https://i.loli.net/2021/01/19/5sMm2pjYkfogC4a.png" alt="640 (1)_看图王.web"></p>
<p>前面的内容，通过这个插件对前面 <code>ESLint</code> 的配置进行重置。如果想使用一些 <code>Prettier</code> 中不支持的格式化配置，我们把eslint中的格式化加在他们后面写了，也不会有冲突。</p>
<ol>
<li><code>prettier/@typescript-eslint</code> 是用来忽略 <code>typescript</code> 中的格式化配置。</li>
</ol>
<p>这里关于防止 <code>Prettier</code> 和 <code>ESLint</code> 冲突，画了一张</p>
<blockquote>
<p>另外 <code>eslint-plugin-prettier</code> 和 <code>eslint-config-prettier</code> 的源码都不是很复杂，感兴趣的同学可以去看看，下面是源码地址：</p>
<ul>
<li>eslint-plugin-prettier 官网</li>
<li>eslint-config-prettier 官网</li>
</ul>
</blockquote>
<h3 id="Prettier-原理简单说明"><a href="#Prettier-原理简单说明" class="headerlink" title="Prettier 原理简单说明"></a>Prettier 原理简单说明</h3><p>不管你写的代码是个什么鬼样子，<code>Prettier</code> 会去掉你代码里的所有样式风格，然后用统一固定的格式重新输出。输出时基本上只考虑一个参数，就是 <code>line length</code>。</p>
<p>例如你写的这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(arg1, arg2, arg3, arg4);</span><br></pre></td></tr></table></figure>
<p>一行装得下这么多代码，所以就不需要改。</p>
<p>如果你写了下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(reallyLongArg(), omgSoManyParameters(),IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br></pre></td></tr></table></figure>
<p>太长了，<code>Prettier</code> 就会重新改成这样输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(</span><br><span class="line">  reallyLongArg(),</span><br><span class="line">  omgSoManyParameters(),</span><br><span class="line">  IShouldRefactorThis(),</span><br><span class="line">  isThereSeriouslyAnotherOne()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>咱们再仔细探究一下这个过程。不管你之前写的代码是什么样，首先必须符合语法规范。<code>Prettier</code> 先把你的代码转换成一种中间状态，叫 <code>AST(Abstract Syntax Tree)</code>。</p>
<p>用 <code>Prettier</code> 提供的 Playground 更直观一些：</p>
<p><img src="https://i.loli.net/2021/01/19/Tk5SrzM6QBfGiXh.png" alt="图片"></p>
<p>上图左侧是手写代码，中间是 AST(去掉了任何代码风格)，右侧是重新输出的结果。</p>
<p>Prettier 就是在这个 AST 上重新按照自己的风格输出代码。</p>
<p><strong>这是 <code>Prettier</code> 也搞懂后的最终配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析器</span></span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&quot;./.eslintRules.js&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;prettier&quot;</span>,<span class="comment">// 优先 prettier 中的样式规范</span></span><br><span class="line">    <span class="string">&#x27;prettier/@typescript-eslint&#x27;</span>,</span><br><span class="line">  ], <span class="comment">// 继承的规则</span></span><br><span class="line">  plugins: [<span class="string">&#x27;@typescript-eslint&#x27;</span>], <span class="comment">// 插件</span></span><br><span class="line">  env: &#123;</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">    mocha: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 解析 .ts 文件</span></span><br><span class="line">    ecmaVersion: <span class="number">2019</span>,</span><br><span class="line">    sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      modules: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &#125;, <span class="comment">// 规则</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意 <code>eslintRules</code> 是 <code>base</code> 规则，单独提了出来。</p>
<h2 id="VSCode-自动-fix-配置"><a href="#VSCode-自动-fix-配置" class="headerlink" title="VSCode 自动 fix 配置"></a>VSCode 自动 fix 配置</h2><p>因为终极目标是我们在使用<code>eslint</code>格式化并且检查我们自己编写的 <code>javascript</code> 和 <code>typescript</code>。除了我们要求的代码，如果开发者添加别的代码也应该进行格式化，除非忽略的文件，开发者本地安装什么插件我们管不到，在用户级别配置中 <code>setting.json</code> 中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 此模式不能使用skipFiles特性，暂时关闭，需要调试其他进程时请在本地打开</span></span><br><span class="line">  <span class="comment">// &quot;debug.node.autoAttach&quot;: &quot;on&quot;,</span></span><br><span class="line">  <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;debug.openDebug&quot;</span>: <span class="string">&quot;openOnFirstSessionStart&quot;</span>,</span><br><span class="line">  <span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;[typescript]&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lint-校验代码与-与-–fix-参数设置"><a href="#lint-校验代码与-与-–fix-参数设置" class="headerlink" title="lint 校验代码与 与 –fix 参数设置"></a>lint 校验代码与 与 –fix 参数设置</h2><p>上面的配置都做完了，如果不是一个新项目是原有的老项目，可能需要做一些改动喽！我们先 Fix一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm 脚本中需要有这样的配置</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint:create&quot;</span>: <span class="string">&quot;eslint --init&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令<code>npx run lint</code>会出现如下的错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">7</span>   error  <span class="string">&#x27;lint&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"><span class="number">1</span>:<span class="number">14</span>  error  Strings must use doublequote               quotes</span><br><span class="line"><span class="number">1</span>:<span class="number">22</span>  error  Missing semicolon                          semi</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> problems (<span class="number">3</span> errors, <span class="number">0</span> warnings)</span><br><span class="line"><span class="number">2</span> errors, <span class="number">0</span> warnings potentially fixable <span class="keyword">with</span> the <span class="string">`--fix`</span> option.</span><br></pre></td></tr></table></figure>
<p>这里报了三个错误，分别是：</p>
<ul>
<li><code>index.js</code> 第1行第7个字符，报错编码规则为 <code>no-unused-vars</code>：变量 <code>lint</code> 只定义了，但是未使用；</li>
<li><code>index.js</code> 第1行第14个字符，报错编码规则为 <code>quotes</code>：编码规范字符串只能使用双引号，这里却使用了单引号；</li>
<li><code>index.js</code> 第1行第22个字符，报错编码规则为 <code>semi</code>：编码规范每行代码结尾必须加分号，这里没有加分号。</li>
</ul>
<h3 id="设置-fix-参数"><a href="#设置-fix-参数" class="headerlink" title="设置 --fix 参数"></a>设置 <code>--fix</code> 参数</h3><p>说明：这里给 <code>&quot;lint&quot;: &quot;eslint src --fix&quot;</code>, 加上 <code>--fix</code> 参数，是 <code>ESLint</code> 提供的自动修复基础错误的功能。</p>
<p>此时运行 <code>npm run lint</code> 会看到少了两条报错信息，并不是说编码规范变了，而是 Eslint 自动修复了基础错误，打开 index.js 文件，可看到字符串自动变成了双引号，并且代码末尾也加上了分号。可惜的是 <code>--fix</code> 只能修复基础的不影响代码逻辑的错误，像 <code>no-unused-vars</code> 这种错误只能手动修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对开篇那张图片中的本地代码检查部分进行了详细讲解，从实践到原理，另外小伙伴们也可以想下我开篇提到的如何做出亮点，希望有所帮助，最后快去制定一个属于自己项目的规范与检查吧！</p>
<p>如果开篇图中后面 <code>CI/CD</code> 部分感兴趣的可以找我讨论，后面会单独写一篇 <code>CI/CD</code> 文章，不然篇幅太长了，欢迎在看转发。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>Prettier 看这一篇就行了</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750496&idx=2&sn=2627a4bdd7e63343c8947ecf82b2349f&scene=21#wechat_redirect">ESLint 在中大型团队的应用实践</a></li>
<li>使用 ESLint+Prettier 规范 React+Typescript 项目</li>
<li>eslint-plugin-prettier 官网</li>
<li>Using ESLint and Prettier in a TypeScript Project</li>
<li>十分钟了解eslint配置 &amp;&amp; 编写自定义eslint规则</li>
</ul>
]]></content>
      <tags>
        <tag>代码 规范 企业 eslint tslint prettier</tag>
      </tags>
  </entry>
  <entry>
    <title>我所认识的javascript正则表达式</title>
    <url>/2017/12/06/%E6%88%91%E6%89%80%E8%AE%A4%E8%AF%86%E7%9A%84javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>如果说这是一篇关于正则表达式的小结，我更愿意把它当做一个手册。</p>
</blockquote>
<a id="more"></a>

<h1 id="RegExp-三大方法"><a href="#RegExp-三大方法" class="headerlink" title="RegExp 三大方法"></a>RegExp 三大方法</h1><blockquote>
<p>本文的RegExp采用直接量语法表示：/pattern/attributes。attributes有三个选择，i、m和g，m（多行匹配）不常用直接省略，所以一个pattern（匹配模式）可以表示如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pattern &#x3D; &#x2F;hello&#x2F;ig;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>i（ignore）表示不区分大小写（地搜索匹配），比较简单，以下例子中不加述说；g（global）表示全局（搜索匹配），即找到一个后继续找下去，相对复杂，以下各种方法中会特别介绍。</p>
</blockquote>
<p>既然是RegExp的三大方法，所以都是pattern.test/exec/complie的格式。</p>
<ul>
<li>test</li>
</ul>
<blockquote>
<p>主要功能：检测指定字符串是否含有某个子串（或者匹配模式），返回true或者false。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;you&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.test(s);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果attributes用了g，则可以继续找下去，其中还会涉及lastIndex属性（参照exec中搭配g的介绍）。</p>
</blockquote>
<ul>
<li>exec</li>
</ul>
<blockquote>
<p>主要功能：提取指定字符串中的符合要求的子串（或者匹配模式），返回一个数组存放匹配结果；如果没有，则返回null。（也可自己写方法循环提取所有或者指定index的数据）</p>
</blockquote>
<blockquote>
<p>exec可以说是test的升级版本，因为它不仅可以检测，而且检测到了可以直接提取结果。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;you&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]</span><br><span class="line">console.log(ans.index); &#x2F;&#x2F; 0</span><br><span class="line">console.log(ans.input); &#x2F;&#x2F; you love me and I love you</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出的东西很有意思。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。</p>
</blockquote>
<p>啥叫“与子表达式相匹配的文本”？看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;y(o?)u&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans);   &#x2F;&#x2F; [&quot;you&quot;, &quot;o&quot;, index: 0, input: &quot;you love me and I love you&quot;]</span><br><span class="line">console.log(ans.length) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所谓的子表达式就是pattern里（）内的东西（具体可以参考下文对子表达式的介绍）。再看上面例子的数组长度，是2！！index和input只是数组属性（chrome中以上的输出可能会让人误会）。</p>
</blockquote>
<p>除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，<strong>在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。</strong></p>
<blockquote>
<p>如果使用 “g” 参数，exec() 的工作原理如下（还是以上的例子 ps：如果test使用g参数类似）：</p>
</blockquote>
<ol>
<li>找到第一个 “you”，并存储其位置</li>
<li>如果再次运行 exec()，则从存储的位置（lastIndex）开始检索，并找到下一个 “you”，并存储其位置</li>
</ol>
<blockquote>
<p>当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，我们可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。这里引入lastIndex属性，这货只有跟g和test（或者g和exec）三者搭配时才有作用。它是pattern的一个属性，一个整数，标示开始下一次匹配的字符位置。</p>
</blockquote>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;you&#x2F;g;</span><br><span class="line">var ans;</span><br><span class="line">do &#123;</span><br><span class="line">  ans &#x3D; pattern.exec(s);</span><br><span class="line">  console.log(ans);</span><br><span class="line">  console.log(pattern.lastIndex);</span><br><span class="line">&#125;</span><br><span class="line">while (ans !&#x3D;&#x3D; null)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://i.imgur.com/RW3N6d1.png"></p>
<p>应该还容易理解，当第三次循环时，找不到“you”了，于是返回null，lastIndex值也变成0了。</p>
<p>如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串（仍然使用旧的pattern），就必须手动地把 lastIndex 属性重置为 0。</p>
<ul>
<li>compile</li>
</ul>
<p>主要功能：改变当前匹配模式（pattern）</p>
<p>这货是改变匹配模式时用的，用处不大，略过。<a href="http://www.w3school.com.cn/jsref/jsref_regexp_compile.asp" title="JavaScript compile() 方法">详见JavaScript compile() 方法</a></p>
<h1 id="String-四大护法"><a href="#String-四大护法" class="headerlink" title="String 四大护法"></a>String 四大护法</h1><p>和RegExp三大方法分庭抗礼的是String的四大护法，四大护法有些和RegExp三大方法类似，有的更胜一筹。</p>
<p>既然是String家族下的四大护法，所以肯定是string在前，即str.search/match/replace/split形式。</p>
<p>既然是String的方法，当然参数可以只用字符串而不用pattern。</p>
<ul>
<li>search</li>
</ul>
<blockquote>
<p>主要功能：搜索指定字符串中是否含有某子串（或者匹配模式），如有，返回子串在原串中的初始位置，如没有，返回-1。</p>
</blockquote>
<p>是不是和test类似呢？test只能判断有木有，search还能返回位置！当然test()如果有需要能继续找下去，而search则会自动忽略g（如果有的话）。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;you&#x2F;;</span><br><span class="line">var ans &#x3D; s.search(pattern);</span><br><span class="line">console.log(ans);  &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>话说和String的indexOf方法有点相似，不同的是indexOf方法可以从指定位置开始查找，但是不支持正则。</p>
</blockquote>
<ul>
<li>match</li>
</ul>
<blockquote>
<p>主要功能：和exec类似，从指定字符串中查找子串或者匹配模式，找到返回数组，没找到返回null</p>
</blockquote>
<p>match是exec的轻量版，当不使用全局模式匹配时，match和exec返回结果一致；当使用全局模式匹配时，match直接返回一个字符串数组，获得的信息远没有exec多，但是使用方式简单。</p>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">console.log(s.match(&#x2F;you&#x2F;));    &#x2F;&#x2F; [&quot;you&quot;, index: 0, input: &quot;you love me and I love you&quot;]</span><br><span class="line">console.log(s.match(&#x2F;you&#x2F;g));   &#x2F;&#x2F; [&quot;you&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>replace</li>
</ul>
<blockquote>
<p>主要功能：用另一个子串替换指定字符串中的某子串（或者匹配模式），返回替换后的新的字符串  str.replace(‘搜索模式’,’替换的内容’)  如果用的是pattern并且带g，则全部替换；否则替换第一处。</p>
</blockquote>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">console.log(s.replace(&#39;you&#39;, &#39;zichi&#39;)); &#x2F;&#x2F; zichi love me and I love you</span><br><span class="line">console.log(s.replace(&#x2F;you&#x2F;, &#39;zichi&#39;)); &#x2F;&#x2F; zichi love me and I love you</span><br><span class="line">console.log(s.replace(&#x2F;you&#x2F;g, &#39;zichi&#39;));    &#x2F;&#x2F; zichi love me and I love zichi</span><br></pre></td></tr></table></figure>
<p>如果需要替代的内容不是指定的字符串，而是跟匹配模式或者原字符串有关，那么就要用到$了（记住这些和$符号有关的东东只和replace有关哦）。</p>
<p><img src="https://i.imgur.com/Cg10dYD.png"></p>
<p>怎么用？看个例子就明白了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;love&#x2F;;</span><br><span class="line">var ans &#x3D; s.replace(pattern, &#39;$&#96;&#39; + &#39;$&amp;&#39; + &quot;$&#39;&quot;);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; I I love you you</span><br></pre></td></tr></table></figure>
<p>没错，’$`’ + ‘$&amp;’ + “$’”其实就相当于原串了！</p>
<p>replace的第二个参数还能是函数，看具体例子前先看一段介绍：</p>
<p><img src="https://i.imgur.com/yi8KVpp.png"></p>
<p>第一个参数是匹配到的子串，接下去是子表达式匹配的值，如果要用子表达式参数，则必须要有第一个参数（表示匹配到的串），也就是说，如果要用第n个参数代表的值，则左边参数都必须写出来。最后两个参数跟exec后返回的数组的两个属性差不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;love&#x2F;;</span><br><span class="line">var ans &#x3D; s.replace(pattern, function(a) &#123;　　&#x2F;&#x2F; 只有一个参数，默认为匹配到的串（如还有参数，则按序表示子表达式和其他两个参数）</span><br><span class="line">  return a.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; I LOVE you</span><br></pre></td></tr></table></figure>
<ul>
<li>split</li>
</ul>
<p>主要功能：分割字符串</p>
<p>字符串分割成字符串数组的方法（另有数组变成字符串的join方法）。直接看以下例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#39;and&#39;;</span><br><span class="line">var ans &#x3D; s.split(pattern);</span><br><span class="line">console.log(ans);   &#x2F;&#x2F; [&quot;you love me &quot;, &quot; I love you&quot;]</span><br></pre></td></tr></table></figure>
<p>如果你嫌得到的数组会过于庞大，也可以自己定义数组大小，加个参数即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;you love me and I love you&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;and&#x2F;;</span><br><span class="line">var ans &#x3D; s.split(pattern, 1);</span><br><span class="line">console.log(ans);   &#x2F;&#x2F; [&quot;you love me &quot;]</span><br></pre></td></tr></table></figure>
<h1 id="RegExp-字符"><a href="#RegExp-字符" class="headerlink" title="RegExp 字符"></a>RegExp 字符</h1><p><img src="https://i.imgur.com/ibdT2yl.png"></p>
<p><img src="https://i.imgur.com/iqspn9n.png"></p>
<p><img src="https://i.imgur.com/h5ifofy.png"></p>
<ul>
<li>\s 任意空白字符 \S相反 空白字符可以是： 空格符 (space character) 制表符 (tab character) 回车符 (carriage return character) 换行符 (new line character) 垂直换行符 (vertical tab character) 换页符 (form feed character)</li>
<li>\b是正则表达式规定的一个特殊代码，代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。（和^ $ 以及零宽断言类似）</li>
<li>\w 匹配字母或数字或下划线   [a-z0-9A-Z_]完全等同于\w</li>
</ul>
<h1 id="贪婪匹配和懒惰匹配"><a href="#贪婪匹配和懒惰匹配" class="headerlink" title="贪婪匹配和懒惰匹配"></a>贪婪匹配和懒惰匹配</h1><p>什么是贪婪匹配？贪婪匹配就是在正则表达式的匹配过程中，默认会使得匹配长度越大越好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello world welcome to my world&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;hello.*world&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans)  &#x2F;&#x2F; [&quot;hello world welcome to my world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]</span><br></pre></td></tr></table></figure>
<p>以上例子不会匹配最前面的hello world，而是一直贪心的往后匹配。</p>
<p>那么我需要最短的匹配怎么办？很简单，加个‘？’即可，这就是传说中的懒惰匹配，即匹配到了，就不往后找了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello world welcome to my world&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;hello.*?world&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans)  &#x2F;&#x2F; [&quot;hello world&quot;, index: 0, input: &quot;hello world welcome to my world&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>懒惰限定符（？）添加的场景如下：</strong></p>
<p><img src="https://i.imgur.com/TEWYdz8.png"></p>
<h1 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h1><ul>
<li>表示方式</li>
</ul>
<p>用一个小括号指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello world&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(hello)&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans);</span><br></pre></td></tr></table></figure>
<ul>
<li>子表达式出现场景</li>
</ul>
<p>在exec中数组输出子表达式所匹配的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello world&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(h(e)llo)&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;hello&quot;, &quot;hello&quot;, &quot;e&quot;, index: 0, input: &quot;hello world&quot;]</span><br></pre></td></tr></table></figure>
<p>在replace中作为替换值引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello world&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(h\w*o)\s*(w\w*d)&#x2F;;</span><br><span class="line">var ans &#x3D; s.replace(pattern, &#39;$2 $1&#39;)</span><br><span class="line">console.log(ans); &#x2F;&#x2F; world hello</span><br></pre></td></tr></table></figure>
<ul>
<li>子表达式的序号问题</li>
</ul>
<p>简单地说：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>复杂地说：分组0对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</p>
<h1 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h1><p>如果我们要找连续两个一样的字符，比如要找两个连续的c，可以这样/c{2}/，如果要找两个连续的单词hello，可以这样/(hello){2}/，但是要在一个字符串中找连续两个相同的任意单词呢，比如一个字符串hellohellochinaworldworld，我要找的是hello和world，怎么找？</p>
<p>这时候就要用后向引用。看具体例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hellohellochinaworldworld&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(\w+)\1&#x2F;g;</span><br><span class="line">var a &#x3D; s.match(pattern);</span><br><span class="line">console.log(a); &#x2F;&#x2F; [&quot;hellohello&quot;, &quot;worldworld&quot;]</span><br></pre></td></tr></table></figure>
<p>这里的\1就表示和匹配模式中的第一个子表达式（分组）一样的内容，\2表示和第二个子表达式（如果有的话）一样的内容，\3 \4 以此类推。（也可以自己命名，详见参考文献）</p>
<p>或许你觉得数组里两个hello两个world太多了，我只要一个就够了，就又要用到子表达式了。因为match方法里是不能引用子表达式的值的，我们回顾下哪些方法是可以的？没错，exec和replace是可以的！</p>
<ul>
<li>exec方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hellohellochinaworldworld&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(\w+)\1&#x2F;g;</span><br><span class="line">var ans;</span><br><span class="line">do &#123;</span><br><span class="line">　　ans &#x3D; pattern.exec(s);</span><br><span class="line">　　console.log(ans);</span><br><span class="line">&#125; while(ans !&#x3D;&#x3D; null);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; result</span><br><span class="line">&#x2F;&#x2F; [&quot;hellohello&quot;, &quot;hello&quot;, index: 0, input: &quot;hellohellochinaworldworld&quot;] index.html:69</span><br><span class="line">&#x2F;&#x2F; [&quot;worldworld&quot;, &quot;world&quot;, index: 15, input: &quot;hellohellochinaworldworld&quot;] index.html:69</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>
<p>如果输出只要hello和world，console.log(ans[1])即可。</p>
<ul>
<li>replace方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hellohellochinaworldworld&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;(\w+)\1&#x2F;g;</span><br><span class="line">var ans &#x3D; [];</span><br><span class="line">s.replace(pattern, function(a, b) &#123;</span><br><span class="line">　ans.push(b);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ans);   &#x2F;&#x2F; [&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure>
<p>如果要找连续n个相同的串，比如说要找出一个字符串中出现最多的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.getMost &#x3D; function() &#123;</span><br><span class="line">  var a &#x3D; this.split(&#39;&#39;);</span><br><span class="line">  a.sort();</span><br><span class="line">  var s &#x3D; a.join(&#39;&#39;);</span><br><span class="line">  var pattern &#x3D; &#x2F;(\w)\1*&#x2F;g;</span><br><span class="line">  var a &#x3D; s.match(pattern);</span><br><span class="line">  a.sort(function(a, b) &#123;</span><br><span class="line">    return a.length &lt; b.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  var letter &#x3D; a[0][0];</span><br><span class="line">  var num &#x3D; a[0].length;</span><br><span class="line">  return letter + &#39;: &#39; + num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var s &#x3D; &#39;aaabbbcccaaabbbcccccc&#39;;</span><br><span class="line">console.log(s.getMost()); &#x2F;&#x2F; c: 9</span><br></pre></td></tr></table></figure>
<p>如果需要引用某个子表达式（分组），请认准后向引用！</p>
<h1 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h1><p>别被名词吓坏了，其实解释很简单。</p>
<p>它们用于查找在某些内容(但并不包括这些内容)之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)</p>
<ul>
<li>(?=exp)</li>
</ul>
<p>零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取字符串中以ing结尾的单词的前半部分</span><br><span class="line">var s &#x3D; &#39;I love dancing but he likes singing&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;\b\w+(?&#x3D;ing\b)&#x2F;g;</span><br><span class="line">var ans &#x3D; s.match(pattern);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;danc&quot;, &quot;sing&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>(?!exp)</li>
</ul>
<p>零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取第五位不是i的单词的前四位</span><br><span class="line">var s &#x3D; &#39;I love dancing but he likes singing&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;\b\w&#123;4&#125;(?!i)&#x2F;g;</span><br><span class="line">var ans &#x3D; s.match(pattern);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;love&quot;, &quot;like&quot;]</span><br></pre></td></tr></table></figure>
<p>javascript正则只支持前瞻，不支持后瞻（(?&lt;=exp)和(?&lt;!exp)）。</p>
<p>关于零宽断言的具体应用可以参考综合应用一节给字符串加千分符。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>字符转义</li>
</ul>
<p>因为某些字符已经被正则表达式用掉了，比如. * ( ) / \  []，所以需要使用它们（作为字符）时，需要用\转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;zichi&#x2F;&#39;;</span><br><span class="line">var pattern &#x3D; &#x2F;http:\&#x2F;\&#x2F;www\.cnblogs\.com\&#x2F;zichi\&#x2F;&#x2F;;</span><br><span class="line">var ans &#x3D; pattern.exec(s);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;zichi&#x2F;&quot;, index: 0, input: &quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;zichi&#x2F;&quot;]</span><br></pre></td></tr></table></figure>
<ul>
<li>分支条件</li>
</ul>
<p>如果需要匹配abc里的任意字母，可以用[abc]，但是如果不是单个字母那么简单，就要用到分支条件。</p>
<p>分支条件很简单，就是用|表示符合其中任意一种规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &quot;I don&#39;t like you but I love you&quot;;</span><br><span class="line">var pattern &#x3D; &#x2F;I.*(like|love).*you&#x2F;g;</span><br><span class="line">var ans &#x3D; s.match(pattern);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;I don&#39;t like you but I love you&quot;]</span><br></pre></td></tr></table></figure>
<p>答案执行了贪婪匹配，如果需要懒惰匹配，则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &quot;I don&#39;t like you but I love you&quot;;</span><br><span class="line">var pattern &#x3D; &#x2F;I.*?(like|love).*?you&#x2F;g;</span><br><span class="line">var ans &#x3D; s.match(pattern);</span><br><span class="line">console.log(ans); &#x2F;&#x2F; [&quot;I don&#39;t like you&quot;, &quot;I love you&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1><ul>
<li>去除字符串首尾空格（replace）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.trim &#x3D; function() &#123;</span><br><span class="line">  return this.replace(&#x2F;(^\s*)|(\s*$)&#x2F;g, &quot;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var s &#x3D; &#39;    hello  world     &#39;;</span><br><span class="line">var ans &#x3D; s.trim();</span><br><span class="line">console.log(ans.length);    &#x2F;&#x2F; 12</span><br></pre></td></tr></table></figure>
<ul>
<li>给字符串加千分符（零宽断言）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.getAns &#x3D; function() &#123;</span><br><span class="line">  var pattern &#x3D; &#x2F;(?&#x3D;((?!\b)\d&#123;3&#125;)+$)&#x2F;g;</span><br><span class="line">  return this.replace(pattern, &#39;,&#39;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var s &#x3D; &#39;123456789&#39;;</span><br><span class="line">console.log(s.getAns());  &#x2F;&#x2F; 123,456,789</span><br></pre></td></tr></table></figure>
<ul>
<li>找出字符串中出现最多的字符（后向引用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.getMost &#x3D; function() &#123;</span><br><span class="line">  var a &#x3D; this.split(&#39;&#39;);</span><br><span class="line">  a.sort();</span><br><span class="line">  var s &#x3D; a.join(&#39;&#39;);</span><br><span class="line">  var pattern &#x3D; &#x2F;(\w)\1*&#x2F;g;</span><br><span class="line">  var a &#x3D; s.match(pattern);</span><br><span class="line">  a.sort(function(a, b) &#123;</span><br><span class="line">    return a.length &lt; b.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  var letter &#x3D; a[0][0];</span><br><span class="line">  var num &#x3D; a[0].length;</span><br><span class="line">  return letter + &#39;: &#39; + num;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">var s &#x3D; &#39;aaabbbcccaaabbbcccccc&#39;;</span><br><span class="line">console.log(s.getMost()); &#x2F;&#x2F; c: 9</span><br></pre></td></tr></table></figure>
<ul>
<li>字符转义（replace）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escapeHtml(str) &#123;</span><br><span class="line">  return str.replace(&#x2F;[&lt;&gt;&quot;&amp;]&#x2F;g, function(a) &#123;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">      case &quot;&lt;&quot;:</span><br><span class="line">        return &quot;&lt;&quot;;</span><br><span class="line">      case &quot;&gt;&quot;:</span><br><span class="line">        return &quot;&gt;&quot;;</span><br><span class="line">      case &quot;&amp;&quot;:</span><br><span class="line">        return &quot;&amp;&quot;;</span><br><span class="line">      case &quot;\&quot;&quot;:</span><br><span class="line">        return &quot;&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ans &#x3D; escapeHtml(&#39;&lt;&gt;&quot;&amp;&#39;);</span><br><span class="line">  console.log(ans); &#x2F;&#x2F; &lt;&gt;&quot;&amp;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>test：检查指定字符串中有没有某子串（或某匹配模式），返回true或者false；如有必要可以进行全局模式搜索。</li>
<li>exec：检查指定字符串中有没有某子串（或者匹配模式），如有返回数组（数组信息丰富，可参考上文介绍），如没有返回null；如有必要可以进行全局搜索找出所有子串（或者匹配模式）的信息，信息中含有匹配模式中子表达式所对应的字符串。</li>
<li>compile：修改正则表达式中的pattern</li>
<li>search：检查指定字符串中有没有某子串（或者匹配模式），如有返回子串（或者匹配模式）在原串中的开始位置，如没有返回-1。不能进行全局搜索。</li>
<li>match：检查指定字符串中有没有某子串（或者匹配模式），非全局模式下返回信息和exec一致；如进行全局搜索，直接返回字符串数组。（如不需要关于每个匹配的更多信息，推荐用match而不是exec）</li>
<li>replace：检查指定字符串中有没有某子串（或者匹配模式），并用另一个子串代替（该子串可以跟原字符串或者搜索到的子串有关）；如启动g，则全局替换，否则只替换第一个。replace方法可以引用子表达式所对应的值。</li>
<li>split：用特定模式分割字符串，返回一个字符串数组；与Array的join方法正好相反。<br>子表达式：用括号括起来的正则匹配表达式，用后向引用可以对其进行引用；也可以和exec或者replace搭配获取其真实匹配值。</li>
<li>后向引用 ：对子表达式所在分组进行引用。</li>
<li>零宽断言：和\b ^ 以及$类似的某个位置概念。</li>
</ol>
]]></content>
      <tags>
        <tag>javascript js 正则 正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2019/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。</p>
</blockquote>
<a id="more"></a>

<h1 id="为什么需要学习数据结构？"><a href="#为什么需要学习数据结构？" class="headerlink" title="为什么需要学习数据结构？"></a>为什么需要学习数据结构？</h1><h2 id="语言是相通的"><a href="#语言是相通的" class="headerlink" title="语言是相通的?"></a>语言是相通的?</h2><p>人们常说，编程语言是相通的，掌握了一门，其他语言很容易就能掌握，个人认为这是一个似是而非的观点。</p>
<p>每门编程语言都离不开变量，数组，循环，条件判断这些概念，这似乎能够支持上面的观点，但是，每门编程语言都有自己的适用范围。都有自己擅长的事情，即便是有了node.js这种能够一统前后端的语言，也总有它不能胜任的工作，比如机器学习。像python这样的近乎万能的语言，也总有无能为力的时候，比如面对高性能计算，许多python库的底层实现可都是C语言哦。</p>
<p>多年的工作经验告诉我，真正相通的不是语言，而是数据结构和算法。</p>
<p>数据结构和算法是脱离编程语言而存在的，不同的语言有不同的实现版本，但内在的逻辑却不会有变化，所体现的编程思想不会有变化。</p>
<h2 id="一段亲身经历"><a href="#一段亲身经历" class="headerlink" title="一段亲身经历"></a>一段亲身经历</h2><p>我曾经在工作有过这样一次经历，我在后端通过websockt向前端发送数据，数据是一个具体的坐标，前端的同学得到坐标后，要在前端的中国地图上根据坐标显示一个光圈。这是一个非常简单的事情，但却遇到了麻烦，后端向前端推送数据是一个不定时的行为，有时1秒钟推了3条数据，有时3秒钟才推1条数据，当我推送数据频繁的时候，如果这些坐标都在地图上显示，地图会非常乱。长时间不推送数据时，前端页面不应该一直显示之前推送过的坐标，因为每一个坐标代表一个用户刚刚在我们的网站上做了一项操作。</p>
<p>于是，我们对前端显示做了限制，前端同一个时刻最多显示10个坐标，如果已经有10个，新来的坐标要把之前最早到来的坐标挤掉，每个坐标最多显示5秒钟。就是这样一个简单的要求，前端同学却迟迟不能实现该功能，因为他无法兼顾最多显示10个坐标和每个坐标最多显示5秒钟的要求。</p>
<p>后来，我让他用队列来实现。前端在收到坐标后，将坐标和收到时间构造成一个新的对象，一同放入到队列中，如果列队元素已经有10个，则把队列头部的元素删除，于此同时，每隔1秒钟就对队列里的元素检查一次，队列头部的元素都是最早到来的，如果当前时间距离到来时间超过5秒，则删除队列头部元素。</p>
<p>就这样，前端同学使用队列，非常快的实现了这个功能，而且对数据结构产生了浓厚的兴趣。</p>
<p>每当你怀疑学习数据结构的必要性和作用时，请提醒自己，如果你手里只有锤子，那么目光所及之处都是钉子。</p>
<h2 id="学习数据结构的目标"><a href="#学习数据结构的目标" class="headerlink" title="学习数据结构的目标"></a>学习数据结构的目标</h2><ul>
<li><p>提高程序设计能力</p>
</li>
<li><p>提高算法能力</p>
</li>
<li><p>找工作面试的时候hold住面试官</p>
</li>
</ul>
<p>数据结构的精髓在于总结提炼了许多存储管理和使用数据的模式，这些模式的背后是最精华的编程思想，这些思想的领悟需要时间，不要想当然的认为学会了几种数据结构就可以在工作中大显身手，但学会了数据结构，对自身能力的提升是不言而喻的。</p>
<p>当然，在没有参悟这些数据管理方式和编程思想之前，我们先学习具体的工具和方法。</p>
<h2 id="学习数据结构需要准备哪些知识"><a href="#学习数据结构需要准备哪些知识" class="headerlink" title="学习数据结构需要准备哪些知识"></a>学习数据结构需要准备哪些知识</h2><p>你需要熟练地使用数组这种数据类型，我想这没什么困难，再有就是知道如何在javascript中定义类，这里推荐一篇文章<a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html">Javascript定义类（class）的三种方法</a>本系列课程主要使用构造函数法定义类。</p>
<h1 id="数据结构之—-栈"><a href="#数据结构之—-栈" class="headerlink" title="数据结构之—-栈"></a>数据结构之—-栈</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈是一种特殊的线性表，仅能够在栈顶进行操作，有着先进后出(后进先出)的特性，下面这张图展示了栈的工作特点：</p>
<p><img src="https://i.imgur.com/k0yBPn0.png"></p>
<p>对于栈的理解，你必须牢牢抓住一点，那便是你只能在栈顶进行操作，生活中有一个非常贴切的例子，玩羽毛球的同学都会买一桶羽毛球，羽毛球桶就是典型的栈结构。</p>
<p><img src="https://i.imgur.com/lNPG23S.jpg"></p>
<p>每次取羽毛球时，都只能从顶部取，最底下的羽毛球，你是取不到的，用完了羽毛球后，也只能从顶部放回去。</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>上一小节，我们对栈这种数据结构有了视觉上的接触和理解，接下来，我们要对栈进行定义，毕竟，我们写一个栈，为的是使用它，那么就必须先定义数据存储在哪里，提供什么样的方法。</p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>从数据存储的角度看，实现栈有两种方式，一种是以数组做基础，一种是以链表做基础，数组是最简单的实现方式，链表在后面会作为单独的一种数据结构来讲解。本次课程将使用数组来实现栈和队列，数组是大家平时用的最频繁的，也是最了解熟悉的数据类型。</p>
<p>我们先定义一个简单的Stack类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    var items &#x3D; [];  &#x2F;&#x2F; 使用数组存储数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数据将存储在items数组之中，现在，这个类没有任何方法。</p>
<h3 id="栈的方法"><a href="#栈的方法" class="headerlink" title="栈的方法"></a>栈的方法</h3><p>栈有以下几个方法：</p>
<ul>
<li>push 添加一个元素到栈顶（向桶里放入一个羽毛球）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; push方法向栈里压入一个元素</span><br><span class="line">this.push &#x3D; function(item)&#123;</span><br><span class="line">    items.push(item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>pop 弹出栈顶元素（从桶里拿出一个羽毛球）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pop方法把栈顶的元素弹出</span><br><span class="line">this.pop &#x3D; function()&#123;</span><br><span class="line">    return items.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数组的pop方法会删除最靠后的那个元素，同时return该元素</p>
<ul>
<li>top 返回栈顶元素，注意，不是弹出（看一眼桶里最顶端的羽毛球，但是不拿）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; top 方法返回栈顶元素</span><br><span class="line">this.top &#x3D; function()&#123;</span><br><span class="line">    return items[items.length - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>top方法只是想查看一下最顶端的元素</p>
<ul>
<li>isEmpty 判断栈是否为空（看看羽毛球是不是都用完了）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; isEmpty返回栈是否为空</span><br><span class="line">this.isEmpty &#x3D; function()&#123;</span><br><span class="line">    return items.length &#x3D;&#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>size 返回栈里元素的个数（数一下桶里还有多少羽毛球）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; size方法返回栈的大小</span><br><span class="line">this.size &#x3D; function()&#123;</span><br><span class="line">    return items.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>clear 清空栈（把桶里的羽毛球都倒出来扔掉）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; clear 清空栈</span><br><span class="line">this.clear &#x3D; function()&#123;</span><br><span class="line">    items &#x3D; []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终完成版的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Stack() &#123;</span><br><span class="line">    var items &#x3D; [];  &#x2F;&#x2F; 使用数组存储数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; push方法向栈里压入一个元素</span><br><span class="line">    this.push &#x3D; function(item)&#123;</span><br><span class="line">        items.push(item);</span><br><span class="line">    &#125;;</span><br><span class="line">	&#x2F;&#x2F; 获取数组</span><br><span class="line">    this.get &#x3D; function() &#123;</span><br><span class="line">        return items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; pop方法把栈顶的元素弹出</span><br><span class="line">    this.pop &#x3D; function()&#123;</span><br><span class="line">        return items.pop();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; top 方法返回栈顶元素</span><br><span class="line">    this.top &#x3D; function()&#123;</span><br><span class="line">        return items[items.length - 1];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; isEmpty返回栈是否为空</span><br><span class="line">    this.isEmpty &#x3D; function()&#123;</span><br><span class="line">        return items.length &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; size方法返回栈的大小</span><br><span class="line">    this.size &#x3D; function()&#123;</span><br><span class="line">        return items.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; clear 清空栈</span><br><span class="line">    this.clear &#x3D; function()&#123;</span><br><span class="line">        items &#x3D; []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="被欺骗的错觉"><a href="#被欺骗的错觉" class="headerlink" title="被欺骗的错觉"></a>被欺骗的错觉</h3><p>看完上面的实现，难道你没有一种被欺骗的感觉么？传的那么神乎其神的数据结构，这里实现的栈，竟然就只是对数组做了一层封装而已啊！！！</p>
<p>只是做了一层封装么？请思考下面几个问题：</p>
<ul>
<li><p>给你一个数组，你可以通过索引操作任意一个元素，但是给你一个栈，你能操作任意元素么？栈提供的方法只允许你操作栈顶的元素，也就是数组的最后一个元素，这种限制其实提供给我们一种思考问题的方式，这个方式也就是栈的特性，后进先出。</p>
</li>
<li><p>既然栈的底层实现其实就是数组，栈能做的事情，数组一样可以做啊，为什么弄出一个栈来，是不是多此一举？封装是为了隐藏实现细节，站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便，后面的练习题你将有所体会。</p>
</li>
<li><p>既然栈的底层就是对数组的操作，而你平时对数组的使用已经到了非常熟练的程度了，那么请问问自己，为什么就从来都没有自己实现过一个栈呢？是你此前不知道栈的这个概念，还是知道栈的概念但是不知道它有哪些具体方法？不论是哪一种情况，都表明栈对你来说是一个全新的知识，尽管底层的实现是那么的简单，可是越简单就越能说明问题，为啥，你自己就没想出栈这个东西？</p>
</li>
</ul>
<h2 id="栈的应用练习"><a href="#栈的应用练习" class="headerlink" title="栈的应用练习"></a>栈的应用练习</h2><p>通过两个练习题，你或许能够明白我前面所说的站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便。</p>
<h3 id="合法括号"><a href="#合法括号" class="headerlink" title="合法括号"></a>合法括号</h3><ul>
<li>题目要求</li>
</ul>
<p>下面的字符串中包含小括号，请编写一个函数判断字符串中的括号是否合法，所谓合法，就是括号成对出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdf(ds(ew(we)rw)rwqq)qwewe   合法</span><br><span class="line">(sd(qwqw)sd(sd))             合法</span><br><span class="line">()()sd()(sd()fw))(           不合法</span><br></pre></td></tr></table></figure>
<ul>
<li>思路分析</li>
</ul>
<p>括号存在嵌套关系，也存在并列关系，如果是用数组存储这些括号，然后再想办法一对一对的抵消掉，似乎是一个可行的办法，可是如何判断一个左括号对应的是哪个右括号呢？站在数组的肩膀上思考这个问题，就陷入到一种无从下手的绝望之中。</p>
<p>现在，我们站在栈的肩膀上思考这个问题，解题的步骤就非常简单，我们可以使用for循环遍历字符串的每一个字符，对每个字符做如下的操作：</p>
<ul>
<li><p>遇到左括号，就把左括号压如栈中</p>
</li>
<li><p>遇到右括号，判断栈是否为空，为空说明没有左括号与之对应，缺少左括号，字符串括号不合法，如果栈不为空，则把栈顶元素移除，这对括号抵消掉了</p>
</li>
</ul>
<p>当for循环结束之后，如果栈是空的，就说明所有的左右括号都抵消掉了，如果栈里还有元素，则说明缺少右括号，字符串括号不合法。</p>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function is_leagl_brackets(string)&#123;</span><br><span class="line">    var stack &#x3D; new Stack();</span><br><span class="line">    for(var i&#x3D;0; i&lt;string.length; i++ )&#123;</span><br><span class="line">        var item &#x3D; string[i];</span><br><span class="line">        if(item &#x3D;&#x3D; &quot;(&quot;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 将左括号压入栈</span><br><span class="line">            stack.push(item);</span><br><span class="line">        &#125;else if (item&#x3D;&#x3D;&quot;)&quot;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果为空,就说明没有左括号与之抵消</span><br><span class="line">            if(stack.isEmpty())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F; 将栈顶的元素弹出</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return stack.size() &#x3D;&#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(is_leagl_brackets(&quot;()()))&quot;));</span><br><span class="line">console.log(is_leagl_brackets(&quot;sdf(ds(ew(we)rw)rwqq)qwewe&quot;));</span><br><span class="line">console.log(is_leagl_brackets(&quot;()()sd()(sd()fw))(&quot;));</span><br></pre></td></tr></table></figure>
<ul>
<li>小结</li>
</ul>
<p>栈的底层是不是使用了数组这不重要，重要的是栈的这种后进先出的特性，重要的是你只能操作栈顶元素的的限制，一定要忽略掉栈的底层如何实现，而只去关心栈的特性。</p>
<p>我们在编辑文档时，包括写代码，经常进行回退的操作，control+z就可以了，那么你有没有想过，这其实就可以用栈来实现，每一步操作都放入到栈中，当你想回退的时候，就使用pop方法把栈顶元素弹出，于是得到了你之前的一步操作。</p>
<hr>
<h3 id="计算逆波兰表达式"><a href="#计算逆波兰表达式" class="headerlink" title="计算逆波兰表达式"></a>计算逆波兰表达式</h3><ul>
<li>题目要求</li>
</ul>
<p>逆波兰表达式，也叫后序表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式，例如 (a+b)*(c+d)转换为ab+cd+*。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;] 等价于(4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line">[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;] 等价于((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br></pre></td></tr></table></figure>
<p>请编写函数calc_exp(exp) 实现逆波兰表达式计算，exp的类型是数组。</p>
<ul>
<li>思路分析</li>
</ul>
<p>[“4”, “13”, “5”, “/“, “+”] 就是一个数组，在数组层面上思考这个问题，遇到 / 时，把13 和 5 拿出来计算，然后把13 和 5 删除并把结果放入到4的后面，天哪，太复杂了，太笨拙了，我已经无法继续思考了。</p>
<p>如果是使用栈来解决这个问题，一切就那么的自然而简单，使用for循环遍历数组，对每一个元素做如下操作：</p>
<ol>
<li><p>如果元素不是 + - * / 中的某一个，就压入栈中</p>
</li>
<li><p>如果元素是 + - * / 中的某一个，则从栈里连续弹出两个元素，并对这两个元素进行计算，将计算结果压入栈中</p>
</li>
</ol>
<p>for循环结束之后，栈里只有一个元素，这个元素就是整个表达式的计算结果</p>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function calc_exp(arr) &#123;</span><br><span class="line">    var stack &#x3D; new Stack();</span><br><span class="line">    for(var i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i ++) &#123;</span><br><span class="line">        var item &#x3D; arr[i];</span><br><span class="line">        if (~[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;].indexOf(item)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意这里需要用到后序表达式或中序表达式转换一下</span><br><span class="line">            var v1 &#x3D; stack.pop();</span><br><span class="line">            var v2 &#x3D; stack.pop();</span><br><span class="line">            var exp_res &#x3D; parseInt(eval(v2 + item + v1));</span><br><span class="line">            stack.push(exp_res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stack.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;-----------------------------------------&quot;);</span><br><span class="line">console.log(calc_exp([&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;])); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>
<h3 id="课后练习题"><a href="#课后练习题" class="headerlink" title="课后练习题"></a>课后练习题</h3><ul>
<li>实现一个有min方法的栈</li>
</ul>
<p>实现一个栈，除了常见的push，pop方法以外，提供一个min方法，返回栈里最小的元素，且时间复杂度为o(1)</p>
<ul>
<li>思路分析</li>
</ul>
<p>使用两个栈来存储数据，其中一个命名为data_stack,专门用来存储数据，另一个命名为min_stack，专门用来存储栈里最小的数据。</p>
<p>注意了，我接下来的分析过程非常重要，我希望你能多阅读几遍。</p>
<ol>
<li><p>我们要实现的是一个栈，除了常规的方法，还要有一个min方法，data_stack就是专门为常规方法而存在的，min_stack就是为了这个min方法而存在的。</p>
</li>
<li><p>编程思想里有一个分而治之的思想，简单来说，就是分开想，分开处理。那么我们现在考虑data_stack，这个时候别管min方法，你就只关心data_stack，它就是一个普通的栈啊，没什么特别的，一个简单的栈你还不会么，就是push，pop那些方法，正常实现就可以了。</p>
</li>
<li><p>data_stack处理完了以后，再考虑min_stack，这个时候，你就别想data_stack了，只关心min_stack，它要存储栈里的最小值，我们先考虑边界情况，如果min_stack为空，这个时候，如果push进来一个数据，那这个数据一定是最小的，所以此时，直接放入min_stack即可。如果min_stack不为空，这个时候它的栈顶不正是栈的最小元素么，如果push进来的元素比栈顶元素还小，放入min_stack就好了，这样，min_stack的栈顶始终都是栈里的最小值。</p>
</li>
</ol>
<ul>
<li>示例代码:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MinStack() &#123;</span><br><span class="line">    var data_stack &#x3D; new Stack();</span><br><span class="line">    var min_stack &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">    this.push &#x3D; function(item) &#123;</span><br><span class="line">        data_stack.push(item);</span><br><span class="line"></span><br><span class="line">        if (min_stack.isEmpty() || min_stack.top &gt; item) &#123;</span><br><span class="line">            min_stack.push(item);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            min_stack.push(min_stack.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.pop &#x3D; function() &#123;</span><br><span class="line">        min_stack.pop();</span><br><span class="line">        return data_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    this.get &#x3D; function() &#123;</span><br><span class="line">        return data_stack.get();</span><br><span class="line">    &#125;</span><br><span class="line">    this.min &#x3D; function() &#123;</span><br><span class="line">        return min_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var minstack &#x3D; new MinStack();</span><br><span class="line">minstack.push(3);</span><br><span class="line">minstack.push(6);</span><br><span class="line">minstack.push(8);</span><br><span class="line">console.log(minstack.get()); &#x2F;&#x2F; [3, 6, 8]</span><br><span class="line">console.log(minstack.min()); &#x2F;&#x2F; 3</span><br><span class="line">minstack.push(2);</span><br><span class="line">console.log(minstack.min()); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<h3 id="使用栈，完成中序表达式转后序表达式"><a href="#使用栈，完成中序表达式转后序表达式" class="headerlink" title="使用栈，完成中序表达式转后序表达式"></a>使用栈，完成中序表达式转后序表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]</span><br><span class="line">输出:[&quot;12&quot;,&quot;3&quot;,&quot;+&quot;]</span><br><span class="line"></span><br><span class="line">输入:[&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,</span><br><span class="line">&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;]</span><br><span class="line">输出:[ &#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;9&#39;, &#39;8&#39;, &#39;+&#39;, &#39;+&#39; ]</span><br><span class="line"></span><br><span class="line">输入:[&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;,</span><br><span class="line">&#39;)&#39;, &#39;&#x2F;&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]</span><br><span class="line">输出:[&#39;1&#39;, &#39;4&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;+&#39;, &#39;4&#39;,</span><br><span class="line">&#39;&#x2F;&#39;, &#39;+&#39;, &#39;3&#39;, &#39;-&#39;, &#39;6&#39;, &#39;8&#39;, &#39;+&#39;, &#39;3&#39;, &#39;*&#39;, &#39;+&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li>思路分析</li>
</ul>
<p>定义数组postfix_lst，用于存储后序表达式，遍历中序表达式，对每一个遍历到的元素做如处理:</p>
<ol>
<li><p>如果是数字,直接放入到postfix_lst中</p>
</li>
<li><p>遇到左括号入栈</p>
</li>
<li><p>遇到右括号,把栈顶元素弹出并放入到postfix_lst中,直到遇到左括号，最后弹出左括号</p>
</li>
<li><p>遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符， 把弹出的运算符加入到postfix_lst，当前的运算符入栈</p>
</li>
<li><p>for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义运算符的优先级</span><br><span class="line">var priority_map &#x3D; &#123;</span><br><span class="line">    &quot;+&quot;: 1,</span><br><span class="line">    &quot;-&quot;: 1,</span><br><span class="line">    &quot;*&quot;: 2,</span><br><span class="line">    &quot;&#x2F;&quot;: 2&#125;;</span><br><span class="line"></span><br><span class="line">function infix_exp_2_postfix_exp(exp)&#123;</span><br><span class="line">    var stack &#x3D; new Stack();</span><br><span class="line"></span><br><span class="line">    var postfix_lst &#x3D; [];</span><br><span class="line">    for(var i &#x3D; 0;i&lt;exp.length;i++)&#123;</span><br><span class="line">        var item &#x3D; exp[i];</span><br><span class="line">        &#x2F;&#x2F; 如果是数字,直接放入到postfix_lst中</span><br><span class="line">        if(!isNaN(item))&#123;</span><br><span class="line">            postfix_lst.push(item);</span><br><span class="line">        &#125;else if (item &#x3D;&#x3D; &quot;(&quot;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 遇到左括号入栈</span><br><span class="line">            stack.push(item);</span><br><span class="line">        &#125;else if (item &#x3D;&#x3D; &quot;)&quot;)&#123;</span><br><span class="line">            &#x2F;&#x2F; 遇到右括号,把栈顶元素弹出,直到遇到左括号</span><br><span class="line">            while(stack.top() !&#x3D; &quot;(&quot;)&#123;</span><br><span class="line">                postfix_lst.push(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();   &#x2F;&#x2F; 左括号出栈</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符</span><br><span class="line">            while(!stack.isEmpty() &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;&#x2F;&quot;].indexOf(stack.top()) &gt;&#x3D; 0 &amp;&amp; priority_map[stack.top()] &gt;&#x3D; priority_map[item])&#123;</span><br><span class="line">                &#x2F;&#x2F; 把弹出的运算符加入到postfix_lst</span><br><span class="line">                postfix_lst.push(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 当前的运算符入栈</span><br><span class="line">            stack.push(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中</span><br><span class="line">    while(!stack.isEmpty()) &#123;</span><br><span class="line">        postfix_lst.push(stack.pop())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return postfix_lst</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 12+3</span><br><span class="line">console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;]))</span><br><span class="line">&#x2F;&#x2F; 2-3+2</span><br><span class="line">console.log(infix_exp_2_postfix_exp([&quot;2&quot;,&quot;-&quot;, &quot;3&quot;, &quot;+&quot;, &quot;2&quot;]))</span><br><span class="line">&#x2F;&#x2F; (1+(4+5+3)-3)+(9+8)</span><br><span class="line">var exp &#x3D; [&quot;(&quot;,&quot;1&quot;,&quot;+&quot;,&quot;(&quot;,&quot;4&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;,&quot;3&quot;,&quot;)&quot;,&quot;-&quot;,&quot;3&quot;,&quot;)&quot;,&quot;+&quot;,&quot;(&quot;,&quot;9&quot;,&quot;+&quot;,&quot;8&quot;,&quot;)&quot;];</span><br><span class="line">console.log(infix_exp_2_postfix_exp(exp))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (1+(4+5+3)&#x2F;4-3)+(6+8)*3</span><br><span class="line">var exp &#x3D; [&#39;(&#39;, &#39;1&#39;, &#39;+&#39;, &#39;(&#39;, &#39;4&#39;, &#39;+&#39;, &#39;5&#39;, &#39;+&#39;, &#39;3&#39;, &#39;)&#39;, &#39;&#x2F;&#39;, &#39;4&#39;, &#39;-&#39;, &#39;3&#39;, &#39;)&#39;, &#39;+&#39;, &#39;(&#39;, &#39;6&#39;, &#39;+&#39;, &#39;8&#39;, &#39;)&#39;, &#39;*&#39;, &#39;3&#39;]</span><br><span class="line">console.log(infix_exp_2_postfix_exp(exp))</span><br><span class="line"></span><br><span class="line">console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;+&quot;, &quot;3&quot;,&quot;*&quot;, &quot;5&quot;]))</span><br><span class="line">console.log(infix_exp_2_postfix_exp([&quot;12&quot;,&quot;*&quot;, &quot;3&quot;,&quot;+&quot;, &quot;5&quot;]))</span><br></pre></td></tr></table></figure>
<ul>
<li>算法思路推理过程</li>
</ul>
<p>推理的过程要从简入繁，先考虑最简单的情况</p>
<ul>
<li>只有一个运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序: 1 + 2</span><br><span class="line">后序: 1 2 +</span><br></pre></td></tr></table></figure>
<p>后序表达式，数值在前，操作符在后，因此，遇到数值时直接放入到后序表达式中。将操作符放入栈中，等到中序表达式遍历结束后，将栈里的操作符弹出放入到后序表达式中</p>
<ul>
<li>多个运算符，栈顶操作符优先级和当前运算符相同</li>
</ul>
<p>多个运算符，似乎也可以像第一步推理中那样操作，但实际不行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序: 1 + 2 - 3</span><br><span class="line">后序: 1 2 + 3 -</span><br></pre></td></tr></table></figure>
<p>每次遇到操作符时，如果栈里有操作符，说明前面有需要计算的数值，且计算的操作符就在栈顶，应该弹出放入到后缀表达式中，如果都等到中缀表达式结束再弹出，就会变成 1 2 3 + -</p>
<p>就本示例而言，遇到减号时，后缀表达式里是 1 2 ，栈里是+，1和2需要计算，进行计算的操作符就在栈顶，因此需要弹出，放入到后缀表达式，之后减号入栈，中缀表达式遍历结束后，后缀表达式是 1 2 + 3， 栈里是-，将栈里的操作符去全部弹出，放入到后缀表达式，最终结果为 1 2 + 3 -。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序: 1 * 2 + 3</span><br><span class="line">后序: 1 2 * 3 +</span><br></pre></td></tr></table></figure>
<p>栈顶运算符优先级高，和第2步的分析一致，前面有需要计算的数值，应该弹出放入到后缀表达式中</p>
<ul>
<li>多个运算符，栈顶操作符优先级大于当前运算符相同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序: 1 + 2 * 3</span><br><span class="line">后序: 1 2 3 * +</span><br></pre></td></tr></table></figure>
<p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p>
<ul>
<li>多个运算符，栈顶操作符优先级小于当前运算符相同</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序: 1 + 2 * 3</span><br><span class="line">后序: 1 2 3 * +</span><br></pre></td></tr></table></figure>
<p>栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算</p>
<ul>
<li>有括号的情况</li>
</ul>
<p>括号里的的表达式可以视为一个独立的中缀表达式，因此，前面4步的分析都适用，但是括号里的中缀表达式在一个更大的表达式中，因此需要与其他部分分隔，分隔的方法就是遇到小括号后压栈，此后的操作遵循前面的推理逻辑，当遇到右括号时，说明括号内的表达式结束了，根据第一步的分析，应该把所有属于这个括号内表达式的操作符都弹出来放入到后缀表达式，最后一步弹出左括号。</p>
<p><strong>还在学习ing…，学习后再补充</strong></p>
<h1 id="数据结构之—-队列"><a href="#数据结构之—-队列" class="headerlink" title="数据结构之—-队列"></a>数据结构之—-队列</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><h3 id="数据存储-1"><a href="#数据存储-1" class="headerlink" title="数据存储"></a>数据存储</h3><h3 id="队列的方法"><a href="#队列的方法" class="headerlink" title="队列的方法"></a>队列的方法</h3><ul>
<li>enqueue方法</li>
<li>dequeue方法</li>
<li>head方法</li>
<li>size方法</li>
<li>clear方法</li>
<li>isEmpty方法</li>
<li>tail方法<h2 id="队列的应用练习"><a href="#队列的应用练习" class="headerlink" title="队列的应用练习"></a>队列的应用练习</h2><h3 id="约瑟夫环（普通模式）"><a href="#约瑟夫环（普通模式）" class="headerlink" title="约瑟夫环（普通模式）"></a>约瑟夫环（普通模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码<h3 id="斐波那契数列（普通模式）"><a href="#斐波那契数列（普通模式）" class="headerlink" title="斐波那契数列（普通模式）"></a>斐波那契数列（普通模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码</li>
<li>小结<h3 id="用队列实现栈（困难模式）"><a href="#用队列实现栈（困难模式）" class="headerlink" title="用队列实现栈（困难模式）"></a>用队列实现栈（困难模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>代码示例<h3 id="打印杨辉三角（困难模式）"><a href="#打印杨辉三角（困难模式）" class="headerlink" title="打印杨辉三角（困难模式）"></a>打印杨辉三角（困难模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码<h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="用两个栈实现一个队列（普通模式）"><a href="#用两个栈实现一个队列（普通模式）" class="headerlink" title="用两个栈实现一个队列（普通模式）"></a>用两个栈实现一个队列（普通模式）</h3></li>
<li>思路分析</li>
<li>思路分析<h3 id="迷宫问题（地狱模式）"><a href="#迷宫问题（地狱模式）" class="headerlink" title="迷宫问题（地狱模式）"></a>迷宫问题（地狱模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码<h1 id="数据结构之—-链表"><a href="#数据结构之—-链表" class="headerlink" title="数据结构之—-链表"></a>数据结构之—-链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h3 id="首尾节点"><a href="#首尾节点" class="headerlink" title="首尾节点"></a>首尾节点</h3><h3 id="有头链表和无头链表"><a href="#有头链表和无头链表" class="headerlink" title="有头链表和无头链表"></a>有头链表和无头链表</h3><h3 id="猴子捞月"><a href="#猴子捞月" class="headerlink" title="猴子捞月"></a>猴子捞月</h3><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="定义链表类"><a href="#定义链表类" class="headerlink" title="定义链表类"></a>定义链表类</h3><h3 id="链表的方法"><a href="#链表的方法" class="headerlink" title="链表的方法"></a>链表的方法</h3></li>
<li>append方法</li>
<li>print方法</li>
<li>insert方法</li>
<li>remove方法</li>
<li>get方法</li>
<li>indexOf方法<h2 id="基于链表实现的Stack-和-Queue"><a href="#基于链表实现的Stack-和-Queue" class="headerlink" title="基于链表实现的Stack 和 Queue"></a>基于链表实现的Stack 和 Queue</h2><h2 id="链表常见面试题"><a href="#链表常见面试题" class="headerlink" title="链表常见面试题"></a>链表常见面试题</h2><h3 id="翻转链表（困难模式）"><a href="#翻转链表（困难模式）" class="headerlink" title="翻转链表（困难模式）"></a>翻转链表（困难模式）</h3></li>
<li>题目要求</li>
<li>迭代翻转思路分析</li>
<li>递归翻转链表思路分析<h3 id="从尾到头打印链表（普通模式）"><a href="#从尾到头打印链表（普通模式）" class="headerlink" title="从尾到头打印链表（普通模式）"></a>从尾到头打印链表（普通模式）</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码<h3 id="合并两个两个有序链表-困难模式"><a href="#合并两个两个有序链表-困难模式" class="headerlink" title="合并两个两个有序链表(困难模式)"></a>合并两个两个有序链表(困难模式)</h3></li>
<li>题目要求</li>
<li>思路分析</li>
<li>示例代码<h2 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h2><h3 id="查找单链表中的倒数第K个节点（k-gt-0）（普通模式）"><a href="#查找单链表中的倒数第K个节点（k-gt-0）（普通模式）" class="headerlink" title="查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）"></a>查找单链表中的倒数第K个节点（k &gt; 0）（普通模式）</h3><h3 id="查找单链表的中间结点（普通模式）"><a href="#查找单链表的中间结点（普通模式）" class="headerlink" title="查找单链表的中间结点（普通模式）"></a>查找单链表的中间结点（普通模式）</h3><h3 id="实现双向链表（地狱模式）"><a href="#实现双向链表（地狱模式）" class="headerlink" title="实现双向链表（地狱模式）"></a>实现双向链表（地狱模式）</h3><h1 id="数据结构之—-BitMap"><a href="#数据结构之—-BitMap" class="headerlink" title="数据结构之—-BitMap"></a>数据结构之—-BitMap</h1><h2 id="一个简单的问题"><a href="#一个简单的问题" class="headerlink" title="一个简单的问题"></a>一个简单的问题</h2><h3 id="毫无难度的实现"><a href="#毫无难度的实现" class="headerlink" title="毫无难度的实现"></a>毫无难度的实现</h3><h3 id="更快的方法"><a href="#更快的方法" class="headerlink" title="更快的方法"></a>更快的方法</h3><h3 id="更节省空间的算法"><a href="#更节省空间的算法" class="headerlink" title="更节省空间的算法"></a>更节省空间的算法</h3><h2 id="街边的路灯"><a href="#街边的路灯" class="headerlink" title="街边的路灯"></a>街边的路灯</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><h3 id="新的实现方式"><a href="#新的实现方式" class="headerlink" title="新的实现方式"></a>新的实现方式</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="大数据排序"><a href="#大数据排序" class="headerlink" title="大数据排序"></a>大数据排序</h3><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><h3 id="BoolmFilter-类"><a href="#BoolmFilter-类" class="headerlink" title="BoolmFilter 类"></a>BoolmFilter 类</h3></li>
<li>操作二进制位</li>
<li>add方法</li>
<li>isExist方法<h2 id="课后练习题-1"><a href="#课后练习题-1" class="headerlink" title="课后练习题"></a>课后练习题</h2><h3 id="两个集合取交集（普通模式）"><a href="#两个集合取交集（普通模式）" class="headerlink" title="两个集合取交集（普通模式）"></a>两个集合取交集（普通模式）</h3></li>
<li>示例代码<h3 id="支持负数（困难模式）"><a href="#支持负数（困难模式）" class="headerlink" title="支持负数（困难模式）"></a>支持负数（困难模式）</h3></li>
<li>思路分析</li>
<li>示例代码<h3 id="查找不重复的数（地狱模式）"><a href="#查找不重复的数（地狱模式）" class="headerlink" title="查找不重复的数（地狱模式）"></a>查找不重复的数（地狱模式）</h3></li>
<li>思路分析</li>
<li>示例代码<h1 id="数据结构之—-树"><a href="#数据结构之—-树" class="headerlink" title="数据结构之—-树"></a>数据结构之—-树</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2>###结构<br>###节点<br>###节点的度<br>###叶节点<br>###分支节点<br>###子女节点<h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><h3 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h3><h3 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h3><h3 id="节点所在层次"><a href="#节点所在层次" class="headerlink" title="节点所在层次"></a>节点所在层次</h3><h3 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h3><h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><h3 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h3><h3 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h3><h3 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h3><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3></li>
<li>满二叉树</li>
<li>完全二叉树<h3 id="二叉树的类定义"><a href="#二叉树的类定义" class="headerlink" title="二叉树的类定义"></a>二叉树的类定义</h3></li>
<li>定义节点</li>
<li>定义二叉树类</li>
<li>init_tree</li>
<li>in_order 中序遍历算法</li>
<li>pre_order 前序遍历算法</li>
<li>post_order 后序遍历算法</li>
<li>size 返回节点数量</li>
<li>height 返回树的高度</li>
<li>查找节点<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3></li>
<li>求一棵树的镜像(普通模式)<ul>
<li>思路分析</li>
<li>示例代码</li>
</ul>
</li>
<li>使用非递归方式实现前序遍历<ul>
<li>思路分析</li>
<li>示例代码<h3 id="课后练习题-2"><a href="#课后练习题-2" class="headerlink" title="课后练习题"></a>课后练习题</h3></li>
</ul>
</li>
<li>使用非递归方式实现中，后两种遍历方法（普通模式+）</li>
<li>寻找两个节点的最近公共祖先（困难模式）</li>
<li>分层打印二叉树（困难模式+）</li>
<li>输出指定层的节点个数（困难模式+）</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>理顺react，flux，redux这些概念的关系</title>
    <url>/2017/12/06/%E7%90%86%E9%A1%BAreact%EF%BC%8Cflux%EF%BC%8Credux%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<blockquote>
<p>该文以浅显、通俗易懂的语言解释了react、flux、redux的概念以及它们的关系，对充分理解这些概念并灵活运用有很大的帮助。</p>
</blockquote>
<a id="more"></a>

<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这是关于一把玄铁重剑，一本经书，和一套轻功步法的故事。</p>
<p>让我们先从普通程序猿们的日常工作内容说起，</p>
<p>一般来说，程序猿们大部分时间关注的可能不是研发某个具体算法，这是算法工程师／数学家们擅长的东东。程序猿的工作主要是通过调用编程环境中现成的工具函数或接口来实现具体的应用功能，将各个底层接口或算法模块用代码有秩序地拼装联接起来，实现酷炫好用的产品功能，如同组装一件乐高玩具一样。</p>
<p><img src="https://i.imgur.com/fQVKEkr.jpg"></p>
<p>也就是说程序猿的很多工作往往不是围绕某个高大上的具体算法（“我们不生产算法，我们只是算法的搬运工”），而是像代码界的城管、或者清洁工一样，关注怎样组织文件结构，怎样理清编程思路，怎样命名变量，怎样降低代码耦合度，怎样提高代码的复用性和一致性，提高代码的可读性和健壮性，怎样优化分工协作、减少沟通成本等等。不管是OOP、FP等编程思想，还是MVC等设计模式、或是各种编程语言下的应用开发框架，很多都是为了帮助程序猿完成这些脏活、累活儿。</p>
<p>具体到web应用开发而言，react以及他的好基友redux都是程序猿们出色的好帮手，因此让众多前端开发者一见倾心，俺也不例外。</p>
<p><img src="https://i.imgur.com/q92eyWh.jpg"></p>
<p>和一般前端框架相比，react有两个显著特点：</p>
<ol>
<li>react的性能很好，可以满足实际生产环境下的绝大部分性能需求。</li>
<li>react从使用的角度来说非常轻量级，因此很容易和其他顺手常用的工具搭配使用，而没有任何违和感。（如果你发现react可以和backbone、angular等框架很轻松地放到一起使用，请保持高冷，无需惊讶～）</li>
</ol>
<p>事实上，react和redux从使用的角度来说，是如此轻量舒适，以至于我们可以不把它们当作“开发框架”，而是一种编程模式，或是编程的“脚手架”，用起来非常“小清新”。这一点和angularjs这类“重口味”框架有很大区别（我不推荐使用angularjs，当然每个人口味不同，最好自己上手体验再做取舍）。其实本人接触react比较晚，但一试用就有种血槽猛涨的感觉，强烈建议还没上手react的前端程序猿们试用一下！</p>
<p><img src="https://i.imgur.com/WJw7XZA.jpg"></p>
<p>其实，关于react的具体开发实践，知乎上已有很多优秀的文章，例如[react 有哪些最佳实践? - 前端开发]，不再赘述。这里只想分享一下我在学习react过程中的一点体会，捋一下react以及flux背后思想的来龙去脉，从而能够让大家更加自然地接受react开发模式。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们首先举两个栗子：</p>
<h2 id="江湖旧事1"><a href="#江湖旧事1" class="headerlink" title="江湖旧事1"></a>江湖旧事1</h2><p>在web1.0的纯网页时代，前端开发其实是比较happy的，这是因为网页上几乎不需要什么交互，前端开发者基本上只需要根据后台提供的数据将网页内容排版呈现出来即可。用户的交互行为一般仅限于填写一个表单，然后把数据提交到服务器，提交成功后，<strong>直接刷新整个页面</strong>。</p>
<p>我们以常见的todoList为例，当需要添加一条todo任务的时候，用web1.0的思路，典型的流程是这样的：</p>
<p><img src="https://i.imgur.com/IANGtbc.png"></p>
<p>通过这张图，我们再仔细揣摩一下为什么web1.0条件下前端开发是比较轻松的：这是因为所有和数据（大体上等价于state）相关的操作，都已经由服务器完成了，前端开发只需要根据state来决定view（页面）。也就是说，这个时候前端开发者的思维是一个从state到view的<strong>“单向流”</strong>。（当state变化时，只要简单粗暴地整体刷新页面就OK了。）</p>
<p>然而，当页面交互变得丰富细腻、内容变得庞大复杂之后，这种基于服务器维护state，然后页面整体刷新的web1.0方式存在两个严重的缺陷：</p>
<ol>
<li><p>反复刷新页面，尤其是内容复杂的页面，对浏览器的渲染性能消耗很大。一个很小的局部交互动作，就会引起整个页面的刷新，显然对于浏览器性能是非常大的浪费。同时，由于页面刷新，导致不必要的等待和“闪屏”，这些对于有节操的产品汪或者程序猿都是难以容忍的。<br>由交互产生的很多细腻的前端数据，其实也很难交给后台处理，因为这是我们无处安放的临时状态。例如一个菜单是收起还是打开，一个面板是隐藏还是弹出，如果前端不去记录这些view对应的状态，那么后台就要记录这些状态，否则页面刷新后，这些状态信息就会丢失。即使我们不在乎页面和服务器之间通信的时间浪费，我们也很难想象有什么理由要在服务器上记录这些只和view相关的临时状态，毕竟这些状态不对应任何后台业务数据。</p>
</li>
<li><p>正是由于这两个显著缺陷，才导致ajax技术的出现。自从有了ajax通信和局部页面更新的机制以后，妈妈再也不用担心我们页面整体刷新导致的用户体验问题了！于是前端开发大踏步地进入web2.0时代，大量交互细腻，内容丰富的SPA（single page application）也应运而生。但与此同时，前端开发的工作也从此变得苦逼起来。。。因为现在根据后台数据排版生成页面，现在只是最基本的工作。当用户进行某种交互操作引起页面状态变化之后，为了避免页面整体刷新，我们需要小心翼翼地将各个相关的页面局部元素拣选出来，做适当修改，再放回原处，动作一般不会太优雅。（脑补一下《加勒比海盗》中，把眼球拿出来擦一擦又塞回去的那个海盗。。）</p>
</li>
</ol>
<p>当页面逻辑简单，交互行为较少时，这种局部修改也许很容易搞定；然而，一旦页面中各个元素的关系变得复杂，各种交互操作耦合起来之后，这种局部修改就会消耗大量脑细胞，并且我们需要同时对用户操作和服务器反馈做出响应，并确保页面状态和服务器状态的一致性，于是我们就很容易变得左支右绌、顾此失彼。相信不少前端工程师都有过类似的体验。</p>
<p>总之，从上面的例子我们得出两个经验：</p>
<ol>
<li><p>根据确定的交互状态（state），一股脑儿决定页面的呈现（view），这种“单向流”的开发状态对程序员来说是思维清晰、比较轻松的；一旦我们需要不断手动更新view，并且改变state和view的代码还纠缠在一起，我们的内心往往是崩溃的。</p>
</li>
<li><p>为了让前端开发不感到崩溃，就把所有state交给后台来维护，简单粗暴地通过重新加载页面来实现view的更新是不靠谱的（后台的内心独白：我招谁惹谁了啊！！），我们需要找到新的方法，来实现view的自动更新。</p>
</li>
</ol>
<h2 id="江湖旧事2"><a href="#江湖旧事2" class="headerlink" title="江湖旧事2"></a>江湖旧事2</h2><p>其实，通过改变state，来让view自动更新，这个想法一点也不新鲜。css中各种基于className的样式声明，就是典型代表（改变div的className相当于改变它对应的state， 尤其是css3引入transition和animation之后，这种用css来偷懒的做法越来越常见），我们再举个例子，比如说我们要做一个菜单：</p>
<p><img src="https://i.imgur.com/0AzxrRq.png"></p>
<p>生手碰到这个问题，也许会这样做：<br>当用户点击按钮的时候，先改变菜单名的色值，再改变按钮的背景图（由向下箭头，改成向上箭头），最后改变下拉列表的显示状态，有必要的话，还需要做个列表下拉的动画。当用户再次点击按钮的时候，把所有操作倒着来一遍，恢复菜单收起的状态，ok？</p>
<p>然而，对于好逸恶劳的前端老司机们来说，一般会这样做：对整个菜单的容器定义两个className，比如一个是”menu-close”，一个是“menu-open”。在menu-close的状态下，菜单名的色值为黑色，按钮背景图为向下箭头，下拉列表是隐藏状态；在menu-open的状态下，菜单名的色值为白色，按钮背景图是向上箭头，下拉列表是显示状态；需要的话，再用css3 transition给下拉列表加个动画过渡效果。当用户点击按钮的时候，只需要改变整个菜单容器的className即可。所有的交互效果都用css“平铺”的方式声明出来，这样做不仅节省了多个手工步骤，而且更改整个容器的className是个单点操作，因此也方便维护和修改。这也是bootstrap框架里惯用的一招，非常好使。</p>
<p><strong>通过这个例子，我们看到“改变state，让view自动更新”的开发思想在纯粹的前端领域也由来已久。它可以让开发者思维更加清晰，代码更好维护，幸福指数飙升！</strong></p>
<p>然而用css className来实现state功能，其应用范围是非常有限的。原因很简单，css只能改变DOM元素的样式，却不能改变网页中DOM tree本身的结构（例如，例子1中todoList的增删操作就涉及li元素的append或者remove），更没有办法直接和具体的业务数据相关联。于是，knockoutjs、angularjs等前端框架纷纷登场，这些框架可以系统地实现view 和 state（一般在这些框架里称为ViewModel）的相互绑定，从而使代码更有秩序，帮前端开发省去不少麻烦。即便这些框架约定很多，有些束手束脚的感觉，但如果没有另一件大杀器重出江湖，程序猿们也可以将就过了，奈何既生瑜，何生亮。。这是后话。</p>
<h2 id="重剑无锋"><a href="#重剑无锋" class="headerlink" title="重剑无锋"></a>重剑无锋</h2><p>好，抛开knockout、angular这些框架，现在如果让我们自己设计一套根据states（包括后台业务数据和前端临时数据，例如表单input值、某个面板的显隐状态等等）自动更新页面的机制，我们该怎么办呢？</p>
<p>对于每一种特定场景，我们也许有很多种代码方式来根据state自动更新页面的某个局部view。但是，如果页面交互足够复杂，以至于我们需要在页面的很多地方不断修修补补，并且这些“补丁”对应的state可能还彼此重叠，或者我们希望能一劳永逸地解决所有view自动更新的问题，并且还不引入更多繁琐的约定，似乎除了刷新整个页面没有更好的办法（这有点像逐帧动画的原理，我们一般不会真的根据物体运动轨迹一点一点修改画面，形成运动效果，而是直接一帧一帧*重绘整个画布，形成动画效果！）</p>
<p>但前面我们说过，像web1.0的做法一样，重绘整个页面对浏览器的性能损耗是很严重的，用户体验也很糟糕。。怎么办？怎么办？！我脑补着facebook的某个程序员在一个月黑风高的晚上坐在公司电脑前，抿了一口浓浓的咖啡，突然灵光一现，伴着屏幕上忽明忽暗的幽幽蓝光，在文本编辑器里写下这么一行文字：<strong>可不可以把浏览器里的DOM tree克隆一份完整的镜像到内存，也就是所谓的“virtual DOM”，当页面的state发生变化以后，根据最新的state重新生成一份virtual DOM（相当于在内存里“刷新”整个页面），将它和之前的virtual DOM做比对（diff），然后在浏览器里只渲染被改变的那部分内容，这样浏览器的性能损耗和用户体验不就都不成问题了吗？</strong>而我们知道在绝大部分网页应用中js引擎的性能和内存完全没有被充分利用，我们正好可以火力全开，利用js的这部分性能红利，实现内存中virtual DOM的diff工作，完美！</p>
<p>于是React横空出世。</p>
<p>话虽简单，不过单单是在内存中模拟整个DOM tree，这个工作想想就觉得头大，所以不得不佩服facebook的那些前端大神们！表面上react花了很大气力却只做了view层跟virtual DOM相关的工作，但所谓“大巧不工、重剑无锋”，实际上facebook祭出的这件大杀器让<strong>“改变state，view自动更新”</strong>这种直观朴素的想法有了坚实的基础，“state-view”的开发模式从此一马平川！正因为如此，伴随着react的崛起，类似于redux这些专注于管理state的轻量级框架也变得炙手可热起来。</p>
<p>有了React这把重剑，前端开发们第一次感觉到似乎又回到了web1.0美好的田园时代！而react非常具有表达力的jsx语法和完善的模块化结构，又让我们觉得像生活在酷炫的未来时代！这是我们的下一话题。（ 此处应有《Back to The Future》的电影配乐）</p>
<h2 id="庖丁解牛（view的模块化）"><a href="#庖丁解牛（view的模块化）" class="headerlink" title="庖丁解牛（view的模块化）"></a>庖丁解牛（view的模块化）</h2><p>view的组件化和模块化非常有利于分工协作、代码的积累复用以及单元测试。这对于提高团队开发的效率无疑具有非常重要的意义，这也是react广受青睐的重要原因之一，这一点就不再赘述。这里想换个角度，聊一下react的模块化机制，对于开发者个体来说有什么好处？</p>
<p>前面我们提到，由于React的“state-view”模式可以让开发者的大脑得到一种<strong>“单向流</strong>”的舒适体验。那为什么单向流的思维状态更加舒适呢？</p>
<p>这是因为在单向流状态下，要解决的问题如同一个函数映射，已知什么（比如state）是固定不变的，要得到什么（比如view）是定义明确，而人的思维非常习惯于这种定义明确的、没有“分叉”和“环路”的函数式问题。</p>
<p>也就是说，让人抓狂崩溃的往往是那些包含“分叉”或“环路”的非函数式问题，这个时候大脑不得不思前想后，谋划全局，进入一种“多线程”工作状态，而“单线程”作业对于大脑来说一般才是更加轻松高效。所谓“单线程”，就是每时每刻只专注于一个问题 —— one at a time! React的”state-view”模式帮助我们在开发view的时候，只需要专注于view（即关注页面布局样式。view上的交互行为怎样对state产生反馈作用，我们稍后再来讨论），而React简便的“模块化”机制（即只需要写很少量的boilerplate代码，就可以定义或引用一个新模块），让我们可以根据需要，将整个页面的布局样式工作进一步拆分成各个小模块（view component），或者将各个小模块组装成大模块，从而进一步深入贯彻“one at a time”的原则，给大脑减负，因此这时程序猿很容易进入一种舒适高效的状态（心理学中甚至有个<strong>“心流”</strong>的概念用来描述这种状态）。决定页面呈现的state可以通过模块属性（props）从父模块传递到子模块。这种”树状”分流机制，有点像植物将养分（state）从根部不断运输到细枝末叶的过程，如图所示：</p>
<p><img src="https://i.imgur.com/1EYvCHx.jpg"></p>
<p>简便的“模块化”机制客观上鼓励了迅速上手、边走边看的敏捷开发方式。也就是说，前端开发者在做页面布局样式工作的时候，可以根据自己的经验或视角，随意挑选一块比较“容易上手”的区域作为一个模块的出发点，迅速开工，而无需事先瞻前顾后、谋划全局。当挑选的区域中，有某一块内容需要仔细打磨、细化功能的时候，我们可以迅速将这块内容拆分为一个子模块，然后专注于这个子模块的开发，当若干模块开发完毕后，我们也可以将各个模块组装成大模块，最终形成整个页面。这种开发体验，有点像拼乐高或者创作雕塑：比如说我们要做一个人物雕塑群，我们可以先从单个人物开始。当我们在做单个人物的时候，我们可以先粗线条地捏出整体形态，在需要的时候，我们可以换用更称手的工具来雕琢细节，比如人物的五官表情或者衣服的褶皱，如果一上来我们需要谋划雕塑群中每一个人物的每一个表情细节才能开工，显然这个任务是很难完成的。</p>
<p>好，到目前为止，我们看到react已经几乎完美地帮我们理顺了从state到view的开发流程。但是前面的讨论过程中，似乎还有一朵“小乌云”没清理，那就是怎样实现从view到state的反馈流程。也就是说，用户在view上的交互行为（比如点击提交按钮等）应当引起state改变的时候，这个流程该怎么处理？这是我们要聊的下一话题。</p>
<h2 id="易筋经（flux思想）"><a href="#易筋经（flux思想）" class="headerlink" title="易筋经（flux思想）"></a>易筋经（flux思想）</h2><ol>
<li>几点说明</li>
</ol>
<p>如果要用一门武林绝学比喻flux思想，我首先想到的是易筋经。此功虽无固定招式，但意会之后，就会有种打通全身经络、气血通畅的感觉，并且可以将前端开发中的其他武功串联起来，运用自如 : )</p>
<p>关于flux首先有几点需要说明：</p>
<p>flux与react没有直接的关系，二者是完全独立的概念。<br>flux不是一个js库，而是一种前端代码的组织思想，比如说redux库可以认为是一种flux思想的实现。<br>flux的核心思想和代码实现虽然很简单（基本上就是一个event dispatcher而已），但在“state-view”开发模式中，却是非常重要的一个环节，所以facebook给这个思想特意起了这么一个“高大上”的名字。</p>
<ol start="2">
<li>MVC模式</li>
</ol>
<p>在讲flux之前，我们不得不首先提一下大名鼎鼎的MVC开发模式。</p>
<p>所谓MVC开发模式, 主要讲的是在开发交互应用时，怎样将不同功能的代码拆分到不同文件或区块，以便降低代码的耦合度，提高代码的可读性和健壮性。<strong>简单理解就是：要将 Model-View-Controller 这三部分代码拆分到不同文件。</strong></p>
<p>对于服务器端开发，Model指的是和处理业务数据相关的代码，例如通过ORM实现数据库的增删改查等操作；View指的是和页面组装相关的代码，主要是和各种模版引擎（例如Java Velocity、PHP Smarty、nodejs ejs等等）相关的代码部分；Controller指的是和用户交互行为相关的代码，具体到网站后台应用，指的就是对各种http请求的handler，也就是根据不同<strong>url路径和http请求的参数</strong>，将数据和模版绑定到一起，最终形成页面呈现给用户。</p>
<p>对于网站前端开发，在web1.0时代，由于js基本上只是个跑龙套的小角色，所以不需要什么设计模式；但是随着web应用功能变得越来越丰富、越来越复杂，js的地位也越来越靠近舞台中心。在目前情况下，如果没有一定的设计模式作为指导，其实很难开发出真正大型复杂的html5应用，也很难实现分工协作和持续维护。</p>
<p>于是MVC模式被很自然地引入到前端开发领域。也许某种意义上，前端开发的整个MVC，仅仅对应于后台开发眼中的View部分；但其实，如今前端MVC思想的深入性和重要性，对于整个web应用来说，其实一点也不逊色于服务器端的MVC。</p>
<p>具体而言，前端开发的Model相当于后台数据的镜像或缓存池，它和服务器端MVC中的Model概念一脉相承；View对应页面的呈现，主要指的是和html、css相关的代码，它和服务器端MVC中的View概念也非常相近。</p>
<p>显著的差别来自于controller：在后台应用中，用户和服务器之间的交互是通过http请求实现的，因此后台controller的表达形式是http请求的handler，并且和router（定义网站的url规则）紧密相关; 而前端应用中，用户和网页之间的交互主要是通过操作事件（例如点击鼠标、键盘输入等）实现的，因此前端的controller这里可以简单理解为各种交互事件的handler。</p>
<blockquote>
<p>当然, 前端controller的概念是个大杂烩，比如angularjs中的controller被定义为一个作用域（$scope）的闭包, 参考AngularJS文档，这个闭包可以和一段html模版绑定在一起，最终将数据渲染到模版中形成页面。大约正是因为这种将数据和模版绑定的功能，非常类似于后台应用中的controller，因此很多框架包括angular将这种功能模块称为controller。为避免混淆，强调一下：后面我们用controller指代<strong>“凡是和交互事件handler相关的代码单元”</strong></p>
</blockquote>
<p>backbonejs 是一个广受欢迎的轻量级MVC前端框架，我们先来看一个 Backbone.js Todo Example，下面是其View组件的代码片断：</p>
<p><img src="https://i.imgur.com/IaByf5C.png"></p>
<p>注意到这里createOnEnter是对键盘输入事件的响应，因此可视为一小段controller代码（即controller是“内嵌”在View组件中的），并且这段代码中对Todos （Model）进行了直接操作，<strong>即View直接对Model产生修改</strong></p>
<p>（这是个危险的信号！因为前面我们在讨论“state-view单向流”的时候提到：一旦改变state和改变view的代码纠缠在一起，程序猿的内心就比较容易崩溃…）。也就是说backbone框架的MVC模式可以用下图表示：</p>
<p><img src="https://i.imgur.com/NC0JHui.png"></p>
<p>我们再来看angularjs的todoList实例 (AngularJS Example:)，可以发现其MVC模式（也有人称angular的模式为MVVM，这么细腻的区分感觉没太大必要）也完全符合上面的图示。</p>
<p>虽然这种View对Model直接修改的方式非常直截了当，适合小型web应用，然而一但web应用中存在多个Model，多个View，那么Model和View之间的决定关系就可能变得混乱，难以驾驭，如下图所示：</p>
<p><img src="https://i.imgur.com/wtAgnbW.png"></p>
<p>也就是说类似于上述代码片断中常见的MVC模式，阻碍了Model和View的组件化拆分（只有Model和View个数较少的时候，依赖关系才比较清晰）。因此，facebook团队总结说：MVC模式难以scale up！ [参考链接](Facebook: MVC Does Not Scale, Use Flux Instead [Updated])</p>
<p>怎么破？？</p>
<p>c. Flux模式</p>
<p>前面我们提到“单向流”的思维状态可以让大脑更加轻松驾驭，本质上而言，这也是为什么上面这种杂乱的双向图示让我们感到无所适从的原因。我们注意到：之所以图示中 Model-View （MVC中的Model大体上可以看作是前面提到的State）的“单向流”被破坏，是由于修改Model的Controller代码像一把黄豆一样散落在了各个View组件的内部，如果可以用某种方式把这些散落的代码单独收拢到一起，是不是就让这可以让这张图示恢复秩序呢？好，我们顺着这个思路想下去。</p>
<p>现在我们又可以从服务器端的MVC模式中获得灵感了！因为我们注意到，服务器端的controller通常也需要对很多Model产生修改，但在代码结构中却集中在一起，没有散落一地。原因很简单，由于server和client是远程通信的关系，因此为了尽量减少通信耦合，client每个操作的全部信息都以http请求的形式被概括成了精简的“作用量”（action）。请求的url路径约定了用户的操作意图（当然RESTful概念中，请求的method也可以反映操作意图），request参数表征了该“意图”的具体内容。正是基于这个action的抽象，client端的交互操作才可以被集中转移到server端的controller中做统一响应。</p>
<p>对比之下，我们立刻发现上述代码片断中前端MVC模式的“痛点”所在：不是MVC模式错了，而是我们压根缺少了一个和用户交互行为有关的action抽象！因此，对model的具体操作才没法从各个view组件中被剥离出来，放到一处。</p>
<p>参考http请求，我们将要定义的action，需要一个typeName用来表示对model操作的意图（类似于http请求的url路径），还可能需要其他字段，用来描述怎样具体操作model（类似于http请求的参数）。</p>
<p>也就是说，当用户在view上的交互行为（例如点击提交按钮）应当引起Model发生变化时，我们不直接修改model，而是简单地dispatch一个action（其实跟常见的event机制没有什么区别）以表达修改model的意图，这些action将被集中转移给数据端（models），然后数据端会根据这些action做出需要的自我更新。同时，我们考虑到react中view组件的树状分流结构，所以有如下图所示：</p>
<p><img src="https://i.imgur.com/p5V0BXU.jpg"></p>
<p>图中A表示Action，V表示View组件，Models部分的结构会进一步讨论。稍微总结一下：从代码层面而言，flux无非就是一个常见的event dispatcher，其目的是要将以往MVC中各个View组件内的controller代码片断提取出来放到更加恰当的地方进行集中化管理，并从开发体验上实现了舒适清爽、容易驾驭的“单向流”模式。 所以我觉得，Flux与其说是对前端MVC模式的颠覆，倒不如说是对前端MVC思想的补充和优化。</p>
<p>但为了区分于以往的MVC模式，并向facebook的贡献表达敬意，后面我们将把这种优化后的 Model-View-Controller 开发模式在React背景下正式称为Flux模式</p>
<p>好，易筋经Flux练到这里，打完收工。到目前为止，我们看到React的独孤九剑可以通过View Component把页面呈现进行<strong>“原子化”拆分</strong>（即上图中兰色区域的树状分流结构）；Flux打通了State-View的任督二脉（绿色区域），并通过action抽象把用户交互行为进行了<strong>“原子化”拆分</strong>；那么联系上面的图示，我们自然要问数据端（紫色区域）的处理，可否同样被<strong>“原子化”拆分</strong>？这是我们要聊的下一门武林绝学。</p>
<h2 id="凌波微步（数据端的“原子化”）"><a href="#凌波微步（数据端的“原子化”）" class="headerlink" title="凌波微步（数据端的“原子化”）"></a>凌波微步（数据端的“原子化”）</h2><p><strong>redux登场</strong></p>
<p>凌波微步指的是redux中的reducer机制，可以用来将state端的数据处理过程作“原子化”拆分。redux是来自函数式编程（Functional Programming）的一朵奇葩，据说很有背景（[参考链接](Prior Art | Redux) ）。本人还没有深究过，但一接触redux，就立刻被其reducer机制的轻盈小巧惊艳到（redux库本身也只有几kb，有必要的化，自己重写也不是难事），因此称其为“凌波微步”。</p>
<p>reducer，从代码上说，其实就是一个函数，具有如下形式：</p>
<p>(previousState, action) =&gt; newState</p>
<p>即，reducer作为一个函数，可以根据web应用之前的状态（previousState）和交互行为（通过flux中提到的action来表征），决定web应用的下一状态（newState），从而实现state端的数据更新处理。这个函数行为和大名鼎鼎的“Map-Reduce”概念中的Reduce操作非常类似，因而称这个函数为“Reducer”。</p>
<p><strong>“shut up and show me the code”</strong></p>
<p>ok，我们还是以todoList应用为例, 此处有[完整代码](Example: Todo List)。这里不打算详细讲解Redux的具体使用，而只想通过一个Redux对state数据进行操作的代码片断，管窥一下reducer机制对数据进行拆分和组装的简洁过程。代码片断如下：</p>
<p><img src="https://i.imgur.com/vaqtYWy.png"></p>
<p>其中的todos是和任务列表数据相关的reducer，todo是和单条任务数据有关的reducer。注意：在todos的函数体内调用了todo，并将action作为参数原样传递给了todo，这种干净利落地通过函数调用将action由 “parent reducer” 传递给 “child reducer”，是redux实现数据处理拆分的普遍方式。回味一下，<strong>我们应该可以体会到，这种数据处理“原子化”拆分的方式和react中view组件的拆分有异曲同工之妙，二者都会形成一种“树状”分流结构</strong>（在react的view hierarchy中，数据通过props的直接赋值实现单向流；在redux的reducer hierarchy中，数据通过action的函数传参实现单向流）。</p>
<p>visibilityFilter是和列表显示状态相关的另一个reducer；combineReducers将visibilityFilter和todos合并为整个应用的reducer，也就是todoApp。这个过程，从感觉上也和react中view组件的合并过程非常相像。</p>
<p>createStore是一个工厂函数。通过它，todoApp（相当于一个数据处理的引擎）被装配到整个应用的state容器，也就是store中。可以通过store的getState方法获取整个应用的state；同时，store也是一个event dispatcher，可以通过其dispatch和subscribe方法，分别实现触发action事件和注册对action事件的响应函数。总言之，从概念上来说 <strong>Redux ＝ Reducer ＋ Flux</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全体亮相</p>
<p>好，现在React开发模式中的几个核心概念已经全部出场亮相。我们俯瞰一下整个开发流程：首先，react框架为我们理顺了 store –&gt; view 的<strong>“单向”工作流</strong>（store是state的容器）；<strong>然后，redux框架为我们理顺了 view –&gt; store 的“单向”工作流。并且，react和redux都以组件化的形式可以将各自负责的功能进行灵活地组装或拆分</strong>，最大程度上确保我们<strong>“一次只需要专注于一个局部问题”</strong>。具体来说，分为以下步骤：</p>
<ol>
<li><p>单例store的数据在react中可以通过view组件的属性（props）不断由父模块<strong>“单向”传递给子模块，形成一个树状分流结构。如果我们把redux比作整个应用的“心肺” （redux的flux功能像心脏，reducer功能像肺部毛细血管），那么这个过程可以比作心脏（store）将氧分子（数据）通过动脉毛细血管（props）送到各个器官组织（view组件）</strong></p>
</li>
<li><p>末端的view组件，又可以通过flux机制，将携带交互意图信息的action反馈给store。这个过程有点像将携带代谢产物的“红细胞”（action）通过静脉毛细血管又泵回心脏（store）</p>
</li>
<li><p>action流回到store以后，action以参数的形式又被分流到各个具体的reducer组件中，这些reducer同样构成一个树状的hierarchy。这个过程像静脉血中的红细胞（action）被运输到肺部毛细血管（reducer组件）</p>
</li>
<li><p>接收到action后，各个child reducer以返回值的形式，将最新的state返回给parent reducer，最终确保整个单例store的所有数据是最新的。这个过程可以比作肺部毛细血管的血液充氧后，又被重新泵回了心脏</p>
</li>
<li><p>回到步骤1</p>
</li>
</ol>
<p>用图示的方式来表达，即，</p>
<p><img src="https://i.imgur.com/kf6IIAP.jpg"></p>
<p>图中A表示Action，V表示View组件，R表示Reducer。为了确保我们比较容易理解程序的全局行为，或者说提高程序行为的确定性（predictable），我们一般期望具有类似职能的代码片断被“平铺”着摆放在一。因此图示中相同颜色区域的代码通常会被放到同一个文件夹／文件中。另外，同样出于提高程序的确定性，redux所遵循的函数式编程鼓励我们使用pure function和immutable。（函数式编程是另一个漫长的故事，这里就不再展开）</p>
<p>要你命三千</p>
<p>当然实际的react－redux开发步骤中也有不少变通，例如为了能在适当条件下节省些参数传递的代码，redux中提供了provider机制，它像《星际迷航》中的瞬间传送机一样，可以绕过view组件的hierarchy把state一步到位地传递到末端view组件；再比如redux虽然鼓励使用pure function（即不含side effect的函数）, 但我们一般还是会通过side effect实现store和服务器端的通信。这些变通，觉得是好事。毕竟再严格的框架，也经不起胡乱使用；再完美的框架，也很难说能包治百病，倒不如提供一些台阶，让程序猿们去自由发挥吧。</p>
<p>除了React、Reducer、Flux这三驾马车的主线情节外，react开发模式的周边生态也有很多振奋人心的新鲜事物，例如：拥抱函数式编程和模块化的es6语法，日趋成熟的模块资源管理工具npm，自动化编程及打包神器webpack， 让初始化性能和SEO不再成为问题的server-side rendering方案，将触角伸到原生开发领域的React-Native系列项目等等，这些零零总总加起来，不由得让人想起《国产凌凌漆》中集各种武器于一身的终极武器 “要你命三千”！</p>
]]></content>
      <tags>
        <tag>javascript js react flux redux 概念 MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>编写「可读」代码的实践</title>
    <url>/2018/09/27/%E7%BC%96%E5%86%99%E3%80%8C%E5%8F%AF%E8%AF%BB%E3%80%8D%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>作者： From 淘宝前端团队</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>编写<strong>可读</strong>的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是<strong>能够被阅读</strong>，其次才是<strong>能够被正确执行</strong>。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p>
<p>在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。</p>
<blockquote>
<p>JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p>
</blockquote>
<blockquote>
<p>这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。</p>
</blockquote>
<a id="more"></a>

<h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><p>变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p>
<p>命名必须传递足够的信息，形如 getData 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 fetchUserInfoAsync 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 Async 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p>
<h2 id="命名的基础"><a href="#命名的基础" class="headerlink" title="命名的基础"></a>命名的基础</h2><p>通常，我们使用名词来命名对象，使用动词来命名函数。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monkey.eat(banana);  &#x2F;&#x2F; the money eats a banana</span><br><span class="line">const apple &#x3D; pick(tree);  &#x2F;&#x2F; pick an apple from the tree</span><br></pre></td></tr></table></figure>
<p>这两句代码与自然语言（右侧的注释）很接近，即使完全不了解编程的人也能看懂大概。</p>
<p>有时候，我们需要表示某种集合概念，比如数组或哈希对象。这时可以通过名词的复数形式来表示，比如用 bananas 表示一个数组，这个数组的每一项都是一个 banana。如果需要特别强调这种集合的形式，也可以加上 List 或 Map 后缀来显式表示出来，比如用 bananaList 表示数组。</p>
<blockquote>
<p>有些单词的复数形式和单数形式相同，有些不可数的单词没有复数形式（比如 data，information），这时我也会使用 List 等后缀来表示集合概念。</p>
</blockquote>
<h2 id="命名的上下文"><a href="#命名的上下文" class="headerlink" title="命名的上下文"></a>命名的上下文</h2><p>变量都是处在<strong>上下文</strong>（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。举个例子，假设我们的程序需要管理一个动物园，程序的代码里有一个名为 feedAnimals 的函数来喂食动物园中的所有动物：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function feedAnimals(food, animals) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; 上下文中有 bananas, peaches, monkey 变量</span><br><span class="line">  const banana &#x3D; bananas.pop();</span><br><span class="line">  if (banana) &#123;</span><br><span class="line">    monkey.eat(banana);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const peach &#x3D; peaches.pop();</span><br><span class="line">    monkey.eat(peach);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负责喂食动物的函数 feedAnimals 函数的主要逻辑就是：用各种食物把动物园里的各种动物喂饱。也许，每种动物能接受的食物种类不同，也许，我们需要根据各种食物的库存来决定每种动物最终分到的食物，总之在这个上下文中，我们需要关心食物的种类，所以传给 money.eat 方法的实参对象命名为 banana 或者 peach，代码很清楚地表达出了它的关键逻辑：「猴子要么吃香蕉，要么吃桃子（如果没有香蕉了）」。我们肯定不会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 我们不会这样写</span><br><span class="line">const food &#x3D; bananas.pop();</span><br><span class="line">if(food) &#123;</span><br><span class="line">  monkey.eat(food);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const food &#x3D; peaches.pop();</span><br><span class="line">  monkey.eat(food);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Monkey#eat 方法内部就不一样了，这个方法很可能是下面这样的（假设 eat 是 Monkey 的基类 Animal 的方法）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    this.hunger -&#x3D; food.energy;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monkey extends Animal&#123; </span><br><span class="line">  &#x2F;&#x2F; ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，「吃」这个方法的核心逻辑就是根据食物的能量来减少动物（猴子）自身的饥饿度，至于究竟是吃了桃子还是香蕉，我们不关心，所以在这个方法的上下文中，我们直接将表示食物的函数形参命名为 food。</p>
<p>想象一下，假设我们正在编写某个函数，即将写一段公用逻辑，我们会选择去写一个新的功能函数来执行这段公用逻辑。在编写这个新的功能函数过程中，往往会受到之前那个函数的影响，变量的命名也是按照其在之前那个函数中的意义来的。虽然写的时候不感觉有什么阻碍，但是读者阅读的单元是函数（他并不了解之前哪个函数），会被深深地困扰。</p>
<h2 id="严格遵循一种命名规范的收益"><a href="#严格遵循一种命名规范的收益" class="headerlink" title="严格遵循一种命名规范的收益"></a>严格遵循一种命名规范的收益</h2><p>如果你能够时刻按照某种严格的规则来命名变量和函数，还能带来一个潜在的好处，那就是你再也不用记住哪些之前命名过（甚至其他人命名过）的变量或函数了。特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。比如，「获取用户信息」这个概念，就叫作 fetchUserInfomation，不管是在早晨还是傍晚，不管你是在公司还是家中，你都会将它命名为 fetchUserInfomation 而不是 getUserData。那么当你再次需要使用这个变量时，你根本不用翻阅之前的代码或依赖 IDE 的代码提示功能，你只需要再命名一下「获取用户信息」这个概念，就可以得到 fetchUserInfomation 了，是不是很酷？</p>
<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><p>分支是代码里最常见的结构，一段结构清晰的代码单元应当是像二叉树一样，呈现下面的结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">  if (condition2) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  if (condition3) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种优美的结构能够帮助我们在大脑中迅速绘制一张图，便于我们在脑海中模拟代码的执行。但是，我们大多数人都不会遵循上面这样的结构来写分支代码。以下是一些常见的，在我看来可读性比较差的分支语句的写法：</p>
<h2 id="不好的做法：在分支中-return"><a href="#不好的做法：在分支中-return" class="headerlink" title="不好的做法：在分支中 return"></a>不好的做法：在分支中 return</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  if (condition) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分支1的逻辑</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 分支2的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种分支代码很常见，而且往往分支 2 的逻辑是先写的，也是函数的主要逻辑，分支 1 是后来对函数进行修补的过程中产生的。这种分支代码有一个很致命的问题，那就是，如果读者没有注意到分支1中的 return（我敢保证，在使用 IDE 把代码折叠起来后，没人能第一时间注意到这个 return），就不会意识到后面一段代码（分支 2）是有可能不会执行的。我的建议是，把分支 2 放到一个 else 语句块中，代码就会清晰可读很多：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  if (condition) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分支 1 的逻辑</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 分支 2 的逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果某个分支是空的，我也倾向于留下一个空行，这个空行明确地告诉代码的读者，如果走到这个 else，我什么都不会做。如果你不告诉读者，读者就会产生怀疑，并尝试自己去弄明白。</p>
</blockquote>
<h2 id="不好的做法：多个条件复合"><a href="#不好的做法：多个条件复合" class="headerlink" title="不好的做法：多个条件复合"></a>不好的做法：多个条件复合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (condition1 &amp;&amp; condition2 &amp;&amp; condition3) &#123;</span><br><span class="line">  &#x2F;&#x2F; 分支1：做一些事情</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 分支2：其他的事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码也很常见：在若干条件同时满足（或有任一满足）的时候做一些主要的事情（分支1，也就是函数的主逻辑），否则就做一些次要的事情（分支2，比如抛异常，输出日志等）。虽然写代码的人知道什么是主要的事情，什么是次要的事情，但是代码的读者并不知道。读者遇到这种代码，就会产生困惑：分支2到底对应了什么条件？</p>
<p>在上面这段代码中，三种条件只要任意一个不成立就会执行到分支 2，但这其实本质上是多个分支：1)条件 1 不满足，2)条件 1 满足而条件 2 不满足，3)条件 1 和 2 都满足而条件 3 不满足。如果我们笼统地使用同一段代码来处理多个分支，那么就会增加阅读者阅读分支 2 时的负担（需要考虑多个情况）。更可怕的是，如果后面需要增加一些额外的逻辑（比如，在条件 1 成立且条件 2 不成立的时候多输出一条日志），整个 if-else 都可能需要重构。</p>
<p>对这种场景，我通常这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">  if (condition2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 分支1：做一些事情</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 分支2：其他的事情</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 分支3：其他的事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使分支 2 和分支 3 是完全一样的，我也认为有必要将其分开。虽然多了几行代码，收益却是很客观的。</p>
<blockquote>
<p>万事非绝对。对于一种情况，我不反对将多个条件复合起来，那就是当被复合的多个条件联系十分紧密的时候，比如 if(foo &amp;&amp; foo.bar)。</p>
</blockquote>
<h2 id="不好的做法：使用分支改变环境"><a href="#不好的做法：使用分支改变环境" class="headerlink" title="不好的做法：使用分支改变环境"></a>不好的做法：使用分支改变环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let foo &#x3D; someValue;</span><br><span class="line">if (condition) &#123;</span><br><span class="line">  foo &#x3D; doSomethingTofoo(foo);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 继续使用 foo 做一些事情</span><br></pre></td></tr></table></figure>
<p>这种风格的代码很容易出现在那些屡经修补的代码文件中，很可能一开始是没有这个 if 代码块的，后来发现了一个 bug，于是加上了这个 if 代码块，在某些条件下对 foo 做一些特殊的处理。如果你希望项目在迭代过程中，风险越积越高，那么这个习惯绝对算得上「最佳实践」了。</p>
<p>事实上，这样的「补丁」积累起来，很快就会摧毁代码的可读性和可维护性。怎么说呢？当我们在写下上面这段代码中的 if 分支以试图修复 bug 的时候，我们内心存在这样一个假设：我们是知道程序在执行到这一行时，foo 什么样子的；但事实是，我们根本不知道，因为在这一行之前，foo 很可能已经被另一个人所写的尝试修复另一个 bug 的另一个 if 分支所篡改了。所以，当代码出现问题的时候，我们应当完整地审视一段独立的功能代码（通常是一个函数），并且多花一点时间来修复他，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const foo &#x3D; condition ? doSomethingToFoo(someValue) : someValue;</span><br></pre></td></tr></table></figure>
<p>我们看到，很多风险都是在项目快速迭代的过程中积累下来的。为了「快速」迭代，在添加功能代码的时候，我们有时候连函数这个最小单元的都不去了解，仅仅着眼于自己插入的那几行，希望在那几行中解决/hack掉所有问题，这是十分不可取的。</p>
<p>我认为，项目的迭代再快，其代码质量和可读性都应当有一个底线。这个底线是，当我们在修改代码的时候，应当完整了解当前修改的这个函数的逻辑，然后修改这个函数，以达到添加功能的目的。注意，这里的「修改一个函数」和「在函数某个位置添加几行代码」是不同的，在「修改一个函数」的时候，为了保证函数功能独立，逻辑清晰，不应该畏惧在这个函数的任意位置增删代码。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数只做一件事情"><a href="#函数只做一件事情" class="headerlink" title="函数只做一件事情"></a>函数只做一件事情</h2><p>有时，我们会自作聪明地写出一些很「通用」的函数。比如，我们有可能写出下面这样一个获取用户信息的函数 fetchUserInfo：其逻辑是：</p>
<ol>
<li>当传入的参数是用户ID（字符串）时，返回单个用户数据；</li>
<li>而传入的参数是用户ID的列表（数组）时，返回一个数组，其中的每一项是一个用户的数据。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fetchUserInfo(id) &#123;</span><br><span class="line">  const isSingle &#x3D; typeof idList &#x3D;&#x3D;&#x3D; &#39;string&#39;;</span><br><span class="line">  const idList &#x3D; isSingle ? [id] : id;</span><br><span class="line">  const result &#x3D; await request.post(&#39;&#x2F;api&#x2F;userInfo&#39;, &#123;idList&#125;);</span><br><span class="line">  return isSingle ? result[0] : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以这样调用</span><br><span class="line">const userList &#x3D; await fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;]);</span><br><span class="line">&#x2F;&#x2F; 也可以这样调用</span><br><span class="line">const user &#x3D; await fetchUserInfo(&#39;1017&#39;);</span><br></pre></td></tr></table></figure>
<p>这个函数能够做两件事：1)获取多个用户的数据列表；2)获取单个用户的数据。在项目的其他地方调用 fetchUserInfo 函数时，也许我们确实能感到「方便」了一些。但是，代码的读者一定不会有相同的体会，当读者在某处读到 fetchUserInfo([‘1011’, ‘1013’]) 这句调用的代码时，他就会立刻对 fetchUserInfo 产生「第一印象」：这个函数需要传入用户ID数组；当他读到另外一种调用形式时，他一定会怀疑自己之前是不是眼睛花了。读者并不了解背后的「潜规则」，除非规则是预先设计好并且及时地更新到文档中。总之，我们绝不该一时兴起就写出上面这种函数。</p>
<p>遵循一个函数只做一件事的原则，我们可以将上述功能拆成两个函数fetchMultipleUser 和 fetchSingleUser 来实现。在需要获取用户数据时，只需要选择调用其中的一个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fetchMultipleUser(idList) &#123;</span><br><span class="line">  return await request.post(&#39;&#x2F;api&#x2F;users&#x2F;&#39;, &#123;idList&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fetchSingleUser(id) &#123;</span><br><span class="line">  return await fetchMultipleUser([id])[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述改良不仅改善了代码的可读性，也改善了可维护性。举个例子，假设随着项目的迭代，获取单一用户信息的需求不再存在了。</p>
<ul>
<li><p>如果是改良前，我们会删掉那些「传入单个用户ID来调用 fetchUserInfo」的代码，同时保留剩下的那些「传入多个用户ID调用 fetchUserInfo」的代码， 但是 fetchUserInfo 函数几乎一定不会被更改。这样，函数内部 isSingle 为 true 的分支，就留在了代码中，成了永远都不会执行的「脏代码」，谁愿意看到自己的项目中充斥着永远不会执行的代码呢？</p>
</li>
<li><p>对于改良后的代码，我们（也许借助IDE）能够轻松检测到 fetchSingleUser 已经不会被调用了，然后放心大胆地直接删掉这个函数。</p>
</li>
</ul>
<p>那么，如何界定某个函数做的是不是一件事情？我的经验是这样：<strong>如果一个函数的参数仅仅包含输入数据（交给函数处理的数据），而没有混杂或暗含有指令（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是一件事情。</strong>比如说，改良前的 fetchUserInfo 函数的参数是「多个用户的ID数组或单个用户的ID」，这个「或」字其实就暗含了某种指令。</p>
<h2 id="函数应适当地处理异常"><a href="#函数应适当地处理异常" class="headerlink" title="函数应适当地处理异常"></a>函数应适当地处理异常</h2><p>有时候，我们会陷入一种很不好的习惯中，那就是，总是去尝试写出永远不会报错的函数。我们会给参数配上默认值，在很多地方使用 || 或者 &amp;&amp; 来避免代码运行出错，仿佛如果你的函数报错会成为某种耻辱似的。而且，当我们尝试去修复一个运行时报错的函数时，我们往往倾向于在报错的那一行添加一些兼容逻辑来避免报错。</p>
<p>举个例子，假设我们需要编写一个获取用户详情的函数，它要返回一个完整的用户信息对象：不仅包含ID，名字等基本信息，也包含诸如「收藏的书籍」等通过额外接口返回的信息。这些额外的接口也许不太稳定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function getUserDetail(id) &#123;</span><br><span class="line">  const user &#x3D; await fetchSingleUser(id);</span><br><span class="line">  user.favoriteBooks &#x3D; (await fetchUserFavorits(id)).books;</span><br><span class="line">  &#x2F;&#x2F; 上面这一行报错了：Can not read property &#39;books&#39; of undefined.</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设 fetchUserFavorites 会时不时地返回 undefined，那么读取其 books 属性自然就会报错。为了修复该问题，我们很可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const favorites &#x3D; await fetchUserFavorits(id);</span><br><span class="line">user.favoriteBooks &#x3D; favorites &amp;&amp; favorites.books;</span><br><span class="line">&#x2F;&#x2F; 这下不会报错了</span><br></pre></td></tr></table></figure>
<p>这样做看似解决了问题：的确，getUserDetail 不会再报错了，但同时埋下了更深的隐患。</p>
<p>当 fetchUserFavorites 返回 undefined 时，程序已经处于一种异常状态了，我们没有任何理由放任程序继续运行下去。试想，如果后面的某个时刻（比如用户点击「我收藏的书」选项卡），程序试图遍历 user.favoriteBooks 属性（它被赋值成了undefined），那时也会报错，而且那时排查起来会更加困难。</p>
<p>如何处理上述的情况呢？我认为，如果被我们依赖的 fetchUserFavorits 属于当前的项目，那么 getUserDetail 对此报错真的没什么责任，因为 fetchUserFavorits 就不应该返回 undefined，我们应该去修复 fetchUserFavorits，任务失败时显式地告知出来，或者直接抛出异常。同时，getUserDetail 稍作修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 情况1：显式告知，此时应认为获取不到收藏数据不算致命的错误</span><br><span class="line">const result &#x3D; await fetchUserFavorits(id);</span><br><span class="line">if(result.success) &#123;</span><br><span class="line">  user.favoriteBooks &#x3D; result.data.books;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  user.favoriteBooks &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况2：直接抛出异常</span><br><span class="line">user.favoriteBooks &#x3D; (await fetchUserFavorits(id)).books;</span><br><span class="line">&#x2F;&#x2F; 这时 &#96;getUserDetail&#96; 不需要改动，任由异常沿着调用栈向上冒泡</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么如果 fetchUserFavorits 不在当前项目中，而是依赖的外部模块呢？我认为，这时你就该为选择了这样一个不可靠的模块负责，在 getUserDetail 中增加一些「擦屁股」代码，来避免你的项目的其他部分受到侵害。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const favorites &#x3D; await fetchUserFavorits(id);</span><br><span class="line">if(favorites) &#123;</span><br><span class="line">  user.favoriteBooks &#x3D; favorites.books;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  throw new Error(&#39;获取用户收藏失败&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制函数的副作用"><a href="#控制函数的副作用" class="headerlink" title="控制函数的副作用"></a>控制函数的副作用</h2><p>无副作用的函数，是<strong>不依赖上下文，也不改变上下文</strong>的函数。长久依赖，我们已经习惯了去写「有副作用的函数」，毕竟 JavaScript 需要通过副作用去操作环境的 API 完成任务。这就导致了，很多原本可以用纯粹的、无副作用的函数完成任务的场合，我们也会不自觉地采取有副作用的方式。</p>
<p>虽然看上去有点可笑，但我们有时候就是会写出下面这样的代码！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function getUserDetail(id) &#123;</span><br><span class="line">  const user &#x3D; await fetchSingleUserInfo(id);</span><br><span class="line">  await addFavoritesToUser(user);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">async function addFavoritesToUser(user) &#123;</span><br><span class="line">  const result &#x3D; await fetchUserFavorits(user.id);</span><br><span class="line">  user.favoriteBooks &#x3D; result.books;</span><br><span class="line">  user.favoriteSongs &#x3D; result.songs;</span><br><span class="line">  user.isMusicFan &#x3D; result.songs.length &gt; 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，addFavoritesToUser 函数就是一个「有副作用」的函数，它改变了 users，给它新增了几个个字段。问题在于，仅仅阅读 getUserData 函数的代码完全无法知道，user 会发生怎样的改变。</p>
<p>一个无副作用的函数应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function getUserDetail(id) &#123;</span><br><span class="line">  const user &#x3D; await fetchSingleUserInfo(id);</span><br><span class="line">  const &#123;books, songs, isMusicFan&#125; &#x3D; await getUserFavorites(id);</span><br><span class="line">  return Object.assign(user, &#123;books, songs, isMusicFan&#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function getUserFavorites(id) &#123;</span><br><span class="line">  const &#123;books, songs&#125; &#x3D; await fetchUserFavorits(user.id);</span><br><span class="line">  return &#123;</span><br><span class="line">    books, songs, isMusicFan: result.songs.length &gt; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难道这不是理所当然的形式吗？</p>
<h2 id="非侵入性地改造函数"><a href="#非侵入性地改造函数" class="headerlink" title="非侵入性地改造函数"></a>非侵入性地改造函数</h2><p>函数是一段独立和内聚的逻辑。在产品迭代的过程中，我们有时候不得不去修改函数的逻辑，为其添加一些新特性。之前我们也说过，一个函数只应做一件事，如果我们需要添加的新特性，与原先函数中的逻辑没有什么联系，那么决定是否通过改造这个函数来添加新功能，应当格外谨慎。</p>
<p>仍然用「向服务器查询用户数据」为例，假设我们有如下这样一个函数（为了让它看上去复杂一些，假设我们使用了一个更基本的 request 库）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fetchUserInfo &#x3D; (userId, callback) &#x3D;&gt; &#123;</span><br><span class="line">  const param &#x3D; &#123;</span><br><span class="line">    url: &#39;&#x2F;api&#x2F;user&#39;,</span><br><span class="line">    method: &#39;post&#39;,</span><br><span class="line">    payload: &#123;id: userId&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  request(param, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有了一个新需求：为 fetchUserInfo 函数增加一道本地缓存，如果第二次请求同一个 userId 的用户信息，就不再重新向服务器发起请求，而直接以第一次请求得到的数据返回。</p>
<p>按照如下快捷简单的解决方案，改造这个函数只需要五分钟时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const userInfoMap &#x3D; &#123;&#125;;</span><br><span class="line">const fetchUserInfo &#x3D; (userId, callback) &#x3D;&gt; &#123;</span><br><span class="line">  if (userInfoMap[userId]) &#123;            &#x2F;&#x2F; 新增代码</span><br><span class="line">    callback(userInfoMap[userId]);    &#x2F;&#x2F; 新增代码</span><br><span class="line">  &#125; else &#123;                              &#x2F;&#x2F; 新增代码</span><br><span class="line">    const param &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F; ... 参数</span><br><span class="line">    &#125;;</span><br><span class="line">    request(param, (result) &#x3D;&gt; &#123;</span><br><span class="line">      userInfoMap[userId] &#x3D; result;   &#x2F;&#x2F; 新增代码</span><br><span class="line">      callback(result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知你有没有发现，经此改造，这个函数的可读性已经明显降低了。没有缓存机制前，函数很清晰，一眼就能明白，加上新增的几行代码，已经不能一眼就看明白了。</p>
<p>实际上，「缓存」和「获取用户数据」完全是独立的两件事。我提出的方案是，编写一个通用的缓存包装函数（类似装饰器）memorizeThunk，对 fetchUserInfo 进行包装，产出一个新的具有缓存功能的 fetchUserInfoCache，在不破坏原有函数可读性的基础上，提供缓存功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const memorizeThunk &#x3D; (func, reducer) &#x3D;&gt; &#123;</span><br><span class="line">  const cache &#x3D; &#123;&#125;;</span><br><span class="line">  return (...args, callback) &#x3D;&gt; &#123;</span><br><span class="line">    const key &#x3D; reducer(...args);</span><br><span class="line">    if (cache[key]) &#123;</span><br><span class="line">      callback(...cache[key]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      func(...args, (...result) &#x3D;&gt; &#123;</span><br><span class="line">        cache[key] &#x3D; result;</span><br><span class="line">        callback(...result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const fetchUserInfo &#x3D; (userInfo, callback) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 原来的逻辑</span><br><span class="line">&#125;</span><br><span class="line">const fetchUserInfoCache &#x3D; memorize(fetchUserInfo, (userId) &#x3D;&gt; userId);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也许实现这个方案需要十五分钟，但是试想一下，如果将来的某个时候，我们又不需要缓存功能了（或者需要提供一个开关来打开/关闭缓存功能），修改代码的负担是怎样的？第一种简单方案，我们需要精准（提心吊胆地）地删掉新增的若干行代码，而我提出的这种方案，是以函数为单位增删的，负担要轻很多，不是吗？</p>
<h1 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h1><h2 id="避免滥用成员函数"><a href="#避免滥用成员函数" class="headerlink" title="避免滥用成员函数"></a>避免滥用成员函数</h2><p>JavaScript 中的类，是 ES6 才有的概念，此前是通过函数和原型链来模拟的。在编写类的时候，我们常常忍不住地写很多没必要的成员函数：当类的某个成员函数的内部逻辑有点复杂了，行数有点多了之后，我们往往会将其中一部分「独立」逻辑拆分出来，实现为类的另一个成员函数。比如，假设我们编写某个 React 组件来显示用户列表，用户列表的形式是每两个用户为一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserList extends React.Component&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  chunk &#x3D; (users) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 [&#39;张三&#39;, &#39;李四&#39;, &#39;王二&#39;, &#39;麻子&#39;] 转化为 [[&#39;张三&#39;, &#39;李四&#39;], [&#39;王二&#39;, &#39;麻子&#39;]]</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    const chunks &#x3D; this.chunk(this.props.users);</span><br><span class="line">    &#x2F;&#x2F; 每两个用户为一行</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;chunks.map(users&#x3D;&gt;</span><br><span class="line">          &lt;row&gt;</span><br><span class="line">            &#123;users.map(user &#x3D;&gt; </span><br><span class="line">              &lt;col&gt;&lt;UserItem user&#x3D;&#123;user&#125;&gt;&lt;&#x2F;col&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">          &lt;&#x2F;row&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，UserList 组件按照「两个一行」的方式来显示用户列表，所以需要先将用户列表进行组合。进行组合的工作这件事情看上去是比较独立的，所以我们往往会将 chunk 实现成 UserList 的一个成员函数，在 render 中调用它。</p>
<p>我认为这样做并不可取，因为 chunk 只会被 render 所调用，仅仅服务于 render。阅读这个类源码的时候，读者其实只需要在 render 中去了解 chunk 函数就够了。然而 chunk 以成员函数的形式出现，扩大了它的可用范围，提前把自己曝光给了读者，反而会造成干扰。读者阅读源码，首先就是将代码折叠起来，然后他看到的是这样的景象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserList extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;...&#125;</span><br><span class="line">  componentWillUnmount() &#123;...&#125;</span><br><span class="line">  chunk() &#123;...&#125;    &#x2F;&#x2F; 读者的内心独白：这是什么鬼？</span><br><span class="line">  render() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉 React 的同学对组件中出现一个不熟悉的方法多半会感到困惑。不管怎么说，读者肯定会首先去浏览一遍这些成员函数，但是阅读 chunk 函数带给读者的信息基本是零，反而还会干扰读者的思路，因为读者现在还不知道用户列表需要以「每两个一行」的方式呈现。所以我认为，chunk 函数绝对应该定义在 render 中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  const chunk &#x3D; (users) &#x3D;&gt; ...</span><br><span class="line">  const chunks &#x3D; this.chunk(this.props.users);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然函数的行数可能会比较多，但将代码折叠起来后，函数的逻辑则会非常清楚。而且，chunk 函数曝光在读者眼中的时机是非常正确的，那就是，在它即将被调用的地方。实际上，在「计算函数的代码行数」这个问题上，我会把内部定义的函数视为一行，因为函数对读者可以是黑盒，它的负担只有一行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复打磨自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p>
]]></content>
      <tags>
        <tag>开发 学习 提升 编程 代码</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 代码简洁之道</title>
    <url>/2019/01/08/JavaScript%20%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<h1 id="测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。"><a href="#测试代码质量的唯一方式：别人看你代码时说-f-k-的次数。" class="headerlink" title="测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。"></a>测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</h1><p>代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。</p>
<p>本文并不是代码风格指南，而是关于代码的可读性、复用性、扩展性探讨。</p>
<p>我们将从几个方面展开讨论：</p>
<ol>
<li><p>变量</p>
</li>
<li><p>函数</p>
</li>
<li><p>对象和数据结构</p>
</li>
<li><p>类</p>
</li>
<li><p>SOLID</p>
</li>
<li><p>测试</p>
</li>
<li><p>异步</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>代码风格</p>
</li>
<li><p>注释</p>
</li>
</ol>
<a id="more"></a>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="用有意义且常用的单词命名变量"><a href="#用有意义且常用的单词命名变量" class="headerlink" title="用有意义且常用的单词命名变量"></a>用有意义且常用的单词命名变量</h2><h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad:"></a>Bad:</h3><p><code>const yyyymmdstr = moment().format(&#39;YYYY/MM/DD&#39;);</code></p>
<h3 id="Good"><a href="#Good" class="headerlink" title="Good:"></a>Good:</h3><p><code>const currentDate = moment().format(&#39;YYYY/MM/DD&#39;);</code></p>
<h2 id="保持统一"><a href="#保持统一" class="headerlink" title="保持统一"></a>保持统一</h2><p>可能同一个项目对于获取用户信息，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 codelf 搜索，看别人是怎么取名的。</p>
<h3 id="Bad-1"><a href="#Bad-1" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getUserInfo();</span><br><span class="line">getClientData();</span><br><span class="line">getCustomerRecord();</span><br></pre></td></tr></table></figure>
<h3 id="Good-1"><a href="#Good-1" class="headerlink" title="Good:"></a>Good:</h3><p><code>  getUser()</code></p>
<h2 id="每个常量都该命名"><a href="#每个常量都该命名" class="headerlink" title="每个常量都该命名"></a>每个常量都该命名</h2><p>可以用 buddy.js 或者 ESLint 检测代码中未命名的常量。</p>
<h3 id="Bad-2"><a href="#Bad-2" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 三个月之后你还能知道 86400000 是什么吗?</span><br><span class="line">setTimeout(blastOff, 86400000);</span><br></pre></td></tr></table></figure>
<h3 id="Good-2"><a href="#Good-2" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MILLISECOND_IN_A_DAY &#x3D; 86400000;</span><br><span class="line">setTimeout(blastOff, MILLISECOND_IN_A_DAY);</span><br></pre></td></tr></table></figure>
<h2 id="可描述"><a href="#可描述" class="headerlink" title="可描述"></a>可描述</h2><p>通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。</p>
<h3 id="Bad-3"><a href="#Bad-3" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ADDRESS &#x3D; &#39;One Infinite Loop, Cupertino 95014&#39;;</span><br><span class="line">const CITY_ZIP_CODE_REGEX &#x3D; &#x2F;^[^,\\]+[,\\\s]+(.+?)\s*(\d&#123;5&#125;)?$&#x2F;;</span><br><span class="line">saveCityZipCode(ADDRESS.match(CITY_ZIP_CODE_REGEX)[1],</span><br><span class="line">                ADDRESS.match(CITY_ZIP_CODE_REGEX)[2]);</span><br></pre></td></tr></table></figure>
<h3 id="Good-3"><a href="#Good-3" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ADDRESS &#x3D; &#39;One Infinite Loop, Cupertino 95014&#39;;</span><br><span class="line">const CITY_ZIP_CODE_REGEX &#x3D; &#x2F;^[^,\\]+[,\\\s]+(.+?)\s*(\d&#123;5&#125;)?$&#x2F;;</span><br><span class="line">const [, city, zipCode] &#x3D; ADDRESS.match(CITY_ZIP_CODE_REGEX) || [];</span><br><span class="line">saveCityZipCode(city, zipCode);</span><br></pre></td></tr></table></figure>
<h2 id="直接了当"><a href="#直接了当" class="headerlink" title="直接了当"></a>直接了当</h2><h3 id="Bad-4"><a href="#Bad-4" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const l &#x3D; [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];</span><br><span class="line">locations.forEach((l) &#x3D;&gt; &#123;</span><br><span class="line">  doStuff();</span><br><span class="line">  doSomeOtherStuff();</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; 需要看其他代码才能确定 &#39;l&#39; 是干什么的。</span><br><span class="line">  dispatch(l);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-4"><a href="#Good-4" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const locations &#x3D; [&#39;Austin&#39;, &#39;New York&#39;, &#39;San Francisco&#39;];</span><br><span class="line">locations.forEach((location) &#x3D;&gt; &#123;</span><br><span class="line">  doStuff();</span><br><span class="line">  doSomeOtherStuff();</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  dispatch(location);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="避免无意义的前缀"><a href="#避免无意义的前缀" class="headerlink" title="避免无意义的前缀"></a>避免无意义的前缀</h2><p>如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</p>
<h3 id="Bad-5"><a href="#Bad-5" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const car &#x3D; &#123;</span><br><span class="line">  carMake: &#39;Honda&#39;,</span><br><span class="line">  carModel: &#39;Accord&#39;,</span><br><span class="line">  carColor: &#39;Blue&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function paintCar(car) &#123;</span><br><span class="line">  car.carColor &#x3D; &#39;Red&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-5"><a href="#Good-5" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const car &#x3D; &#123;</span><br><span class="line">  make: &#39;Honda&#39;,</span><br><span class="line">  model: &#39;Accord&#39;,</span><br><span class="line">  color: &#39;Blue&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function paintCar(car) &#123;</span><br><span class="line">  car.color &#x3D; &#39;Red&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h2><h3 id="Bad-6"><a href="#Bad-6" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMicrobrewery(name) &#123;</span><br><span class="line">  const breweryName &#x3D; name || &#39;Hipster Brew Co.&#39;;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-6"><a href="#Good-6" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMicrobrewery(name &#x3D; &#39;Hipster Brew Co.&#39;) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数越少越好"><a href="#参数越少越好" class="headerlink" title="参数越少越好"></a>参数越少越好</h2><p>如果参数超过两个，使用 ES2015/ES6 的解构语法，不用考虑参数的顺序。（注：不要超过3个参数，如果确实需要3个以上的参数，用对象包起来）</p>
<h3 id="Bad-7"><a href="#Bad-7" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(title, body, buttonText, cancellable) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-7"><a href="#Good-7" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createMenu(&#123; title, body, buttonText, cancellable &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMenu(&#123;</span><br><span class="line">  title: &#39;Foo&#39;,</span><br><span class="line">  body: &#39;Bar&#39;,</span><br><span class="line">  buttonText: &#39;Baz&#39;,</span><br><span class="line">  cancellable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="只做一件事情"><a href="#只做一件事情" class="headerlink" title="只做一件事情"></a>只做一件事情</h2><p>这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。</p>
<h3 id="Bad-8"><a href="#Bad-8" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function emailClients(clients) &#123;</span><br><span class="line">  clients.forEach((client) &#x3D;&gt; &#123;</span><br><span class="line">    const clientRecord &#x3D; database.lookup(client);</span><br><span class="line">    if (clientRecord.isActive()) &#123;</span><br><span class="line">      email(client);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-8"><a href="#Good-8" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function emailActiveClients(clients) &#123;</span><br><span class="line">  clients</span><br><span class="line">    .filter(isActiveClient)</span><br><span class="line">    .forEach(email);</span><br><span class="line">&#125;</span><br><span class="line">function isActiveClient(client) &#123;</span><br><span class="line">  const clientRecord &#x3D; database.lookup(client);    </span><br><span class="line">  return clientRecord.isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顾名思义"><a href="#顾名思义" class="headerlink" title="顾名思义"></a>顾名思义</h2><p>看函数名就应该知道它是干啥的。(注：其实就是语义化命名，代码是给人看的)</p>
<h3 id="Bad-9"><a href="#Bad-9" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addToDate(date, month) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const date &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 很难知道是把什么加到日期中</span><br><span class="line">addToDate(date, 1);</span><br></pre></td></tr></table></figure>
<h3 id="Good-9"><a href="#Good-9" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addMonthToDate(month, date) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const date &#x3D; new Date();</span><br><span class="line">addMonthToDate(1, date);</span><br></pre></td></tr></table></figure>
<h2 id="只需要一层抽象层"><a href="#只需要一层抽象层" class="headerlink" title="只需要一层抽象层"></a>只需要一层抽象层</h2><p>如果函数嵌套过多会导致很难复用以及测试。</p>
<h3 id="Bad-10"><a href="#Bad-10" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseBetterJSAlternative(code) &#123;</span><br><span class="line">  const REGEXES &#x3D; [</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  const statements &#x3D; code.split(&#39; &#39;);</span><br><span class="line">  const tokens &#x3D; [];</span><br><span class="line">  REGEXES.forEach((REGEX) &#x3D;&gt; &#123;</span><br><span class="line">    statements.forEach((statement) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const ast &#x3D; [];</span><br><span class="line">  tokens.forEach((token) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; lex...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ast.forEach((node) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; parse...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-10"><a href="#Good-10" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parseBetterJSAlternative(code) &#123;</span><br><span class="line">  const tokens &#x3D; tokenize(code);</span><br><span class="line">  const ast &#x3D; lexer(tokens);</span><br><span class="line">  ast.forEach((node) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; parse...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tokenize(code) &#123;</span><br><span class="line">  const REGEXES &#x3D; [</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  const statements &#x3D; code.split(&#39; &#39;);</span><br><span class="line">  const tokens &#x3D; [];</span><br><span class="line">  REGEXES.forEach((REGEX) &#x3D;&gt; &#123;</span><br><span class="line">    statements.forEach((statement) &#x3D;&gt; &#123;</span><br><span class="line">      tokens.push( &#x2F;* ... *&#x2F; );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function lexer(tokens) &#123;</span><br><span class="line">  const ast &#x3D; [];</span><br><span class="line">  tokens.forEach((token) &#x3D;&gt; &#123;</span><br><span class="line">    ast.push( &#x2F;* ... *&#x2F; );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return ast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除重复代码"><a href="#删除重复代码" class="headerlink" title="删除重复代码"></a>删除重复代码</h2><p>很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。</p>
<p>要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 SOLID 原则（SOLID 是什么？稍后会详细介绍）。</p>
<h3 id="Bad-11"><a href="#Bad-11" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function showDeveloperList(developers) &#123;</span><br><span class="line">  developers.forEach((developer) &#x3D;&gt; &#123;</span><br><span class="line">    const expectedSalary &#x3D; developer.calculateExpectedSalary();</span><br><span class="line">    const experience &#x3D; developer.getExperience();</span><br><span class="line">    const githubLink &#x3D; developer.getGithubLink();</span><br><span class="line">    const data &#x3D; &#123;</span><br><span class="line">      expectedSalary,</span><br><span class="line">      experience,</span><br><span class="line">      githubLink</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function showManagerList(managers) &#123;</span><br><span class="line">  managers.forEach((manager) &#x3D;&gt; &#123;</span><br><span class="line">    const expectedSalary &#x3D; manager.calculateExpectedSalary();</span><br><span class="line">    const experience &#x3D; manager.getExperience();</span><br><span class="line">    const portfolio &#x3D; manager.getMBAProjects();</span><br><span class="line">    const data &#x3D; &#123;</span><br><span class="line">      expectedSalary,</span><br><span class="line">      experience,</span><br><span class="line">      portfolio</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-11"><a href="#Good-11" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function showEmployeeList(employees) &#123;</span><br><span class="line">  employees.forEach(employee &#x3D;&gt; &#123;</span><br><span class="line">    const expectedSalary &#x3D; employee.calculateExpectedSalary();</span><br><span class="line">    const experience &#x3D; employee.getExperience();</span><br><span class="line">    const data &#x3D; &#123;</span><br><span class="line">      expectedSalary,</span><br><span class="line">      experience,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    switch(employee.type) &#123;</span><br><span class="line">      case &#39;develop&#39;:</span><br><span class="line">        data.githubLink &#x3D; employee.getGithubLink();</span><br><span class="line">        break</span><br><span class="line">      case &#39;manager&#39;:</span><br><span class="line">        data.portfolio &#x3D; employee.getMBAProjects();</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    render(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象设置默认属性"><a href="#对象设置默认属性" class="headerlink" title="对象设置默认属性"></a>对象设置默认属性</h2><h3 id="Bad-12"><a href="#Bad-12" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const menuConfig &#x3D; &#123;</span><br><span class="line">  title: null,</span><br><span class="line">  body: &#39;Bar&#39;,</span><br><span class="line">  buttonText: null,</span><br><span class="line">  cancellable: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function createMenu(config) &#123;</span><br><span class="line">  config.title &#x3D; config.title || &#39;Foo&#39;;</span><br><span class="line">  config.body &#x3D; config.body || &#39;Bar&#39;;</span><br><span class="line">  config.buttonText &#x3D; config.buttonText || &#39;Baz&#39;;</span><br><span class="line">  config.cancellable &#x3D; config.cancellable !&#x3D;&#x3D; undefined ? config.cancellable : true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMenu(menuConfig);</span><br></pre></td></tr></table></figure>
<h3 id="Good-12"><a href="#Good-12" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const menuConfig &#x3D; &#123;</span><br><span class="line">  title: &#39;Order&#39;,</span><br><span class="line">  &#x2F;&#x2F; &#39;body&#39; key 缺失</span><br><span class="line">  buttonText: &#39;Send&#39;,</span><br><span class="line">  cancellable: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function createMenu(config) &#123;</span><br><span class="line">  config &#x3D; Object.assign(&#123;</span><br><span class="line">    title: &#39;Foo&#39;,</span><br><span class="line">    body: &#39;Bar&#39;,</span><br><span class="line">    buttonText: &#39;Baz&#39;,</span><br><span class="line">    cancellable: true</span><br><span class="line">  &#125;, config);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; config 就变成了: &#123;title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true&#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createMenu(menuConfig);</span><br></pre></td></tr></table></figure>
<h2 id="不要传-flag-参数"><a href="#不要传-flag-参数" class="headerlink" title="不要传 flag 参数"></a>不要传 flag 参数</h2><p>通过 flag 的 true 或 false，来判断执行逻辑，违反了一个函数干一件事的原则。(这个持保留意见，只能说尽量不要把分支判断放在函数里面)</p>
<h3 id="Bad-13"><a href="#Bad-13" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createFile(name, temp) &#123;</span><br><span class="line">  if (temp) &#123;</span><br><span class="line">    fs.create(&#96;.&#x2F;temp&#x2F;$&#123;name&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fs.create(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-13"><a href="#Good-13" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createFile(name) &#123;</span><br><span class="line">  fs.create(name);</span><br><span class="line">&#125;</span><br><span class="line">function createFileTemplate(name) &#123;</span><br><span class="line">  createFile(&#96;.&#x2F;temp&#x2F;$&#123;name&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免副作用（第一部分）"><a href="#避免副作用（第一部分）" class="headerlink" title="避免副作用（第一部分）"></a>避免副作用（第一部分）</h2><p>函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。</p>
<p>当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。</p>
<p>副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。</p>
<p>（注：这就是纯函数的作用，同样的输入，返回的一定是同样的输入，这样对于结果是可预料的，不会出现意料之外甚至很难修复的问题）</p>
<h3 id="Bad-14"><a href="#Bad-14" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局变量被一个函数引用</span><br><span class="line">&#x2F;&#x2F; 现在这个变量从字符串变成了数组，如果有其他的函数引用，会发生无法预见的错误。</span><br><span class="line">var name &#x3D; &#39;Ryan McDermott&#39;;</span><br><span class="line"></span><br><span class="line">function splitIntoFirstAndLastName() &#123;</span><br><span class="line">  name &#x3D; name.split(&#39; &#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">splitIntoFirstAndLastName();</span><br><span class="line"></span><br><span class="line">console.log(name); &#x2F;&#x2F; [&#39;Ryan&#39;, &#39;McDermott&#39;];</span><br></pre></td></tr></table></figure>
<h3 id="Good-14"><a href="#Good-14" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Ryan McDermott&#39;;</span><br><span class="line">var newName &#x3D; splitIntoFirstAndLastName(name)</span><br><span class="line"></span><br><span class="line">function splitIntoFirstAndLastName(name) &#123;</span><br><span class="line">  return name.split(&#39; &#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name); &#x2F;&#x2F; &#39;Ryan McDermott&#39;;</span><br><span class="line">console.log(newName); &#x2F;&#x2F; [&#39;Ryan&#39;, &#39;McDermott&#39;];</span><br></pre></td></tr></table></figure>
<h2 id="避免副作用（第二部分）"><a href="#避免副作用（第二部分）" class="headerlink" title="避免副作用（第二部分）"></a>避免副作用（第二部分）</h2><p>在 JavaScript 中，基本类型通过赋值传递，对象和数组通过引用传递。以引用传递为例：</p>
<p>假如我们写一个购物车，通过 addItemToCart() 方法添加商品到购物车，修改 购物车数组。此时调用 purchase() 方法购买，由于引用传递，获取的 购物车数组 正好是最新的数据。</p>
<p>看起来没问题对不对？</p>
<p>如果当用户点击购买时，网络出现故障， purchase() 方法一直在重复调用，与此同时用户又添加了新的商品，这时网络又恢复了。那么 purchase() 方法获取到 购物车数组 就是错误的。</p>
<p>为了避免这种问题，我们需要在每次新增商品时，克隆 购物车数组 并返回新的数组。</p>
<h3 id="Bad-15"><a href="#Bad-15" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const addItemToCart &#x3D; (cart, item) &#x3D;&gt; &#123;</span><br><span class="line">  cart.push(&#123; item, date: Date.now() &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Good-15"><a href="#Good-15" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const addItemToCart &#x3D; (cart, item) &#x3D;&gt; &#123;</span><br><span class="line">  return [...cart, &#123;item, date: Date.now()&#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不要写全局方法"><a href="#不要写全局方法" class="headerlink" title="不要写全局方法"></a>不要写全局方法</h2><p>在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 Array.prototype 上新增一个 diff 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 diff 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 Array 进行扩展。</p>
<h3 id="Bad-16"><a href="#Bad-16" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.diff &#x3D; function diff(comparisonArray) &#123;</span><br><span class="line">  const hash &#x3D; new Set(comparisonArray);</span><br><span class="line">  return this.filter(elem &#x3D;&gt; !hash.has(elem));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Good-16"><a href="#Good-16" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SuperArray extends Array &#123;</span><br><span class="line">  diff(comparisonArray) &#123;</span><br><span class="line">    const hash &#x3D; new Set(comparisonArray);</span><br><span class="line">    return this.filter(elem &#x3D;&gt; !hash.has(elem));        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比起命令式我更喜欢函数式编程"><a href="#比起命令式我更喜欢函数式编程" class="headerlink" title="比起命令式我更喜欢函数式编程"></a>比起命令式我更喜欢函数式编程</h2><p>函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。</p>
<h3 id="Bad-17"><a href="#Bad-17" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const programmerOutput &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;Uncle Bobby&#39;,</span><br><span class="line">    linesOfCode: 500</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Suzie Q&#39;,</span><br><span class="line">    linesOfCode: 1500</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Jimmy Gosling&#39;,</span><br><span class="line">    linesOfCode: 150</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Gracie Hopper&#39;,</span><br><span class="line">    linesOfCode: 1000</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let totalOutput &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; programmerOutput.length; i++) &#123;</span><br><span class="line">  totalOutput +&#x3D; programmerOutput[i].linesOfCode;</span><br></pre></td></tr></table></figure>
<h3 id="Good-17"><a href="#Good-17" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const programmerOutput &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &#39;Uncle Bobby&#39;,</span><br><span class="line">    linesOfCode: 500</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Suzie Q&#39;,</span><br><span class="line">    linesOfCode: 1500</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Jimmy Gosling&#39;,</span><br><span class="line">    linesOfCode: 150</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#39;Gracie Hopper&#39;,</span><br><span class="line">    linesOfCode: 1000</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">let totalOutput &#x3D; programmerOutput</span><br><span class="line">  .map(output &#x3D;&gt; output.linesOfCode)</span><br><span class="line">  .reduce((totalLines, lines) &#x3D;&gt; totalLines + lines, 0)</span><br></pre></td></tr></table></figure>
<h2 id="封装条件语句"><a href="#封装条件语句" class="headerlink" title="封装条件语句"></a>封装条件语句</h2><h2 id="Bad-18"><a href="#Bad-18" class="headerlink" title="Bad:"></a>Bad:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (fsm.state &#x3D;&#x3D;&#x3D; &#39;fetching&#39; &amp;&amp; isEmpty(listNode)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Good-18"><a href="#Good-18" class="headerlink" title="Good:"></a>Good:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 持保留意见</span><br><span class="line">function shouldShowSpinner(fsm, listNode) &#123;</span><br><span class="line">  return fsm.state &#x3D;&#x3D;&#x3D; &#39;fetching&#39; &amp;&amp; isEmpty(listNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尽量别用“非”条件句"><a href="#尽量别用“非”条件句" class="headerlink" title="尽量别用“非”条件句"></a>尽量别用“非”条件句</h2><h3 id="Bad-19"><a href="#Bad-19" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isDOMNodeNotPresent(node) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!isDOMNodeNotPresent(node)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-19"><a href="#Good-19" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isDOMNodePresent(node) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (isDOMNodePresent(node)) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免使用条件语句"><a href="#避免使用条件语句" class="headerlink" title="避免使用条件语句"></a>避免使用条件语句</h2><p>Q：不用条件语句写代码是不可能的。</p>
<p>A：绝大多数场景可以用多态替代。</p>
<p>Q：用多态可行，但为什么就不能用条件语句了呢？</p>
<p>A：为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则。</p>
<h3 id="Bad-20"><a href="#Bad-20" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取巡航高度</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;777&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getPassengerCount();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Air Force One&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude();</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Cessna&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getFuelExpenditure();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-20"><a href="#Good-20" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 波音777</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boeing777</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getPassengerCount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空军一号</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirForceOne</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赛纳斯飞机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cessna</span> <span class="keyword">extends</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">getCruisingAltitude</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getFuelExpenditure();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象使用分支判断</span></span><br><span class="line"><span class="keyword">var</span> Airplane = &#123;</span><br><span class="line">	<span class="string">&#x27;777&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getPassengerCount();</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&#x27;Air Force One&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude();</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&#x27;Cessna&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getMaxAltitude() - <span class="built_in">this</span>.getFuelExpenditure();</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免类型检查（第一部分）"><a href="#避免类型检查（第一部分）" class="headerlink" title="避免类型检查（第一部分）"></a>避免类型检查（第一部分）</h2><p>JavaScript 是无类型的，意味着你可以传任意类型参数，这种自由度很容易让人困扰，不自觉的就会去检查类型。仔细想想是你真的需要检查类型还是你的 API 设计有问题？（注：持保留意见）</p>
<h3 id="Bad-21"><a href="#Bad-21" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Bicycle) &#123;</span><br><span class="line">    vehicle.pedal(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Car) &#123;</span><br><span class="line">    vehicle.drive(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-21"><a href="#Good-21" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  vehicle.move(<span class="built_in">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">&#x27;texas&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免类型检查（第二部分）"><a href="#避免类型检查（第二部分）" class="headerlink" title="避免类型检查（第二部分）"></a>避免类型检查（第二部分）</h2><p>如果你需要做静态类型检查，比如字符串、整数等，推荐使用 TypeScript，不然你的代码会变得又臭又长。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> val2 === <span class="string">&#x27;number&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> val1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> val2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> val1 + val2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Must be of type String or Number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-22"><a href="#Good-22" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要过度优化"><a href="#不要过度优化" class="headerlink" title="不要过度优化"></a>不要过度优化</h2><p>现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间，想知道现代浏览器优化了哪些内容，请点这里。（注：持保留意见，低版本的浏览器没有做该优化，虽然性能提升不大，但这是一个好的编码习惯）</p>
<h3 id="Bad-22"><a href="#Bad-22" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在老的浏览器中，由于 `list.length` 没有做缓存，每次迭代都会去计算，造成不必要开销。</span></span><br><span class="line"><span class="comment">// 现代浏览器已对此做了优化。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-23"><a href="#Good-23" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除弃用代码"><a href="#删除弃用代码" class="headerlink" title="删除弃用代码"></a>删除弃用代码</h2><p>很多时候有些代码已经没有用了，但担心以后会用，舍不得删。</p>
<p>如果你忘了这件事，这些代码就永远存在那里了。</p>
<p>放心删吧，你可以在代码库历史版本中找他它。</p>
<p>（持保留意见，因为保留部分注释的重要代码是以防出现问题可以直接线上恢复代码而不用上紧急版本）</p>
<h3 id="Bad-23"><a href="#Bad-23" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oldRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = newRequestModule;</span><br><span class="line">inventoryTracker(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Good-24"><a href="#Good-24" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newRequestModule</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = newRequestModule;</span><br><span class="line">inventoryTracker(<span class="string">&#x27;apples&#x27;</span>, req, <span class="string">&#x27;www.inventory-awesome.io&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h1><h2 id="用-get、set-方法操作数据"><a href="#用-get、set-方法操作数据" class="headerlink" title="用 get、set 方法操作数据"></a>用 get、set 方法操作数据</h2><p>这样做可以带来很多好处，比如在操作数据时打日志，方便跟踪错误；在 set 的时候很容易对数据进行校验…</p>
<h3 id="Bad-24"><a href="#Bad-24" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeBankAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    balance: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> account = makeBankAccount();</span><br><span class="line">account.balance = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Good-25"><a href="#Good-25" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeBankAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">let</span> balance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setBalance</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 在更新 balance 前，对 amount 进行校验</span></span><br><span class="line">    balance = amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    getBalance,</span><br><span class="line">    setBalance,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> account = makeBankAccount();</span><br><span class="line">account.setBalance(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="使用私有变量"><a href="#使用私有变量" class="headerlink" title="使用私有变量"></a>使用私有变量</h2><p>可以用闭包来创建私有变量</p>
<h3 id="Bad-25"><a href="#Bad-25" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Employee = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Employee.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> employee = <span class="keyword">new</span> Employee(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Employee name: <span class="subst">$&#123;employee.getName()&#125;</span>`</span>); </span><br><span class="line"><span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Employee name: <span class="subst">$&#123;employee.getName()&#125;</span>`</span>);</span><br><span class="line"> <span class="comment">// Employee name: undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="Good-26"><a href="#Good-26" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeEmployee</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> employee = makeEmployee(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Employee name: <span class="subst">$&#123;employee.getName()&#125;</span>`</span>); </span><br><span class="line"><span class="comment">// Employee name: John Doe</span></span><br><span class="line"><span class="keyword">delete</span> employee.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Employee name: <span class="subst">$&#123;employee.getName()&#125;</span>`</span>); </span><br><span class="line"><span class="comment">// Employee name: John Doe</span></span><br></pre></td></tr></table></figure>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="使用-class"><a href="#使用-class" class="headerlink" title="使用 class"></a>使用 class</h2><p>在 ES2015/ES6 之前，没有类的语法，只能用构造函数的方式模拟类，可读性非常差。</p>
<h3 id="Bad-26"><a href="#Bad-26" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Animal)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Instantiate Animal with `new`&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal.prototype.move = <span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哺乳动物</span></span><br><span class="line"><span class="keyword">const</span> Mammal = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Mammal)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Instantiate Mammal with `new`&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Animal.call(<span class="built_in">this</span>, age);</span><br><span class="line">  <span class="built_in">this</span>.furColor = furColor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mammal.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Mammal.prototype.constructor = Mammal;</span><br><span class="line">Mammal.prototype.liveBirth = <span class="function"><span class="keyword">function</span> <span class="title">liveBirth</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span>(<span class="params">age, furColor, languageSpoken</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Human)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Instantiate Human with `new`&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Mammal.call(<span class="built_in">this</span>, age, furColor);</span><br><span class="line">  <span class="built_in">this</span>.languageSpoken = languageSpoken;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Human.prototype = <span class="built_in">Object</span>.create(Mammal.prototype);</span><br><span class="line">Human.prototype.constructor = Human;</span><br><span class="line">Human.prototype.speak = <span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Good-27"><a href="#Good-27" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哺乳动物</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mammal</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age, furColor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(age);</span><br><span class="line">    <span class="built_in">this</span>.furColor = furColor;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">liveBirth</span>(<span class="params"></span>)</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age, furColor, languageSpoken</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(age, furColor);</span><br><span class="line">    <span class="built_in">this</span>.languageSpoken = languageSpoken;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>这种模式相当有用，可以在很多库中发现它的身影，比如 jQuery、Lodash 等。它让你的代码简洁优雅。实现起来也非常简单，在类的方法最后返回 this 可以了。</p>
<h3 id="Bad-27"><a href="#Bad-27" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">make, model, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = make;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setMake</span>(<span class="params">make</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = make;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setModel</span>(<span class="params">model</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.make, <span class="built_in">this</span>.model, <span class="built_in">this</span>.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">&#x27;Ford&#x27;</span>,<span class="string">&#x27;F-150&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">car.setColor(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">car.save();</span><br></pre></td></tr></table></figure>
<h3 id="Good-28"><a href="#Good-28" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">make, model, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = make;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setMake</span>(<span class="params">make</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.make = make;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setModel</span>(<span class="params">model</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">save</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.make, <span class="built_in">this</span>.model, <span class="built_in">this</span>.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">&#x27;Ford&#x27;</span>,<span class="string">&#x27;F-150&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  .setColor(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">  .save();</span><br></pre></td></tr></table></figure>
<h2 id="不要滥用继承"><a href="#不要滥用继承" class="headerlink" title="不要滥用继承"></a>不要滥用继承</h2><p>很多时候继承被滥用，导致可读性很差，要搞清楚两个类之间的关系，继承表达的一个属于关系，而不是包含关系，比如 Human-&gt;Animal vs. User-&gt;UserDetails</p>
<h3 id="Bad-28"><a href="#Bad-28" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, email</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.email = email;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaxData（税收信息）并不是属于 Employee（雇员），而是包含关系。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-29"><a href="#Good-29" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeTaxData</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, email</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.email = email;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setTaxData</span>(<span class="params">ssn, salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.taxData = <span class="keyword">new</span> EmployeeTaxData(ssn, salary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h1><p>SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。</p>
<h2 id="单一功能原则-The-Single-Responsibility-Principle"><a href="#单一功能原则-The-Single-Responsibility-Principle" class="headerlink" title="单一功能原则 The Single Responsibility Principle"></a>单一功能原则 The Single Responsibility Principle</h2><p>如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p>
<h3 id="Bad-29"><a href="#Bad-29" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSettings</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">changeSettings</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.verifyCredentials()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">verifyCredentials</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-30"><a href="#Good-30" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAuth</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">verifyCredentials</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSetting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">    <span class="built_in">this</span>.auth = <span class="keyword">new</span> UserAuth(<span class="built_in">this</span>.user);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">changeSettings</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.auth.verifyCredentials()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开闭原则-The-Open-Closed-Principle"><a href="#开闭原则-The-Open-Closed-Principle" class="headerlink" title="开闭原则 The Open Closed Principle"></a>开闭原则 The Open Closed Principle</h2><p>“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。</p>
<h3 id="Bad-30"><a href="#Bad-30" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxAdapter</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;ajaxAdapter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeAdapter</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;nodeAdapter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">adapter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">fetch</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.adapter.name === <span class="string">&#x27;ajaxAdapter&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> makeAjaxCall(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 传递 response 并 return</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.adapter.name === <span class="string">&#x27;httpNodeAdapter&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> makeHttpCall(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 传递 response 并 return</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 request 并 return promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHttpCall</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 request 并 return promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-31"><a href="#Good-31" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjaxAdapter</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;ajaxAdapter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">request</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 request 并 return promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeAdapter</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;nodeAdapter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">request</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 request 并 return promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">adapter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">fetch</span>(<span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.adapter.request(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 传递 response 并 return</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则 Liskov Substitution Principle"></a>里氏替换原则 Liskov Substitution Principle</h2><p>名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。</p>
<h3 id="Bad-31"><a href="#Bad-31" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">area</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setWidth</span>(<span class="params">width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setHeight</span>(<span class="params">height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setWidth</span>(<span class="params">width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">    <span class="built_in">this</span>.height = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setHeight</span>(<span class="params">height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = height;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeRectangles</span>(<span class="params">rectangles</span>) </span>&#123;</span><br><span class="line">  rectangles.forEach(<span class="function">(<span class="params">rectangle</span>) =&gt;</span> &#123;</span><br><span class="line">    rectangle.setWidth(<span class="number">4</span>);</span><br><span class="line">    rectangle.setHeight(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">const</span> area = rectangle.getArea(); </span><br><span class="line">    rectangle.render(area);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangles = [<span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Rectangle(), <span class="keyword">new</span> Square()];</span><br><span class="line">renderLargeRectangles(rectangles);</span><br></pre></td></tr></table></figure>
<h3 id="Good-32"><a href="#Good-32" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">area</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">width, height</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.length = length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderLargeShapes</span>(<span class="params">shapes</span>) </span>&#123;</span><br><span class="line">  shapes.forEach(<span class="function">(<span class="params">shape</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> area = shape.getArea();</span><br><span class="line">    shape.render(area);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [<span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">5</span>), <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">5</span>), <span class="keyword">new</span> Square(<span class="number">5</span>)];</span><br><span class="line">renderLargeShapes(shapes);</span><br></pre></td></tr></table></figure>
<h2 id="接口隔离原则-The-Interface-Segregation-Principle"><a href="#接口隔离原则-The-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则 The Interface Segregation Principle"></a>接口隔离原则 The Interface Segregation Principle</h2><p>JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。</p>
<h3 id="Bad-32"><a href="#Bad-32" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.settings = settings;</span><br><span class="line">    <span class="built_in">this</span>.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootNode = <span class="built_in">this</span>.settings.rootNode;</span><br><span class="line">    <span class="built_in">this</span>.animationModule.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">traverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</span><br><span class="line">  rootNode: <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  <span class="function"><span class="title">animationModule</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">// Most of the time, we won&#x27;t need to animate when traversing.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-33"><a href="#Good-33" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMTraverser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">settings</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.settings = settings;</span><br><span class="line">    <span class="built_in">this</span>.options = settings.options;</span><br><span class="line">    <span class="built_in">this</span>.setup();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rootNode = <span class="built_in">this</span>.settings.rootNode;</span><br><span class="line">    <span class="built_in">this</span>.setupOptions();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setupOptions</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.options.animationModule) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">traverse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $ = <span class="keyword">new</span> DOMTraverser(&#123;</span><br><span class="line">  rootNode: <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>),</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="function"><span class="title">animationModule</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="依赖倒置原则-The-Dependency-Inversion-Principle"><a href="#依赖倒置原则-The-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则 The Dependency Inversion Principle"></a>依赖倒置原则 The Dependency Inversion Principle</h2><p>说就两点：</p>
<ul>
<li><p>高层次模块不能依赖低层次模块，它们依赖于抽象接口。</p>
</li>
<li><p>抽象接口不能依赖具体实现，具体实现依赖抽象接口。</p>
</li>
</ul>
<p>总结下来就两个字，解耦。</p>
<h3 id="Bad-33"><a href="#Bad-33" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 库存查询</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequester</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库存跟踪</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">items</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里依赖一个特殊的请求类，其实我们只是需要一个请求方法。</span></span><br><span class="line">    <span class="built_in">this</span>.requester = <span class="keyword">new</span> InventoryRequester();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.requester.requestItem(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>]);</span><br><span class="line">inventoryTracker.requestItems();</span><br></pre></td></tr></table></figure>
<h3 id="Good-34"><a href="#Good-34" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 库存跟踪</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">items, requester</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = items;</span><br><span class="line">    <span class="built_in">this</span>.requester = requester;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.requester.requestItem(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterHTTP</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;HTTP&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webSocket 请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryRequesterWS</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.REQ_METHODS = [<span class="string">&#x27;WS&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">requestItem</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过依赖注入的方式将请求模块解耦，这样我们就可以很轻易的替换成 webSocket 请求。</span></span><br><span class="line"><span class="keyword">const</span> inventoryTracker = <span class="keyword">new</span> InventoryTracker([<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>], <span class="keyword">new</span> InventoryRequesterHTTP());</span><br><span class="line">inventoryTracker.requestItems();</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>随着项目变得越来越庞大，时间线拉长，有的老代码可能半年都没碰过，如果此时上线，你有信心这部分代码能正常工作吗？测试的覆盖率和你的信心是成正比的。</p>
<p>PS: 如果你发现你的代码很难被测试，那么你应该优化你的代码了。</p>
<h2 id="单一化"><a href="#单一化" class="headerlink" title="单一化"></a>单一化</h2><h3 id="Bad-34"><a href="#Bad-34" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> assert <span class="keyword">from</span> <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;handles date boundaries&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date;</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">30</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;1/31/2015&#x27;</span>, date);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line"></span><br><span class="line">    date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-35"><a href="#Good-35" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> assert <span class="keyword">from</span> <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;MakeMomentJSGreatAgain&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;handles 30-day months&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;1/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">30</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;1/31/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;handles leap year&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2016&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;02/29/2016&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;handles non-leap year&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> MakeMomentJSGreatAgain(<span class="string">&#x27;2/1/2015&#x27;</span>);</span><br><span class="line">    date.addDays(<span class="number">28</span>);</span><br><span class="line">    assert.equal(<span class="string">&#x27;03/01/2015&#x27;</span>, date);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="不再使用回调"><a href="#不再使用回调" class="headerlink" title="不再使用回调"></a>不再使用回调</h2><p>不会有人愿意去看嵌套回调的代码，用 Promises 替代回调吧。</p>
<h3 id="Bad-35"><a href="#Bad-35" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; get &#125; <span class="keyword">from</span> <span class="string">&#x27;request&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>, <span class="function">(<span class="params">requestErr, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (requestErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(requestErr);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    writeFile(<span class="string">&#x27;article.html&#x27;</span>, response.body, <span class="function">(<span class="params">writeErr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (writeErr) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(writeErr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-36"><a href="#Good-36" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Async-Await-比起-Promises-更简洁"><a href="#Async-Await-比起-Promises-更简洁" class="headerlink" title="Async/Await 比起 Promises 更简洁"></a>Async/Await 比起 Promises 更简洁</h2><h3 id="Bad-36"><a href="#Bad-36" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; get &#125; <span class="keyword">from</span> <span class="string">&#x27;request-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs-promise&#x27;</span>;</span><br><span class="line"></span><br><span class="line">get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-37"><a href="#Good-37" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; get &#125; <span class="keyword">from</span> <span class="string">&#x27;request-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; writeFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs-promise&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getCleanCodeArticle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> get(<span class="string">&#x27;https://en.wikipedia.org/wiki/Robert_Cecil_Martin&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> writeFile(<span class="string">&#x27;article.html&#x27;</span>, response);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;File written&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要忽略抛异常"><a href="#不要忽略抛异常" class="headerlink" title="不要忽略抛异常"></a>不要忽略抛异常</h2><h3 id="Bad-37"><a href="#Bad-37" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  functionThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-38"><a href="#Good-38" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  functionThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 这一种选择，比起 console.log 更直观</span></span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">  <span class="comment">// 也可以在界面上提醒用户</span></span><br><span class="line">  notifyUserOfError(error);</span><br><span class="line">  <span class="comment">// 也可以把异常传回服务器</span></span><br><span class="line">  reportErrorToService(error);</span><br><span class="line">  <span class="comment">// 其他的自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要忘了在-Promises-抛异常"><a href="#不要忘了在-Promises-抛异常" class="headerlink" title="不要忘了在 Promises 抛异常"></a>不要忘了在 Promises 抛异常</h2><h3 id="Bad-38"><a href="#Bad-38" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getdata()</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    functionThatMightThrow(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Good-39"><a href="#Good-39" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getdata()</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    functionThatMightThrow(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这一种选择，比起 console.log 更直观</span></span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    <span class="comment">// 也可以在界面上提醒用户</span></span><br><span class="line">    notifyUserOfError(error);</span><br><span class="line">    <span class="comment">// 也可以把异常传回服务器</span></span><br><span class="line">    reportErrorToService(error);</span><br><span class="line">    <span class="comment">// 其他的自定义方法</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。</p>
<h2 id="常量大写"><a href="#常量大写" class="headerlink" title="常量大写"></a>常量大写</h2><h3 id="Bad-39"><a href="#Bad-39" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DAYS_IN_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> daysInMonth = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> songs = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> Artists = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restore_database</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-40"><a href="#Good-40" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DAYS_IN_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> DAYS_IN_MONTH = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SONGS = [<span class="string">&#x27;Back In Black&#x27;</span>, <span class="string">&#x27;Stairway to Heaven&#x27;</span>, <span class="string">&#x27;Hey Jude&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> ARTISTS = [<span class="string">&#x27;ACDC&#x27;</span>, <span class="string">&#x27;Led Zeppelin&#x27;</span>, <span class="string">&#x27;The Beatles&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eraseDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restoreDatabase</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alpaca</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="先声明后调用"><a href="#先声明后调用" class="headerlink" title="先声明后调用"></a>先声明后调用</h2><p>就像我们看报纸文章一样，从上到下看，所以为了方便阅读把函数声明写在函数调用前面。</p>
<h3 id="Bad-40"><a href="#Bad-40" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">employee</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.employee = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupPeers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupManager</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getPeerReviews</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> peers = <span class="built_in">this</span>.lookupPeers();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">perfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getPeerReviews();</span><br><span class="line">    <span class="built_in">this</span>.getManagerReview();</span><br><span class="line">    <span class="built_in">this</span>.getSelfReview();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getManagerReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> manager = <span class="built_in">this</span>.lookupManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getSelfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> review = <span class="keyword">new</span> PerformanceReview(employee);</span><br><span class="line">review.perfReview();</span><br></pre></td></tr></table></figure>
<h3 id="Good-41"><a href="#Good-41" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerformanceReview</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">employee</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.employee = employee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">perfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getPeerReviews();</span><br><span class="line">    <span class="built_in">this</span>.getManagerReview();</span><br><span class="line">    <span class="built_in">this</span>.getSelfReview();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getPeerReviews</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> peers = <span class="built_in">this</span>.lookupPeers();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupPeers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;peers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getManagerReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> manager = <span class="built_in">this</span>.lookupManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lookupManager</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.lookup(<span class="built_in">this</span>.employee, <span class="string">&#x27;manager&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getSelfReview</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> review = <span class="keyword">new</span> PerformanceReview(employee);</span><br><span class="line">review.perfReview();</span><br></pre></td></tr></table></figure>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="只有业务逻辑需要注释"><a href="#只有业务逻辑需要注释" class="headerlink" title="只有业务逻辑需要注释"></a>只有业务逻辑需要注释</h2><p>代码注释不是越多越好。（注：语义化的命名可以减少很多不必要的注释，最好的代码是自解释的，不要过分地追求注释，影响代码的阅读。）</p>
<h3 id="Bad-41"><a href="#Bad-41" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是初始值</span></span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组的长度</span></span><br><span class="line">  <span class="keyword">const</span> length = data.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取字符代码</span></span><br><span class="line">    <span class="keyword">const</span> char = data.charCodeAt(i);</span><br><span class="line">    <span class="comment">// 修改 hash</span></span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line">    <span class="comment">// 转换为32位整数</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-42"><a href="#Good-42" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hashIt</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = data.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = data.charCodeAt(i);</span><br><span class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + char;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为32位整数</span></span><br><span class="line">    hash &amp;= hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删掉注释的代码"><a href="#删掉注释的代码" class="headerlink" title="删掉注释的代码"></a>删掉注释的代码</h2><p>git 存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧。</p>
<h3 id="Bad-42"><a href="#Bad-42" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doStuff();</span><br><span class="line"><span class="comment">// doOtherStuff();</span></span><br><span class="line"><span class="comment">// doSomeMoreStuff();</span></span><br><span class="line"><span class="comment">// doSoMuchStuff();</span></span><br></pre></td></tr></table></figure>
<h3 id="Good-43"><a href="#Good-43" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doStuff();</span><br></pre></td></tr></table></figure>
<p>javascript</p>
<p>不要记日记<br>记住你有 git！，git log 可以帮你干这事。</p>
<h3 id="Bad-43"><a href="#Bad-43" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2016-12-20: 删除了 xxx</span></span><br><span class="line"><span class="comment"> * 2016-10-01: 改进了 xxx</span></span><br><span class="line"><span class="comment"> * 2016-02-03: 删除了第12行的类型检查</span></span><br><span class="line"><span class="comment"> * 2015-03-14: 增加了一个合并的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Good-44"><a href="#Good-44" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释不需要高亮"><a href="#注释不需要高亮" class="headerlink" title="注释不需要高亮"></a>注释不需要高亮</h2><p>注释高亮，并不能起到提示的作用，反而会干扰你阅读代码。（注：在联调或临时修改代码调试的时候可以用此方法引起自己的注意，保证在提交代码的时候可以注意到此处，不会造成调试代码的提交）</p>
<h3 id="Bad-44"><a href="#Bad-44" class="headerlink" title="Bad:"></a>Bad:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Scope Model Instantiation</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">$scope.model = &#123;</span><br><span class="line">  menu: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  nav: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Action setup</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Good-45"><a href="#Good-45" class="headerlink" title="Good:"></a>Good:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$scope.model = &#123;</span><br><span class="line">  menu: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  nav: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文末推荐一篇很好的讲述前端代码规范的文章，包含前端各种代码的规范，我觉得可以根据自己公司项目的实际情况借鉴一二。<a href="https://guide.aotu.io/docs/index.html">前端代码规范</a></p>
<blockquote>
<p>翻译自 ryanmcdermott 的 <a href="https://github.com/ryanmcdermott/clean-code-javascript">clean-code-javascript</a>，本文对原文进行了一些修改。</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript 代码 风格 编码</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀技术人，如何做到高效沟通？</title>
    <url>/2020/07/21/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E4%BA%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>简介：</strong> 世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。</p>
<p> <img src="https://i.loli.net/2021/01/11/Gp3FTEAmoUzbk59.png" alt="1.png"> </p>
<p>作者 | 鲁佳(鹿迦) 阿里巴巴项目管理专家</p>
<p><strong>导读：</strong>世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。</p>
<a id="more"></a>

<h1 id="为什么沟通那么重要"><a href="#为什么沟通那么重要" class="headerlink" title="为什么沟通那么重要"></a>为什么沟通那么重要</h1><p>谁都知道在工作中沟通是非常重要的，那大家有没有真正想过为什么沟通这么重要呢？</p>
<p>首先我们想想看，在你的日常工作时间分配上，“沟通”所用的时间占比多少呢？日常的会议、在钉钉上的讨论、处理邮件等等，反正我个人是远远超过了 50% 的。这就和管理学上的一个著名理论很契合了：</p>
<blockquote>
<p>管理者 50% 以上的时间用在了沟通上，但同时工作中 50% 以上的障碍都是在沟通中产生的。</p>
</blockquote>
<p>这就是<strong>“双 50% 理论”</strong>，这直观的反应了不论是在占用时间上，还是对工作的影响程度上，沟通都是至关重要的。</p>
<p><img src="https://i.loli.net/2021/01/11/SlecWmMatwKXTyf.png" alt="2.png"></p>
<p>为什么团队里开会大家总是很沉默，有想法的同学也不吭声？上面这个图大家应该在各种不同的渠道都看到过吧，相信大在第一次看到这个图的时候都会和我一样会心一笑吧。</p>
<p>为什么这张图能有这样的效果呢？因为这个图所表现出来的问题真的非常好的影射了我们日常实际工作的情况：<strong>由于沟通不到位的问题导致一个产品在不同的角色的理解上造成了这么巨大的差异</strong>。那么在像阿里这样的互联网公司，工作量常见的沟通问题都要哪些呢？</p>
<p>这里做一些简单的列举：</p>
<ul>
<li>为什么推动兄弟团队配合这么难，他们配合的进度完全不可控？</li>
<li>为什么工作布置给了下属，但是最后又都堆积到了我这里？</li>
<li>为什么会议讨论留下来的 action 执行起来总是拖拖拉拉完成不了？</li>
<li>为什么老板最近的消息经常已读不回？</li>
<li>为什么整天被钉钉消息淹没了，个人的事情只能在夜深人静加班做了？</li>
<li>……</li>
</ul>
<p>这么多的沟通问题，那沟通问什么这么困难呢？这里从最常见的情况来看，特别是在 1 对 1 的沟通中，主要有三个主要的原因：</p>
<p><img src="https://i.loli.net/2021/01/11/KoPgWSIZfrElj48.png" alt="3.png"></p>
<p>既然沟通的问题很多，导致问题的原因也非常复杂，那我们的出路在哪里呢？是不是解决办法就是标准化我们的工作，然后通过标准化、流程化来让我们的工作减少沟通的需求，然后大家都可以在自己的工位安安静静写代码、写方案、这样就万事大吉了呢？答案是否定的。</p>
<p>我们来看这个象限图，这个是李开复博士在对未来 AI 的设想中提到的一个模型：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knti0jcMCt2Ci7bIGWoymBhfiEKVE3Du6cIRlv.O8tjdrNzKokJCwQ3VQbMGTzpG4qYIg8OwdBEWVuNc2b0NhEUgI!/b&bo=IAO3ASADtwEDKQw!&rf=viewer_4" alt="4.png"></p>
<p>可以看到，在区间图的左下角的岗位对应的是低社交需求，并且是结构化的领域，在这样的领域的岗位，未来 5-10 就会被 AI 机器人所取代。</p>
<p>如果我们的工作能够简单的通过定义标准化的接口做到按流程执行，从而避免或减少沟通，那我们的工作的价值就会降低，从而最终被机器取代，就像流水线上的工人正在大量被智能机器人所取代那样。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntv1FFeuM8n7CfmKfo4wd7YcmJNrE*5eg5Ib4LevNZfE1rZbjmao8lC4rCTaiaw1dpMYLqALD36puhpsU79n*PTk!/b&bo=IAMbASADGwEDORw!&rf=viewer_4" alt="5.png"></p>
<p>我想说的意思不是说为了体现工作的价值，要故意提高工作的沟通成本，相反，我们的确需要通过归纳总结梳理标准话的流程、甚至是工具化的手段来降低一个领域的沟通，但我们同时工作在找更复杂、更需要去沟通的场景中，去创造更大的价值。</p>
<p>所以我们要做的是<strong>保持竞争力，持续提升沟通能力</strong>。这个才是大家每个人要持续努力的方向。</p>
<h1 id="沟通的基础"><a href="#沟通的基础" class="headerlink" title="沟通的基础"></a>沟通的基础</h1><p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntj*aLMNOw88KubHENWOqvhiih9bnVV6f.Go.V169wxyI6J7duk1COOE2s4fe5QezV4lY3rIYQbhpQDHVF4BXTDM!/b&bo=IAMzAiADMwIDSWw!&rf=viewer_4" alt="6.png"></p>
<p>有一个西方的谚语是这么说的，“世界上有两件最难的事：把别人的钱装进自己的口袋；把自己的思想装进别人的脑袋。”就像图上的这个场景一样，在沟通遇到问题的时候，大家往往都会觉得自己是对的，都想要说服对方，但有都总是困难重重。</p>
<p>沟通失败的原因总是多种多样，要么是表达上的问题，要么是倾听和反馈上的问题，要么是环境上带来的问题。列举下来，一般的情况有：</p>
<ul>
<li>缺乏信息或知识</li>
<li>没有说明重要性</li>
<li>只注重了表达、没有注重倾听</li>
<li>没有完全理解对方的话，以至于询问不当</li>
<li>没有注重反馈</li>
<li>时间不够</li>
<li>不良情绪</li>
<li>职位的差距、文化的差距</li>
</ul>
<p>首先，我们来一起了解一下沟通模型。沟通是从信息发送者出发，到信息接受者收到消息，然后给出反馈到信息发送者的一个完整闭环。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntk9uiF5RI37ymmVus*kLfqAEou*49srIufRwlll8T3KsvMMJebBRF5T*ooGkPzG1pIJPLcKQM0wWR.L4eYnJrpo!/b&bo=IAOcASADnAEDGTw!&rf=viewer_4" alt="7.png"></p>
<p>这里的编码，可能是文字，也可以是声音，甚至是手势、表情；通道可以是钉钉、邮件、视频、也可以是面对面；各种外界环境可能带来噪音，比如心情不好，或者大家背景不同、缺少共同语言，并行沟通的影响等等。</p>
<p>可以看到，一个最小闭环的沟通过程，因为涉及多个环节，其实形成了一个较长的链路，链路一旦长了，在链路上的各个环节都容易出现问题，最终就会将问题层层放大。这里就必须给大家介绍一下沟通漏斗的理论了。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntixkNl9.OLEqhOgppV9pvJnKpcwnL7QDPHIl9bl7XQOkUnNBtzdbw3Rd1zezn6XPyD6.wC3eGS1UbKullRlilpo!/b&bo=IAOLASADiwEDGTw!&rf=viewer_4" alt="8.png"></p>
<p>这里必须要知道沟通漏斗的形成过程。举个例子，比如一个开发的 leader，发现最近项目开发中引入的问题比较多，产品好几次遇到严重的线上质疑，于是他决定开个会整改，晚上睡不着觉心里想怎么解决呢？</p>
<p>想到了 10 个方面（100%）的问题的，需要与下属员工讲。当第二天站在众人面前开会时，由于没休息好并且紧张，想到的 10 件事情，只说出了其中的 8 件，漏掉了 2 件，也就是只说出了 80%。而这 8 件事在当众讲的时候，由于场地的限制、人员的多少等关系影响，造成员工真正听到的是有 6 件事（60%）。</p>
<p>又由于员工水平、知识背景的差异，我们的技术 leader 语言表达的高低、语言口音方言等实际情况，真正被别人理解、消化的东西大概只有 40%。等到这些人去落地执行时，由于每件事情与个人关系的大小、执行的意愿强弱等因素，造成到最后得到执行的已经变成 20% 了；虽然这个比例比较夸张，实际并没有这么严重，但是这个沟通造成的漏斗确是实实在在存在的，我们只能想办法将他变得影响越小越好。</p>
<p>那么到底有没有办法减少或消除这个沟通造成的漏斗现象呢？我们从说、听、问三个角度来看一下。</p>
<h2 id="沟通基础一：表达"><a href="#沟通基础一：表达" class="headerlink" title="沟通基础一：表达"></a>沟通基础一：表达</h2><p>沟通的基础，第一条就是表达，就是发送信息。我们的马老师是公认的演讲高手，他的表达能力就非常强。</p>
<p>在表达上，除了我们大家比较了解的，需要有易懂的语言、清晰地逻辑，我们还需要注意什么呢？看马老师的形象我们就清楚了，那就是语气、表情、肢体动作这些。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knttn1TWZHASuZOI9V4SifG8Is6LYbIJfM3hLJuyAAorpZATbgggQef.p5hrAGyIs2KgMJJfk1*LMfvNF4*Yx28r8!/b&bo=IANyASADcgEDKQw!&rf=viewer_4" alt="9.png"></p>
<p>在沟通管理领域，有一个非常著名的理论，<strong>“沟通 = 7% 内容 + 38% 声音 + 55% 肢体语言”</strong>，这充分说明了身体语言在沟通过程中的重要性。这里，给大家在沟通表达时的身体语言提供一些建议：</p>
<ul>
<li>语言和身体语言必须保持一致</li>
<li>设法一开始引起对方的注意</li>
<li>如果必要，需要重复、改述</li>
<li>用对方熟悉的语言</li>
<li>要：正面面对、点头、微笑、身体前倾、目光接触</li>
<li>不要：双手抱在胸前、眼神游离、干别的事</li>
</ul>
<p>再举一个我们日常中最常见的例子。日常我们用钉钉做沟通比较多，同样的一句话，如果用不同的语调会表示不同的态度、表达不同的意思（如“这个需求提测了吗？”，是询问还是催促？）。所以我在钉钉上询问别人类似的问题时，总担心被误解，一般都会增加一个笑脸的表情包，不知道大家有没有这样的做法呢？^_^</p>
<h2 id="沟通基础二：倾听"><a href="#沟通基础二：倾听" class="headerlink" title="沟通基础二：倾听"></a>沟通基础二：倾听</h2><p>沟通的第二个基础就是听。沟通的关键往往是接收者、听者，而非说话者。越是成功的人，往往越是擅于倾听的人。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntnLDy.qV9BQp3qITpwCUD3pCH4sXiu3Il5Gy3uxJ*pljr4R7PAdlPq7KoJgXNyaEe5oKLSdGnzHg5UNol6eVP3M!/b&bo=IAOkASADpAEDGTw!&rf=viewer_4" alt="10.png"></p>
<p>相对于简体字（用口听），繁体字的“听”更能体现倾听的精髓（看来我们古人还是的智慧还是很了不起的）：</p>
<ul>
<li><strong>“耳王”</strong>：既然是听，最重要的器官无疑是耳朵，所以听的要义就是以耳为王，带着耳朵来，把倾听放在第一位；</li>
<li><strong>“十四”</strong>：其中的“四”可以看成“目”，也就是眼睛。听不光用耳朵，还要用眼睛，对方的眼神、表情、肢体语言，都包含着丰富的信息，是与对方提供的资料或实物相配合的；</li>
<li><strong>“一心”</strong>：要达到沟通的目的，收到最佳的效果，必须要用心，而且要一心一意。是用心去听讲，用心去观察，用心去提问，用心去思考。</li>
</ul>
<p>倾听也分成几个不同的层次：</p>
<ul>
<li>听而不闻</li>
<li>假装倾听</li>
<li>选择性倾听</li>
<li>专注的倾听</li>
<li>设身处地的倾听</li>
</ul>
<p>其他第五层和第四层的区别是，专注的听还是为了对听到的内容作出反应，但设身处地的听是为了了解对方，而不是为了做反应，目的是通过交流了解对方的观念、感受，真正做到同理心。</p>
<h2 id="沟通基础三：提问"><a href="#沟通基础三：提问" class="headerlink" title="沟通基础三：提问"></a>沟通基础三：提问</h2><p>沟通的第三个基础就是提问，会提问的人更是沟通达人。擅长说的人，沟通的主要时间都是他在讲，不用担心冷场，而且他可以讲得很精彩。典型的就是培训老师；擅长问的人，和他说话时他说的不多，但往往提出一些发人深省的问题，让你娇躯（或者虎躯）一震，打开一个新的世界。所以，善于提问的人才是正在引导沟通方向的人。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntr9UXEbLrKRyF647WJZyUGLvDmabD5p7b*BCZ8RJvFHCjluH3gipjUdcj6kjfA9hnCtS*WsTEgvQLf4987n1Uic!/b&bo=IAOeASADngEDGTw!&rf=viewer_4" alt="11.png"></p>
<p>一般提问的方式有四种，不同的场合环境和目的需要采用不同的提问方式：</p>
<ul>
<li><strong>封闭式</strong>：你同意这个方案吗？我们能按期完成这个任务吗？</li>
<li><strong>开放式</strong>：你有什么好的建议吗？</li>
<li><strong>引导式</strong>：如果资源的问题解决了，你第一步打算怎么做？</li>
<li><strong>反问式</strong>：如果你一味地回答对方问题，就会很容易陷入被动局势。如何让谈话走上你的频道？反问式提问便是一个高招， 例如：“我想问一下，这个需求开发排期是怎么样的？”“那业务的运营节奏是怎样的呢？”</li>
</ul>
<h1 id="团队内沟通和跨团队沟通"><a href="#团队内沟通和跨团队沟通" class="headerlink" title="团队内沟通和跨团队沟通"></a>团队内沟通和跨团队沟通</h1><p>接下来给大家介绍三组最常见的沟通场景，这些沟通场景也是日常工作中最容易遇到困难的地方。首先介绍团队内的沟通和跨团队的沟通。</p>
<h2 id="1-团队内沟通"><a href="#1-团队内沟通" class="headerlink" title="1. 团队内沟通"></a>1. 团队内沟通</h2><p>团队内的沟通是大家每个人首先要面的的场景。在团队里，一般来说有3种沟通的模式。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntoXtLjUy.UiO1g2tZ*6pBnmFpaSMOOxa89MhcmFk*T4Z5ThoFYWmknyloFiCiOznUWrKDHwwzOCOPG4HNycnWs8!/b&bo=IAMOASADDgEDGTw!&rf=viewer_4" alt="12.png"></p>
<ul>
<li><strong>链式：</strong>严格遵循正式的指挥链和沟通链，信息线性传递，如在军事化的组织里就比较常见；</li>
<li><strong>轮式：</strong>轮式沟通仰赖核心人物作为所有成员沟通的引线和中心节点，可以激发强而有力的领导人物出现；</li>
<li><strong>网式：</strong>允许所有团体成员积极主动的沟通，所有成员均能自由的贡献自我，没有信息的中间节点，也没有明显的领导者角色。</li>
</ul>
<p>这里，我们对这三种模式做了一个对比：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntnmu6wLy*09j9c*IvIhyZLq7koGJUvI*yk*cD9pJ3bbFOhgSuYPf8zHKHVQuP.5VfirDTxtXPkmreiMI.yHMV9o!/b&bo=IAOqASADqgEDGTw!&rf=viewer_4" alt="13.png"></p>
<p>在像阿里这种互联网的公司里，如果没有特别的原因，我们会更倾向引导团队超第三种模式，“网状”的沟通模式发展。推荐网状的沟通模式并不是说我们对准确性的要求不高，相反，因为我们有很多非常有效的工具，能够保障我们在网状沟通中仍然保持较高的信息准确性，比如语雀、Aone、钉钉等。</p>
<p>在团队沟通里，我们就不得不提团队沟通协作的五大障碍。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntm0TDh7aPzTvXA3mK.isCXKXUoo2gWnpjcIZHdwQRh399RKR7KTLvF.EfP75xMquhiTo8i0y1ucF08TTvKElang!/b&bo=IAN4ASADeAEDGTw!&rf=viewer_4" alt="14.png"></p>
<ul>
<li><p>首先在团内里经常出现的问题是“缺少信任“，这个在新组建的团队里特别常见；  </p>
</li>
<li><p>缺少信任之后就会给团队带来第二个问题，那就是”害怕冲突“，最常见的就是在会议上大家都沉默不发言；因为缺少信任，大家不知道自己不同的意见会导致别人什么样的反应，为了安全，不发言是最稳妥的；</p>
</li>
<li><p>害怕冲突的团队自然会带来第三个问题”缺乏承诺“。可以想象，如果自已不同的观点没有表达出来，那么团队最终达成的结论，我是不会有太强的承诺的，因为自己对这个结论心里并不认同；  </p>
</li>
<li><p>缺乏承诺继续会导致问题，那就是”逃避责任“，没有承诺的结论如果后续导致了不好的结果，团队成员自然不想对这个结果承担责任，他会心里想，这个本来就不是我希望的做法，看，果然出问题了吧；  </p>
</li>
<li><p>逃避责任的最终就会团队成员”忽视结果“，如果团队成员自己团队的结果都无感了，那么这个团队也就名存实亡了。</p>
</li>
</ul>
<p>如果大家对团队沟通协作的五大障碍有兴趣，希望更深入的了解，推荐大家看一本书《团队协作的五大障碍》。</p>
<p>那问题来了，对于团队里沟通协作的五大障碍之首的”信任“，要怎么培养呢？在团队里建立信任我们有很多办法，比如从小的来说我们要加强团队成员的相互了解，在阿里，我们常见的有破冰（想必大家都经历过）、team building 等等，还有一个建立信任的说法是”一起同过窗,一起扛过枪“，这样大家就比较容易建立相互信任的关系。</p>
<p>不过建立信任也不一定是这样刻意，或者一定要经历历史性的大战役才能培养，其实“信任”是在一次次达成并保持的小的约定的基础上建立起来的。比如大家约定的一个文档产出时间，大家约定的一个会前准备工作，只要类似这种小小的约定能持续达成，大家间的信任就能有效的建立。</p>
<p>团队里的冲突往往是破坏团队沟通氛围的重要因素，不希望团队里有成员的冲突往往是大家共同的想法。不过这里要想和大家聊一聊的是，冲突对于团队的沟通一定是件坏事情吗？</p>
<p>答案是否定的，团队可以从健康的富有成效的分歧及处理中得到成长。对团队不利的是”破坏性冲突“，但对团队有价值的是”建设性的冲突“，我们一起来看看这两种冲突有什么区别：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntlf2NmndMFhNCo9oB4ieaG9hO5dhOtUcHHGqxVAHBHvHfL3qCYYIXVv1Yo.YROueZU8CczFRDnIpgHo*BcGqLiI!/b&bo=IANlASADZQEDKQw!&rf=viewer_4" alt="15.png"></p>
<p>在团队里，阻碍健康冲突的原因一般有：</p>
<ul>
<li>缺乏信任、尊重和理解</li>
<li>过强势的管理风格</li>
<li>团队成员不稳定或跨地域</li>
</ul>
<h2 id="2-跨团队沟通"><a href="#2-跨团队沟通" class="headerlink" title="2. 跨团队沟通"></a>2. 跨团队沟通</h2><p>在跨团队沟通我们经常遇到的各种问题，我们先简单给大家罗列一下：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqTV1ZkgFVO3hG4Hjq32RwYY504L6sRLFYFWjO5sLi2jEM8VwYlHUcS4fU64tTD8bawzFmXjrSuLl7yBxrwOS6U!/b&bo=IAPAASADwAEDKQw!&rf=viewer_4" alt="16.png"></p>
<ul>
<li>专业有 gap，缺少共同语言。比如业务开发的团队依赖中台的能力，如果业务开发团队不了解中台产品的当前现有的体系，讲不清楚对中台需求的需求，就会出现这种情况，最终导致沟通意愿受损，沟通出问题；</li>
<li>目标达不成一致（受部门墙的影响），比如你计划一个战略级的项目规划，但是需要其他部门来支持你，在前期调研的时候很配合，真正开始实施了，你也许发现他们的态度发生了变化，他们不打算真的做较大投入了，因为这个和他们团队的目标不匹配；</li>
<li>进度不透明。和兄弟团队约定好了交付的时间，但是中间过程没有沟通，完全是个黑盒，到了约定的时间快到了才发现很多东西还没有准备好；</li>
<li>职责不清、问题推诿。沟通中经常遇到大家因为分工不清导致工作相互推诿，一些灰色的工作找不到负责人，一旦灰色领域出了问题，又没有人愿意来背锅。</li>
</ul>
<p>那面对这些问题，我们该怎么解决了？这里给大家提供一个跨部门沟通的原则：</p>
<ul>
<li>首先是要大家一起确定目标：一个共赢的目标，不能只是你的目标，一开始就要设定一个大家都能实现自己价值的目标，这样对方才有意愿和你合作；</li>
<li>第二个就是要明确分工、职责、时间、责任人等，做到”亲兄弟、明算账“，俗话说的”丑话说在前面“也是这个意思；</li>
<li>第三个就是一开始要确认好沟通机制，做到信息互通，比如周会、周报等，确保过程中信息透明；</li>
<li>第四个就是在问题的处理上要有责任、有担当、同理心，不能是有好处大家都凑过来，一旦出了问题大家就翻脸不认人，和人一样，团队也要注意信誉。</li>
</ul>
<p>因为跨团队沟通往往双方不像在团队里那样，双方可能不是很了解，没有太多的信任感，所以当双方刚坐下来，还没开始沟通，大家的座位方式已经极大的影响了沟通的结果。这里给大家介绍一下几种不同沟通座位可能带来的影响。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntsMBQcQacWTS5NetKOpGNxI4IGojFEzIM0pEKQf91iTB4vuDhabahPzTQ7JeZZjSU9mCNgMNQLAXo.48f*tLIOM!/b&bo=IAOfASADnwEDGTw!&rf=viewer_4" alt="17.png"></p>
<h1 id="向上沟通和向下沟通"><a href="#向上沟通和向下沟通" class="headerlink" title="向上沟通和向下沟通"></a>向上沟通和向下沟通</h1><p>第二组经常遇到问题的沟通场景就是向上沟通和向下沟通。</p>
<h2 id="1-向上沟通"><a href="#1-向上沟通" class="headerlink" title="1. 向上沟通"></a>1. 向上沟通</h2><p>讲到”向上沟通“，我们就在提一下”向上管理“，先看一下这两个概念的解释。</p>
<ul>
<li><strong>向上管理</strong>，为了给上级和自己取得更好的结果而有意识地配合上级一起工作的过程，可以说，这是让上级改变的过程；向上管理不是领导上级，而是通过向上沟通、向上协调去影响及引导上级的看法与自己协调一致；</li>
<li><strong>向上沟通</strong>，向上沟通是向上管理的主要手段之一，一般指和上级有目的性的沟通行为，从而向上传递必要的信息或影响其决定；</li>
</ul>
<p>向上沟通是一种“有目的性的”向上管理行为，如果是那种在teambuilding时候很放松的闲聊，我们暂不归类到向上沟通里面。那向上沟通的难点是什么呢？</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knto*jogIESexcOI6Zn1cDZ56ds3*SZxu7qktfRHOMXdvXUPRRIRH*WdTgAXSzzbRmWpyNo1I6onlB1jOMDir8D5U!/b&bo=IAPuAiAD7gIDORw!&rf=viewer_4" alt="18.png"></p>
<ul>
<li><strong>传统观念</strong>：中国人已提到向上管理和向上沟通，可能就各种各样的问题都出来了。就如上图，这个是西周的“天子统三公、三公治诸侯”的一个金字塔，这就是中国过去传统的一个很明确、很强烈的等级观念，比如常见的“官大一级压死人”；在中国，这个是一个历史文化的传承，即使到了今天一个自有民主的社会环境，即使在像阿里这样开明的互联网公司，这中固有的观念还是会潜移默化的影响我们。</li>
<li><strong>缺乏主动</strong>：缺乏主动性，一定要等到出了大篓子，兜不住的时候才想到要去通报主管。信息不流通，会让主管没有安全感，会有失控感。永远不要让主管从别人那里知道本应该你告诉他的情况。</li>
<li><strong>信息片面</strong>：你想通过沟通去影响你的老板，如果你发现他现在有一个想法不对，你希望引导他按照你的思路去决策；这个背后还有一个可能性是你获取的信息没有你老板多，你做出的判断是片面的，甚至是错误的。</li>
<li><strong>直线思维</strong>：直线思维，比如上级说：“小明，你这个事儿做得不对”，“我这事哪儿做得不对了！”。那这种沟通方式肯定就没办法谈下去了，是吧，如果这样沟通下去的结果是什么？可以想象，大家可以掏出手机看阿里味儿了。你可以不认同他的观点，或者他处理问题的方式，但是一定不要在公开的场合当面怼。即使在当场觉得那个方式行不通，处理上存在偏差，也可以在会后，私下沟通，在执行过程中进行修正。</li>
</ul>
<p>那么向上沟通的常见问题是哪些呢？</p>
<ul>
<li><p><strong>有问题、有疑虑不敢沟通：1.</strong> 给领导展现出一种事事有反馈、积极复盘的认真工作态度，留下良好的第一印象；<strong>2.</strong> 执行时遇到问题，把问题及时反馈，等于把责任分担了出去，提高解决问题的成功率；<strong>3.</strong> 对于自己来说，主动汇报也能使你理清自己的工作，锻炼自己解决问题的能力，提升效率；<strong>4.</strong> 主动汇报，让老板信任，因为不汇报给领导带来失控感。主动汇报，既可以让你的工作“可视化”，也确保执行方向正确；  </p>
</li>
<li><p><strong>啰里啰嗦说不清问题和影响：</strong>给老板汇报一定要提前准备，思路清晰，表达清楚，提高效率。关于怎么给老板做汇报，后面还会展开讲一下；</p>
</li>
<li><p><strong>只说问题不给方案：</strong>充分思考，提前准备好方案和建议，让老板做选择题而不是问答题。这个不仅提高了和老板沟通的效率，更重要的是要让老板看到你的思考，做到为老板分担。</p>
</li>
</ul>
<p>讲到向上汇报，那我们就需要先来讲一下向上汇报的思考框架，通过这个思考框架，你能判断当前的内容是否需要汇报，已经用什么策略来做汇报。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KnthLxiA2mqoArDgh8gr8dae5xQyjCdWIXWgROC61*mbtaKmeTR30MxTrKeWagX9*ha5m*k8hab4h3BG6kr7Mf1i8!/b&bo=IANrASADawEDKQw!&rf=viewer_4" alt="19.png"></p>
<ul>
<li><p><strong>第一个象限</strong>和老板一起进入重要级别非常高的项目。此时，老板就是你的同事。一起策划一起干活。这个象限里，老板是完全的“参与”。你们之间信息是对称的，这时，重要的汇报形式可能都消失了，因为你们随时都知道对方的信息；</p>
</li>
<li><p><strong>第二个象限</strong>，老板的角色要给你“指导与决策”。这里老板很关心，但具体进展和细节他不清楚，这里的内容往往是汇报中最重要的，也是向上汇报能力的重点。重点汇报里很有一个可能目标是有困难需要老板来支持的，比如资源不够，需要老板协调，你直接告诉老板需要他做什么就好了（这里就转移到了第四象限）；</p>
</li>
<li><p><strong>第三个象限</strong>都是老板授权给你的事情，是你的职责所在。虽然信息在这里也有不对称，但是老板在宏观面上会知道你的内容（甚至他当年还干过你这个工作），或者内容的重要性不能进入老板的“管理仪表盘”（不涉及他要做的高级别管理决策）。这部分内容只要表达：你在按部就班地在如期进行就好，老板只需阶段性的检视一下就行，不是汇报的重点。常见的误区是：这部分内容总是错误地摆上 PPT，向老板事无巨细的读一遍，大家都很沉闷，成为最没水平的汇报。这个区间里如果有异常情况，异常情况需要转移到第二区间处理；  </p>
</li>
<li><p><strong>第四象限</strong>的内容，其缘由和理由都无需论述，老板和你已经达成共识，信息是对称的。但是，这里有下属难以完成的任务，或者超出职权的任务，或者是新范畴的任务，最常见的是下属需要领导帮助解决某种资源。这里老板的角色是“帮助与支持”。</p>
</li>
</ul>
<p>前面说到要主动汇报，那汇报最好的时机是什么时候呢？这里提供了4种最基本的向上汇报时机，大家可以参考：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntp8cCi.XS*MfLyt*kMyLtAD3GE8adZh67XGWmQytsDoc1eJq8ao7kJlkhw7S1TbHRbuxr9S90A5gj.by9skmlbo!/b&bo=IANaASADWgEDGTw!&rf=viewer_4" alt="20.png"></p>
<p>现在要介绍一下向上汇报的方法了：</p>
<ul>
<li><strong>内容精简扼要</strong>：要相信老板都是看过成千上万张 PPT 的，所以他们大多数时候都能够一眼看出 PPT 中所要表达的意思，因此 PPT 的信息需要精简扼要。同时需要使用大量的数据来佐证自己的观点，尽量从客观的角度来陈述；</li>
<li><strong>直奔主题</strong>：如上面的描述，老板的时间安排极其紧凑，甚至会在汇报过程中由于突发事件而离开，所以汇报一开始就要开门见山的陈述自己的观点或要求，然后再罗列理由和证据，最后再重新陈述一下自己的观点即可。以上即为“电梯游说”的 PREP 结构：Position（观点）、Reason（理由）、Evidence（证据）、Position（观点）；</li>
<li><strong>做好充分准备</strong>：汇报的内容也需仅有数页 PPT，但是很多时候领导都会顺藤摸瓜的询问一些相关问题。所以作为汇报人，需要同时将相关的信息都要提前了解清楚，以防被问的哑口无言，不但会影响汇报进度，而且会被认为不尽职；</li>
<li>掌握 10/30 原则：30 分钟的时间计划中，汇报时间最多占用 10 分钟，剩下的 20 分钟留给讨论时间，往往能够产生价值的信息会在讨论时间内产生。</li>
</ul>
<h3 id="PREP-汇报方法"><a href="#PREP-汇报方法" class="headerlink" title="PREP 汇报方法"></a>PREP 汇报方法</h3><p>出自麦肯锡的 30 秒电梯理论。麦肯锡要求公司员工能够在最短的时间，把想表达的事情说清楚、讲明白。因此，作出了 PREP 的汇报结构，要求汇报者能够站在一个决策者而不是执行者的角度上汇报工作。其中由四个部分组成：</p>
<ul>
<li><strong>观点</strong>：就是首先用一两句话说清楚你想要表达的核心观点，包括：希望领导原则上同意、定下一步计划或者尽快看看你的详细材料等等；</li>
<li><strong>理由</strong>：你需要仔细分析你的汇报材料，凝结成不超过三个理由，然后试着用简洁而有力的语言表达出来；</li>
<li><strong>证据</strong>：主要是说明汇报重点中包涵的具体细节，例如：具体现象、数据和效果估计等等；</li>
<li>重复观点：最后，再一次重复你的要求。</li>
</ul>
<h2 id="2-向下沟通"><a href="#2-向下沟通" class="headerlink" title="2. 向下沟通"></a>2. 向下沟通</h2><p>向上沟通有很多困难，那是不是就意味着向下沟通就简单了呢？你的下属都向你汇报，那还有什么难度吗？</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntpj8m0Ig1cUFf0*jQCw1MkTG68Y1Mgw7G9l.Jk665KtIp7zuYEQ8O4CTlhfGWD8yVgCJOZ6Qi8FIphF5YHWpMqM!/b&bo=IAOyASADsgEDORw!&rf=viewer_4" alt="21.png"></p>
<p>是的，有带团队的同学都能体会，考虑到你每个下属的情况都不相同，向下沟通并不容易。并且如果不考虑到这些差异，糟糕的向下沟通对管理者和团队来说都是一个灾难。“哈佛商业评论”就有一个调研表明：91% 的员工表示，上级糟糕的沟通会损害其领导力！</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Knth*iE.U.xjZ7IIDRONW0yRRUlljAEd4zYTatfHM2skv5E87WD*FVL7FBNKl2LTgHIe0Iv1eMqp1RpSSHNqO96tw!/b&bo=IANqASADagEDKQw!&rf=viewer_4" alt="22.png"></p>
<p>那和下属沟通的技巧都有哪些呢？</p>
<ul>
<li><p><strong>发布指令目的清晰，目标明确</strong>。说明任务的重要性，明确任务的 SMART 目标；如果说得不好听，一个含糊的目标（如我们要重视用户体验），你的下属怎么知道你是不是一时兴起，随口说的呢？  </p>
</li>
<li><p><strong>给与反馈关注行为及影响</strong>。反馈分为两类：积极性反馈和发展性反馈。顾名思义，积极性反馈是为了表达对被指导者的赞扬与认可，发展性反馈则用于指出需要改善的地方。这里区别于父母常用的唠叨模式，我们同样要有结构，即行为+影响+态度（认可或不足）；如：不能简单粗暴的说 xx 没有团队精神。</p>
</li>
<li><p><strong>建立定期的 one one 沟通渠道</strong>：Oneone 沟通，展现了重视，给与了确定性的准备时间，面对面的沟通更容易进入到更深层面的沟通。</p>
</li>
</ul>
<p>向下沟通还有非常重要的点是，上级怎么处理下级扔过来的问题。</p>
<p>当下属找你的时候，他们很多时候不是在寻求解决方案，而是寻求一个能解决问题的人。下属向管理者报告时，应该引导他说“我有一个问题”，而不能说“我们有一个问题”。下属提出问题的时候，应该让他理解这个问题是他的。这里举两个列子：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1Kntm9ugHEirZHv8dNMbj2mWKe27170pSvYBh9ZsoikV7PWHSUG.TF17bFswOjFqYC4I70y3WvsgRAbNTjq5xwG.J4!/b&bo=IANhASADYQEDGTw!&rf=viewer_4" alt="23.png"></p>
<p>正确的对话方式：“我暂时不能给你建议。你要把你负责的事情再考虑下，下午 4 点半，来我的办公室，提出可行的进一步想法。”或者“我 24 小时内没空处理这个问题，你继续去想，明天再给我汇报新的进展。”</p>
<p>如果大家对怎么处理和下属中间任务职责的问题感兴趣的话，推荐大家去看一本书：《别让猴子跳回背上》。</p>
<p>主管的工作，是协助下属完成工作，而不是替下属工作。授人以鱼不如授人以渔的这个道理大家都懂。管理者的目的是培养出更多可以独当一面的员工，如下面的图所示，主管要尽量避免出现自有层级为 1、2 级的员工。不要帮助下属去完成他们分内的事情，培养下属解决问题和思考的能力。面对下属的求助，多问问他“你觉得呢”，让下属自己去想办法解决问题。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqcFNZ*7OBjWh6XgedC.lCo9*3WtP2fzFnkVEhYgIjj82w9*raoFdUOxWiFXM.snb2r3LtA74ArtpsII4y*vzWE!/b&bo=IANwASADcAEDGTw!&rf=viewer_4" alt="24.png"></p>
<ul>
<li>5 级、等待指示——连该做什么都不知道；</li>
<li>4 级、请示要做什么——知道该做什么，但不知道该怎么做；</li>
<li>3 级、提出建议，按照裁断的结果行动——能提出备选方案，但需要主管进行方案选择；</li>
<li>2 级、行动，但需立即指示——能决定合适的行动方案，但具体执行时会随时请示；</li>
<li>1 级、独立行动，主管只需要看他的例行报告。</li>
</ul>
<p>自由层级第 1 层级与第 2 层级是争取来的特权——他们不是与生俱来的天然权利。这种特权获得来自于你能向上司成功的推销自己的想法和建议而慢慢积累的名声。这种名声也只有在第 3 层级自由量表中才能培养出来。</p>
<h1 id="同步沟通和异步沟通"><a href="#同步沟通和异步沟通" class="headerlink" title="同步沟通和异步沟通"></a>同步沟通和异步沟通</h1><p>最后一组要介绍的是同步沟通和异步沟通，这个组词就不像前面那两组那么常见了，不知道大家是不是都理解这两个词的意思？</p>
<ul>
<li>同步沟通：同步沟通是指你发出一个消息，接收方立即处理这个信息，并马上回复；</li>
<li>异步沟通：异步沟通指的是你发出一个消息，并不期待立即得到反馈的沟通方式。</li>
</ul>
<p>按照上面的定义，大家就可以把我们日常的沟通方式做一个归类了，比如“会议”、“面对面讨论”、“电话”就属于典型的同步沟通；“邮件”、“语雀”、“Aone”就是典型的异步沟通了。</p>
<p>那“钉钉”和“微信”应该归在哪一类呢？微信和钉钉一般认为是同时具备同步沟通和异步沟通的特征的，过程中有随时变化的可能，就看大家在沟通的过程中是否实时。不过考虑到钉钉有消息阅读状态的提示，一般我们认为钉钉更加接近同步沟通的方式。</p>
<p>下面我们就对这两种沟通的方式和场景做一个对比：</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntrN0iTvN7*vkGe*tHYe1l60BMSillHFvmZsKFzy9Y6DWK101lGMOM7wnOMf.pK817CfPyIXRVStNUdeHhhHrGq8!/b&bo=IANPASADTwEDGTw!&rf=viewer_4" alt="25.png"></p>
<p>随着在阿里钉钉的深度使用，同步沟通的比重越来越大，不可否认这种方式让整体的工作效率得到了很大的提升，但任何事情过量就会带来问题。同步沟通常见的问题有：</p>
<ul>
<li>频繁打断，大家的工作时间都被切割成了碎片，妨碍了深度工作的开展；</li>
<li>在线的优先级优于高产。不在线的人连发声机会都没有，事情就已经决定了。于是大家都得被迫实时在线，被迫参加每个可能有关的会议；</li>
<li>造成不必要的压力。实时在线的期望使人们丧失对时间表的控制。工作时间内，大家响应式回应各方请求，而不是主动地按自己的计划行事。有研究表明，因为常被打断，人们反而会努力把事情做得更快（做得更差为代价），并由此感到更大的压力和困惑；</li>
<li>导致低质量的讨论和次优方案。因为需要马上回复，人们没有充分的时间来考虑周全。第一时间给出的方案往往不是你能给出的最优方案。</li>
</ul>
<p>那在日常的项目管理中，我们怎么有效的利用好各种沟通方式，让这些沟通方式能更好的发挥他们的作用，同时避免一些副作用呢？这里我把项目中最常见的沟通方式放在了一个象限空间中（横坐标是同步或者异步，纵坐标是沟通内容的复杂程度），希望大家可以对比一下自己的日常项目，做个参考。</p>
<p><img src="http://m.qpic.cn/psc?/V113wYm11CpCjy/heyUv10nwEJXJa0yD1KntqSdPbaR*brGsy5WCjMd7puUAKIgM4HdOMvYxRt0.e3oL3.OnOu3Ak9dxpgCJQMV00OqT6.87P.5E6aTpAdSP*Y!/b&bo=IAOQAiADkAIDKQw!&rf=viewer_4" alt="26.png"></p>
<h1 id="最后，也是最重要的"><a href="#最后，也是最重要的" class="headerlink" title="最后，也是最重要的"></a>最后，也是最重要的</h1><p>终于到了最后（感谢有人能看到这里）。</p>
<p>本文讲了很多的不同沟通场景中的技巧，这些沟通技巧有的时候换个角度也可以看成沟通中的套路。在这里，我需要强调一下，一个沟通的成败，套路的东西会有效果，但是效果也是有限的，沟通中更重要的还是要看沟通的动机。你沟通的目的是不是希望要实现 “1+1&gt;2” 的效果，你是不是有一个开放的心态，是不是重视差异化、视每次冲突是成长的机会。只要是有一个真诚的心，就算沟通技巧上问题重重，我相信别人还是愿意和你合作。这就是所谓的：“多一点真诚，少一点套路！”</p>
<p>作者：阿里技术<br>        链接：<a href="https://segmentfault.com/a/1190000023318216">https://segmentfault.com/a/1190000023318216</a><br>        来源：SegmentFault 思否<br>        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>项目 管理 程序员 沟通</tag>
      </tags>
  </entry>
  <entry>
    <title>你需要了解的几种JavaScript设计模式</title>
    <url>/2019/01/15/%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A7%8DJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="为什么要学习设计模式？"><a href="#为什么要学习设计模式？" class="headerlink" title="为什么要学习设计模式？"></a>为什么要学习设计模式？</h1><p>为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。</p>
<h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><ul>
<li><p>设计模式是我们每天编程遇到的问题的可重用解决方案。</p>
</li>
<li><p>设计模式主要是为了解决对象的生成和整合问题。</p>
</li>
<li><p>换句话说，设计模式可以作为可应用于现实世界编程问题的模板。</p>
</li>
</ul>
<p><strong>读万卷书，不如行万里路。接下来要贴代码了，从代码中就可以理解常用设计模式的主要概念。</strong></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>单例模式</li>
<li>观察者模式（发布\订阅模式）</li>
<li>中介者模式</li>
<li>策略模式/状态模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>参与者模式</li>
<li>数据访问对象模式</li>
<li>等待者模式</li>
<li>同步模块模式</li>
<li>异步模块模式</li>
<li>链模式</li>
<li>构造函数模式</li>
<li>职责链模式</li>
<li>MVC模式</li>
<li>MVP模式</li>
<li>MVVM模式</li>
<li>享元模式</li>
<li>状态模式</li>
<li>模板方法模式</li>
</ol>
<a id="more"></a>

<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> midseason = getMidseason();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        midseason: midseason, <span class="comment">// 单例模式私有变量 </span></span><br><span class="line">        sendAjax: <span class="function"><span class="keyword">function</span>(<span class="params">api, formData, callback</span>) </span>&#123; </span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        submitForm: <span class="function"><span class="keyword">function</span>(<span class="params">dlg</span>)</span>&#123; </span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        cancelForm: <span class="function"><span class="keyword">function</span>(<span class="params">dlg</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        initChosen: <span class="function"><span class="keyword">function</span>(<span class="params">selector, options</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        initDataTable: <span class="function"><span class="keyword">function</span>(<span class="params">selector, options</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        editInventoryType: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 代码...</span></span><br><span class="line">            Singleton.initChosen($(<span class="string">&#x27;.check-goods-type&#x27;</span>));</span><br><span class="line">        &#125;,</span><br><span class="line">        changePriceCardStatus: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            Singleton.sendAjax(<span class="string">&#x27;api&#x27;</span>, &#123;<span class="string">&#x27;data&#x27;</span>: data&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 代码...</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h1 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布\订阅模式）"></a>观察者模式（发布\订阅模式）</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _message = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        regist: <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> _message[type] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                _message[type] = [fn];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _message[type].push(fn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params">type, args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!_message[type]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> events = &#123;</span><br><span class="line">                type: type,</span><br><span class="line">                args: args || &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> i = _message[type].length -<span class="number">1</span> ; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                _message[type][i].call(<span class="built_in">this</span>, events);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_message[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">var</span> i = _message[type]; i&gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">                    _message[type][i] === fn &amp;&amp; _message[type].splice(i ,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Observer.regist(<span class="string">&#x27;test&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.type, e.args.msg);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observer.fire(<span class="string">&#x27;test&#x27;</span>, &#123;<span class="attr">msg</span>: <span class="string">&#x27;传递参数&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Mediator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _msg = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        register: <span class="function"><span class="keyword">function</span>(<span class="params">type, action</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_msg[type]) &#123;</span><br><span class="line">                _msg[type].push(action);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _msg[type] = [];</span><br><span class="line">                _msg[type].push(action);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        send: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (_msg[type]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = _msg[type].length; i &lt; len; i++) &#123;</span><br><span class="line">                    _msg[type][i] &amp;&amp; _msg[type][i]();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line">Mediator.register(<span class="string">&#x27;demo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">&#125;).register(<span class="string">&#x27;demo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">&#125;).send(<span class="string">&#x27;demo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="策略模式与状态模式类似，区别是调用指定的方法传参"><a href="#策略模式与状态模式类似，区别是调用指定的方法传参" class="headerlink" title="策略模式与状态模式类似，区别是调用指定的方法传参"></a>策略模式与状态模式类似，区别是调用指定的方法传参</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Pattern = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> status = &#123;</span><br><span class="line">        return30: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(price+<span class="string">&#x27;折扣&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        return50: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(price+<span class="string">&#x27;折扣&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">item, price</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status[item] &amp;&amp; status[item](price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">Pattern(<span class="string">&#x27;return30&#x27;</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">&quot;canvas&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> CanvasCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     	<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>),</span><br><span class="line">     		ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">     	<span class="keyword">var</span> Action = &#123;</span><br><span class="line">     		fillStyle: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">     			ctx.fillStyle = c;</span><br><span class="line">	     	&#125;,</span><br><span class="line">	     	fillRect: <span class="function"><span class="keyword">function</span>(<span class="params">x, y, width, height</span>) </span>&#123;</span><br><span class="line">	     		ctx.fillRect(x, y, width, height);</span><br><span class="line">	     	&#125;</span><br><span class="line">     	&#125;</span><br><span class="line">     	<span class="keyword">return</span> &#123;</span><br><span class="line">     		excute: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">     			<span class="keyword">if</span> (!msg) <span class="keyword">return</span>;</span><br><span class="line">     			<span class="keyword">if</span> (msg.length) &#123;</span><br><span class="line">     				<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = msg.length; i &lt; len; i ++) &#123;</span><br><span class="line">     					<span class="built_in">arguments</span>.callee(msg[i]);</span><br><span class="line">     				&#125;</span><br><span class="line">     			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     				msg.param = <span class="built_in">Object</span>.prototype.toString.call(msg.param) === <span class="string">&#x27;[object Array]&#x27;</span> ? msg.param : [msg.param];</span><br><span class="line">     				Action[msg.command].apply(Action, msg.param);</span><br><span class="line">     			&#125;</span><br><span class="line">     		&#125;</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;()</span><br><span class="line">     CanvasCommand.excute([</span><br><span class="line">     	&#123;<span class="attr">command</span>: <span class="string">&#x27;fillStyle&#x27;</span>, <span class="attr">param</span>: <span class="string">&#x27;red&#x27;</span>&#125;,</span><br><span class="line">     	&#123;<span class="attr">command</span>: <span class="string">&#x27;fillRect&#x27;</span>, <span class="attr">param</span>: [<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>]&#125;</span><br><span class="line">     ])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> Iterator = <span class="function"><span class="keyword">function</span>(<span class="params">items, container</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> container = container &amp;&amp; <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>) || <span class="built_in">document</span>,</span><br><span class="line">            items = container.getElementsByTagName(items),</span><br><span class="line">            length = items.length,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> splice = [].splice;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 获取第一个元素</span></span><br><span class="line">            first: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> items[index];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 获取最后一个元素</span></span><br><span class="line">            last: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                index = length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> items[index];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 获取前一个元素</span></span><br><span class="line">            pre: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (--index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> items[index];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 获取后一个元素</span></span><br><span class="line">            next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (++index &lt; length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> items[index];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = length - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 获取某一个元素</span></span><br><span class="line">            get: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">                index = num &gt;= <span class="number">0</span> ? num % length : num % length + length;</span><br><span class="line">                <span class="keyword">return</span> items[index];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 对每一个元素执行某一个方法</span></span><br><span class="line">            dealEach: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> args = splice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                    fn.apply(items[i], args);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 对某一个元素执行某一个方法</span></span><br><span class="line">            dealItem: <span class="function"><span class="keyword">function</span>(<span class="params">num, fn</span>) </span>&#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>.get(num), splice.call(<span class="built_in">arguments</span>, <span class="number">2</span>));</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 排他方式处理某一个元素</span></span><br><span class="line">            exclusive: <span class="function"><span class="keyword">function</span>(<span class="params">num, allFn, numFn</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.dealEach(allFn);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(num) === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = num.length; i &lt; len; i++) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.dealItem(num[i], numFn);</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.dealItem(num, numFn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> demo = <span class="keyword">new</span> Iterator(<span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;container&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(demo.first());</span><br><span class="line">    <span class="built_in">console</span>.log(demo.last());</span><br><span class="line">    <span class="built_in">console</span>.log(demo.pre());</span><br><span class="line">    <span class="built_in">console</span>.log(demo.next());</span><br><span class="line">    <span class="built_in">console</span>.log(demo.get(<span class="number">1</span>));</span><br><span class="line">    demo.dealEach(<span class="function"><span class="keyword">function</span>(<span class="params">text, color</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.innerHTML = text;</span><br><span class="line">        <span class="built_in">this</span>.style.background = color;</span><br><span class="line">    &#125;, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">    demo.exclusive([<span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;被排除的&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;被选中的&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参与者模式"><a href="#参与者模式" class="headerlink" title="参与者模式"></a>参与者模式</h1><p>其实就是把函数绑定和函数柯里化结合起来的设计模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Function</span>.prototype.bind === <span class="literal">undefined</span>) &#123;</span><br><span class="line">	<span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">			args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">			that = <span class="built_in">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> addArgs = slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">				allArgs = args.concat(addArgs);</span><br><span class="line">			<span class="keyword">return</span> that.apply(context, allArgs);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 数据访问对象模式可以方便我们对前端存储的管理，并且使用时更方便</span></span><br><span class="line">    <span class="keyword">var</span> BaseLocalStorage = <span class="function"><span class="keyword">function</span>(<span class="params">preId, timeSign</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preId = preId; <span class="comment">// 定义本地存储数据前缀</span></span><br><span class="line">        <span class="built_in">this</span>.timeSign = timeSign || <span class="string">&#x27;|-|&#x27;</span>; <span class="comment">// 定义时间戳与存储数据之间的拼接符</span></span><br><span class="line">    &#125;</span><br><span class="line">    BaseLocalStorage.prototype = &#123;</span><br><span class="line">        status: &#123;</span><br><span class="line">            SUCCESS: <span class="number">0</span>, <span class="comment">// 成功</span></span><br><span class="line">            FAILURE: <span class="number">1</span>, <span class="comment">// 失败</span></span><br><span class="line">            OVERFLOW: <span class="number">2</span>, <span class="comment">// 溢出</span></span><br><span class="line">            TIMEOUT: <span class="number">3</span>, <span class="comment">// 过期</span></span><br><span class="line">        &#125;, <span class="comment">// 操作状态</span></span><br><span class="line">        storage: <span class="built_in">localStorage</span> || <span class="built_in">window</span>.localStorage, <span class="comment">// 保存本地存储链接</span></span><br><span class="line">        getKey: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.preId + key;</span><br><span class="line">        &#125;, <span class="comment">// 获取本地存储数据库数据真实字段</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加修改数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;string&#125;</span>   </span>key      数据字段标识</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;string&#125;</span>   </span>value    数据值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;time&#125;</span>     </span>time     添加时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">key, value, callback, time</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> status = <span class="built_in">this</span>.status.SUCCESS,</span><br><span class="line">                key = <span class="built_in">this</span>.getKey[key];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                time = <span class="keyword">new</span> <span class="built_in">Date</span>(time).getTime() || time.getTime();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                time = <span class="built_in">Date</span>.now() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">31</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.storage.setItem[key, time + <span class="built_in">this</span>.timeSign + value];</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                status = <span class="built_in">this</span>.status.OVERFLOW;</span><br><span class="line">            &#125;</span><br><span class="line">            callback &amp;&amp; callback.call(<span class="built_in">this</span>, status, key, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;string&#125;</span>   </span>key      数据字段标识</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return <span class="type">&#123;[object]&#125;</span>          </span>值和状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">key, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> status = <span class="built_in">this</span>.status.SUCCESS,</span><br><span class="line">                key = <span class="built_in">this</span>.getKey[key],</span><br><span class="line">                value = <span class="literal">null</span>,</span><br><span class="line">                timeSignLen = <span class="built_in">this</span>.timeSign.length,</span><br><span class="line">                that = <span class="built_in">this</span>,</span><br><span class="line">                index,</span><br><span class="line">                time,</span><br><span class="line">                result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = that.storage.getItem(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                result = &#123;</span><br><span class="line">                    status: that.status.FAILURE,</span><br><span class="line">                    value: <span class="literal">null</span>,</span><br><span class="line">                &#125;</span><br><span class="line">                callback &amp;&amp; callback.call(<span class="built_in">this</span>, result.status, result.value);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                index = value.indexOf(that.timeSign);</span><br><span class="line">                time = +value.slice(<span class="number">0</span>, index);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>(time).getTime() &gt; <span class="built_in">Date</span>.now() || time == <span class="number">0</span>) &#123;</span><br><span class="line">                    value = value.slice(index + timeSignLen);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    value = <span class="literal">null</span>,</span><br><span class="line">                    status = that.status.TIMEOUT;</span><br><span class="line">                    that.remove(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = that.status.FAILURE;</span><br><span class="line">            &#125;</span><br><span class="line">            result = &#123;</span><br><span class="line">                status: status,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">            callback &amp;&amp; callback.call(<span class="built_in">this</span>, result.status, result.value);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除数据</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;string&#125;</span>   </span>key      数据字段标识</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params">key, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> status = <span class="built_in">this</span>.status.FAILURE,</span><br><span class="line">                key = <span class="built_in">this</span>.getKey[key],</span><br><span class="line">                value = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value = <span class="built_in">this</span>.storage.getItem(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.storage.removeItem(key);</span><br><span class="line">                    status = <span class="built_in">this</span>.status.SUCCESS;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            callback &amp;&amp; callback.call(<span class="built_in">this</span>, status, status &gt; <span class="number">0</span> ? <span class="literal">null</span> : value.slice(value.indexOf(<span class="built_in">this</span>.timeSign) + <span class="built_in">this</span>.timeSign.length))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> LS = <span class="keyword">new</span> BaseLocalStorage(<span class="string">&#x27;LS__&#x27;</span>);</span><br><span class="line">    LS.set(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;xiao ming&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;)</span><br><span class="line">    LS.remove(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;)</span><br><span class="line">    LS.remove(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;)</span><br><span class="line">    LS.get(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="等待者模式"><a href="#等待者模式" class="headerlink" title="等待者模式"></a>等待者模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> Waiter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dfd = [], <span class="comment">// 注册等待对象容器</span></span><br><span class="line">        doneArr = [], <span class="comment">// 成功回调方法容器</span></span><br><span class="line">        failArr = [], <span class="comment">// 失败回调方法容器</span></span><br><span class="line">        slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 监控对象类</span></span><br><span class="line">    <span class="keyword">var</span> Primise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.resolved = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.rejected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控对象类原型方法</span></span><br><span class="line">    Primise.prototype = &#123;</span><br><span class="line">        resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.resolved = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfd.length) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = dfd.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 如果有任意一个监控对象没有被解决或者解决失败则返回</span></span><br><span class="line">                <span class="keyword">if</span> (dfd[i] &amp;&amp; !dfd[i].resolved || dfd[i].rejected) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 清除监控对象</span></span><br><span class="line">                dfd.splice(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行解决成功回调方法</span></span><br><span class="line">            _exec(doneArr);</span><br><span class="line">        &#125;,</span><br><span class="line">        reject: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.rejected = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfd.length) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 清除所有监控对象</span></span><br><span class="line">            dfd.splice(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 执行解决成功回调方法</span></span><br><span class="line">            _exec(failArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建监控对象</span></span><br><span class="line">    that.Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Primise();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_exec</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">            len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                arr[i] &amp;&amp; arr[i]();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 监控异步方法 参数 监控对象</span></span><br><span class="line">    that.when = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        dfd = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> i = dfd.length;</span><br><span class="line">        <span class="keyword">for</span>( --i; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在监控对象，或者监控对象已经解决，或者不是监控对象</span></span><br><span class="line">            <span class="keyword">if</span>(!dfd || dfd[i].resolved || dfd[i].rejected || !dfd[i] <span class="keyword">instanceof</span> Primise) &#123;</span><br><span class="line">                dfd.splice(i, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> that;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解决成功回调函数添加方法</span></span><br><span class="line">    that.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        doneArr = doneArr.concat(slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> that;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解决失败回调函数添加方法</span></span><br><span class="line">    that.fail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        failArr = failArr.concat(slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> that;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line"><span class="keyword">var</span> first = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dtd = waiter.Deferred();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;first finish&quot;</span>);</span><br><span class="line">        <span class="comment">// 发布解决成功消息</span></span><br><span class="line">        dtd.resolve();</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> dtd;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> second = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dtd = waiter.Deferred();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;second finish&quot;</span>);</span><br><span class="line">        <span class="comment">// 发布解决成功消息</span></span><br><span class="line">        dtd.resolve();</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">return</span> dtd;</span><br><span class="line">&#125;();</span><br><span class="line">waiter</span><br><span class="line">    .when(first, second)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;success again&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// first finish</span></span><br><span class="line"><span class="comment">// second finish</span></span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"><span class="comment">// success again</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="同步模块模式"><a href="#同步模块模式" class="headerlink" title="同步模块模式"></a>同步模块模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span>&gt;                fsadas         &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = F || &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义模块方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;string&#125;</span>   </span>str 模块路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>fn  模块方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    F.define = <span class="function"><span class="keyword">function</span>(<span class="params">str, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parts = str.split(<span class="string">&#x27;.&#x27;</span>),</span><br><span class="line">            old = parent = <span class="built_in">this</span>,</span><br><span class="line">            i = len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果第一个模式是模块管理器单体对象，则移除</span></span><br><span class="line">        <span class="keyword">if</span> (parts[<span class="number">0</span>] === <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            parts = parts.slice(<span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 屏蔽对define与module模块方法的重写</span></span><br><span class="line">        <span class="keyword">if</span> (parts[<span class="number">0</span>] === <span class="string">&#x27;define&#x27;</span> || parts[<span class="number">0</span>] === <span class="string">&#x27;module&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(len = parts.length; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 生命当前模块</span></span><br><span class="line">                parent[parts[i]] = &#123;&#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存下一层的祖父模块</span></span><br><span class="line">        old = parent;</span><br><span class="line">        <span class="comment">// 缓存下一层级父模块</span></span><br><span class="line">        parent = parent[parts[i]];</span><br><span class="line">        <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">            old[parts[-- i]] = fn();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    F.module = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">            <span class="comment">// 获取回调执行函数</span></span><br><span class="line">            fn = args.pop(),</span><br><span class="line">            <span class="comment">// 获取依赖模块，如果args[0]是数组，则依赖模块为args[0]，否则依赖模块为arg</span></span><br><span class="line">            parts = args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? args[<span class="number">0</span>] : args,</span><br><span class="line">            <span class="comment">// 依赖模块列表</span></span><br><span class="line">            modules = [],</span><br><span class="line">            <span class="comment">// 模块路由</span></span><br><span class="line">            modIds = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="comment">// 依赖模块索引</span></span><br><span class="line">            i = <span class="number">0</span>,</span><br><span class="line">            <span class="comment">// 依赖模块长度</span></span><br><span class="line">            ilen = parts.length,</span><br><span class="line">            <span class="comment">// 父模块，模块路由层级索引，模块路由层级长度</span></span><br><span class="line">            parent, j, jlen;</span><br><span class="line">        <span class="comment">// 遍历依赖模块</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; ilen) &#123;</span><br><span class="line">            <span class="comment">// 如果是路由模块</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parts[i] === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置当前模块父对象F</span></span><br><span class="line">                parent = <span class="built_in">this</span>;</span><br><span class="line">                <span class="comment">// 解析模块路由，并屏蔽掉模块父对象</span></span><br><span class="line">                modIds = parts[i].replace(<span class="regexp">/^F\./</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="comment">// 遍历模块路由层级</span></span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>, jlen = modIds.length; j &lt; jlen; j ++) &#123;</span><br><span class="line">                    <span class="comment">// 重置父模块</span></span><br><span class="line">                    parent = parent[modIds[j]] || <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将模块添加到依赖模块列表中</span></span><br><span class="line">                modules.push(parent);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是模块对象</span></span><br><span class="line">                <span class="comment">// 直接加入依赖模块列表中</span></span><br><span class="line">                modules.push(parts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fn.apply(<span class="literal">null</span>, modules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F.define(<span class="string">&#x27;string&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            trim: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    F.define(<span class="string">&#x27;dom&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">            $.dom = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">            <span class="keyword">return</span> $;</span><br><span class="line">        &#125;</span><br><span class="line">        $.html = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (html) &#123;</span><br><span class="line">                <span class="built_in">this</span>.dom.innerHTML = html;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.dom.innerHTML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(F.dom(<span class="string">&#x27;test&#x27;</span>).html());</span><br><span class="line">    <span class="built_in">console</span>.log(F.string.trim(<span class="string">&#x27;    范德萨更大噶  &#x27;</span>));</span><br><span class="line"></span><br><span class="line">    F.module(<span class="string">&#x27;dom&#x27;</span>, <span class="string">&#x27;string.trim&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">dom, trim</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> html = dom(<span class="string">&#x27;test&#x27;</span>).html();</span><br><span class="line">        <span class="keyword">var</span> str = trim(html);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;***&#x27;</span> + html + <span class="string">&#x27;***&#x27;</span> + str + <span class="string">&#x27;***&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="异步模块模式"><a href="#异步模块模式" class="headerlink" title="异步模块模式"></a>异步模块模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 向闭包中传入模块管理器对象F，~屏蔽压缩文件时，前面漏写;报错</span></span><br><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params">F</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块缓存器。存储已创建模块</span></span><br><span class="line">    <span class="keyword">var</span> moduleCache = &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置模块并执行模块构造函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span>   </span>moduleName 模块id名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span>   </span>params     依赖模块</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>callback   模块构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        setModule: <span class="function"><span class="keyword">function</span>(<span class="params">moduleName, params, callback</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 模块容器，模块文件加载完成回调函数</span></span><br><span class="line">            <span class="keyword">var</span> _module, fn;</span><br><span class="line">            <span class="comment">// 如果模块被调用过</span></span><br><span class="line">            <span class="keyword">if</span> (moduleCach[moduleName]) &#123;</span><br><span class="line">                <span class="comment">// 获取模块</span></span><br><span class="line">                _module = moduleCache[moduleName];</span><br><span class="line">                <span class="comment">// 设置模块已经加载完成</span></span><br><span class="line">                _module.status = <span class="string">&#x27;loaded&#x27;</span>;</span><br><span class="line">                <span class="comment">// 矫正模块接口</span></span><br><span class="line">                _module.exports = callback ? callback.apply(_module, params) : <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 执行模块文件加载完成回调函数</span></span><br><span class="line">                <span class="keyword">while</span>(fn = _module.onload.shift()) &#123;</span><br><span class="line">                    fn(_module.exports);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 模块不存在，则直接执行构造函数</span></span><br><span class="line">                callback &amp;&amp; callback.apply(<span class="literal">null</span>, params)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步加载依赖模块所在文件</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>moduleName 模块路径</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[Function]&#125;</span> </span>callback  模块加载完成回调函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return <span class="type">&#123;[type]&#125;</span>            </span>[description]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        loadModule: <span class="function"><span class="keyword">function</span>(<span class="params">moduleName, callback</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 依赖模块</span></span><br><span class="line">            <span class="keyword">var</span> _module;</span><br><span class="line">            <span class="comment">// 如果依赖模块被要求加载过</span></span><br><span class="line">            <span class="keyword">if</span> (moduleCache[moduleName]) &#123;</span><br><span class="line">                <span class="comment">// 获取该模块信息</span></span><br><span class="line">                _module = moduleCache[moduleName];</span><br><span class="line">                <span class="comment">// 如果模块加载完成</span></span><br><span class="line">                <span class="keyword">if</span> (_module.status === <span class="string">&#x27;loaded&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 执行模块加载完成回调函数</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(callback(_module.exports), <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 缓存该模块所处文件加载完成回调函数</span></span><br><span class="line">                    _module.onload.push(callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模块第一次被依赖引用</span></span><br><span class="line">                <span class="comment">// 缓存该模块初始化信息</span></span><br><span class="line">                moduleCache[moduleName] = &#123;</span><br><span class="line">                    moduleName: moduleName,</span><br><span class="line">                    status: <span class="string">&#x27;loading&#x27;</span>, <span class="comment">// 模块对应文件加载状态，默认加载中</span></span><br><span class="line">                    <span class="built_in">exports</span>: <span class="literal">null</span>, <span class="comment">// 模块接口</span></span><br><span class="line">                    onload: [callback] <span class="comment">// 模块对应文件加载完成回调函数缓冲器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 加载模块对应文件</span></span><br><span class="line">            loadScript(getUrl[moduleName]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 获取文件路径</span></span><br><span class="line">    getUrl: <span class="function"><span class="keyword">function</span>(<span class="params">moduleName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(moduleName).replace(<span class="regexp">/\.js$/g</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;.js&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 加载脚本文件</span></span><br><span class="line">    loadScript: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        _script.type = <span class="string">&#x27;text/JavaScript&#x27;</span>;</span><br><span class="line">        _script.charset = <span class="string">&#x27;UTF-8&#x27;</span>;</span><br><span class="line">        _script.async = <span class="literal">true</span>;</span><br><span class="line">        _script.src = src;</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(_script);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建模块管理对象F,并保存在全局作用域中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.F = &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建或调用模块方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;string&#125;</span> </span>url         参数为模块url</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>modDeps     参数为依赖模块</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>modCallback 参数为模块主函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">module</span>: <span class="function"><span class="keyword">function</span>(<span class="params">url, modDeps, modCallback</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 将参数转化为数组</span></span><br><span class="line">            <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">                <span class="comment">// 获取模块构造函数（参数数组中最后一个参数成员）</span></span><br><span class="line">                callback = args.pop(),</span><br><span class="line">                <span class="comment">// 获取依赖模块（紧邻回调函数参数，且数据类型为数组）</span></span><br><span class="line">                deps = (args.length &amp;&amp; args[args.length - <span class="number">1</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? args.pop() : [];</span><br><span class="line">                <span class="comment">// 该模块url</span></span><br><span class="line">                url = args.length ? args.pop() : <span class="literal">null</span>,</span><br><span class="line">                <span class="comment">// 依赖模块序列</span></span><br><span class="line">                params = [],</span><br><span class="line">                <span class="comment">// 未加载的依赖模块数量统计</span></span><br><span class="line">                depsCount = <span class="number">0</span>,</span><br><span class="line">                <span class="comment">// 依赖模块序列中索引值</span></span><br><span class="line">                i = <span class="number">0</span>,</span><br><span class="line">                <span class="comment">// 依赖模块序列长度</span></span><br><span class="line">                len;</span><br><span class="line">            <span class="comment">// 获取依赖模块长度</span></span><br><span class="line">            <span class="keyword">if</span> (len = deps.length) &#123;</span><br><span class="line">                <span class="comment">// 遍历依赖模块</span></span><br><span class="line">                <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">                    <span class="comment">// 闭包保存i</span></span><br><span class="line">                    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// 增加未加载依赖模块数量统计</span></span><br><span class="line">                        depsCount ++;</span><br><span class="line">                        <span class="comment">// 异步加载依赖模块</span></span><br><span class="line">                        loadModule(deps[i], <span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">                            <span class="comment">// 依赖模块序列中添加依赖模块接口引用</span></span><br><span class="line">                            params[i] = mod;</span><br><span class="line">                            <span class="comment">// 依赖模块加载完成，依赖模块数量统计减一</span></span><br><span class="line">                            depsCount --;</span><br><span class="line">                            <span class="comment">// 如果依赖模块全部加载</span></span><br><span class="line">                            <span class="keyword">if</span> (depsCount === <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 在模块缓存器中矫正该模块，并执行构造函数</span></span><br><span class="line">                                setModule(url, param, callback);</span><br><span class="line">                            &#125;;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)(i)</span><br><span class="line">                    i ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无依赖模块，直接执行回调函数</span></span><br><span class="line">                <span class="comment">// 在模块缓存器中矫正该模块，并执行构造函数</span></span><br><span class="line">                setModule(url, [], callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="链模式（仿jquery）"><a href="#链模式（仿jquery）" class="headerlink" title="链模式（仿jquery）"></a>链模式（仿jquery）</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;<span class="number">123</span>&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A.fn.init(selector, context);</span><br><span class="line">    &#125;</span><br><span class="line">    A.fn = A.prototype = &#123;</span><br><span class="line">        <span class="title">constructor</span>: <span class="title">A</span>,</span><br><span class="line">        <span class="title">init</span>: <span class="title">function</span>(<span class="params">selector, context</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.length = <span class="number">0</span>,</span><br><span class="line">            context = context || <span class="built_in">document</span>;</span><br><span class="line">            <span class="keyword">if</span>(~selector.indexOf(<span class="string">&#x27;#&#x27;</span>)) &#123;</span><br><span class="line">                <span class="built_in">this</span>[<span class="number">0</span>] = <span class="built_in">document</span>.getElementById(selector.slice(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> domes = context.getElementsByTagName(selector),</span><br><span class="line">                    i = <span class="number">0</span>,</span><br><span class="line">                    len = doms.length;</span><br><span class="line">                <span class="keyword">for</span>(; i &lt; len; i ++) &#123;</span><br><span class="line">                    <span class="built_in">this</span>[i] = doms[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.lenth = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.context = context;</span><br><span class="line">            <span class="built_in">this</span>.selector = selector;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(A(<span class="string">&#x27;#demo&#x27;</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;age&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">		<span class="string">&#x27;say&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-----------------------------------------------------------------------&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> Singletom = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">		<span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.instance || (<span class="built_in">this</span>.instance = <span class="keyword">new</span> Singletom(name, age)); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> a = getInstance(<span class="string">&#x27;zs&#x27;</span>, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">var</span> b = getInstance(<span class="string">&#x27;ls&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">	a.say();</span><br><span class="line">	b.say();</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="built_in">console</span>.log(b);</span><br><span class="line">	<span class="built_in">console</span>.log(a.name);</span><br><span class="line">	<span class="built_in">console</span>.log(a.age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-----------------------------------------------------------------------&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> getInstance2 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> result || (result = fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建div</span></span><br><span class="line">	<span class="keyword">var</span> createWindow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">	    div.innerHTML = <span class="string">&quot;我是弹窗内容&quot;</span>;</span><br><span class="line">	    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">	    <span class="keyword">return</span> div;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> divs = getInstance2(createWindow);</span><br><span class="line">	<span class="built_in">console</span>.log(divs());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">职责链模式定义了请求的传递方向，通过多个对象对请求的传递，实现一个复杂的逻辑操作。因此职责链模式将负责的需求颗粒化逐一实现每个对象分内的需求，并将请求顺序地传递。对于职责链上的每一个对象来说，他都可能是请求的发起者也可能是请求的接收者。通过这样的方式不仅仅简化原对象的复杂度，而且解决原请求的发起者与元请求的接收者之间的耦合。当然也方便对每个阶段对象进行单元测试。同时对于中途插入的请求，此模式依然使用，并可顺利对请求执行并产出结果。</span><br><span class="line"></span><br><span class="line">对于职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费，并且多个对象参与请求的传递，这在代码调试时增加了调试成本。</span><br><span class="line"></span><br><span class="line">有感：职责链模式就是把一个复杂的逻辑处理分解成更细粒度的单元，结合项目中，就是把请求，弹框等功能分解封装好，职责链这种设计模式有利于实现那种某些需求点不确定的需求，把不确定的需求单独抽离出来并且单独封装，其他的功能点或需求点不影响，有利于分别对各个功能点做测试。</span><br></pre></td></tr></table></figure>
<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// MVC架构模式很好地解决了页面中数据层、视图层、业务逻辑层（控制器）之间的耦合关系，使它们得到显性的区分，这也使得层次之间的耦合度降低。我们在开发中可以不用顾忌所有需求而专注于某一层次开发，降低了开发与维护成本，提升了开发效率。如果页面系统足够复杂，某些视图要共享同一组数据，或者某些需求的实现引用类似视图，此时MVC模式便可提高某些视图与数据的复用率。</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> MVC = MVC || &#123;&#125;;</span><br><span class="line">    MVC.model = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 内部数据对象</span></span><br><span class="line">        <span class="keyword">var</span> M = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 服务器端获取的数据，通常通过ajax获取并存储</span></span><br><span class="line">        M.data = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 配置数据，页面加载时即提供</span></span><br><span class="line">        M.conf = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 返回数据模型层对象操作方法</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 获取服务器端数据</span></span><br><span class="line">            getData: <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> M.data[m];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 获取配置数据</span></span><br><span class="line">            getConf: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> M.conf[c];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 设置服务器端数据</span></span><br><span class="line">            setData: <span class="function"><span class="keyword">function</span>(<span class="params">m, v</span>) </span>&#123;</span><br><span class="line">                M.data[m] = v;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 设置配置数据</span></span><br><span class="line">            setConf: <span class="function"><span class="keyword">function</span>(<span class="params">c, v</span>) </span>&#123;</span><br><span class="line">                M.conf[c] = v;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    MVC.view = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 模型数据层对象操作方法引用</span></span><br><span class="line">        <span class="keyword">var</span> M = MVC.model;</span><br><span class="line">        <span class="comment">// 内部视图创建方法对象</span></span><br><span class="line">        <span class="keyword">var</span> V = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 获取视图接口方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 根据视图名称返回视图</span></span><br><span class="line">            V[v]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    MVC.controller = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 模型数据层对象操作方法引用</span></span><br><span class="line">        <span class="keyword">var</span> M = MVC.model;</span><br><span class="line">        <span class="comment">// 视图数据层对象操作方法引用</span></span><br><span class="line">        <span class="keyword">var</span> V = MVC.view;</span><br><span class="line">        <span class="comment">// 控制器创建方法对象</span></span><br><span class="line">        <span class="keyword">var</span> C = &#123;&#125;;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> MVP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    MVP.model = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> M = &#123;&#125;;</span><br><span class="line">        M.data = [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&#x27;新闻头条&#x27;</span>,</span><br><span class="line">                mode: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                url: <span class="string">&#x27;http://www.example.com/01&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&#x27;最新电影&#x27;</span>,</span><br><span class="line">                mode: <span class="string">&#x27;movie&#x27;</span>,</span><br><span class="line">                url: <span class="string">&#x27;http://www.example.com/02&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ];</span><br><span class="line">        M.conf = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            getData: <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> M.data(m);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 设置数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span> </span>m 模块名称</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span> </span>v 模块数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setData: <span class="function"><span class="keyword">function</span>(<span class="params">m, v</span>) </span>&#123;</span><br><span class="line">                M.data[m] = v;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;,</span><br><span class="line">            getConf: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> M.conf[c]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 设置配置</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span> </span>c 配置项名称</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param <span class="type">&#123;[type]&#125;</span> </span>v 配置项值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setConf: <span class="function"><span class="keyword">function</span>(<span class="params">c, v</span>) </span>&#123;</span><br><span class="line">                M.conf[c] = v;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    MVP.view = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 子元素或者兄弟元素替换模板</span></span><br><span class="line">        <span class="keyword">var</span> REPLACEKEY = <span class="string">&#x27;__REPLACEKEY__&#x27;</span>;</span><br><span class="line">        <span class="comment">// 获取完整元素模板</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getHTML</span>(<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str</span><br><span class="line">                    .replace(<span class="regexp">/^(\w+)()[^\&#123;\&#125;*]?(\&#123;([@\w]+)\&#125;)?(.*?)$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span></span>) </span>&#123;</span><br><span class="line">                        $<span class="number">2</span> = $<span class="number">2</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                        $<span class="number">3</span> = $<span class="number">3</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                        $<span class="number">4</span> = $<span class="number">4</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                        $<span class="number">5</span> = $<span class="number">5.</span>replace(<span class="regexp">/\&#123;([@\w]+)\&#125;/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                        <span class="keyword">return</span> type === <span class="string">&#x27;in&#x27;</span> ?</span><br><span class="line">                        <span class="string">&#x27;&lt;&#x27;</span> + $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">5</span> + <span class="string">&#x27;&gt;&#x27;</span> + $<span class="number">4</span> + REPLACEKEY + <span class="string">&#x27;&lt;/&#x27;</span> + $<span class="number">1</span> + <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                            type === <span class="string">&#x27;add&#x27;</span> ?</span><br><span class="line">                            <span class="string">&#x27;&lt;&#x27;</span> + $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">5</span> + <span class="string">&#x27;&gt;&#x27;</span> + $<span class="number">4</span> + <span class="string">&#x27;&lt;/&#x27;</span> + $<span class="number">1</span> + <span class="string">&#x27;&gt;&#x27;</span> + REPLACEKEY</span><br><span class="line">                            :</span><br><span class="line">                            <span class="string">&#x27;&lt;&#x27;</span> + $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">5</span> + <span class="string">&#x27;&gt;&#x27;</span> + $<span class="number">4</span> + <span class="string">&#x27;&lt;/&#x27;</span> + $<span class="number">1</span> + <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .replace(<span class="regexp">/#([@\-\w]+)/g</span>, <span class="string">&#x27; id=&quot;$1&quot;&#x27;</span>)</span><br><span class="line">                    .replace(<span class="regexp">/\.([@\-\s\w]+/g</span>, <span class="string">&#x27; class=&quot;$1&quot;&#x27;</span>)</span><br><span class="line">                    .replace(<span class="regexp">/\[(.+)\]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> a = key</span><br><span class="line">                                .replace(<span class="regexp">/&#x27;|&quot;/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                                .split(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">                            h = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>, len = a.length; j &lt; len; j ++) &#123;</span><br><span class="line">                            h += <span class="string">&#x27; &#x27;</span> + a[j].replace(<span class="regexp">/=(.*)/g</span>, <span class="string">&#x27;=&quot;$1&quot;&#x27;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> h;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .replace(<span class="regexp">/@(\w+)/g</span>, <span class="string">&#x27;&#123;#$1#&#125;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">eachArray</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="comment">// 将索引值、索引对应值、数组长度传入回调函数中并执行</span></span><br><span class="line">                fn(i, arr[i], len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换兄弟元素模板或者子元素模板</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>str 原始字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>rep 兄弟元素模板或者子元素模板</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">formateItem</span>(<span class="params">str, rep</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 用对应元素字符串替换兄弟元素模板或者子元素模板</span></span><br><span class="line">            <span class="keyword">return</span> str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(REPLACEKEY, <span class="string">&#x27;g&#x27;</span>), rep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> part = str</span><br><span class="line">                .replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                .replace(<span class="regexp">/^\s+(&gt;)\s+/g</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">                .split(<span class="string">&#x27;&gt;&#x27;</span>),</span><br><span class="line">                html = REPLACEKEY,</span><br><span class="line">                item,</span><br><span class="line">                nodeTpl;</span><br><span class="line">            eachArray(part, <span class="function"><span class="keyword">function</span>(<span class="params">partIndex, partValue, partLen</span>) </span>&#123;</span><br><span class="line">                item = partValue.split(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                nodeTpl = REPLACEKEY;</span><br><span class="line">                eachArray(item, <span class="function"><span class="keyword">function</span>(<span class="params">itemIndex, itemValue, itemLen</span>) </span>&#123;</span><br><span class="line">                    nodeTpl = formateItem(nodeTpl, getHTML(itemValue, itemIndex === itemLen - <span class="number">1</span> ? (partIndex === partLen - <span class="number">1</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;in&#x27;</span>) : <span class="string">&#x27;add&#x27;</span>));</span><br><span class="line">                &#125;)</span><br><span class="line">                html = formateItem(html, nodeTpl);</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    MVP.presenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> V = MVP.view;</span><br><span class="line">        <span class="keyword">var</span> M = MVP.model;</span><br><span class="line">        <span class="keyword">var</span> C = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> C) &#123;</span><br><span class="line">                    C[i] &amp;&amp; C[i](M, V, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            add: <span class="function"><span class="keyword">function</span>(<span class="params">modName, pst</span>) </span>&#123;</span><br><span class="line">                C[modName] = pst;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    MVP.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.MVP = MVP;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = &#123;</span><br><span class="line">    nav: <span class="function"><span class="keyword">function</span>(<span class="params">M, V</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = M.getData(<span class="string">&#x27;nav&#x27;</span>);</span><br><span class="line">        data[<span class="number">0</span>].choose = <span class="string">&#x27;choose&#x27;</span>;</span><br><span class="line">        data[data.length - <span class="number">1</span>].last = <span class="string">&#x27;last&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> tpl = V(<span class="string">&#x27;li.@mode @choose @last[data-mode=@mode]&gt;a#nax_@mode.nav-@mode[href=@url title=@text]&gt;i.nav-icon-@mode-@mode+span&#123;@text&#125;&#x27;</span>);</span><br><span class="line">        $</span><br><span class="line">        .create(<span class="string">&#x27;ul&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;navigator&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;nav&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .html(</span><br><span class="line">            A.formateString(tpl, data)</span><br><span class="line">        )</span><br><span class="line">        .appendTo(<span class="string">&#x27;#container&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    MVP.init();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;first&quot;</span> data-bind=<span class="string">&quot;type: &#x27;slider&#x27;, data: demo1&quot;</span>&gt;test1&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;second&quot;</span> data-bind=<span class="string">&quot;type: &#x27;slider&#x27;, data: demo2&quot;</span>&gt;test2&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;third&quot;</span> data-bind=<span class="string">&quot;type: &#x27;progressbar&#x27;, data: demo3&quot;</span>&gt;test3&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">window</span> = <span class="built_in">this</span> || (<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取页面字体大小，作为创建页面UI尺寸参照物</span></span><br><span class="line">    <span class="keyword">var</span> FONTSIZE = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取页面body元素字体大小并转化成整数。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">document</span>.body.currentStyle ? <span class="built_in">document</span>.body.currentStyle[<span class="string">&#x27;fontSize&#x27;</span>] : getComputedStyle(<span class="built_in">document</span>.body, <span class="literal">false</span>)[<span class="string">&#x27;fontSize&#x27;</span>]);</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="comment">// 视图模型对象（策略对象）</span></span><br><span class="line">    <span class="keyword">var</span> VM = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> Method = &#123;</span><br><span class="line">            progressbar: <span class="function"><span class="keyword">function</span>(<span class="params">dom, data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 进度条进度完成容器</span></span><br><span class="line">                <span class="keyword">var</span> progress = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">                    param = data.data;</span><br><span class="line">                <span class="comment">// 设置进度完成容器尺寸</span></span><br><span class="line">                progress.style.width = (param.position || <span class="number">100</span>) + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                <span class="comment">// 为进度条组件添加UI样式</span></span><br><span class="line">                dom.className += <span class="string">&#x27; ui-progressbar&#x27;</span>;</span><br><span class="line">                <span class="comment">// 进度完成容器元素插入进度条容器中</span></span><br><span class="line">                dom.appendChild(progress);</span><br><span class="line">            &#125;,</span><br><span class="line">            slider: <span class="function"><span class="keyword">function</span>(<span class="params">dom, data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 滚动条拨片</span></span><br><span class="line">                <span class="keyword">var</span> bar = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>),</span><br><span class="line">                    <span class="comment">// 滑动条进度容器</span></span><br><span class="line">                    progress = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">                    <span class="comment">// 滑动条容量提示信息</span></span><br><span class="line">                    totleText = <span class="literal">null</span>,</span><br><span class="line">                    <span class="comment">// 滑动条拨片提示信息</span></span><br><span class="line">                    progressText = <span class="literal">null</span>,</span><br><span class="line">                    <span class="comment">// 数据模型数据，结构&#123;position: 60, totle: 200&#125;</span></span><br><span class="line">                    param = data.data,</span><br><span class="line">                    <span class="comment">// 容器元素宽度</span></span><br><span class="line">                    width = dom.clientWidth,</span><br><span class="line">                    <span class="comment">// 容器元素横坐标值</span></span><br><span class="line">                    left = dom.offsetLeft,</span><br><span class="line">                    <span class="comment">// 拨片位置</span></span><br><span class="line">                    realWidth = (param.position || <span class="number">100</span>) * width / <span class="number">100</span>;</span><br><span class="line">                <span class="comment">// 清空滑动条容器，为创建滑动条作准备</span></span><br><span class="line">                dom.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                <span class="comment">// 如果模型数据中提供容器总量信息，则创建滚动条提示文案</span></span><br><span class="line">                <span class="keyword">if</span> (param.totle) &#123;</span><br><span class="line">                    <span class="comment">// 容器总量提示文案</span></span><br><span class="line">                    text = <span class="built_in">document</span>.createElement(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 拨片位置提示文案</span></span><br><span class="line">                    progressText = <span class="built_in">document</span>.createElement(<span class="string">&#x27;em&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 设置容器总量提示文案</span></span><br><span class="line">                    text.innerHTML = param.totle;</span><br><span class="line">                    <span class="comment">// 将容器总量提示文案元素添加到滑动条组件中</span></span><br><span class="line">                    dom.appendChild(text);</span><br><span class="line">                    <span class="comment">// 将拨片位置提示文案元素添加到滑动条组件中</span></span><br><span class="line">                    dom.appendChild(progressText);</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 设置滑动条</span></span><br><span class="line">                setStyle(realWidth);</span><br><span class="line">                <span class="comment">// 为滑动条组件添加UI样式</span></span><br><span class="line">                dom.className += <span class="string">&#x27; ui-slider&#x27;</span>;</span><br><span class="line">                <span class="comment">// 将进度容器添加到滑动条组件中</span></span><br><span class="line">                dom.appendChild(progress);</span><br><span class="line">                <span class="comment">// 将拨片添加到滑动条组件中</span></span><br><span class="line">                dom.appendChild(bar);</span><br><span class="line">                <span class="comment">// 设置滑动条</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">setStyle</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 设置进度容器宽度</span></span><br><span class="line">                    progress.style.width = w + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                    <span class="comment">// 设置拨片横坐标</span></span><br><span class="line">                    bar.style.left = w - FONTSIZE / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                    <span class="comment">// 如果有拨片提示文案</span></span><br><span class="line">                    <span class="keyword">if</span> (progressText) &#123;</span><br><span class="line">                        <span class="comment">// 设置拨片提示文案横坐标</span></span><br><span class="line">                        progressText.style.left = w - FONTSIZE / <span class="number">2</span> * <span class="number">2.4</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                        <span class="comment">// 设置拨片提示文案内容</span></span><br><span class="line">                        progressText.innerHTML = <span class="built_in">parseFloat</span>(w / width * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建组件逻辑 按下鼠标拨片</span></span><br><span class="line">                bar.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 移动拨片（鼠标光标在页面中滑动，事件绑定给document是为了优化交互体验，使鼠标光标可以在页面中自由滑动）</span></span><br><span class="line">                    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span><br><span class="line">                        <span class="keyword">var</span> w = e.clientX - left;</span><br><span class="line">                        <span class="comment">// 设置滑动条</span></span><br><span class="line">                        setStyle(w &lt; width ? ( w &gt; <span class="number">0</span> ? w : <span class="number">0</span>) : width);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 阻止页面滑动选取事件</span></span><br><span class="line">                    <span class="built_in">document</span>.onselectstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 停止滑动交互</span></span><br><span class="line">                    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// 取消文档鼠标光标移动事件</span></span><br><span class="line">                        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 取消文档滑动选取事件</span></span><br><span class="line">                        <span class="built_in">document</span>.onselectstart = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取视图层组件渲染数据的映射信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>dom 组件元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getBindData</span>(<span class="params">dom</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 获取组件自定义属性data-bind值</span></span><br><span class="line">            <span class="keyword">var</span> data = dom.getAttribute(<span class="string">&#x27;data-bind&#x27;</span>);</span><br><span class="line">            <span class="comment">// 将自定义属性data-bind值转化为对象</span></span><br><span class="line">            <span class="keyword">return</span> !!data &amp;&amp; (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;return (&#123;&quot;</span>+ data +<span class="string">&quot;&#125;)&quot;</span>))();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组件实例化方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> doms = <span class="built_in">document</span>.body.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>),</span><br><span class="line">            <span class="comment">// 元素自定义数据句柄</span></span><br><span class="line">                ctx = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// ui处理是会向页面中插入元素，此时doms.length会改变，此时动态获取dom.length</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; doms.length; i ++) &#123;</span><br><span class="line">                <span class="comment">// 获取元素自定义数据</span></span><br><span class="line">                ctx = getBindData(doms[i]);</span><br><span class="line">                <span class="comment">// 如果元素是ui组件，则根据自定义属性中组件类型，渲染该组件</span></span><br><span class="line">                ctx.type &amp;&amp; Method[ctx.type] &amp;&amp; Method[ctx.type](doms[i], ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="comment">// 将视图模型对象绑定在Window上，供外部获取</span></span><br><span class="line">    <span class="built_in">window</span>.VM = VM;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> demo1 = &#123;</span><br><span class="line">        position: <span class="number">60</span>,</span><br><span class="line">        totle: <span class="number">200</span></span><br><span class="line">    &#125;,</span><br><span class="line">    demo2 = &#123;</span><br><span class="line">        position: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    demo3 = &#123;<span class="attr">position</span>: <span class="number">50</span>&#125;;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    VM();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 其实就是js里组合继承，构造函数绑定属性，原型绑定方法</span></span><br><span class="line"><span class="comment">// 每页显示5条数据，不够5条从最前面取</span></span><br><span class="line"><span class="keyword">var</span> FlyWeight = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> created = [];</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>).appendChild(dom);</span><br><span class="line">		created.push(dom);</span><br><span class="line">		<span class="keyword">return</span> dom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getDiv: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (created.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> create();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> div = created.shift();</span><br><span class="line">				created.push(div);</span><br><span class="line">				<span class="keyword">return</span> div;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(FlyWeight.getDiv());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">	FlyWeight.getDiv().innerHTML = i;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MarrySate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _currentState = &#123;&#125;,</span><br><span class="line">		status = &#123;</span><br><span class="line">			jump: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;jump&quot;</span>); &#125;,</span><br><span class="line">			move: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;move&quot;</span>); &#125;,</span><br><span class="line">			shoot: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;shoot&quot;</span>); &#125;,</span><br><span class="line">			squat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;squat&quot;</span>); &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">var</span> Action = &#123;</span><br><span class="line">		changeState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> arg = <span class="built_in">arguments</span>;</span><br><span class="line">			_currentState = &#123;&#125;;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arg.length; i &lt; len; i ++) &#123;</span><br><span class="line">				_currentState[arg[i]] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		goes: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;触发了&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> _currentState) &#123;</span><br><span class="line">				_currentState[k] &amp;&amp; status[k]();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		change: Action.changeState,</span><br><span class="line">		goes: Action.goes</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">MarrySate()</span><br><span class="line">		.change(<span class="string">&#x27;jump&#x27;</span>, <span class="string">&#x27;move&#x27;</span>)</span><br><span class="line">		.goes()</span><br><span class="line"><span class="comment">// 触发了</span></span><br><span class="line"><span class="comment">// jump</span></span><br><span class="line"><span class="comment">// move</span></span><br></pre></td></tr></table></figure>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote>
<p>可以利用该模式封装弹层插件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> Alert = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!data) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 设置内容</span></span><br><span class="line">	<span class="built_in">this</span>.content = data.content;</span><br><span class="line">	<span class="comment">// 创建提示框面板</span></span><br><span class="line">	<span class="built_in">this</span>.panel = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">	<span class="comment">// 创建提示内容组件</span></span><br><span class="line">	<span class="built_in">this</span>.contentNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">	<span class="comment">// 创建确定按钮组件</span></span><br><span class="line">	<span class="built_in">this</span>.confirmBtn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">	<span class="comment">// 创建关闭按钮组件</span></span><br><span class="line">	<span class="built_in">this</span>.closeBtn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">	<span class="comment">// 为提示框面板增加类</span></span><br><span class="line">	<span class="built_in">this</span>.panel.className = <span class="string">&#x27;alert&#x27;</span>;</span><br><span class="line">	<span class="comment">// 为关闭按钮增加类</span></span><br><span class="line">	<span class="built_in">this</span>.closeBtn.className = <span class="string">&#x27;a-close&#x27;</span>;</span><br><span class="line">	<span class="comment">// 为确定按钮增加类</span></span><br><span class="line">	<span class="built_in">this</span>.confirmBtn.className = <span class="string">&#x27;a-confirm&#x27;</span>;</span><br><span class="line">	<span class="comment">// 为关闭按钮增加文案</span></span><br><span class="line">	<span class="built_in">this</span>.closeBtn.innerHTML = data.close || <span class="string">&#x27;关闭&#x27;</span>;</span><br><span class="line">	<span class="comment">// 为确定按钮增加文案</span></span><br><span class="line">	<span class="built_in">this</span>.confirmBtn.innerHTML = data.confirm || <span class="string">&#x27;确定&#x27;</span>;</span><br><span class="line">	<span class="comment">// 为提示内容增加文本</span></span><br><span class="line">	<span class="built_in">this</span>.contentNode.innerHTML = <span class="built_in">this</span>.content;</span><br><span class="line">	<span class="comment">// 点击确定按钮执行方法 如果data中有succuess方法则为success方法，否则为空函数</span></span><br><span class="line">	<span class="built_in">this</span>.success = data.success || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">	<span class="comment">// 点击关闭按钮执行方法</span></span><br><span class="line">	<span class="built_in">this</span>.fail = data.fail || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提示框原型方法</span></span><br><span class="line">Alert.prototype = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.panel.appendChild(<span class="built_in">this</span>.closeBtn);</span><br><span class="line">		<span class="built_in">this</span>.panel.appendChild(<span class="built_in">this</span>.contentNode);</span><br><span class="line">		<span class="built_in">this</span>.panel.appendChild(<span class="built_in">this</span>.confirmBtn);</span><br><span class="line">		<span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>.panel);</span><br><span class="line">		<span class="built_in">this</span>.bindEvent();</span><br><span class="line">		<span class="built_in">this</span>.show();</span><br><span class="line">	&#125;,</span><br><span class="line">	bindEvent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">		<span class="built_in">this</span>.closeBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			self.fail();</span><br><span class="line">			self.hide();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.confirmBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			self.success();</span><br><span class="line">			self.hide();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	hide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.panel.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.panel.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Alert(&#123;</span><br><span class="line">	<span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;close&#x27;</span>: <span class="string">&#x27;close test&#x27;</span></span><br><span class="line">&#125;).init()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RightAlert = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	Alert.call(<span class="built_in">this</span>, data);</span><br><span class="line">	<span class="built_in">this</span>.confirmBtn.className = <span class="built_in">this</span>.confirmBtn.className + <span class="string">&#x27; right&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">RightAlert.prototype = <span class="keyword">new</span> Alert();</span><br><span class="line"><span class="keyword">new</span> RightAlert(&#123;</span><br><span class="line">	<span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;close&#x27;</span>: <span class="string">&#x27;right close test&#x27;</span></span><br><span class="line">&#125;).init()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript 代码 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>入门Webpack，看这篇就够了</title>
    <url>/2017/12/17/%E5%85%A5%E9%97%A8Webpack%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><blockquote>
<p>阅读本文之前，先看下面这个webpack的配置文件，如果每一项你都懂，那本文能带给你的收获也许就比较有限，你可以快速浏览或直接跳过；如果你和十天前的我一样，对很多选项存在着疑惑，那花一段时间慢慢阅读本文，你的疑惑一定一个一个都会消失；如果你以前没怎么接触过Webpack，而你又你对webpack感兴趣，那么动手跟着本文中那个贯穿始终的例子写一次，写完以后你会发现你已明明白白的走进了Webpack的大门。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个常见的&#96;webpack&#96;配置文件</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">        entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;, &#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">            filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: &#39;none&#39;,</span><br><span class="line">        devServer: &#123;</span><br><span class="line">            contentBase: &quot;.&#x2F;public&quot;, &#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">            historyApiFallback: true, &#x2F;&#x2F;不跳转</span><br><span class="line">            inline: true,</span><br><span class="line">            hot: true</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                    test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: &quot;babel-loader&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                        fallback: &quot;style-loader&quot;,</span><br><span class="line">                        use: [&#123;</span><br><span class="line">                            loader: &quot;css-loader&quot;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true,</span><br><span class="line">                                localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, &#123;</span><br><span class="line">                            loader: &quot;postcss-loader&quot;</span><br><span class="line">                        &#125;],</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;&#x2F;app&#x2F;index.tmpl.html&quot; &#x2F;&#x2F;new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="什么是WebPack，为什么要使用它？"><a href="#什么是WebPack，为什么要使用它？" class="headerlink" title="什么是WebPack，为什么要使用它？"></a>什么是WebPack，为什么要使用它？</h1><h2 id="为什要使用WebPack"><a href="#为什要使用WebPack" class="headerlink" title="为什要使用WebPack"></a>为什要使用WebPack</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>
<ul>
<li>模块化，让我们可以把复杂的程序细化为小的文件;</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器</li>
<li>…</li>
</ul>
<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>
<h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p>
<h2 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h2><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</p>
<p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p>
<p><img src="https://i.imgur.com/bKBUQ5Y.png"></p>
<p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
<p><img src="https://i.imgur.com/SwOp7E6.png"></p>
<p>如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。</p>
<h1 id="开始使用Webpack"><a href="#开始使用Webpack" class="headerlink" title="开始使用Webpack"></a>开始使用Webpack</h1><p>初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Webpack可以使用npm安装，新建一个空的练习文件夹（此处命名为webpack sample project），在终端中转到该文件夹后执行下述指令就可以完成安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局安装</span><br><span class="line">npm install -g webpack</span><br><span class="line">&#x2F;&#x2F;安装到你的项目目录</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>
<h2 id="正式使用Webpack前的准备"><a href="#正式使用Webpack前的准备" class="headerlink" title="正式使用Webpack前的准备"></a>正式使用Webpack前的准备</h2><ol>
<li>在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用<code>npm init</code>命令可以自动创建这个package.json文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。</p>
<ol start="2">
<li>package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装Webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。接下来我们再创建三个文件:</li>
</ol>
<ul>
<li><code>index.html</code> –放在public文件夹中;</li>
<li><code>Greeter.js</code>– 放在app文件夹中;</li>
<li><code>main.js</code>– 放在app文件夹中;</li>
</ul>
<p>此时项目结构如下图所示</p>
<p><img src="https://i.imgur.com/3iY0fNe.png"></p>
<p>我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为<code>bundle.js</code>，之后我们还会详细讲述）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Sample Project&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;root&#39;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在<code>Greeter.js</code>中定义一个返回包含问候信息的<code>html</code>元素的函数,并依据CommonJS规范导出这个函数为一个模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Greeter.js</span><br><span class="line">module.exports &#x3D; function() &#123;</span><br><span class="line">  var greet &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  greet.textContent &#x3D; &quot;Hi there and greetings!&quot;;</span><br><span class="line">  return greet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>main.js</code>文件中我们写入下述代码，用以把<code>Greeter</code>模块返回的节点插入页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js </span><br><span class="line">const greeter &#x3D; require(&#39;.&#x2F;Greeter.js&#39;);</span><br><span class="line">document.querySelector(&quot;#root&quot;).appendChild(greeter());</span><br></pre></td></tr></table></figure>
<h2 id="正式使用Webpack"><a href="#正式使用Webpack" class="headerlink" title="正式使用Webpack"></a>正式使用Webpack</h2><p>webpack可以在终端中使用，在基本的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，</span><br><span class="line"># &#123;destination for bundled file&#125;处填写打包文件的存放路径</span><br><span class="line"># 填写路径的时候不用添加&#123;&#125;</span><br><span class="line">webpack &#123;entry file&#125; &#123;destination for bundled file&#125;</span><br></pre></td></tr></table></figure>
<p>指定入口文件后，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># webpack非全局安装的情况</span><br><span class="line">node_modules&#x2F;.bin&#x2F;webpack app&#x2F;main.js public&#x2F;bundle.js</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="https://i.imgur.com/prUbTHf.png"></p>
<p>可以看出webpack同时编译了<code>main.js</code> 和<code>Greeter,js</code>,现在打开<code>index.html</code>,可以看到如下结果</p>
<p><img src="https://i.imgur.com/3ZSkCoR.png"></p>
<p>有没有很激动，已经成功的使用<code>Webpack</code>打包了一个文件了。不过在终端中进行复杂的操作，其实是不太方便且容易出错的，接下来看看Webpack的另一种更常见的使用方法。</p>
<h2 id="通过配置文件来使用Webpack"><a href="#通过配置文件来使用Webpack" class="headerlink" title="通过配置文件来使用Webpack"></a>通过配置文件来使用Webpack</h2><p>Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的<code>loaders</code>和<code>plugins</code>），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。</p>
<p>继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为<code>webpack.config.js</code>的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry:  __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;&#x2F;public&quot;,&#x2F;&#x2F;打包后的文件存放的地方</span><br><span class="line">    filename: &quot;bundle.js&quot;&#x2F;&#x2F;打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
</blockquote>
<p>有了这个配置之后，再打包文件，只需在终端里运行<code>webpack(非全局安装需使用node_modules/.bin/webpack)</code>命令就可以了，这条命令会自动引用<code>webpack.config.js</code>文件中的配置选项，示例如下：</p>
<p><img src="https://i.imgur.com/oxcZjg9.png"></p>
<p>又学会了一种使用<code>Webpack</code>的方法，这种方法不用管那烦人的命令行参数，有没有感觉很爽。如果我们可以连<code>webpack(非全局安装需使用node_modules/.bin/webpack)</code>这条命令都可以不用，那种感觉会不会更爽~，继续看下文。</p>
<h2 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h2><p>在命令行中输入命令需要代码类似于<code>node_modules/.bin/webpack</code>这样的路径其实是比较烦人的，不过值得庆幸的是<code>npm</code>可以引导任务执行，对npm进行配置后可以在命令行中使用简单的<code>npm start</code>命令来替代上面略微繁琐的命令。在<code>package.json</code>中对<code>scripts</code>对象进行相关设置即可，设置方法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot; &#x2F;&#x2F; 修改的是这里，JSON文件不支持注释，引用时请清除</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;zhang&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>package.json</code>中的script会安装一定顺序寻找命令对应位置，本地的<code>node_modules/.bin</code>路径就在这个寻找清单中，所以无论是全局还是局部安装的<code>Webpack</code>，你都不需要写前面那指明详细的路径了。</p>
</blockquote>
<p>npm的<code>start</code>命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用<code>npm start</code>就可以执行其对于的命令，如果对应的此脚本名称不是<code>start</code>，想要在命令行中运行时，需要这样用<code>npm run &#123;script name&#125;</code>如<code>npm run build</code>，我们在命令行中输入<code>npm start</code>试试，输出结果如下：</p>
<p><img src="https://i.imgur.com/kZEQiZR.png"></p>
<p>现在只需要使用<code>npm start</code>就可以打包文件了，有没有觉得<code>webpack</code>也不过如此嘛，不过不要太小瞧<code>webpack</code>，要充分发挥其强大的功能我们需要修改配置文件的其它选项，一项项来看。</p>
<h1 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h1><h2 id="生成Source-Maps（使调试更容易）"><a href="#生成Source-Maps（使调试更容易）" class="headerlink" title="生成Source Maps（使调试更容易）"></a>生成Source Maps（使调试更容易）</h2><p>开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，<code>Source Maps</code>就是来帮我们解决这个问题的。</p>
<p>通过简单的配置，webpack就可以在打包时为我们生成的<code>source maps</code>，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。</p>
<p>在<code>webpack</code>的配置文件中配置<code>source maps</code>，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：</p>
<table>
<thead>
<tr>
<th align="left">devtool选项</th>
<th align="left">配置结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>source-map</code></td>
<td align="left">在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的<code>source map</code>，但是它会减慢打包速度；</td>
</tr>
<tr>
<td align="left"><code>cheap-module-source-map</code></td>
<td align="left">在一个单独的文件中生成一个不带列映射的<code>map</code>，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>
</tr>
<tr>
<td align="left"><code>eval-source-map</code></td>
<td align="left">使用eval打包源文件模块，在同一个文件中生成干净的完整的<code>source map</code>。这个选项可以在不影响构建速度的前提下生成完整的<code>sourcemap</code>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>
</tr>
<tr>
<td align="left"><code>cheap-module-eval-source-map</code></td>
<td align="left">这是在打包文件时最快的生成<code>source map</code>的方法，生成的<code>Source Map</code> 会和打包后的<code>JavaScript</code>文件同行显示，没有列映射，和<code>eval-source-map</code>选项具有相似的缺点；</td>
</tr>
</tbody></table>
<p>正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。</p>
<p>对小到中型的项目中，<code>eval-source-map</code>是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的<code>webpack.config.js</code>，进行如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  devtool: &#39;eval-source-map&#39;,</span><br><span class="line">  entry:  __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;&#x2F;public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑时间成本时使用。</p>
</blockquote>
<h2 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h2><p>想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>devserver作为webpack配置选项中的一项，以下是它的一些配置选项，更多配置可参考<a href="https://webpack.js.org/configuration/dev-server/">这里</a></p>
<table>
<thead>
<tr>
<th>devserver的配置选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>contentBase</td>
<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>
</tr>
<tr>
<td>port</td>
<td>设置默认监听端口，如果省略，默认为”8080“</td>
</tr>
<tr>
<td>inline</td>
<td>设置为<code>true</code>，当源文件改变时会自动刷新页面</td>
</tr>
<tr>
<td>historyApiFallback</td>
<td>在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为<code>true</code>，所有的跳转将指向index.html</td>
</tr>
</tbody></table>
<p>把这些命令加到webpack的配置文件中，现在的配置文件<code>webpack.config.js</code>如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  devtool: &#39;eval-source-map&#39;,</span><br><span class="line"></span><br><span class="line">  entry:  __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;&#x2F;public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">    inline: true&#x2F;&#x2F;实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>package.json</code>中的<code>scripts</code>对象中添加如下命令，用以开启本地服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>在终端中输入<code>npm run server</code>即可在本地的<code>8080</code>端口查看结果</p>
<p><img src="https://i.imgur.com/kp5SKkO.png"></p>
<h2 id="Loaders-鼎鼎大名的Loaders登场了！"><a href="#Loaders-鼎鼎大名的Loaders登场了！" class="headerlink" title="Loaders  鼎鼎大名的Loaders登场了！"></a>Loaders  鼎鼎大名的Loaders登场了！</h2><p><code>Loaders</code>是<code>webpack</code>提供的最激动人心的功能之一了。通过使用不同的<code>loader</code>，<code>webpack</code>有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。</p>
<p>Loaders需要单独安装并且需要在<code>webpack.config.js</code>中的<code>modules</code>关键字下进行配置，Loaders的配置包括以下几方面：</p>
<ul>
<li><p>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</p>
</li>
<li><p>loader：loader的名称（必须）</p>
</li>
<li><p>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</p>
</li>
<li><p>query：为loaders提供额外的设置选项（可选）</p>
</li>
</ul>
<p>不过在配置loader之前，我们把<code>Greeter.js</code>里的问候消息放在一个单独的JSON文件里,并通过合适的配置使<code>Greeter.js</code>可以读取该JSON文件的值，各文件修改后的代码如下：</p>
<p>在app文件夹中创建带有问候信息的JSON文件(命名为<code>config.json</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新后的Greeter.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var config &#x3D; require(&#39;.&#x2F;config.json&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function() &#123;</span><br><span class="line">  var greet &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  greet.textContent &#x3D; config.greetText;</span><br><span class="line">  return greet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注 由于webpack3.*/webpack2.*已经内置可处理JSON文件，这里我们无需再添加webpack1.*需要的json-loader。在看如何具体使用loader之前我们先看看Babel是什么？</p>
</blockquote>
<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p>
<ul>
<li><p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；</p>
</li>
<li><p>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</p>
</li>
</ul>
<h2 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h2><p>Babel其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的<code>babel-env-preset</code>包和解析JSX的<code>babel-preset-react</code>包）。</p>
<p>我们先来一次性安装这些依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</span><br></pre></td></tr></table></figure>
<p>在<code>webpack</code>中配置Babel的方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;public&quot;,&#x2F;&#x2F;打包后的文件存放的地方</span><br><span class="line">        filename: &quot;bundle.js&quot;&#x2F;&#x2F;打包后输出文件的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;eval-source-map&#39;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true&#x2F;&#x2F;实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [</span><br><span class="line">                            &quot;env&quot;, &quot;react&quot;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save react react-dom</span><br></pre></td></tr></table></figure>
<p>接下来我们使用ES6的语法，更新<code>Greeter.js</code>并返回一个React组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Greeter,js</span><br><span class="line">import React, &#123;Component&#125; from &#39;react&#39;</span><br><span class="line">import config from &#39;.&#x2F;config.json&#39;;</span><br><span class="line"></span><br><span class="line">class Greeter extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;config.greetText&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Greeter</span><br></pre></td></tr></table></figure>
<p>修改<code>main.js</code>如下，使用ES6的模块定义和渲染Greeter模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import Greeter from &#39;.&#x2F;Greeter&#39;;</span><br><span class="line"></span><br><span class="line">render(&lt;Greeter &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>
<p>重新使用<code>npm start</code>打包，如果之前打开的本地服务器没有关闭，你应该可以在<code>localhost:8080</code>下看到与之前一样的内容，这说明react和es6被正常打包了。</p>
<p><img src="https://i.imgur.com/J3EDplA.png"></p>
<h2 id="Babel的配置"><a href="#Babel的配置" class="headerlink" title="Babel的配置"></a>Babel的配置</h2><p>Babel其实可以完全在 <code>webpack.config.js</code> 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的<code>webpack.config.js</code>文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用<code>.babelrc</code>里的babel配置选项），如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;public&quot;,&#x2F;&#x2F;打包后的文件存放的地方</span><br><span class="line">        filename: &quot;bundle.js&quot;&#x2F;&#x2F;打包后输出文件的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;eval-source-map&#39;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true&#x2F;&#x2F;实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。</p>
<h1 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h1><p>Webpack有一个不可不说的优点，它把所有的文件都都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>webpack提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使你能够使用类似<code>@import </code>和 <code>url(...)</code>的方法实现 <code>require()</code>的功能,<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>
<p>继续上面的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;安装</span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意这里对同一个文件引入多个loader的方法。</p>
</blockquote>
<p>接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* main.css *&#x2F;</span><br><span class="line">html &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  -ms-text-size-adjust: 100%;</span><br><span class="line">  -webkit-text-size-adjust: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *:before, *:after &#123;</span><br><span class="line">  box-sizing: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1, h2, h3, h4, h5, h6, p, ul &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里例子中用到的<code>webpack</code>只有单一的入口，其它的模块需要通过 <code>import</code>, <code>require</code>, <code>url</code>等与入口文件建立其关联，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123;render&#125; from &#39;react-dom&#39;;</span><br><span class="line">import Greeter from &#39;.&#x2F;Greeter&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;.&#x2F;main.css&#39;;&#x2F;&#x2F;使用require导入css文件</span><br><span class="line"></span><br><span class="line">render(&lt;Greeter &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。</p>
</blockquote>
<p>上面的代码说明webpack是怎么把css当做模块看待的，咱们继续看一个更加真实的css模块实践。</p>
<h2 id="CSS-module"><a href="#CSS-module" class="headerlink" title="CSS module"></a>CSS module</h2><p>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动完成。</p>
<p>不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。</p>
<p>被称为<code>CSS modules</code>的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。具体的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true, &#x2F;&#x2F; 指定启用css modules</span><br><span class="line">                            localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39; &#x2F;&#x2F; 指定css的类名格式</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在app文件夹下创建一个<code>Greeter.css</code>文件来进行一下测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Greeter.css *&#x2F;</span><br><span class="line">.root &#123;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  border: 3px solid #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入<code>.root</code>到Greeter.js中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import config from &#39;.&#x2F;config.json&#39;;</span><br><span class="line">import styles from &#39;.&#x2F;Greeter.css&#39;;&#x2F;&#x2F;导入</span><br><span class="line"></span><br><span class="line">class Greeter extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&#123;styles.root&#125;&gt; &#x2F;&#x2F;使用cssModule添加类名的方法</span><br><span class="line">        &#123;config.greetText&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Greeter</span><br></pre></td></tr></table></figure>
<p>放心使用把，相同的类名也不会造成不同组件之间的污染。</p>
<p><img src="https://i.imgur.com/kiHmsaq.png"></p>
<p>CSS modules 也是一个很大的主题，有兴趣的话可以去其<a href="https://github.com/css-modules/css-modules">官方文档</a>了解更多。</p>
<h2 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h2><p><code>Sass</code> 和 <code>Less</code> 之类的预处理器是对原生CSS的拓展，它们允许你使用类似于<code>variables</code>, <code>nesting</code>, <code>mixins</code>, <code>inheritance</code>等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，</p>
<p>你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理<code>loaders</code>:</p>
<ul>
<li><p><code>Less Loader</code></p>
</li>
<li><p><code>Sass Loader</code></p>
</li>
<li><p><code>Stylus Loader</code></p>
</li>
</ul>
<p>不过其实也存在一个CSS的处理平台<code>-PostCSS</code>，它可以帮助你的CSS实现更多的功能，在其<a href="https://github.com/postcss/postcss">官方文档</a>可了解更多相关知识。</p>
<p>举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</p>
<p>首先安装<code>postcss-loader</code> 和 <code>autoprefixer</code>（自动添加前缀的插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>
<p>接下来，在webpack配置文件中添加<code>postcss-loader</code>，在根目录新建<code>postcss.config.js</code>,并添加如下代码之后，重新使用<code>npm start</code>打包时，你写的css会自动根据Can i use里的数据添加不同前缀了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;webpack.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; postcss.config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        require(&#39;autoprefixer&#39;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，本文已经谈论了处理JS的Babel和处理CSS的PostCSS的基本用法，它们其实也是两个单独的平台，配合<code>webpack</code>可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-<code>Plugins</code></p>
<h1 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h1><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。</p>
<p><code>Loaders</code>和<code>Plugins</code>常常被弄混，但是他们其实是完全不同的东西，可以这么来说，<code>loaders</code>是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>
<p>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<h2 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h2><p>要使用某个插件，我们需要通过<code>npm</code>安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续上面的例子，我们添加了一个给打包后代码<a href="https://webpack.js.org/plugins/banner-plugin/">添加版权声明的插件</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;)</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这个插件，打包后的JS文件显示如下</p>
<p><img src="https://i.imgur.com/rwskoq1.png"></p>
<p>这就是webpack插件的基础用法了，下面给大家推荐几个常用的插件</p>
<h2 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h2><p>这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改：</p>
<ol>
<li><p>移除public文件夹，利用此插件，<code>index.html</code>文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</p>
</li>
<li><p>在app目录下，创建一个<code>index.tmpl.html</code>文件模板，这个模板包含<code>title</code>等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，<code>index.tmpl.html</code>中的模板源代码如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Sample Project&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;root&#39;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>更新<code>webpack</code>的配置文件，方法同上,新建一个<code>build</code>文件夹用来存放最终的输出文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">        filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;eval-source-map&#39;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true&#x2F;&#x2F;实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;&#x2F;app&#x2F;index.tmpl.html&quot;&#x2F;&#x2F;new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再次执行<code>npm start</code>你会发现，build文件夹下面生成了<code>bundle.js</code>和<code>index.html</code>。</p>
<p><img src="https://i.imgur.com/XU0jiRk.png"></p>
<h2 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h2><p><code>Hot Module Replacement（HMR）</code>也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</p>
<p>在webpack中实现HMR也很简单，只需要做两项配置</p>
<ol>
<li><p>在webpack配置文件中添加HMR插件；</p>
</li>
<li><p>在Webpack Dev Server中添加“hot”参数；</p>
</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p>
<p>整理下我们的思路，具体实现方法如下</p>
<ul>
<li><p>Babel和webpack是独立的工具</p>
</li>
<li><p>二者可以一起工作</p>
</li>
<li><p>二者都可以通过插件拓展功能</p>
</li>
<li><p>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；</p>
</li>
<li><p>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；<br>还是继续上例来实际看看如何配置</p>
</li>
</ul>
<p>还是继续上例来实际看看如何配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">        filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;eval-source-map&#39;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true,</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;&#x2F;app&#x2F;index.tmpl.html&quot;&#x2F;&#x2F;new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.HotModuleReplacementPlugin()&#x2F;&#x2F;热加载插件</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="安装react-transform-hmr"><a href="#安装react-transform-hmr" class="headerlink" title="安装react-transform-hmr"></a>安装react-transform-hmr</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-react-transform react-transform-hmr</span><br></pre></td></tr></table></figure>
<h3 id="配置Babel"><a href="#配置Babel" class="headerlink" title="配置Babel"></a>配置Babel</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;development&quot;: &#123;</span><br><span class="line">    &quot;plugins&quot;: [[&quot;react-transform&quot;, &#123;</span><br><span class="line">       &quot;transforms&quot;: [&#123;</span><br><span class="line">         &quot;transform&quot;: &quot;react-transform-hmr&quot;,</span><br><span class="line">         </span><br><span class="line">         &quot;imports&quot;: [&quot;react&quot;],</span><br><span class="line">         </span><br><span class="line">         &quot;locals&quot;: [&quot;module&quot;]</span><br><span class="line">       &#125;]</span><br><span class="line">     &#125;]]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在当你使用React时，可以热加载模块了,每次保存就能在浏览器上看到更新内容。</p>
<h1 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h1><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。</p>
<p>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个<code>webpack.production.config.js</code>的文件，在里面加上基本的配置,它和原始的<code>webpack.config.js</code>很像，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.production.config.js</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;, &#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">        filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;null&#39;, &#x2F;&#x2F;注意修改了这里，这能大大压缩我们的打包代码</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;, &#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true, &#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true,</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &quot;babel-loader&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: &#x2F;\.css$&#x2F;,</span><br><span class="line">            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: &quot;style-loader&quot;,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: &quot;css-loader&quot;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        modules: true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: &quot;postcss-loader&quot;</span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;&#x2F;app&#x2F;index.tmpl.html&quot; &#x2F;&#x2F;new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.HotModuleReplacementPlugin() &#x2F;&#x2F;热加载插件</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;NODE_ENV&#x3D;production webpack --config .&#x2F;webpack.production.config.js --progress&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^15.6.1&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^15.6.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:如果是window电脑，build需要配置为”build”: “set NODE_ENV=production &amp;&amp; webpack –config ./webpack.production.config.js –progress”.谢谢评论区简友提醒。</p>
</blockquote>
<h2 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h2><p>webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p>
<ul>
<li><p><code>OccurenceOrderPlugin</code> :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</p>
</li>
<li><p><code>UglifyJsPlugin</code>：压缩JS代码；</p>
</li>
<li><p><code>ExtractTextPlugin</code>：分离CSS和JS文件</p>
</li>
</ul>
<p>我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装其它非内置插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>在配置文件的plugins后引用它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.production.config.js</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: __dirname + &quot;&#x2F;app&#x2F;main.js&quot;,&#x2F;&#x2F;已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">        filename: &quot;bundle.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;none&#39;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;public&quot;,&#x2F;&#x2F;本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,&#x2F;&#x2F;不跳转</span><br><span class="line">        inline: true,</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;(\.jsx|\.js)$&#x2F;,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.css$&#x2F;,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            modules: true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;&#x2F;app&#x2F;index.tmpl.html&quot;</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时执行<code>npm run build</code>可以看见代码是被压缩后的</p>
<p><img src="https://i.imgur.com/nHIKZI6.png"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）</p>
<p>webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class="line">const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">..</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;&#x2F;build&quot;,</span><br><span class="line">        filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在用户会有合理的缓存了。</p>
<p><img src="https://i.imgur.com/1GWGRHn.png"></p>
<h2 id="去除build文件中的残余文件"><a href="#去除build文件中的残余文件" class="headerlink" title="去除build文件中的残余文件"></a>去除build文件中的残余文件</h2><p>添加了<code>hash</code>之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件<code>clean-webpack-plugin</code>。</p>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p><code>cnpm install clean-webpack-plugin --save-dev</code></p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>引入<code>clean-webpack-plugin</code>插件后在配置文件的<code>plugins</code>中做相应配置即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CleanWebpackPlugin &#x3D; require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">  plugins: [</span><br><span class="line">    ...&#x2F;&#x2F; 这里是之前配置的其它各种插件</span><br><span class="line">    new CleanWebpackPlugin(&#39;build&#x2F;*.*&#39;, &#123;</span><br><span class="line">      root: __dirname,</span><br><span class="line">      verbose: true,</span><br><span class="line">      dry: false</span><br><span class="line">  &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>关于<code>clean-webpack-plugin</code>的详细使用可参考<a href="https://github.com/johnagan/clean-webpack-plugin">这里</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>其实这是一年前的文章了，趁周末重新运行和修改了一下，现在所有的代码都可以正常运行，所用webpack基于最新的webpack3.5.3。希望依旧能对你有帮助。</p>
</blockquote>
]]></content>
      <tags>
        <tag>webpack 模块 打包 CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>工程师如何在工作中提升自己</title>
    <url>/2018/09/12/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1/</url>
    <content><![CDATA[<p>作者： 刘丁 From 美团技术团队</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。</p>
<p>如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答：</p>
<ul>
<li><p>第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。</p>
</li>
<li><p>提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。</p>
</li>
<li><p>成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。</p>
</li>
</ul>
<a id="more"></a>

<h1 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h1><p>在繁忙的工作中，持之以恒、不断学习和进步是一件艰巨的任务，需要坚强的毅力和坚定的决心。如果方法不得当，更是事倍功半。幸好我们的古人和现在哲人已经总结了很多优秀的学习方法论，这里汇总了一些重要原则。遵循这些方法必会对大家的工作学习大有裨益。</p>
<h2 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h2><p>有报道指出，过去几十年的知识量超过之前人类几千年的知识量总和。而计算机领域绝对是当代知识更新最快的领域之一，因此，工程师必须要接受这样一个现实，现在所掌握的深厚知识体系很快就会被淘汰。要想在计算机领域持续做优秀架构师，就必须不停的学习，掌握最新技术。总之，学不可以已。</p>
<p>所谓“冰冻三尺，非一日之寒，水滴石穿，非一日之功”，通往架构师的道路漫长而又艰巨，轻易放弃，则所有付出瞬间付之东流。要想成为优秀的架构师，贵在坚持！</p>
<p>虽然知识更新很快，但是基础理论的变化却非常缓慢。这就是“道”和“象”关系，纵是世间万象，道却万变不离其宗。对于那些非常基础的理论知识，我们需要经常复习，也就是“学而时习之”。</p>
<h2 id="重视实践"><a href="#重视实践" class="headerlink" title="重视实践"></a>重视实践</h2><p>古人云：“纸上得来终觉浅，绝知此事要躬行。” 学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但对于工程师们来说，按照实践、学习和培训的方式进行重要性排序，大致是不错的。所以重视实践，在实践中成长是最重要的学习原则。</p>
<p>人类的认知有两种：感性认知和理性认知。这两种认知互相不可替代性。实践很大程度来自于感性学习，看书更像是理性学习。以学开汽车做例子，很难想象什么人能够仅仅通过学习书本知识就会开汽车。</p>
<p>书本知识主要是传道——讲述抽象原型，而对其具体应用场景的讲述往往含糊其辞，对抽象原型之间的关系也是浅尝辄止。采用同样精确的语言去描述应用场景和关联关系将会失去重点，让人摸不着头脑。所以，仅仅通过看书来获得成长就像是用一条腿走路。</p>
<p>重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。</p>
<h2 id="重视交流"><a href="#重视交流" class="headerlink" title="重视交流"></a>重视交流</h2><p>牛顿说：“如果说我看得比别人远一些，那是因为我站在巨人的肩膀上。”我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。</p>
<p>向老师和领导学习已经是人们生活习惯的一部分了。但是从同事甚至对手那里学习也很重要，因为这些人和我们自身更相似。所以要多多观察，取其所长，弃其所短。对于团队的小兄弟和下属，也要“不耻下问”。</p>
<p>此外，在项目中积极参与具体方案讨论也非常重要。参与者先验感知了相关背景，并且讨论的观点和建议也是综合了发言者多种知识和技能。所以，讨论让参与者能够非常全面，立体地理解书本知识。同时，和高手讨论，他们的观点就会像修剪机剪树枝一样，快速的剪掉自己知识领域里面的疑惑点。</p>
<h2 id="重视总结和输出"><a href="#重视总结和输出" class="headerlink" title="重视总结和输出"></a>重视总结和输出</h2><p>工程师在实践中会掌握大量细节，但是，即使掌握了所有细节，却没有深刻的总结和思考，也会陷入到“学而不思则罔”的境地。成长的“量变”来自于对细节的逐渐深入地把控，而真正的“质变”来自于对“道”的更深层次的理解。</p>
<p>将经验输出，接受别人的检验是高层次的总结。这种输出不仅帮助了别人，对自身更是大有裨益。总结的方式有很多，包括组织分享，撰写技术文章等等。当然“日三省吾身”也是不错的总结方式。总之，多多总结，多多分享，善莫大焉！</p>
<p>解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。</p>
<h2 id="重视规划"><a href="#重视规划" class="headerlink" title="重视规划"></a>重视规划</h2><p>凡事预则立，不预则废。对于漫长的学习生涯而言，好的计划是成功的一半。</p>
<h2 id="长期规划"><a href="#长期规划" class="headerlink" title="长期规划"></a>长期规划</h2><p>长期规划的实施需要毅力和决心，但是做正确的长期规划还需要高瞻远瞩的眼界、超级敏感的神经和中大奖的运气。对于大部分人来说，长期规划定主要是“定方向”。但遵循如下原则能够减少犯方向性错误的概率：</p>
<ul>
<li><p>远离日暮西山的行业。</p>
</li>
<li><p>做自己感兴趣的事情。</p>
</li>
<li><p>做有积累的事情。</p>
</li>
<li><p>一边走一边看，切勿一条道走到黑。</p>
</li>
</ul>
<h2 id="短期规划"><a href="#短期规划" class="headerlink" title="短期规划"></a>短期规划</h2><p>良好的短期规划应该在生活、成长、绩效和晋升之间取得平衡。大部分公司都会制定一个考核周期——少则一个月，多则一年。所以不妨以考核周期作为短期学习规划周期。本质上，规划是一个多目标优化问题，它有一系列的理论方案，这里不一一细说。基于相关理论，我给出一个简单易行的方案：</p>
<ul>
<li><p>确定目标优先级。比如：成长、生活、绩效。</p>
</li>
<li><p>确定每个目标的下限。从优化理论的角度来看，这被称为约束。比如绩效必须在一般以上，之前已经规划好的旅行不能更改，必须读完《Effective Java》等等。</p>
</li>
<li><p>优先为下限目标分配足够的资源。比如，事先规划好的旅行需要10天，这10天就必须预算出去。</p>
</li>
<li><p>按照各主目标的顺序依次分配资源。比如，最终分配给学习的时间是10天。</p>
</li>
<li><p>在给定的学习预算下，制定学习目标，要激进。然后给出执行方案。比如，学习目标是掌握基本的统计学知识，并成为Java专家。具体方案为：完成《Effective Java》、《Java Performance》、《Design Pattern》、《Head First Statistics》四本书的阅读。</p>
</li>
<li><p>对规划中的各学习任务按目标优先级进行排序，并最先启动优先级最高的任务。比如，最高优先级是掌握统计理论，那么就要先看《Head First Statistics》。</p>
</li>
</ul>
<p>对于该方案，要注意以下几点：</p>
<ul>
<li><p>最低目标必须能够轻松达成的目标，否则，从优化理论的角度来讲，该命题无解。比如，类似“半年内完成晋级两次、绩效全部S、从菜鸟成为Java专家”就不太合适作为最低目标。总之，要区分理想和梦想。</p>
</li>
<li><p>主要目标规划必须具备一定的挑战性，需要规划出不可能完成的目标。过度规划本质上是一种贪婪算法，目的是目标价值最大化。因为一切皆有变数，如果其他目标能够提前完成，就不妨利用这些时间去完成更多的学习目标。总之，前途必须光明，道路必须坎坷。</p>
</li>
<li><p>各目标之间不一定共享资源，规划不一定互有冲突。</p>
</li>
</ul>
<p>此外，短期规划还可以从如下几个方面进行优化：</p>
<ul>
<li><p>学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。比如，本季度规划去做一些数据分析工作，那么不妨把学习目标设置为学习统计知识。</p>
</li>
<li><p>要灵活对待规划的目标和具体执行步骤，需要避免“郑人买履”式的笑话。面临新的挑战和变化，规划需要不断地调整。</p>
</li>
</ul>
<h1 id="那些令人纠结的困惑"><a href="#那些令人纠结的困惑" class="headerlink" title="那些令人纠结的困惑"></a>那些令人纠结的困惑</h1><p>人生是一场马拉松，在漫长的征途中，难免有很多困惑。困惑就像枷锁，使我们步履蹒跚，困惑就像死锁，让我们停滞不前。</p>
<p>接下来我将总结自己在工作中碰到和看到的一些典型困惑。这些困惑或者长期困扰作者本人，或者困扰我身边的同事和朋友。当这些困惑被释然之后，大家都感觉如重获释，为下一阶段的征程提供满满的正能量。人生就像一场旅途，不必在乎目的地，在乎的，应该是沿途的风景，以及看风景的心情。良好的心态是技术之旅最好的伴侣。期望通过这个解惑之旅，让大家拥有一个愉快的心情去感受漫长的学习旅途。</p>
<h2 id="学无止境吗"><a href="#学无止境吗" class="headerlink" title="学无止境吗"></a>学无止境吗</h2><p>必须要承认一个残酷的现实：人的生命是有限的，知识却是无限的。用有限的生命去学习无限的知识是不可能完成的任务。一想到此，有些工程师不免产生一些悲观情绪。如果方法得当并且足够勤奋，悲伤大可不必。</p>
<p>虽然，人类的整体知识体系一直在扩张。但是就很多重要的工程细分领域，基础理论并不高深。计算机的很多重要领域，工程师有能力在有限时间内抓住核心要害。</p>
<p>比如，密码学被认为是门非常高深的学科，但是一大类密码技术的基础是数论中一个非常简单的理论——素因数分解：给出两个素数，很容易算出它们的积，然而反过来给定两个素数的积，分解的计算量却非常惊人。</p>
<p>“一致性”算得上是计算机领域里面最经典的难题，它是所有分布式系统的基础，从多核多CPU到多线程，从跨机器到跨机房，无所不在，几乎所有的计算机从业人员都在解决这个问题，但是Paxos给出了一个很优雅的解决方案。</p>
<p>权限管理是很多工程师的噩梦，但如果你能搞定“Attribute Based Access Control(ABAC)”和“Role-Based Access Control(RBAC)”，也能达到相当高度。</p>
<p>另外，技术学习是一场对抗赛，虽然学无止境，超越大部分对手就是一种胜利。所以，以正确的学习方式，长时间投入就会形成核心竞争力。</p>
<h2 id="没有绝对高明的技术，只有真正的高手"><a href="#没有绝对高明的技术，只有真正的高手" class="headerlink" title="没有绝对高明的技术，只有真正的高手"></a>没有绝对高明的技术，只有真正的高手</h2><p>致力于在技术上有所成就的工程师，都梦想有朝一日成为技术高手。但技术高手的标准却存在很大的争议。这是一个有着悠久历史的误解：以某种技术的掌握作为技术高手的评判标准。我经常碰到这样一些情景：因为掌握了某些技术，比如Spring、Kafka、Elasticsearch等，一些工程师就自封为高手。有些工程师非常仰慕别的团队，原因竟是那个团队使用了某种技术。</p>
<p>这种误解的产生有几个原因：首先，技多不压身，技术自然是掌握的越多越好，掌握很多技术的人自然不是菜鸟。其次，在互联网时代来临之前，信息获取是非常昂贵的事情。这就导致一项技能的掌握可以给个人甚至整个公司带来优势地位。互联网时代，各种框架的出现以及开源的普及快速淘汰或者降低了很多技能的价值，同时降低了很多技术的学习门槛。所以，在当前，掌握某项技能知识只能是一个短期目标。怀揣某些技能就沾沾自喜的人需要记住：骄傲使人退步。</p>
<p>所谓麻雀虽小，五脏俱全。如果让你来做造物主，设计麻雀和设计大象的复杂度并没有明显区别。一个看起来很小的业务需求，为了达到极致，所需要的技术和能力是非常综合和高深的。真正的高手不是拿着所掌握的技术去卡客户需求，而是倾听客户的需求，给出精益求精的方案。完成客户的需求是一场擂台赛，真正的高手，是会见招拆招的。</p>
<h2 id="不做项目就无法成长吗"><a href="#不做项目就无法成长吗" class="headerlink" title="不做项目就无法成长吗"></a>不做项目就无法成长吗</h2><p>在项目中学习是最快的成长方式之一，很多工程师非常享受这个过程。但是一年到头都做项目，你可能是在一家外包公司。对于一个做产品的公司，如果年头到年尾都在做项目，要不然就是在初步创业阶段，要不然就是做了大量失败的项目，总之不算是特别理想的状态。正常情况，在项目之间都会有一些非项目时间。在这段时间，有些同学会产生迷茫，成长很慢。</p>
<p>项目真的是越多越好吗？答案显然是否定的。重复的项目不会给工程师们带来新的成长。不停的做项目，从而缺乏学习新知识的时间，会导致“做而不学则殆”。真正让工程师出类拔萃的是项目的深度，而不是不停地做项目。所以，在项目之间的空档期，工程师们应该珍惜难得的喘息之机，深入思考，把项目做深，做精。</p>
<p>如何提高项目的深度呢？一般而言，任何项目都有一个目标，当项目完成后，目标就算基本达成了。但是，客户真的满意了吗？系统的可用性、可靠性、可扩展性、可维护性已经做到极致了吗？这几个问题的答案永远是否定的。所以，任何一个有价值的项目，都可以一直深挖。深挖项目，深度思考还可以锻炼工程师的创造力。期望不停地做项目的人，就像一个致力于训练更多千里马的人是发明不出汽车的。锻炼创造力也不是一蹴而就的事情，需要长时间地思考。总之，工程师们应该总是觉得时间不够用，毕竟时间是最宝贵的资源。</p>
<h2 id="职责真的很小吗"><a href="#职责真的很小吗" class="headerlink" title="职责真的很小吗"></a>职责真的很小吗</h2><p>很多时候，一个工程师所负责系统的数量和团队规模与其“江湖地位”正相关。但是，江湖地位与技术成长没有必然关联。提升技术能力的关键是项目深度以及客户的挑剔程度。项目越多，在单个项目中投入的时间就越少，容易陷入肤浅。特别需要避免的是“ 在其位不谋其政”的情况。团队越大，在管理方面需要投入的精力就越多。在管理技巧不成熟，技术眼界不够高的前提强行负责大团队，可能会导致个人疲于应付，团队毫无建树。最终“ 一将无能，累死三军”，效果可能适得其反。</p>
<p>从技术发展的角度来说，技术管理者应该关注自己所能把控的活跃项目的数量，并致力于提高活跃项目的影响力和技术深度。团队人数要与个人管理能力、规划能力和需求把控能力相适应。一份工作让多个人来干，每个人的成长都受限。每个人都做简单重复的工作，对技术成长没有任何好处。团队管理和项目管理需要循序渐进，忌“拔苗助长”。</p>
<h2 id="一定要当老大吗"><a href="#一定要当老大吗" class="headerlink" title="一定要当老大吗"></a>一定要当老大吗</h2><p>有一些工程师的人生理想是做团队里的技术老大，这当然是一个值得称赞的理想。可是，如果整个团队技术能力一般，发展潜力一般，而你是技术最强者，这与其说是幸运，不如说是悲哀。这种场景被称之为“武大郎开店”。 团队里的技术顶尖高手不是不能做，但为了能够持续成长，需要满足如下几个条件：</p>
<ul>
<li><p>首先你得是行业里面的顶尖专家了——实在很难找到比你更强的人了！</p>
</li>
<li><p>其次，你经常需要承担对你自己的能力有挑战的任务，但同时你拥有一批聪明能干的队友。虽然你的技术能力最高，但是在你不熟悉的领域，你的队友能够进行探索并扩展整个团队的知识。</p>
</li>
<li><p>最后，你必须要敏而好学，不耻下问。</p>
</li>
</ul>
<p>否则，加入更强的技术团队或许是更好的选择，最少不是什么值得骄傲的事情。</p>
<h2 id="平台化的传说"><a href="#平台化的传说" class="headerlink" title="平台化的传说"></a>平台化的传说</h2><p>平台化算得上是“高大上”的代名词了，很多工程师挤破头就为了和“平台化”沾点边。然而和其他业务需求相比，平台化需求并没有本质上的区别。无论是平台化需求还是普通业务需求，它的价值都来自于客户价值。不同点如下：</p>
<ul>
<li><p>很多平台化需求的客户来自于技术团队，普通需求的客户来自于业务方。</p>
</li>
<li><p>产品经理不同。普通业务需求来自于产品经理，平台化需求的产品经理可能就是工程师自己。长期被产品经理“压迫”的工程师们，在平台化上终于找到“翻身农奴把歌唱”的感觉。</p>
</li>
<li><p>很多平台化的关注点是接入能力和可扩展性，而普通业务的关注点更多。</p>
</li>
</ul>
<p>归根结底，平台化就是一种普通需求。在实施平台化之前，一定要避免下面两个误区：</p>
<ul>
<li><p>平台化绝对不是诸如“统一”、“全面”之类形容词的堆砌。是否需要平台化，应该综合考虑：客户数量，为客户解决的问题，以及客户价值是否值得平台化的投入。</p>
</li>
<li><p>平台化不是你做平台，让客户来服务你。一些平台化设计者的规划设计里面，把大量的平台接入工作、脏活累活交给了客户，然后自己专注于所谓“最高大上”的功能。恰恰相反，平台化应该是客户什么都不做，所有的脏活累活都由平台方来做。本质上讲，平台化的价值来自于技术深度。真正体现技术深度的恰恰是设计者能够很轻松的把所有的脏活累活搞定。</p>
</li>
</ul>
<p>所以平台化的最佳实践是：投入最少的资源，解决最多的问题。平台解决一切，客户坐享其成。</p>
<h2 id="搞基础技术就一定很牛吗"><a href="#搞基础技术就一定很牛吗" class="headerlink" title="搞基础技术就一定很牛吗"></a>搞基础技术就一定很牛吗</h2><p>经常听到同学们表达对基础技术部同学的敬仰之情，而对搞业务技术的同学表现出很轻视，认为存储、消息队列、服务治理框架（比如美团点评内部使用的OCTO）、Hadoop等才能被称为真正的技术。事实并非如此，更基础的并不一定更高深。</p>
<p>比如下面这个流传很久的段子：越高级的语言就越没有技术含量。但真是这样吗，就拿Java和C来说，这是完全不同的两种语言，所需要的技能完全不同。C或许跟操作系统更加接近一点，和CPU、内存打交道的机会更多一点。但是为了用好Java，程序员在面向对象、设计模式、框架技术方面必须要非常精通。Java工程师转到C方向确实不容易，但作者也见过很多转到Java语言的C工程师水土不服。</p>
<p>基础技术和业务应用技术必然会有不同的关注点，没有高低之分。之所以产生这种误解，有两个原因：</p>
<ul>
<li><p>基础技术相对成熟，有比较完整的体系，这给人一个高大上的感觉。业务应用技术相对来说，由于每个团队使用的不一样，所以成熟度参差不齐，影响力没有那么大。</p>
</li>
<li><p>基础技术的门槛相对来说高一点，考虑到影响面，对可靠性、可用性等有比较高的最低要求。但是门槛高不代表技术含量高，另外成熟技术相对来说在创新方面会受到很大的约束。但是最先进的技术都来自活跃的创新。</p>
</li>
</ul>
<p>对比下来，业务技术和基础技术各有千秋。但真正的高手关注的是解决问题，所有的技术都是技能而已。</p>
<h2 id="可行性调研的那些坑"><a href="#可行性调研的那些坑" class="headerlink" title="可行性调研的那些坑"></a>可行性调研的那些坑</h2><p>工作中开展可行性调研时有发生。做可行性调研要避免如下情况：</p>
<ul>
<li><p>把可行性调研做成不可行性调研。这真的非常糟糕。不可行性的结论往往是：因为这样或者那样的原因，所以不可行。</p>
</li>
<li><p>避免“老鼠给猫挂铃铛”式的高风险可行性方案。“天下大事必作于细”，可行性调研一定要细致入微，避免粗枝大叶。</p>
</li>
<li><p>避免调研时间过长。如果发现调研进展进入到指数级复杂度，也就是每前进一步需要之前两倍的时间投入，就应该果断的停止调研。</p>
</li>
</ul>
<p>可行性调研的结论应该是收益与成本的折衷，格式一般如下：</p>
<ul>
<li><p>首先明确预期的结果，并按照高中低收益进行分级。</p>
</li>
<li><p>阐述达成每种预期结果需要采取的措施和方案。</p>
</li>
<li><p>给出实施各方案需要付出的成本。</p>
</li>
</ul>
<h2 id="工程师天生不善沟通吗"><a href="#工程师天生不善沟通吗" class="headerlink" title="工程师天生不善沟通吗"></a>工程师天生不善沟通吗</h2><p>实际工作中，沟通所导致的问题层出不穷。工程师有不少是比较内向的，总是被贴上“不善沟通”的标签。实际上，沟通能力是工程师最重要的能力之一，良好的沟通是高效工作学习的基础，也是通过学习可以掌握的。下面我按工程师的语言说说沟通方面的经验。</p>
<p>第一类常见的问题是沟通的可靠性。从可靠性的角度来讲，沟通分为TCP模式和UDP模式。TCP模式的形象表述是：我知道你知道。UDP模式的形象表述是：希望你知道。TCP模式当然比较可靠，不过成本比较高，UDP模式成本低，但是不可靠。在沟通可靠性方面，常见错误有如下两种：</p>
<ul>
<li><p>经常听到的这样的争论。一方说：“我已经告诉他了”，另一方说：“我不知道这个事情呀”。把UDP模式被当作TCP模式来使用容易产生扯皮。</p>
</li>
<li><p>过度沟通。有些同学对沟通的可靠性产生了过度焦虑，不断的重复讨论已有结论问题。把TCP模式当成UDP来使用，效率会比较低。</p>
</li>
</ul>
<p>第二类沟通问题是时效性问题。从时效性讲，沟通分为：同步模式和异步模式。同步沟通形象地说就是：你现在给我听好了。异步沟通的形象表述是：记得给我做好了。在沟通时效性方面，有如下两种常见错误：</p>
<ul>
<li><p>已经出现线上事故，紧急万分。大家你一言，我一语，感觉事故可能和某几个人有关，但是也不能完全确定，所以没有通知相关人员。最终，一个普通的事故变成了严重事故。对于紧急的事情，必须要同步沟通。</p>
</li>
<li><p>半夜三点你正在熟睡，或者周末正在逛街，接到一个电话：“现在有个需求，能否立刻帮忙做完。”这会非常令人郁闷，因为那并不是紧急的事情。不是所有的需求都需要立刻解决。</p>
</li>
</ul>
<p>有效沟通的一个重要原则是提前沟通。沟通本质是信息交流和处理，可以把被沟通对象形象地比喻成串行信息处理的CPU。提前沟通，意味着将处理请求尽早放入处理队列里面。下面的例子让很多工程师深恶痛绝：一个需求策划了1个月，产品设计了2周。当开发工程是第一次听说该需求的时候，发现开发的时间是2天。工程师据理力争，加班加点1周搞定。最后的结论是工程师非常不给力，不配合。就像工程师讨厌类似需求一样。要协调一个大项目，希望获得别人的配合，也需要尽早沟通。</p>
<p>有效沟通的另外一个重点是“不要跑题”。很多看起来很接近的问题，本质上是完全不同的问题。比如：一个会议的主题是“如何实施一个方案”，有人却可能提出“是否应该实施该方案”。 “如何实施”和“是否应该实施”是完全不同的两个问题，很多看起来相关的问题实际上跑题很远。“跑题”是导致无效沟通的重要原因。</p>
<p>良好沟通的奥秘在于能掌握TCP模式和UDP模式精髓，正确判断问题的紧急性，尽量提前沟通，避免跑题。</p>
<h2 id="带人之道"><a href="#带人之道" class="headerlink" title="带人之道"></a>带人之道</h2><p>有些初为导师的工程师由于担心毕业生的能力太弱，安排任务时候谆谆教诲，最后感觉还是有所顾虑，干脆自己写代码。同样的事情发生在很多刚刚管理小团队的工程师身上。最终的结果他们：写完所有的代码，让下属无代码可写。“ 事必躬亲”当然非常糟糕，最终的往往是团队的整体绩效不高，团队成员的成长很慢，而自己却很累。</p>
<p>古人说：“用人不疑，疑人不用。”这句话并非“放之四海而皆准”。在古代，受限于通信技术，反馈延迟显著，而且信息在传递过程中有大量噪音，变形严重。在这种情况下，如果根据短期内收集的少量变形的信息做快速决断，容易陷于草率。在公司里，这句话用于选人环节更为恰当，应该改为：录用不疑，疑人不录。</p>
<p>考虑到招聘成本，就算是在录用层面，有时候也无法做到。作为一个小团队的管理者，能够快速准确的获取团队成员的各种反馈信息，完全不需要“用人不疑，疑人不用”。用人的真正理论基础来自于“探索和利用”(Exploration and Exploitation )。不能因为下属能做什么就只让他做什么，更不能因为下属一次失败就不给机会。</p>
<p>根据经典的“探索和利用”(Exploration and Exploitation )理论，良好的用人方式应该如下：</p>
<ul>
<li><p>首选选择相信，在面临失败后，收缩信任度。</p>
</li>
<li><p>查找失败的原因，提供改进意见，提升下属的能力。</p>
</li>
<li><p>总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。</p>
</li>
</ul>
<h2 id="效率、效率、效率"><a href="#效率、效率、效率" class="headerlink" title="效率、效率、效率"></a>效率、效率、效率</h2><p>经常看到有些同学给自己的绩效评分是100分——满分，原因是在过去一段时间太辛苦了，但最终的绩效却一般般。天道酬勤不错，但是天道更酬巧。工程师们都学过数据结构，不同算法的时间复杂度的差距，仅仅通过更长的工作时间是难以弥补的。为了提升工作学习效率，我们需要注意以下几点：</p>
<ul>
<li><p>主要关注效率提升。很多时候，与效率提升所带来的收益相比，延长时间所带来的成果往往不值得一提。</p>
</li>
<li><p>要有清晰的结果导向思维。功劳和苦劳不是一回事。</p>
</li>
<li><p>做正确的事情，而不仅仅正确地做事情。这是一个被不断提起的话题，但是错误每天都上演。为了在规定的时间内完成一个大项目，总是要有所取舍。如果没有重点，均匀发力，容易事倍功半。如果“南辕北辙”，更是可悲可叹。</p>
</li>
</ul>
<h1 id="架构师能力模型"><a href="#架构师能力模型" class="headerlink" title="架构师能力模型"></a>架构师能力模型</h1><p>前面我们已经讲完了原则和一些困惑，那么工程师到底应该怎么提升自己呢？</p>
<p>成为优秀的架构师是大部分初中级工程师的阶段性目标。优秀的架构师往往具备七种核心能力：编程能力、调试能力、编译部署能力、性能优化能力、业务架构能力、在线运维能力、项目管理能力和规划能力。</p>
<p>这几种能力之间的关系大概如下图。编程能力、调试能力和编译部署能力属于最基础的能力。不能精通掌握这三种能力，很难在性能优化能力和业务架构能力方面有所成就。具备了一定的性能优化能力和业务架构能力之后，才能在线运维能力和项目管理能力方面表现优越。团队管理能力是最高能力，它对项目管理能力的依赖度更大。</p>
<h2 id="编程能力"><a href="#编程能力" class="headerlink" title="编程能力"></a>编程能力</h2><p>对工程师而言，编程是最基础的能力，必备技能。其本质是一个翻译能力，将业务需求翻译成机器能懂的语言。</p>
<p>提升编程能力的书籍有很多。精通面向对象和设计模式是高效编程的基础。初级工程师应该多写代码、多看代码。找高手做Code Review，也是提升编程水平的捷径。</p>
<h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>程序代码是系统的静态形式，调试的目的是通过查看程序的运行时状态来验证和优化系统。本质上讲，工程师们通过不断调试可以持续强化其通过静态代码去预测运行状态的能力。所以调试能力也是工程师编程能力提升的关键手段。很早之前有个传说：“调试能力有多强，编程能力就有多强。”不过现在很多编辑器的功能很强大，调试能力的门槛已经大大降低。</p>
<p>调试能力是项目能否按时、高质量提交的关键。即使一个稍具复杂度的项目，大部分工程师也无法一次性准确无误的完成。大项目都是通过不断地调试进行优化和纠错的。所以调试能力是不可或缺的能力。</p>
<p>多写程序，解决Bug，多请教高手是提升调试能力的重要手段。</p>
<h2 id="编译部署能力"><a href="#编译部署能力" class="headerlink" title="编译部署能力"></a>编译部署能力</h2><p>编译并在线上部署运行程序是系统上线的最后一个环节。随着SOA架构的普及以及业务复杂度的增加，大部分系统只是一个完整业务的一个环节，因此，本地编译和运行并不能完全模拟系统在线运行。为了快速验证所编写程序的正确性，编译并在线上部署就成了必要环节。所以编译部署能力是一个必备技能。</p>
<p>让盘根错节的众多子系统运行起来是个不小的挑战。得益于SOA架构的普及以及大量编译、部署工具的发展，编译部署的门槛已经大大降低。基于应用层进行开发的公司，已经很少有“编译工程师”的角色了。但是对于初级工程师而言，编译部署仍然不是一个轻松的事情。</p>
<h2 id="性能优化能力"><a href="#性能优化能力" class="headerlink" title="性能优化能力"></a>性能优化能力</h2><p>衡量一个系统成功的一个重要指标是使用量。随着使用量的增加和业务复杂度的增加，大部分系统最终都会碰到性能问题。 性能优化能力是一个综合能力。因为：</p>
<ul>
<li><p>影响系统性能的因素众多，包括：数据结构、操作系统、虚拟机、CPU、存储、网络等。为了对系统性能进行调优，架构师需要掌握所有相关的技术。</p>
</li>
<li><p>精通性能优化意味着深刻理解可用性、可靠性、一致性、可维护性、可扩展性等的本质。</p>
</li>
<li><p>性能优化与业务强耦合，最终所采取的手段是往往折衷的结果。所以，性能优化要深谙妥协的艺术。</p>
</li>
</ul>
<p>可以说，性能优化能力是工程师们成长过程中各种技能开始融会贯通的一个标志。这方面可以参考之前的博客文章“<a href="https://tech.meituan.com/performance_tunning.html" title="常见性能优化策略的总结">见性能优化策略的总结</a>”。市场上还有很多与性能优化相关的书籍，大家可以参考。多多阅读开源框架中关于性能优化方面的文档和代码也不失为好的提升手段。动手解决线上性能问题也是提升性能优化能力的关键。如果有机会，跟着高手学习，分析性能优化解决方案案例（我们技术博客之前也发表了很多这方面的<a href="https://tech.meituan.com/tag/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" title="文章">文章</a>），也是快速提升性能优化能力的手段。</p>
<h2 id="在线运维能力"><a href="#在线运维能力" class="headerlink" title="在线运维能力"></a>在线运维能力</h2><p>如果说性能优化能力体现的是架构师的静态思考能力，在线运维能力考验的就是动态反应能力。残酷的现实是，无论程序多么完美，Bug永远存在。与此同时，职位越高、责任越大，很多架构师需要负责非常重要的在线系统。对于线上故障，如果不能提前预防以及快速解决，损失可能不堪设想，所以在线运维能力是优秀架构师的必备技能。</p>
<p>为了对线上故障进行快速处理，标准化的监控、上报、升级，以及基本应对机制当然很重要。通过所观察到的现象，快速定位、缓解以及解决相关症状也相当关键。这要求架构师对故障系统的业务、技术具备通盘解读能力。解决线上故障的架构师就好比一个在参加比赛F1的车手。赛车手必须要了解自身、赛车、对手、同伴、天气、场地等所有因素，快速决策，不断调整。架构师必须要了解所有技术细节、业务细节、处理规范、同伴等众多因素，快速决断，迅速调整。</p>
<p>在线运维本质上是一个强化学习的过程。很多能力都可以通过看书、查资料来完成，但在线运维能力往往需要大量的实践来提升。</p>
<h2 id="业务架构能力"><a href="#业务架构能力" class="headerlink" title="业务架构能力"></a>业务架构能力</h2><p>工程师抱怨产品经理的故事屡见不鲜，抱怨最多的主要原因来自于需求的频繁变更。需求变更主要有两个来源：第一个原因是市场改变或战略调整，第二个原因是伪需求。对于第一个原因，无论是工程师还是产品经理，都只能无奈的接受。优秀的架构师应该具备减少第二种原因所导致的需求变更的概率。</p>
<h3 id="伪需求的产生有两个原因："><a href="#伪需求的产生有两个原因：" class="headerlink" title="伪需求的产生有两个原因："></a>伪需求的产生有两个原因：</h3><ul>
<li><p>第一个原因是需求传递变形。从信息论的角度来讲，任何沟通都是一个编码和解码的过程。典型的需求从需求方到产品经理，最终到开发工程师，最少需要经历三次编码和解码过程。而信息的每一次传递都存在一些损失并带来一些噪音，这导致有些时候开发出来的产品完全对不上需求。此外，需求方和产品经理在需求可行性、系统可靠性，开发成本控制方面的把控比较弱，也会导致需求变形。</p>
</li>
<li><p>第二个原因就是需求方完全没有想好自己的需求。</p>
</li>
</ul>
<p>优秀的架构师应该具备辨别真伪需求的能力。应该花时间去了解客户的真实业务场景，具备较强的业务抽象能力，洞悉客户的真实需求。系统的真正实施方是工程师，在明确客户真实需求后，高明的架构师应该具备准确判断项目对可行性、可靠性、可用性等方面的要求，并能具备成本意识。最后，由于需求与在线系统的紧耦合关系，掌握在线系统的各种细节也是成功的业务架构的关键。随着级别的提升，工程师所面对的需求会越来越抽象。承接抽象需求，提供抽象架构是架构师走向卓越的必经之途。</p>
<p>市场上有一些关于如何成为架构师的书，大家可以参考。但是架构能力的提升，实践可能是更重要的方式。业务架构师应该关注客户的痛点而不是PRD文档，应该深入关注真实业务。掌握现存系统的大量技术和业务细节也是业务架构师的必备知识。</p>
<h2 id="项目管理能力"><a href="#项目管理能力" class="headerlink" title="项目管理能力"></a>项目管理能力</h2><p>作为工业时代的产物，分工合作融入在互联网项目基因里面。架构师也需要负责几个重大项目才能给自己正名。以架构师角色去管理项目，业务架构能力当然是必备技能。此外，人员管理和成本控制意识也非常重要。</p>
<p>项目管理还意味着要有一个大心脏。重大项目涉及技术攻关、人员变动、需求更改等众多可变因素。面临各种变化，还要在确保目标顺利达成，需要较强的抗压能力。</p>
<p>人员管理需要注意的方面包括：知人善用，优化关系，简化沟通，坚持真理。</p>
<ul>
<li><p>知人善用意味着架构师需要了解每个参与者的硬技能和软素质。同时，关注团队成员在项目过程中的表现，按能分配。</p>
</li>
<li><p>优化关系意味着管理团队的情绪，毕竟项目的核心是团队，有士气的团队才能高效达成目标。</p>
</li>
<li><p>简化沟通意味着快速决策，该妥协的时候妥协，权责分明。</p>
</li>
<li><p>坚持真理意味着顶住压力，在原则性问题上绝不退步。</p>
</li>
</ul>
<p>成本控制意味着对项目进行精细化管理，需要遵循如下几个原则：</p>
<ul>
<li><p>以终为始、确定里程碑。为了达成目标，所有的计划必须以终为始来制定。将大项目分解成几个小阶段，控制每个阶段的里程碑可以大大降低项目失败的风险。</p>
</li>
<li><p>把控关键路径和关键项目。按照关键路径管理理论（CPM）的要求，架构师需要确定每个子项目的关键路径，确定其最早和最晚启动时间。同时，架构师需要关注那些可能会导致项目整体延期的关键节点，并集中力量攻破。</p>
</li>
<li><p>掌控团队成员的张弛度。大项目持续时间会比较长，也包含不同工种。项目实施是一个不断变化的动态过程，在这个过程中不是整个周期都很紧张，不是所有的工种都一样忙。优秀的架构师必须要具备精细阅读整体项目以及快速反应和实时调整的能力。这不仅仅可以大大降低项目成本，还可以提高产出质量和团队满意度。总体来说，“前紧后松”是项目管理的一个重要原则。</p>
</li>
</ul>
<p>项目管理方面的书籍很多。但是，提高业务架构能力同样重要。积极参与大项目并观察别人管理项目的方式也是非常重要的提升手段。</p>
<h2 id="团队管理能力"><a href="#团队管理能力" class="headerlink" title="团队管理能力"></a>团队管理能力</h2><p>不想做CTO的工程师不是一个好的架构师。走向技术管理应该是工程师的一个主流职业规划。团队管理的一个核心能力就是规划能力，这包括项目规划和人员规划。良好的规划需要遵循如下原则：</p>
<ul>
<li><p>规划是利益的博弈。良好的规划上面对得起老板，中间对得起自己，下面对得起团队。在三者利益者寻找平衡点，实现多方共赢考验着管理者的智慧和精细拿捏的能力。</p>
</li>
<li><p>任何规划都比没有规划好。没有规划的团队就是没头的苍蝇，不符合所有人的利益。</p>
</li>
<li><p>规划不是本本主义。市场在变，团队在变，规划也不应该一成不变。</p>
</li>
<li><p>客户至上的是项目规划的出发点。</p>
</li>
<li><p>就人员规划而言，规划需要考量团队成员的能力、绩效、成长等多方面的因素。</p>
</li>
</ul>
<p>市场上有很多规划管理方面的书籍，值得阅读。最优化理论虽然是技术书籍，但它是规划的理论基础，所以不妨多看看翻阅一下。从自我规划开始，多多学习别人的规划也是规划能力提升的重要手段。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为受邀去做一个关于“一边工作，一边学习”的分享，作者花了一段时间去思考和汇总学习方法论，接着每天不断地采集谣言并尝试解惑，再根据个人经验绘制出优秀架构师的能力模型，最后汇集成文。</p>
<p>文章系统性地阐述了学习原则、分析了常见困惑，并制定明确学习目标，期望对工程师们的工作学习有所帮助。需要申明的是，文章内容挂一漏万，所谓的架构师能力模型也是作者的个人观点。欢迎大家在评论中分享自己在学习成长方面的心得。</p>
]]></content>
      <tags>
        <tag>开发 学习 提升 编程 工程师</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端开发标准规范</title>
    <url>/2020/04/08/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2></li>
<li><h2 id="HTML代码规范"><a href="#HTML代码规范" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h2></li>
<li><h2 id="CSS和SCSS代码规范"><a href="#CSS和SCSS代码规范" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h2></li>
<li><h2 id="JavaScript代码规范"><a href="#JavaScript代码规范" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h2></li>
<li><h2 id="jQuery代码规范"><a href="#jQuery代码规范" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h2></li>
<li><h2 id="vue代码规范"><a href="#vue代码规范" class="headerlink" title="vue代码规范"></a>vue代码规范</h2></li>
</ul>
<a id="more"></a>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://tgideas.qq.com/doc/frontend/">腾讯前端开发规范</a></li>
<li><a href="http://alloyteam.github.io/CodeGuide/#project-naming">通过分析github代码库总结出来的工程师代码书写习惯</a></li>
<li><a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a>。</li>
<li><a href="https://cn.vuejs.org/v2/style-guide/">Vue官网风格指南</a></li>
</ol>
<h1 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h1><h2 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h2><ul>
<li>全部采用小写方式， 以下划线分隔；</li>
<li>有明显分类的，使用语义化的命名，无明确意义的，可用page01.html；</li>
<li>禁止使用特殊字符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：my_project_name</span><br></pre></td></tr></table></figure>
<h2 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h2><ul>
<li>参照项目命名规则；</li>
<li>有复数结构时，要采用复数命名法；</li>
<li>图片文件夹：img；</li>
<li>css文件夹：css；</li>
<li>js文件夹：js；</li>
<li>include页面片段文件夹：inc。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：scripts, styles, images, data_models</span><br></pre></td></tr></table></figure>
<h2 id="JS文件命名"><a href="#JS文件命名" class="headerlink" title="JS文件命名"></a>JS文件命名</h2><ul>
<li>参照项目命名规则 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：account_model.js</span><br></pre></td></tr></table></figure>
<h2 id="CSS-SCSS文件命名"><a href="#CSS-SCSS文件命名" class="headerlink" title="CSS, SCSS文件命名"></a>CSS, SCSS文件命名</h2><ul>
<li>参照项目命名规则。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：retina_sprites.scss</span><br></pre></td></tr></table></figure>
<h2 id="HTML文件命名"><a href="#HTML文件命名" class="headerlink" title="HTML文件命名"></a>HTML文件命名</h2><ul>
<li>参照项目命名规则。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">例：error_report.html</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="HTML代码规范-1"><a href="#HTML代码规范-1" class="headerlink" title="HTML代码规范"></a>HTML代码规范</h1><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul>
<li><code>doctype</code>声明使用<code>html5</code> ；</li>
<li>在html标签上加上lang属性，更多关于 <code>lang</code> 属性的说明<a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-html-element">在这里</a>，在sitepoint上可以查到<a href="http://reference.sitepoint.com/html/lang-codes">语言列表</a>；</li>
<li>缩进使用soft tab（4个空格），嵌套的节点应该缩进；</li>
<li>清晰、简介的层级嵌套结构，保证嵌套层级最少；</li>
<li>在属性上，使用双引号，不要使用单引号；</li>
<li>标签、标签属性全部小写，用中划线做分隔符；</li>
<li>在无法用标签表明语义的场景下增加适当的注释；</li>
<li>所有html标签必须有结束符，<code>&lt;img /&gt;</code>, <code>&lt;col /&gt;</code>, <code>&lt;base /&gt;</code>, <code>&lt;link /&gt;</code>, <code>&lt;meta /&gt;</code>,<code> &lt;input /&gt;</code> 除外；</li>
<li>标签语法无错误，需要符合语义化；</li>
<li>较长的HTML文件，请在板块之间加入注释，使得结构更清晰，也更利于后期维护；</li>
<li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式 ；</li>
<li>统一页面编码格式为<code>utf-8</code> , <code>meta</code>标签<code>charset</code>设置为<code>utf-8</code>;</li>
<li>给 <code>&lt;a&gt;</code> 标签加上title属性；</li>
<li><code>&lt;a&gt;</code>标签的href属性必须写上链接地址，暂无的加上<code>javascript:alert(&#39;敬请期待！&#39;)</code>；</li>
<li>非本专题的页面间跳转，采用打开新窗口模式：<code>target=&quot;_blank&quot;</code>，同时为了避免<a href="https://blog.csdn.net/chinashanzhang/article/details/88537581">安全问题</a>加上<code>rel=&quot;noopener&quot;</code>；</li>
<li>标签自定义属性使用<code>data-name=&quot;value&quot;</code>的形式来写, 如果自定义属性特别多, 可以考虑使用标准 json 的方式去写:<code> data-json=&#39;&#123;&quot;a&quot;:&quot;a&quot;, &quot;b&quot;:&quot;b&quot;&#125;&#39;</code>；</li>
<li>css 引用置于头部<code>&lt;head&gt;</code>标签内；</li>
<li>js 引用置于底部<code>&lt;/body&gt;</code>标签前；</li>
<li><code>img</code>标签必须加<code>alt</code>，尤其是logo、商品图片等关键图片信息，对SEO友好 ；</li>
<li>不要忽略可选的关闭标签，例：</li> 和 </body>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/company_logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Company&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;hello-world&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 活动板块 开始 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;part-act&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br><span class="line">        	...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 活动板块 结束 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul>
<li>兼容IE11及以上、Firefox、chrome、QQ浏览器；</li>
<li>页面如无指定，不需要兼容IE6、7、8、9、10；</li>
<li>不兼容IE6、7、8、9、10的情况下，需要在页面顶部加入提示，并对.browser-tips使用醒目的颜色标识样式。</li>
</ul>
<h2 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h2><ul>
<li>class、id都需小写，首字符必须是字母，禁止数字或其他特殊字符。由以字母开头的小写 字母<code>（a-z）</code>、数字<code>（0-9）</code>、中划线 <code>（-）</code>组成；</li>
<li>可以是单个单词，也可以是组合单词，要求能够描述清楚模块和元素的含义，使其具有语义化；</li>
<li>双单词或多单词组合方式：<code>命名空间-模块-元素-修饰</code>，如：<code>wb-demo-header-title</code>；</li>
<li>样式名不能包含<code>ad</code>、ads、adv、banner、sponsor、guanggao<code>、</code>ads<code>、</code>gg`是广告含义的关键词，避免元素被网页拓展、插件屏蔽；</li>
<li>涉及数据、交互等需要联调的部分，禁止通过id选择器定义样式，以免开发过程中id名变化，引起页局错乱；</li>
<li>除非是样式reset需要，禁止对纯元素选择器设置特定样式，避免样式污染；</li>
<li>自己写的z-index的值不能超过100（通用组件除外），元素内容不能超过10，弹层提示在10-99之间，不允许直接使用1000-9999之类大值；</li>
<li>命名词穷了怎么办？试下这个工具：<a href="https://unbug.github.io/codelf/">codelf</a>。</li>
</ul>
<h2 id="通用命名"><a href="#通用命名" class="headerlink" title="通用命名"></a>通用命名</h2><h3 id="页面框架命名，一般具有唯一性，推荐用ID命名"><a href="#页面框架命名，一般具有唯一性，推荐用ID命名" class="headerlink" title="页面框架命名，一般具有唯一性，推荐用ID命名"></a>页面框架命名，一般具有唯一性，推荐用ID命名</h3><table>
<thead>
<tr>
<th align="left">ID名称</th>
<th align="left">命名</th>
<th align="left">ID名称</th>
<th align="left">命名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">头部</td>
<td align="left">header</td>
<td align="left">主体</td>
<td align="left">main</td>
</tr>
<tr>
<td align="left">脚部</td>
<td align="left">footer</td>
<td align="left">容器</td>
<td align="left">wrapper</td>
</tr>
<tr>
<td align="left">侧栏</td>
<td align="left">sidebar</td>
<td align="left">栏目</td>
<td align="left">column</td>
</tr>
<tr>
<td align="left">布局</td>
<td align="left">layout</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="模块结构命名"><a href="#模块结构命名" class="headerlink" title="模块结构命名"></a>模块结构命名</h3><table>
<thead>
<tr>
<th align="left">Class名称</th>
<th align="left">命名</th>
<th align="left">Class名称</th>
<th align="left">命名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">模块(如：新闻模块)</td>
<td align="left">mod (mod-news)</td>
<td align="left">标题栏</td>
<td align="left">title</td>
</tr>
<tr>
<td align="left">内容</td>
<td align="left">content</td>
<td align="left">次级内容</td>
<td align="left">sub-content</td>
</tr>
</tbody></table>
<h3 id="导航结构命名"><a href="#导航结构命名" class="headerlink" title="导航结构命名"></a>导航结构命名</h3><table>
<thead>
<tr>
<th align="left">Class名称</th>
<th align="left">命名</th>
<th align="left">Class名称</th>
<th align="left">命名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">导航</td>
<td align="left">nav</td>
<td align="left">主导航</td>
<td align="left">main-nav</td>
</tr>
<tr>
<td align="left">子导航</td>
<td align="left">sub-nav</td>
<td align="left">顶部导航</td>
<td align="left">top-nav</td>
</tr>
<tr>
<td align="left">菜单</td>
<td align="left">menu</td>
<td align="left">子菜单</td>
<td align="left">sub-menu</td>
</tr>
</tbody></table>
<h3 id="一般元素命名"><a href="#一般元素命名" class="headerlink" title="一般元素命名"></a>一般元素命名</h3><table>
<thead>
<tr>
<th align="left">Class名称</th>
<th align="left">命名</th>
<th align="left">Class名称</th>
<th align="left">命名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">二级</td>
<td align="left">sub</td>
<td align="left">面包屑</td>
<td align="left">breadcrumb</td>
</tr>
<tr>
<td align="left">标志</td>
<td align="left">logo</td>
<td align="left">广告</td>
<td align="left">bner(禁用banner或ad)</td>
</tr>
<tr>
<td align="left">登陆</td>
<td align="left">login</td>
<td align="left">注册</td>
<td align="left">register/reg</td>
</tr>
<tr>
<td align="left">搜索</td>
<td align="left">search</td>
<td align="left">加入</td>
<td align="left">join</td>
</tr>
<tr>
<td align="left">状态</td>
<td align="left">status</td>
<td align="left">按钮</td>
<td align="left">btn</td>
</tr>
<tr>
<td align="left">滚动</td>
<td align="left">scroll</td>
<td align="left">标签页</td>
<td align="left">tab</td>
</tr>
<tr>
<td align="left">文章列表</td>
<td align="left">list</td>
<td align="left">短消息</td>
<td align="left">msg/message</td>
</tr>
<tr>
<td align="left">当前的</td>
<td align="left">current</td>
<td align="left">提示小技巧</td>
<td align="left">tips</td>
</tr>
<tr>
<td align="left">图标</td>
<td align="left">icon</td>
<td align="left">注释</td>
<td align="left">note</td>
</tr>
<tr>
<td align="left">指南</td>
<td align="left">guide</td>
<td align="left">服务</td>
<td align="left">service</td>
</tr>
<tr>
<td align="left">热点</td>
<td align="left">hot</td>
<td align="left">新闻</td>
<td align="left">news</td>
</tr>
<tr>
<td align="left">下载</td>
<td align="left">download</td>
<td align="left">投票</td>
<td align="left">vote</td>
</tr>
<tr>
<td align="left">合作伙伴</td>
<td align="left">partner</td>
<td align="left">友情链接</td>
<td align="left">link</td>
</tr>
<tr>
<td align="left">版权</td>
<td align="left">copyright</td>
<td align="left">演示</td>
<td align="left">demo</td>
</tr>
<tr>
<td align="left">下拉框</td>
<td align="left">select</td>
<td align="left">摘要</td>
<td align="left">summary</td>
</tr>
<tr>
<td align="left">翻页</td>
<td align="left">pages</td>
<td align="left">主题风格</td>
<td align="left">themes</td>
</tr>
<tr>
<td align="left">设置</td>
<td align="left">set</td>
<td align="left">成功</td>
<td align="left">suc</td>
</tr>
<tr>
<td align="left">按钮</td>
<td align="left">btn</td>
<td align="left">文本</td>
<td align="left">txt</td>
</tr>
<tr>
<td align="left">颜色</td>
<td align="left">color/c</td>
<td align="left">背景</td>
<td align="left">bg</td>
</tr>
<tr>
<td align="left">边框</td>
<td align="left">border/bor</td>
<td align="left">居中</td>
<td align="left">center</td>
</tr>
<tr>
<td align="left">上</td>
<td align="left">top/t</td>
<td align="left">下</td>
<td align="left">bottom/b</td>
</tr>
<tr>
<td align="left">左</td>
<td align="left">left/l</td>
<td align="left">右</td>
<td align="left">right/r</td>
</tr>
<tr>
<td align="left">添加</td>
<td align="left">add</td>
<td align="left">删除</td>
<td align="left">del</td>
</tr>
<tr>
<td align="left">间隔</td>
<td align="left">sp</td>
<td align="left">段落</td>
<td align="left">p</td>
</tr>
<tr>
<td align="left">弹出层</td>
<td align="left">pop</td>
<td align="left">公共</td>
<td align="left">global/gb</td>
</tr>
<tr>
<td align="left">操作</td>
<td align="left">op</td>
<td align="left">密码</td>
<td align="left">pwd</td>
</tr>
<tr>
<td align="left">透明</td>
<td align="left">tran</td>
<td align="left">信息</td>
<td align="left">info</td>
</tr>
<tr>
<td align="left">重点</td>
<td align="left">hit</td>
<td align="left">预览</td>
<td align="left">pvw</td>
</tr>
<tr>
<td align="left">单行输入框</td>
<td align="left">input</td>
<td align="left">首页</td>
<td align="left">index</td>
</tr>
<tr>
<td align="left">日志</td>
<td align="left">blog</td>
<td align="left">相册</td>
<td align="left">photo</td>
</tr>
<tr>
<td align="left">留言板</td>
<td align="left">guestbook</td>
<td align="left">用户</td>
<td align="left">user</td>
</tr>
<tr>
<td align="left">确认</td>
<td align="left">confirm</td>
<td align="left">取消</td>
<td align="left">cancel</td>
</tr>
<tr>
<td align="left">报错</td>
<td align="left">error</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="引入CSS-JS"><a href="#引入CSS-JS" class="headerlink" title="引入CSS, JS"></a>引入CSS, JS</h2><blockquote>
<p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 <code>type</code>，因为 <code>text/css</code> 和 <code>text/javascript</code> 分别是他们的默认值。 </p>
</blockquote>
<h3 id="HTML5-规范链接"><a href="#HTML5-规范链接" class="headerlink" title="HTML5 规范链接"></a>HTML5 规范链接</h3><ul>
<li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-link-element">使用link</a></li>
<li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/semantics.html#the-style-element">使用style</a></li>
<li><a href="http://www.w3.org/TR/2011/WD-html5-20110525/scripting-1.html#the-script-element">使用script</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 外联样式 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;reset.css&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联样式 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 外部JS --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;index.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内部JS --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h2><blockquote>
<p>属性应该按照特定的顺序出现以保证易读性。</p>
</blockquote>
<ul>
<li><code>id</code></li>
<li><code>class</code></li>
<li><code>name</code></li>
<li><code>data-*</code></li>
<li><code>src</code>, <code>for</code>, <code>type</code>, <code>href</code>, <code>value</code> , <code>max-length</code>, <code>max</code>, <code>min</code>, <code>pattern</code></li>
<li><code>placeholder</code>, <code>title</code>, <code>alt</code></li>
<li><code>aria-*</code>, <code>role</code></li>
<li><code>required</code></li>
</ul>
<blockquote>
<p>id更加具体且应该尽量少使用，它与JS代码息息相关，所以将它放在第一位；class是为高可复用组件设计的，所以将它放在id后面（第一/二位）。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">data-modal</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Example link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="boolean属性"><a href="#boolean属性" class="headerlink" title="boolean属性"></a>boolean属性</h2><blockquote>
<p>boolean属性指不需要声明取值的属性，XHTML需要每个属性声明取值，但是HTML5并不需要；</p>
</blockquote>
<blockquote>
<p>更多内容可以参考 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attributes">WhatWG section on boolean attributes</a>：</p>
</blockquote>
<blockquote>
<p><em>boolean属性的存在表示取值为true，不存在则表示取值为false。</em></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">selected</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="JS生成标签"><a href="#JS生成标签" class="headerlink" title="JS生成标签"></a>JS生成标签</h2><blockquote>
<p>在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免在javascript中生成DOM。</p>
</blockquote>
<h2 id="减少标签数量"><a href="#减少标签数量" class="headerlink" title="减少标签数量"></a>减少标签数量</h2><blockquote>
<p>在编写HTML代码时，需要尽量避免多余的父节点；很多时候，需要通过迭代和重构来使HTML变得更少。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实用高于完美"><a href="#实用高于完美" class="headerlink" title="实用高于完美"></a>实用高于完美</h2><blockquote>
<p>尽量遵循HTML标准和语义，但是不应该以浪费实用性作为代价；任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。</p>
</blockquote>
<hr>
<h1 id="CSS和SCSS代码规范-1"><a href="#CSS和SCSS代码规范-1" class="headerlink" title="CSS和SCSS代码规范"></a>CSS和SCSS代码规范</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li>CSS类名命名参考样式命名；</li>
<li>让规则越具体越好，尽量不要使用**<code>ul li a &#123;&#125;</code><strong>这样长的选择器，最好使用</strong><code>.wb-list-wrapper &#123;&#125;</code>**之类的选择器；</li>
<li>禁止使用层级过深的选择器，最多5级；</li>
<li>除非有特定的功能、组件要求等，禁止随意使用id来定义元素样式；</li>
<li>除非是样式reset需要，禁止对标签选择器设置特定样式，避免样式污染；</li>
<li>样式文件中不要出现大写的标签定义, 不要对 JS 钩子进行样式定义；</li>
<li>避免使用*来选择元素；</li>
<li>避免使用float、position，优先使用flex和grid；</li>
<li>避免使用<code>!important</code>, 如果必须请加注释；</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//会导致页面所有的<span class="selector-tag">a</span>标签都被加上背景</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">background</span>:<span class="built_in">url</span>(xxx);&#125;</span><br><span class="line"></span><br><span class="line">//后期修改可能会添加一些<span class="selector-tag">span</span>标签，如果刚好在<span class="selector-tag">div</span>里面，会被污染；不利于后期维护</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span>&#123;<span class="attribute">display</span>:block&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><blockquote>
<p>使用soft tab（4个空格）。 </p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><blockquote>
<p>每个属性声明末尾都要加分号。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><blockquote>
<p>以下几种情况不需要空格：</p>
</blockquote>
<ul>
<li>属性名后</li>
<li>多个规则的分隔符’,’前</li>
<li><code>!important</code> ‘!’后</li>
<li>属性值中’(‘后和’)’前</li>
<li>行末不要有多余的空格</li>
</ul>
<blockquote>
<p>以下几种情况需要空格：</p>
</blockquote>
<ul>
<li>属性值前</li>
<li>选择器’&gt;’, ‘+’, ‘~’前后</li>
<li>‘{‘前</li>
<li><code>!important</code> ‘!’前</li>
<li><code>@else</code> 前后</li>
<li>属性值中的’,’后</li>
<li>注释’/*‘后和’*/‘前</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span> :red! important;</span><br><span class="line">    <span class="attribute">background-color</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> ,</span><br><span class="line"><span class="selector-class">.dialog</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span>,</span><br><span class="line"><span class="selector-class">.dialog</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span>&gt;<span class="selector-class">.dialog</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &gt; <span class="selector-class">.dialog</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="keyword">@if</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">@else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="keyword">@if</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><blockquote>
<p>以下几种情况需要空行：</p>
</blockquote>
<ul>
<li>文件最后保留一个空行；</li>
<li>‘}’后最好跟一个空行，包括scss中嵌套的规则；</li>
<li>属性之间需要适当的空行，具体见后面属性声明顺序。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dialog</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dialog</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><blockquote>
<p>以下几种情况不需要换行：</p>
</blockquote>
<ul>
<li>‘{‘前</li>
</ul>
<blockquote>
<p>以下几种情况需要换行：</p>
</blockquote>
<ul>
<li>‘{‘后和’}’前</li>
<li>每个属性独占一行</li>
<li>多个规则的分隔符’,’后</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span></span><br><span class="line">&#123;<span class="attribute">color</span>: red; <span class="attribute">background-color</span>: black;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span>, <span class="selector-class">.dialog</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span>,</span><br><span class="line"><span class="selector-class">.dialog</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>注释统一用’/* */‘（scss中也不要用’//‘），具体参照下面的写法；</li>
<li>缩进与下一行代码保持一致；</li>
<li>难于理解的代码添加注释；</li>
<li>可能被错误理解的代码添加注释；</li>
<li>工具类等公共方法添加文档注释；</li>
<li>浏览器特性hack添加注释；</li>
<li>修改别人的 CSS 请添加注释 ；</li>
<li><strong>可位于一个代码行的末尾，与代码间隔一个空格。</strong></li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Modal header */</span></span><br><span class="line"><span class="selector-class">.modal-header</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Modal header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-class">.modal-header</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.modal-header</span> &#123;</span><br><span class="line">    <span class="comment">/* 50px */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>: red; <span class="comment">/* color red */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul>
<li>最外层统一使用双引号；</li>
<li>url的内容要用引号；</li>
<li>属性选择器中的属性值需要引号。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&quot;logo.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-attr">[data-type=&quot;single&quot;]</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul>
<li>类名使用小写字母，以中划线分隔。推荐BEM命名法</li>
<li>id采用驼峰式命名</li>
<li>scss中的变量、函数、混合、placeholder采用驼峰式命名</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* class */</span></span><br><span class="line"><span class="selector-class">.block-element-modifier</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* id */</span></span><br><span class="line"><span class="selector-id">#myDialog</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量 */</span></span><br><span class="line"><span class="variable">$colorBlack</span>: <span class="number">#000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="keyword">@function</span> pxToRem(<span class="variable">$px</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 混合 */</span></span><br><span class="line"><span class="keyword">@mixin</span> centerBlock &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* placeholder */</span></span><br><span class="line">%myDialog &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性声明顺序"><a href="#属性声明顺序" class="headerlink" title="属性声明顺序"></a>属性声明顺序</h2><blockquote>
<p>相关的属性声明按下面的顺序做分组处理，组之间需要有一个空行。</p>
<ul>
<li>位置属性（position，top。，right， z-index， display， float等）；</li>
<li>大小（width, height, padding, margin）；</li>
<li>文字系列（font，line-height， letter-spacing，color- text-align等）；</li>
<li>背景边框（background，border等）；</li>
<li>其他（animation，transition等）；</li>
</ul>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.declaration-order</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">&quot;Helvetica Neue&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是推荐的属性的顺序</span></span><br><span class="line">[</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="attribute">display</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">visibility</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">float</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">clear</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">overflow</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">overflow-x</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">overflow-y</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">clip</span>&quot;,</span><br><span class="line">        &quot;zoom&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="selector-tag">table</span>-layout&quot;,</span><br><span class="line">        &quot;<span class="attribute">empty-cells</span>&quot;,</span><br><span class="line">        &quot;<span class="selector-tag">caption</span>-side&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-spacing</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-collapse</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">list-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">list-style-position</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">list-style-type</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">list-style-image</span>&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;-webkit-box-orient&quot;,</span><br><span class="line">        &quot;-webkit-box-<span class="attribute">direction</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">box-decoration-break</span>&quot;,</span><br><span class="line">        &quot;-webkit-box-pack&quot;,</span><br><span class="line">        &quot;-webkit-box-align&quot;,</span><br><span class="line">        &quot;-webkit-box-<span class="attribute">flex</span>&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="attribute">position</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">top</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">right</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">bottom</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">left</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">z-index</span>&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="attribute">margin</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">margin-top</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">margin-right</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">margin-bottom</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">margin-left</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">box-sizing</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">box-sizing</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">box-sizing</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-color</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top-color</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-right</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-right-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-right-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-right-color</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom-color</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-left</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-left-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-left-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-left-color</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-radius</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-radius</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-radius</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-top-left-radius</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-radius</span>-topleft&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top-left-radius</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-top-right-radius</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-radius</span>-topright&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-top-right-radius</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-bottom-right-radius</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-radius</span>-bottomright&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom-right-radius</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-bottom-left-radius</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-radius</span>-bottomleft&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-bottom-left-radius</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image-source</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image-source</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image-source</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image-source</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image-slice</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image-slice</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image-slice</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image-slice</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image-width</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image-width</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image-width</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image-outset</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image-outset</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image-outset</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image-outset</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">border-image-repeat</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">border-image-repeat</span>&quot;,</span><br><span class="line">        &quot;-o-<span class="attribute">border-image-repeat</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">border-image-repeat</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">padding</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">padding-top</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">padding-right</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">padding-bottom</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">padding-left</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">min-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">max-width</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">height</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">min-height</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">max-height</span>&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="attribute">font</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-family</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-size</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-weight</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-variant</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-size-adjust</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font-stretch</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font</span>-effect&quot;,</span><br><span class="line">        &quot;<span class="attribute">font</span>-emphasize&quot;,</span><br><span class="line">        &quot;<span class="attribute">font</span>-emphasize-<span class="attribute">position</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font</span>-emphasize-<span class="selector-tag">style</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">font</span>-smooth&quot;,</span><br><span class="line">        &quot;<span class="attribute">line-height</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-align</span>&quot;,</span><br><span class="line">        &quot;-webkit-<span class="attribute">text-align-last</span>&quot;,</span><br><span class="line">        &quot;-moz-<span class="attribute">text-align-last</span>&quot;,</span><br><span class="line">        &quot;-ms-<span class="attribute">text-align-last</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-align-last</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">vertical-align</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">white-space</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-decoration</span>&quot;,</span><br><span class="line">        &quot;text-emphasis&quot;,</span><br><span class="line">        &quot;text-emphasis-<span class="attribute">color</span>&quot;,</span><br><span class="line">        &quot;text-emphasis-<span class="selector-tag">style</span>&quot;,</span><br><span class="line">        &quot;text-emphasis-<span class="attribute">position</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-indent</span>&quot;,</span><br><span class="line">        &quot;-ms-text-justify&quot;,</span><br><span class="line">        &quot;text-justify&quot;,</span><br><span class="line">        &quot;<span class="attribute">letter-spacing</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">word-spacing</span>&quot;,</span><br><span class="line">        &quot;-ms-writing-mode&quot;,</span><br><span class="line">        &quot;text-<span class="attribute">outline</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-transform</span>&quot;,</span><br><span class="line">        &quot;text-wrap&quot;,</span><br><span class="line">        &quot;-ms-<span class="attribute">text-overflow</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-overflow</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-overflow</span>-ellipsis&quot;,</span><br><span class="line">        &quot;<span class="attribute">text-overflow</span>-mode&quot;,</span><br><span class="line">        &quot;-ms-<span class="attribute">word-wrap</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">word-wrap</span>&quot;,</span><br><span class="line">        &quot;-ms-<span class="attribute">word-break</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">word-break</span>&quot;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        &quot;<span class="attribute">color</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">background</span>&quot;,</span><br><span class="line">        &quot;<span class="attribute">filter</span>:progid:DXImageTransform.Microsoft.AlphaImageLoader<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-color<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-image<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-repeat<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-attachment<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-position<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-background-position-x<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-position-x<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-background-position-y<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-position-y<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-background-clip<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-background-clip<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-clip<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-background-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-background-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-background-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>background-size<span class="string">&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">        &quot;</span>outline<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>outline-width<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>outline-style<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>outline-color<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>outline-offset<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>opacity<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>filter:progid:DXImageTransform.Microsoft.Alpha(Opacity<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-filter:\\<span class="string">&#x27;progid:DXImageTransform.Microsoft.Alpha&quot;,</span></span><br><span class="line"><span class="string">        &quot;-ms-interpolation-mode&quot;,</span></span><br><span class="line"><span class="string">        &quot;-webkit-box-shadow&quot;,</span></span><br><span class="line"><span class="string">        &quot;-moz-box-shadow&quot;,</span></span><br><span class="line"><span class="string">        &quot;box-shadow&quot;,</span></span><br><span class="line"><span class="string">        &quot;filter:progid:DXImageTransform.Microsoft.gradient&quot;,</span></span><br><span class="line"><span class="string">        &quot;-ms-filter:\\&#x27;</span>progid:DXImageTransform.Microsoft.gradient<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>text-shadow<span class="string">&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transition<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transition<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transition<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transition<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transition<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transition-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transition-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transition-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transition-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transition-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transition-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transition-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transition-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transition-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transition-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transition-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transition-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transition-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transition-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transition-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transition-property<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transition-property<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transition-property<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transition-property<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transition-property<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transform<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transform<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transform<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transform<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transform<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-transform-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-transform-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-transform-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-transform-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>transform-origin<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-name<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-name<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-name<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-name<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-name<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-duration<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-play-state<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-play-state<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-play-state<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-play-state<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-play-state<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-timing-function<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-delay<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-iteration-count<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-iteration-count<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-iteration-count<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-iteration-count<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-iteration-count<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-animation-direction<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-animation-direction<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-animation-direction<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-animation-direction<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>animation-direction<span class="string">&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">        &quot;</span>content<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>quotes<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>counter-reset<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>counter-increment<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>resize<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>cursor<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-user-select<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-user-select<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-ms-user-select<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>user-select<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>nav-index<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>nav-up<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>nav-right<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>nav-down<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>nav-left<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-tab-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-o-tab-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>tab-size<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-webkit-hyphens<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>-moz-hyphens<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>hyphens<span class="string">&quot;,</span></span><br><span class="line"><span class="string">        &quot;</span>pointer-events<span class="string">&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><blockquote>
<p>颜色16进制用小写字母；颜色16进制尽量用简写。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ABCDEF</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#001122</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#abcdef</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#012</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h2><blockquote>
<p>属性简写需要你非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰；</p>
</blockquote>
<blockquote>
<p><code>margin</code> 和 <code>padding</code> 相反，需要使用简写；</p>
</blockquote>
<blockquote>
<p>常见的属性简写包括：</p>
</blockquote>
<ul>
<li><code>font</code></li>
<li><code>background</code></li>
<li><code>transition</code></li>
<li><code>animation</code></li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: opacity <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-property</span>: opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>尽量将媒体查询的规则靠近与他们相关的规则，不要将他们一起放到一个独立的样式文件中，或者丢在文档的最底部，这样做只会让大家以后更容易忘记他们。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element-avatar</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (min-width: <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.element</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.element-avatar</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SCSS相关"><a href="#SCSS相关" class="headerlink" title="SCSS相关"></a>SCSS相关</h2><ul>
<li>声明顺序：<ul>
<li><code>@extend</code></li>
<li>不包含 <code>@content</code> 的 <code>@include</code></li>
<li>包含 <code>@content</code> 的 <code>@include</code></li>
<li>自身属性</li>
<li>嵌套规则</li>
</ul>
</li>
<li>提交的代码中不要有 <code>@debug</code>；</li>
<li><code>@import</code> 引入的文件不需要开头的’_’和结尾的’.scss’；</li>
<li>嵌套最多不能超过5层；</li>
<li><code>@extend</code> 中使用placeholder选择器；</li>
<li>去掉不必要的父级引用符号’&amp;’。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_dialog.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;dialog&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.fatal</span> &#123;</span><br><span class="line">    <span class="keyword">@extend</span> .error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.fatal</span> &#123;</span><br><span class="line">    <span class="keyword">@extend</span> %error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    &amp; &gt; <span class="selector-class">.dialog</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    &gt; <span class="selector-class">.dialog</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>不允许有空的规则；</li>
<li>元素选择器用小写字母；</li>
<li>去掉小数点前面的0；</li>
<li>去掉数字中不必要的小数点和末尾的0；</li>
<li>属性值’0’后面不要加单位；</li>
<li>同个属性不同前缀的写法需要在垂直方向保持对齐，具体参照右边的写法；</li>
<li>无前缀的标准属性应该写在有前缀的属性后面；</li>
<li>不要在同个规则里出现重复的属性，如果重复的属性是连续的则没关系；</li>
<li>不要在一个文件里出现两个相同的规则；</li>
<li>用 <code>border: 0;</code> 代替 <code>border: none;</code>；</li>
<li>选择器不要超过5层（在scss中如果超过5层应该考虑用嵌套的方式来写）；</li>
<li>发布的代码中不要有 <code>@import</code>；</li>
<li>尽量少用’*’选择器。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-tag">LI</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50.0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background</span>: linear-gradient(to bottom, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(top, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>: -moz-linear-gradient(top, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">       -moz-<span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(top, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(top, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">background</span>:         linear-gradient(to bottom, <span class="number">#fff</span> <span class="number">0</span>, <span class="number">#eee</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><h3 id="图片命名"><a href="#图片命名" class="headerlink" title="图片命名"></a>图片命名</h3><ul>
<li>图片名称必须小写，禁止使用特殊字符、中文；</li>
<li>使用英文或拼音缩写，禁止特殊字符；</li>
<li>名称间隔使用-符号；</li>
<li>命名需要能体现图片的大概用途；</li>
<li>禁止文件名和实际图片内容不符。反面例子：图片名为’weixin-qrcode’，图片内容却是头像。</li>
</ul>
<h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul>
<li>图片体积不能超过300K；</li>
<li>JPG图片必须压缩，一般80%品质即可，保证文字清晰；</li>
<li>JPG图片必须使用渐进式图片：使用Photoshop的“存储为web所用格式”时候，勾选“连续”；</li>
<li>透明PNG图片必须使用<a href="https://tgideas.qq.com/doc/frontend/tool/imagecompress.html">压缩工具</a>压缩后提供。</li>
</ul>
<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><ul>
<li>img图片必须填写width、height、alt属性；</li>
<li>移动端必须填写<code>alt</code>属性；</li>
<li><code>alt</code>不能为无意义字符，需要能表现出图片的含义，如图片为道具图，则应该为道具的名称。</li>
</ul>
<h3 id="合理切图"><a href="#合理切图" class="headerlink" title="合理切图"></a>合理切图</h3><ul>
<li>文字禁止切到图片中，如果不确定是否需要变动，请咨询接口人；</li>
<li>序后台动态生成的图片，如道具图片、头像、奖品，必须单独切割出来；</li>
<li>图片合并成精灵图或做成字体图标，减少页面请求。</li>
</ul>
<hr>
<h1 id="JavaScript代码规范-1"><a href="#JavaScript代码规范-1" class="headerlink" title="JavaScript代码规范"></a>JavaScript代码规范</h1><h2 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h2><blockquote>
<p>使用soft tab（2个空格）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">  x += <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h2><blockquote>
<p>不要超过100，但如果编辑器开启word wrap可以不考虑单行长度。</p>
</blockquote>
<h2 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h2><blockquote>
<p>以下几种情况后需加分号：</p>
</blockquote>
<ul>
<li>变量声明</li>
<li>表达式</li>
<li>return</li>
<li>throw</li>
<li>break</li>
<li>continue</li>
<li>do-while</li>
</ul>
<blockquote>
<p>以下几种情况后无需分号</p>
</blockquote>
<ul>
<li>for</li>
<li>function</li>
<li>if</li>
<li>switch</li>
<li>try</li>
<li>while</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* var declaration */</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* expression statement */</span></span><br><span class="line">x++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do-while */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><blockquote>
<p>以下几种情况不需要空格：</p>
</blockquote>
<ul>
<li>对象的属性名后；</li>
<li>前缀一元运算符后；</li>
<li>后缀一元运算符前；</li>
<li>函数调用括号前；</li>
<li>无论是函数声明还是函数表达式，’(‘前不要空格；</li>
<li>数组的’[‘后和’]’前；</li>
<li>对象的’{‘后和’}’前；</li>
<li>运算符’(‘后和’)’前。</li>
</ul>
<blockquote>
<p>以下几种情况需要空格：</p>
</blockquote>
<ul>
<li>二元运算符前后；</li>
<li>三元运算符’?:’前后；</li>
<li>代码块’{‘前；</li>
<li>下列关键字前：<code>else</code>, <code>while</code>, <code>catch</code>, <code>finally；</code></li>
<li>下列关键字后：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>case</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>, <code>return</code>, <code>typeof；</code></li>
<li>单行注释’//‘后（若单行注释和代码同行，则’//‘前也需要），多行注释’*’后；</li>
<li>对象的属性值前；</li>
<li>for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格；</li>
<li>无论是函数声明还是函数表达式，’{‘前一定要有空格；</li>
<li>函数的参数之间。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b :<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line">++ x;</span><br><span class="line">y ++;</span><br><span class="line">z = x?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">++x;</span><br><span class="line">y++;</span><br><span class="line">z = x ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="number">1</span>, <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = ( <span class="number">1</span>+<span class="number">2</span> )*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no space before &#x27;(&#x27;, one space before &#x27;&#123;&#x27;, one space between function parameters</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no space before &#x27;(&#x27;</span></span><br><span class="line">doSomething(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h2><blockquote>
<p>以下几种情况需要空行：</p>
</blockquote>
<ul>
<li>变量声明后（当变量声明在代码块的最后一行时，则无需空行）；</li>
<li>连续空行数控制在 1 ~ 3 行（根据代码块层次来控制空行数）；</li>
<li>注释前（当注释在代码块的第一行时，则无需空行）；</li>
<li>代码块后（在函数调用、数组、对象中则无需空行）；</li>
<li>语法意义上相互独立的代码将用空行分隔；</li>
<li>文件最后保留一个空行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// need blank line after variable declaration</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not need blank line when variable declaration is last expression in the current block</span></span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> y = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need blank line before line comment</span></span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// not need blank line when comment is first line of block</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need blank line after blocks</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not need blank line when in argument list, array, object</span></span><br><span class="line">func(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = [</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h2><ul>
<li>(建议)每行代码不要超过 80 字符。当一条语句一行写不下时, 折行；</li>
<li>“{}” (大括号)前面不需要换行, 例如函数定义、if 语句、while 语句、switch 等；</li>
<li>换行的地方，行末必须有’,’或者运算符；</li>
<li>以下几种情况不需要换行：<ul>
<li>下列关键字后：<code>else</code>, <code>catch</code>, <code>finally</code></li>
<li>代码块’{‘前</li>
</ul>
</li>
<li>以下几种情况需要换行：<ul>
<li>代码块’{‘后和’}’前</li>
<li>变量赋值后</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">    , <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">    ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x = y ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">x = y ?</span><br><span class="line">    <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no need line break with &#x27;else&#x27;, &#x27;catch&#x27;, &#x27;finally&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a, foo = <span class="number">7</span>, b,</span><br><span class="line">    c, bar = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a,</span><br><span class="line">    foo = <span class="number">7</span>,</span><br><span class="line">    b, c, bar = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><ul>
<li>双斜线后，必须跟一个空格；</li>
<li>缩进与下一行代码保持一致；</li>
<li>可位于一个代码行的末尾，与代码间隔一个空格。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// if you made it here, then all security checks passed</span></span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="string">&#x27;zhangsan&#x27;</span>; <span class="comment">// one space after code</span></span><br></pre></td></tr></table></figure>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><ul>
<li>最少三行, ‘*’后跟一个空格，具体参照右边的写法；</li>
<li>建议在以下情况下使用：<ul>
<li>难于理解的代码段</li>
<li>可能存在错误的代码段</li>
<li>浏览器特殊的HACK代码</li>
<li>业务逻辑强相关的代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * one space after &#x27;*&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><blockquote>
<p>各类标签@param, @method等请参考<a href="http://usejsdoc.org/">usejsdoc</a>和<a href="http://yuri4ever.github.io/jsdoc/">JSDoc Guide</a>；</p>
</blockquote>
<blockquote>
<p>建议在以下情况下使用：</p>
</blockquote>
<ul>
<li>所有常量</li>
<li>所有函数</li>
<li>所有类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * @func</span><br><span class="line"> * @desc 一个带参数的函数</span><br><span class="line"> * @param &#123;string&#125; a - 参数a</span><br><span class="line"> * @param &#123;number&#125; b=<span class="number">1</span> - 参数b默认值为<span class="number">1</span></span><br><span class="line"> * @param &#123;string&#125; c=<span class="number">1</span> - 参数c有两种支持的取值&lt;<span class="regexp">/br&gt;1—表示x&lt;/</span>br&gt;<span class="number">2</span>—表示xx</span><br><span class="line"> * @param &#123;object&#125; d - 参数d为一个对象</span><br><span class="line"> * @param &#123;string&#125; d.e - 参数d的e属性</span><br><span class="line"> * @param &#123;string&#125; d.f - 参数d的f属性</span><br><span class="line"> * @param &#123;object[]&#125; g - 参数g为一个对象数组</span><br><span class="line"> * @param &#123;string&#125; g.h - 参数g数组中一项的h属性</span><br><span class="line"> * @param &#123;string&#125; g.i - 参数g数组中一项的i属性</span><br><span class="line"> * @param &#123;string&#125; [j] - 参数j是一个可选参数</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c, d, g, j</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引号-1"><a href="#引号-1" class="headerlink" title="引号"></a>引号</h2><blockquote>
<p>最外层统一使用单引号。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    z = <span class="string">&#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul>
<li>精简短小, 见名知意。 必须是有意义的文件名， 文件名中严禁出现中文 ， 多个英文单词请用大小驼峰命名法。尽量保持所有名称最短, 但是一定要保证名称具有描述性；</li>
<li>字符串变量值统一用单引号；</li>
<li>变量的命名, 不得使用 js 保留字；</li>
<li>请不要在文件名后加数字, 来实现相同功能的多个版本；</li>
<li>除非必要, 请不要使用全局变量, 避免出现全局变量污染。</li>
<li>函数内部的变量, 请在函数定义的头部声明。出于避免造成不必要消耗的考虑, 复杂类型的变量可以只声明不赋值。唯一特殊的情况, 是 for 循环的下标变量, 可以使用的时候实时声明；</li>
<li>函数内两次以上使用到的同一全局变量或者外部对象, 定义为一个局部变量, 以保证程序性能最优, 例如: var doc = document, win = window；</li>
<li>私有化变量和方法名应该以下划线 _ 开头；</li>
<li>变量不要先使用后声明；</li>
<li>不使用(汉语拼音/拼音英文数字组合/不规范的英文缩写)作为文件名；</li>
<li>尽量使用英文小写作为文件名, 免某些系统不区分文件名大小写；</li>
<li>常量全大写，用下划线连接，避免魔术常量，优先使用const，其次let，最后才是var；</li>
<li>变量名fetch或async代表异步，get代表获取，set或put代表修改，is、has、can代表布尔值，handle代表普通函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thisIsMyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MAX_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><blockquote>
<p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWithItems</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// use one var</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">10</span>,</span><br><span class="line">        result = value + <span class="number">10</span>,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = items.length; i &lt; len; i++) &#123;</span><br><span class="line">        result += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件语句-循环"><a href="#条件语句-循环" class="headerlink" title="条件语句/循环"></a>条件语句/循环</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li>if语句, 即使只有单行, 也要用花括号括起来；</li>
<li>使用三元运算符, 替代单一的 if else 语句；</li>
<li>if/else/while/for 条件表达式必须有小括号, 且自占一行；</li>
<li>利用 &amp;&amp; 和 || 短路来简化代码；</li>
<li>使用严格的条件判断符。用 === 代替 ==, 用!== 代替 !=。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> foo();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写作:</span></span><br><span class="line"><span class="keyword">return</span> val ? foo() : bar();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opt_win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> win;</span><br><span class="line">    <span class="keyword">if</span> (opt_win) &#123;</span><br><span class="line">        win = opt_win;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        win = <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写作:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">opt_win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> win = opt_win || <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amp-amp-短路"><a href="#amp-amp-短路" class="headerlink" title="&amp;&amp; 短路:"></a>&amp;&amp; 短路:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.kids) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.kids[index]) &#123;</span><br><span class="line">            foo(node.kids[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写作:</span></span><br><span class="line"><span class="keyword">if</span> (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) &#123;</span><br><span class="line">    foo(node.kids[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];</span><br><span class="line"><span class="keyword">if</span> (kid) &#123;</span><br><span class="line">    foo(kid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>尽量避免 for-in 循环, 只用于 object/hash 的遍历, 数组的遍历使用 for 循环；</li>
<li>for-in 循环体中必须用 hasOwnProperty 方法检查成员是否为自身成员, 避免来自原型链上的污染；</li>
<li>避免在 if 和 while 语句的条件部分进行赋值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (错误)</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (i = i - <span class="number">2</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应该写作: (正确)</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">    i = i - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>一个函数的内容不宜太长, 较复杂的逻辑, 需拆分成多个函数来实现, 使代码逻辑清晰；</li>
<li>对外暴露的 API 型函数, 尽量保持输入输出的稳定, 减小调用者修改代码的成本和风险；</li>
<li>无论是函数声明还是函数表达式，’(‘前不要空格，但’{‘前一定要有空格；</li>
<li>函数调用括号前不需要空格；</li>
<li>立即执行函数外必须包一层括号；</li>
<li>参数之间用’, ‘分隔，注意逗号后有一个空格；</li>
<li>拥抱函数式编程，遵循单一原则；</li>
<li>尽量减少参数数量，一般超过3个参数用对象代替；</li>
<li>可以嵌套函数, 用于减少重复代码, 隐藏一些局部函数等, 但不要在块内声明一个函数。因为 JS 并不支持块级作用域, 虽然很多 js 引擎都支持块内声明函数, 但它不属于 ECMAScript 规范 (见 ECMA-262, 第 13 和 14 条)。各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背。ECMAScript 只允 许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (错误)</span></span><br><span class="line"><span class="keyword">if</span> (x)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应该写作: (正确)</span></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no space before &#x27;(&#x27;, but one space before&#x27;&#123;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line">doSomething (item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">doSomething(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// requires parentheses around immediately invoked function expressions</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].forEach(<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// use &#x27;, &#x27; between function parameters</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组、对象"><a href="#数组、对象" class="headerlink" title="数组、对象"></a>数组、对象</h2><ul>
<li>对象属性名不需要加引号；</li>
<li>对象以缩进的形式书写，不要写在一行；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>number to string的转换，建议使用**<code>1 + &#39;&#39;</code>** 或 <strong><code>Sring(1)</code>**，不使用</strong><code>new String(1)</code>** 或 <strong><code>1.tiString()</code></strong> 的方式；</li>
<li>string to number的转换，建议使用**<code>parseInt</code>**；</li>
<li>float to integer 的转换，建议使用**<code>Math.floor/Math.round/Math.ceil</code><strong>方法，不使用</strong><code>parseInt</code>**。</li>
</ul>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><blockquote>
<p>下列关键字后必须有大括号（即使代码块的内容只有一行）：<code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>do</code>, <code>switch</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>with</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><blockquote>
<p>适用场景：</p>
</blockquote>
<ul>
<li>初始化一个将来可能被赋值为对象的变量</li>
<li>与已经初始化的变量做比较</li>
<li>作为一个参数为对象的函数的调用传参</li>
<li>作为一个返回对象的函数的返回值</li>
</ul>
<blockquote>
<p>不适用场景：</p>
</blockquote>
<ul>
<li>不要用null来判断函数调用时有无传参</li>
<li>不要与未初始化的变量做比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// not mean b is not supply</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><ul>
<li>永远不要直接使用undefined进行变量判断；</li>
<li>使用typeof和字符串’undefined’对变量进行判断。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">if</span> (person === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> person === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>不要使用 void、eval, with, 只在将 ajax 响应的文本解析为 json 时使用 eval()；</li>
<li>不要使用 function 构造器；</li>
<li>代码中调试用的 alert、console.log、console.dir、debugger 等代码, 在提交到 git 之前, 必须完全清理掉；</li>
<li>不要在内置对象的原型上添加方法，如Array, Date；</li>
<li>不要在内层作用域的代码里声明了变量，之后却访问到了外层作用域的同名变量；</li>
<li>不要在一句代码中单单使用构造函数，记得将其赋值给某个变量；</li>
<li>不要在同个作用域下声明同名变量；</li>
<li>不要在一些不需要的地方加括号，例：delete(a.b)；</li>
<li>不要使用未声明的变量；</li>
<li>不要声明了变量却不使用；</li>
<li>不要在应该做比较的地方做赋值；</li>
<li>数组中不要存在空元素；</li>
<li>不要在循环内部声明函数；</li>
<li>不要像这样使用构造函数，例：<code>new function () &#123; ... &#125;</code>, <code>new Object</code>；</li>
<li>不要混用tab和space；</li>
<li>对上下文this的引用只能使用’_this’, ‘that’, ‘self’其中一个来命名；</li>
<li>行尾不要有空白字符；</li>
<li>switch的falling through和no default的情况一定要有注释特别说明；</li>
<li>避免硬编码；</li>
<li>关键的代码添加适当的异常处理；</li>
<li>自测要保证每一个方法、每一个变量的所有场景都覆盖到；</li>
<li>不允许有空的代码块。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">// be sure that obj[key] belongs to the object and was not inherited</span></span><br><span class="line">        <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.count = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">delete</span>(obj.attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">delete</span> obj.attr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">10</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , , <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> nums = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        nums[i] = <span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i + j;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> singleton = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateVar;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVar = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.publicMethod2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVar = <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">var</span> a   = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// not good</span></span><br><span class="line">    <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// good</span></span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// good</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// good</span></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// why fall through</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// why no default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not good with empty block</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="jQuery代码规范-1"><a href="#jQuery代码规范-1" class="headerlink" title="jQuery代码规范"></a>jQuery代码规范</h1><h2 id="jQuery变量"><a href="#jQuery变量" class="headerlink" title="jQuery变量"></a>jQuery变量</h2><ul>
<li>所有用于存储、缓存jQuery对象的变量应该以$前缀命名；</li>
<li>最好把使用选择器返回的jQuery对象缓存到变量里，以便复用；</li>
<li>使用<a href="http://en.wikipedia.org/wiki/CamelCase">驼峰法</a>命名变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $userName = $(<span class="string">&#x27;#userName&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li>尽可能的使用ID选择器；</li>
<li>使用类（class）选择器时，不要使用元素类型；</li>
<li>对于ID-&gt;child的方式，使用find比用嵌套选择器高效；</li>
<li>给选择器一个范围，如**<code>$(&#39;.class&#39;, &#39;.context&#39;)</code>**；</li>
<li>避免使用全局选择器，如**<code>$(&#39;div.class &gt; *&#39;)</code>**；</li>
</ul>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><ul>
<li>字符串拼接可用ES6的模版字符串；</li>
<li>使用字符串连接符或者array.join()，比append高效；</li>
<li>不要操作空对象。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>每个页面只使用一次document的ready事件；</li>
<li>尽量不要使用匿名函数绑定事件，因为匿名函数不利于调试、维护、测试、重用；</li>
<li>不要在html标签中写事件调用，始终使用jquery来绑定、删除事件；</li>
<li>如果有必要，使用自定义事件（即：给事件一个作用域），这样可以方便解除事件，而不影响其它事件；</li>
<li>当需要给多个对象绑定相同事件时，使用事件委托。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#J_my-link&quot;</span>).on(<span class="string">&quot;click.mySpecialClick&quot;</span>, myEventHandler);</span><br></pre></td></tr></table></figure>
<h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><ul>
<li>将链式操作看成变量缓存和多选择器请求的替代方式；</li>
<li>当链式操作超过三个或者因为事件绑定变得复杂时，使用换行和缩进提高链式操作可读性；</li>
<li>对于长的链式操作来说，也可以把中间对象缓存成一个变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#userName&#x27;</span>).html(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">			  .siblings(<span class="string">&#x27;#userAge&#x27;</span>)</span><br><span class="line">			  .html(<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line">			  .siblings(<span class="string">&#x27;#gender&#x27;</span>)</span><br><span class="line">			  .html(<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h1 id="vue代码规范-1"><a href="#vue代码规范-1" class="headerlink" title="vue代码规范"></a>vue代码规范</h1><h2 id="必要的"><a href="#必要的" class="headerlink" title="必要的"></a>必要的</h2><ul>
<li>组件的<code>data</code>必须是一个函数；</li>
<li><code>Prop</code>定义应该尽量详细；</li>
<li>为<code>v-for</code>设置键值<code>key</code>；</li>
<li>避免<code>v-if</code>和<code>v-for</code>用在一起，<code>v-for</code>的优先级要高于<code>v-if</code>；</li>
<li>为组件样式设置作用域<strong>（注：scss有替代解决方案）</strong>；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;syncing&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;synced&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;version-conflict&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        ].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span></span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;user in users&quot;</span><br><span class="line">    :key=&quot;user.id&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> scoped&gt;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="selector-class">.title</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h2 id="强烈推荐"><a href="#强烈推荐" class="headerlink" title="强烈推荐"></a>强烈推荐</h2><ul>
<li>单文件组件的文件名应该要么始终是大驼峰命名，要么始终是中划线命名；</li>
<li>应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或无状态的组件）应该全部以一个特定的前缀开头；</li>
<li>只应该用有单个活跃实例的组件应该以<code>The</code>前缀命名，以示其唯一性；</li>
<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名；</li>
<li>组件名应该以高级别的单词开头，以描述性的修饰词结尾；</li>
<li>对于绝大多数项目来说，在单文件组件和字符串模版中组件名应该总是大驼峰命名，但在DOM模版中总是中划线命名；</li>
<li>组件名应该倾向于完整单词而不是缩写；</li>
<li>在声明<code>prop</code>的时候，其命名应该始终使用大驼峰，而在模版中应该始终使用中划线；</li>
<li>多个属性的元素应该分多行，每个属性一行；</li>
<li>组件模版应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法；</li>
<li>应该把复杂计算属性分割为尽可能多的更 简单的属性；</li>
<li>非空的属性值应该始终带引号（单引号或双引号，选你JS里不用的那个）；</li>
<li>指令缩写；</li>
<li>其它参考Vue官网的风格指南。</li>
</ul>
]]></content>
      <tags>
        <tag>代码 前端 开发 标准 规范 质量</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式详解</title>
    <url>/2017/09/09/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Javascript常用的设计模式详解</p>
<h1 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h1><ul>
<li>一：理解工厂模式</li>
<li>二：理解单体模式</li>
<li>三：理解模块模式</li>
<li>四：理解代理模式</li>
<li>五：理解职责链模式</li>
<li>六：命令模式的理解</li>
<li>七：模板方法模式</li>
<li>八：理解javascript中的策略模式</li>
<li>九：Javascript中理解发布–订阅模式</li>
<li>十：理解中介者模式</li>
</ul>
<a id="more"></a>

<h1 id="一、理解工厂模式"><a href="#一、理解工厂模式" class="headerlink" title="一、理解工厂模式"></a>一、理解工厂模式</h1><p>　　工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果;这时候需要使用工厂模式。</p>
<p>　　简单的工厂模式可以理解为解决多个相似的问题;这也是她的优点;比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.sex = sex;</span><br><span class="line">    obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">&quot;longen&quot;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">&quot;tugenhua&quot;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// longen</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);  <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex);  <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName()); <span class="comment">// longen</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);  <span class="comment">// tugenhua</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 27</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.sex);   <span class="comment">// 女</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.sayName()); <span class="comment">// tugenhua</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p1);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p2);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>　　如上代码：函数CreatePerson能接受三个参数name,age,sex等参数，可以无数次调用这个函数，每次返回都会包含三个属性和一个方法的对象。</p>
<p>　　工厂模式是为了解决多个类似对象声明的问题;也就是为了解决实列化对象产生重复的问题。</p>
<p>　　<strong>优点：能解决多个相似的问题。</strong></p>
<p>　　<strong>缺点：不能知道对象识别的问题(对象的类型不知道)。</strong></p>
<p>　　<strong>复杂的工厂模式定义是：将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。</strong></p>
<p>　　父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。</p>
<p>　　父类就变成了一个抽象类，但是父类可以执行子类中相同类似的方法，具体的业务逻辑需要放在子类中去实现；比如我现在开几个自行车店，那么每个店都有几种型号的自行车出售。我们现在来使用工厂模式来编写这些代码;</p>
<p>　　父类的构造函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义自行车的构造函数</span></span><br><span class="line"><span class="keyword">var</span> BicycleShop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">BicycleShop.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">BicycleShop</span>,</span><br><span class="line">    /*</span><br><span class="line">    * 买自行车这个方法</span><br><span class="line">    * @<span class="title">param</span> &#123;model&#125; 自行车型号</span><br><span class="line">    */</span><br><span class="line">    sellBicycle: <span class="function"><span class="keyword">function</span>(<span class="params">model</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bicycle = <span class="built_in">this</span>.createBicycle(mode);</span><br><span class="line">        <span class="comment">// 执行A业务逻辑</span></span><br><span class="line">        bicycle.A();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行B业务逻辑</span></span><br><span class="line">        bicycle.B();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bicycle;</span><br><span class="line">    &#125;,</span><br><span class="line">    createBicycle: <span class="function"><span class="keyword">function</span>(<span class="params">model</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　上面是定义一个自行车抽象类来编写工厂模式的实列，定义了createBicycle这个方法，但是如果直接实例化父类，调用父类中的这个createBicycle方法,会抛出一个error，因为父类是一个抽象类，他不能被实列化，只能通过子类来实现这个方法，实现自己的业务逻辑，下面我们来定义子类，我们学会如何使用工厂模式重新编写这个方法，首先我们需要继承父类中的成员，然后编写子类;如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义自行车的构造函数</span></span><br><span class="line"><span class="keyword">var</span> BicycleShop = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BicycleShop.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">BicycleShop</span>,</span><br><span class="line">    /*</span><br><span class="line">     * 买自行车这个方法</span><br><span class="line">     * @<span class="title">param</span> &#123;model&#125; 自行车型号</span><br><span class="line">    */</span><br><span class="line">    sellBicycle: <span class="function"><span class="keyword">function</span>(<span class="params">model</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> bicycle = <span class="built_in">this</span>.createBicycle(model);</span><br><span class="line">            <span class="comment">// 执行A业务逻辑</span></span><br><span class="line">            bicycle.A();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行B业务逻辑</span></span><br><span class="line">            bicycle.B();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bicycle;</span><br><span class="line">        &#125;,</span><br><span class="line">        createBicycle: <span class="function"><span class="keyword">function</span>(<span class="params">model</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 实现原型继承</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Sub,Sup</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//Sub表示子类，Sup表示超类</span></span><br><span class="line">        <span class="comment">// 首先定义一个空函数</span></span><br><span class="line">        <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置空函数的原型为超类的原型</span></span><br><span class="line">        F.prototype = Sup.prototype; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化空函数，并把超类原型引用传递给子类</span></span><br><span class="line">        Sub.prototype = <span class="keyword">new</span> F();</span><br><span class="line">                    </span><br><span class="line">        <span class="comment">// 重置子类原型的构造器为子类自身</span></span><br><span class="line">        Sub.prototype.constructor = Sub;</span><br><span class="line">                    </span><br><span class="line">        <span class="comment">// 在子类中保存超类的原型,避免子类与超类耦合</span></span><br><span class="line">        Sub.sup = Sup.prototype;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Sup.prototype.constructor === <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">            <span class="comment">// 检测超类原型的构造器是否为原型自身</span></span><br><span class="line">            Sup.prototype.constructor = Sup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> BicycleChild = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="comment">// 继承构造函数父类中的属性和方法</span></span><br><span class="line">        BicycleShop.call(<span class="built_in">this</span>,name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 子类继承父类原型方法</span></span><br><span class="line">    extend(BicycleChild,BicycleShop);</span><br><span class="line"><span class="comment">// BicycleChild 子类重写父类的方法</span></span><br><span class="line">BicycleChild.prototype.createBicycle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;执行A业务操作&quot;</span>);    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;执行B业务操作&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        A: A,</span><br><span class="line">        B: B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> childClass = <span class="keyword">new</span> BicycleChild(<span class="string">&quot;龙恩&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(childClass);</span><br></pre></td></tr></table></figure>
<p>　　实例化子类，然后打印出该实例, 如下截图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/561794/201602/561794-20160218145257206-1612447294.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(childClass.name);  <span class="comment">// 龙恩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是实例化后 执行父类中的sellBicycle这个方法后会依次调用父类中的A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和B方法；A方法和B方法依次在子类中去编写具体的业务逻辑。</span></span><br><span class="line"></span><br><span class="line">childClass.sellBicycle(<span class="string">&quot;mode&quot;</span>); <span class="comment">// 打印出  执行A业务操作和执行B业务操作</span></span><br></pre></td></tr></table></figure>
<p>　　上面只是”龙恩”自行车这么一个型号的，如果需要生成其他型号的自行车的话，可以编写其他子类，工厂模式最重要的优点是：可以实现一些相同的方法，这些相同的方法我们可以放在父类中编写代码，那么需要实现具体的业务逻辑，那么可以放在子类中重写该父类的方法，去实现自己的业务逻辑；使用专业术语来讲的话有2点：第一：弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。第二：重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。</p>
<h1 id="二、理解单体模式"><a href="#二、理解单体模式" class="headerlink" title="二、理解单体模式"></a>二、理解单体模式</h1><p>　　单体模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。</p>
<p>　　<strong>单体模式的优点是：</strong></p>
<p>　　<strong>1. 可以用来划分命名空间，减少全局变量的数量。</strong><br>　　<strong>2. 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。</strong><br>　　<strong>3. 可以被实例化，且实例化一次。</strong></p>
<p>　　什么是单体模式？单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。</p>
<p>　　但是并非所有的对象字面量都是单体，比如说模拟数组或容纳数据的话，那么它就不是单体，但是如果是组织一批相关的属性和方法在一起的话，那么它有可能是单体模式，所以这需要看开发者编写代码的意图；</p>
<p>　　下面我们来看看定义一个对象字面量(结构类似于单体模式)的基本结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">var</span> Singleton = &#123;</span><br><span class="line">    attr1: <span class="number">1</span>,</span><br><span class="line">    attr2: <span class="number">2</span>,</span><br><span class="line">    method1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr1;</span><br><span class="line">    &#125;,</span><br><span class="line">    method2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attr2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　如上面只是简单的字面量结构，上面的所有成员变量都是通过Singleton来访问的，但是它并不是单体模式；因为单体模式还有一个更重要的特点，就是可以仅被实例化一次，上面的只是不能被实例化的一个类，因此不是单体模式；对象字面量是用来创建单体模式的方法之一；</p>
<p>　　使用单体模式的结构如下demo</p>
<p>　　我们明白的是单体模式如果有实例化的话，那么只实例化一次，要实现一个单体模式的话，我们无非就是使用一个变量来标识该类是否被实例化，如果未被实例化的话，那么我们可以实例化一次，否则的话，直接返回已经被实例化的对象。</p>
<p>　　<strong>如下代码是单体模式的基本结构：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体模式</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试单体模式的实例</span></span><br><span class="line"><span class="keyword">var</span> a = getInstance(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = getInstance(<span class="string">&quot;bb&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>// 因为单体模式是只实例化一次，所以下面的实例是相等的</code></p>
<p><code>console.log(a === b); // true</code></p>
<p>　　由于单体模式只实例化一次，因此第一次调用，返回的是a实例对象，当我们继续调用的时候，b的实例就是a的实例，因此下面都是打印的是aa；</p>
<p><code>console.log(a.getName());// aa</code></p>
<p><code>console.log(b.getName());// aa</code></p>
<p>　　上面的封装单体模式也可以改成如下结构写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体模式</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取实例对象</span></span><br><span class="line"><span class="keyword">var</span> getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 测试单体模式的实例</span></span><br><span class="line"><span class="keyword">var</span> a = getInstance(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = getInstance(<span class="string">&quot;bb&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>// 因为单体模式是只实例化一次，所以下面的实例是相等的</code></p>
<p><code>console.log(a === b); // true</code></p>
<p><code>console.log(a.getName());// aa</code></p>
<p><code>console.log(b.getName());// aa</code></p>
<p>　　<strong>理解使用代理实现单列模式的好处</strong></p>
<p>　　比如我现在页面上需要创建一个div的元素，那么我们肯定需要有一个创建div的函数，而现在我只需要这个函数只负责创建div元素，其他的它不想管，也就是想实现单一职责原则，就好比淘宝的kissy一样，一开始的时候他们定义kissy只做一件事，并且把这件事做好，具体的单体模式中的实例化类的事情交给代理函数去处理，这样做的好处是具体的业务逻辑分开了，代理只管代理的业务逻辑，在这里代理的作用是实例化对象，并且只实例化一次; 创建div代码只管创建div，其他的不管；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体模式</span></span><br><span class="line"><span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.html = html;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHTML = <span class="built_in">this</span>.html;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理实现单体模式</span></span><br><span class="line"><span class="keyword">var</span> ProxyMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateDiv(<span class="string">&quot;我来测试下&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ProxyMode(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ProxyMode(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a===b);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>　　<strong>理解使用单体模式来实现弹窗的基本原理</strong></p>
<p>　　下面我们继续来使用单体模式来实现一个弹窗的demo；我们先不讨论使用单体模式来实现，我们想下我们平时是怎么编写代码来实现弹窗效果的; 比如我们有一个弹窗，默认的情况下肯定是隐藏的，当我点击的时候，它需要显示出来；如下编写代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现弹窗</span><br><span class="line">var createWindow &#x3D; function()&#123;</span><br><span class="line">    var div &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">    div.innerHTML &#x3D; &quot;我是弹窗内容&quot;;</span><br><span class="line">    div.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">    document.body.appendChild(&#39;div&#39;);</span><br><span class="line">    return div;</span><br><span class="line">&#125;;</span><br><span class="line">document.getElementById(&quot;Id&quot;).onclick &#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F; 点击后先创建一个div元素</span><br><span class="line">    var win &#x3D; createWindow();</span><br><span class="line">    win.style.display &#x3D; &quot;block&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　如上的代码；大家可以看看，有明显的缺点，比如我点击一个元素需要创建一个div，我点击第二个元素又会创建一次div，我们频繁的点击某某元素，他们会频繁的创建div的元素，虽然当我们点击关闭的时候可以移除弹出代码，但是呢我们频繁的创建和删除并不好，特别对于性能会有很大的影响，对DOM频繁的操作会引起重绘等，从而影响性能；因此这是非常不好的习惯；我们现在可以使用单体模式来实现弹窗效果，我们只实例化一次就可以了；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现单体模式弹窗</span></span><br><span class="line"><span class="keyword">var</span> createWindow = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!div) &#123;</span><br><span class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">            div.innerHTML = <span class="string">&quot;我是弹窗内容&quot;</span>;</span><br><span class="line">            div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> div;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;Id&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 点击后先创建一个div元素</span></span><br><span class="line">    <span class="keyword">var</span> win = createWindow();</span><br><span class="line">    win.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>理解编写通用的单体模式</strong></p>
<p>　　上面的弹窗的代码虽然完成了使用单体模式创建弹窗效果，但是代码并不通用，比如上面是完成弹窗的代码，假如我们以后需要在页面中一个iframe呢？我们是不是需要重新写一套创建iframe的代码呢？比如如下创建iframe：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createIframe = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!iframe) &#123;</span><br><span class="line">            iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">            iframe.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> iframe;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>　　我们看到如上代码，创建div的代码和创建iframe代码很类似，我们现在可以考虑把通用的代码分离出来，使代码变成完全抽象，我们现在可以编写一套代码封装在getInstance函数内，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　如上代码：我们使用一个参数fn传递进去，如果有result这个实例的话，直接返回，否则的话，当前的getInstance函数调用fn这个函数，是this指针指向与这个fn这个函数；之后返回被保存在result里面；现在我们可以传递一个函数进去，不管他是创建div也好，还是创建iframe也好，总之如果是这种的话，都可以使用getInstance来获取他们的实例对象；</p>
<p>　　如下测试创建iframe和创建div的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建div</span></span><br><span class="line"><span class="keyword">var</span> createWindow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    div.innerHTML = <span class="string">&quot;我是弹窗内容&quot;</span>;</span><br><span class="line">    div.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建iframe</span></span><br><span class="line"><span class="keyword">var</span> createIframe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取实例的封装代码</span></span><br><span class="line"><span class="keyword">var</span> getInstance = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试创建div</span></span><br><span class="line"><span class="keyword">var</span> createSingleDiv = getInstance(createWindow);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;Id&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> win = createSingleDiv();</span><br><span class="line">    win.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试创建iframe</span></span><br><span class="line"><span class="keyword">var</span> createSingleIframe = getInstance(createIframe);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;Id&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> win = createSingleIframe();</span><br><span class="line">    win.src = <span class="string">&quot;http://cnblogs.com&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、理解模块模式"><a href="#三、理解模块模式" class="headerlink" title="三、理解模块模式"></a>三、理解模块模式</h1><p>　　我们通过单体模式理解了是以对象字面量的方式来创建单体模式的；比如如下的对象字面量的方式代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleMode = &#123;</span><br><span class="line">    name: value,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用；<strong>如下就是一个模块模式的代码结构：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateNum = <span class="number">112</span>;</span><br><span class="line">    <span class="comment">// 创建私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 实现自己的业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个对象包含公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicMethod1: publicMethod1,</span><br><span class="line">        publicMethod2: publicMethod1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数。</p>
<p>我们什么时候使用模块模式？</p>
<p>如果我们必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么我们这个时候就可以使用模块模式了。</p>
<p>理解增强的模块模式</p>
<p>增强的模块模式的使用场合是：适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;tugenhua&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CustomType.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> application = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义私有</span></span><br><span class="line">    <span class="keyword">var</span> privateA = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加公有属性</span></span><br><span class="line">    object.A = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    <span class="comment">// 添加公有方法</span></span><br><span class="line">    object.B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回该对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>下面我们来打印下application该对象；如下：</p>
<p>console.log(application);</p>
<p><img src="http://images2015.cnblogs.com/blog/561794/201602/561794-20160218150032331-250843296.png"></p>
<p>继续打印该公有属性和方法如下：</p>
<p><code>console.log(application.A);// aa</code></p>
<p><code>console.log(application.B()); // aa</code></p>
<p><code>console.log(application.name); // tugenhua</code></p>
<p><code>console.log(application.getName());// tugenhua</code></p>
<h1 id="四、理解代理模式"><a href="#四、理解代理模式" class="headerlink" title="四、理解代理模式"></a>四、理解代理模式</h1><p>　　代理是一个对象，它可以用来控制对本体对象的访问，它与本体对象实现了同样的接口，代理对象会把所有的调用方法传递给本体对象的；代理模式最基本的形式是对访问进行控制，而本体对象则负责执行所分派的那个对象的函数或者类，简单的来讲本地对象注重的去执行页面上的代码，代理则控制本地对象何时被实例化，何时被使用；我们在上面的单体模式中使用过一些代理模式，就是使用代理模式实现单体模式的实例化，其他的事情就交给本体对象去处理；</p>
<p>　　<strong>代理的优点：</strong></p>
<p>　　1. 代理对象可以代替本体被实例化，并使其可以被远程访问；<br>　　2. 它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象；</p>
<p>　　我们先来理解代理对象代替本体对象被实例化的列子；比如现在京东ceo想送给奶茶妹一个礼物，但是呢假如该ceo不好意思送，或者由于工作忙没有时间送，那么这个时候他就想委托他的经纪人去做这件事，于是我们可以使用代理模式来编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先申明一个奶茶妹对象</span></span><br><span class="line"><span class="keyword">var</span> TeaAndMilkGirl = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这是京东ceo先生</span></span><br><span class="line"><span class="keyword">var</span> Ceo = <span class="function"><span class="keyword">function</span>(<span class="params">girl</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.girl = girl;</span><br><span class="line">    <span class="comment">// 送结婚礼物 给奶茶妹</span></span><br><span class="line">    <span class="built_in">this</span>.sendMarriageRing = <span class="function"><span class="keyword">function</span>(<span class="params">ring</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hi &quot;</span> + <span class="built_in">this</span>.girl.name + <span class="string">&quot;, ceo送你一个礼物：&quot;</span> + ring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 京东ceo的经纪人是代理，来代替送</span></span><br><span class="line"><span class="keyword">var</span> ProxyObj = <span class="function"><span class="keyword">function</span>(<span class="params">girl</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.girl = girl;</span><br><span class="line">    <span class="comment">// 经纪人代理送礼物给奶茶妹</span></span><br><span class="line">    <span class="built_in">this</span>.sendGift = <span class="function"><span class="keyword">function</span>(<span class="params">gift</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 代理模式负责本体对象实例化</span></span><br><span class="line">        (<span class="keyword">new</span> Ceo(<span class="built_in">this</span>.girl)).sendMarriageRing(gift);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> ProxyObj(<span class="keyword">new</span> TeaAndMilkGirl(<span class="string">&quot;奶茶妹&quot;</span>));</span><br><span class="line">proxy.sendGift(<span class="string">&quot;结婚戒&quot;</span>); <span class="comment">// Hi 奶茶妹, ceo送你一个礼物：结婚戒</span></span><br></pre></td></tr></table></figure>
<p>代码如上的基本结构，TeaAndMilkGirl 是一个被送的对象(这里是奶茶妹)；Ceo 是送礼物的对象，他保存了奶茶妹这个属性，及有一个自己的特权方法sendMarriageRing 就是送礼物给奶茶妹这么一个方法；然后呢他是想通过他的经纪人去把这件事完成，于是需要创建一个经济人的代理模式，名字叫ProxyObj ；他的主要做的事情是，把ceo交给他的礼物送给ceo的情人，因此该对象同样需要保存ceo情人的对象作为自己的属性，同时也需要一个特权方法sendGift ，该方法是送礼物，因此在该方法内可以实例化本体对象，这里的本体对象是ceo送花这件事情，因此需要实例化该本体对象后及调用本体对象的方法(sendMarriageRing).</p>
<p>最后我们初始化是需要代理对象ProxyObj；调用ProxyObj 对象的送花这个方法(sendGift)即可；</p>
<p>对于我们提到的优点，第二点的话，我们下面可以来理解下虚拟代理，虚拟代理用于控制对那种创建开销很大的本体访问，它会把本体的实例化推迟到有方法被调用的时候；比如说现在有一个对象的实例化很慢的话，不能在网页加载的时候立即完成，我们可以为其创建一个虚拟代理，让他把该对象的实例推迟到需要的时候。</p>
<p><strong>理解使用虚拟代理实现图片的预加载</strong></p>
<p>在网页开发中，图片的预加载是一种比较常用的技术，如果直接给img标签节点设置src属性的话，如果图片比较大的话，或者网速相对比较慢的话，那么在图片未加载完之前，图片会有一段时间是空白的场景，这样对于用户体验来讲并不好，那么这个时候我们可以在图片未加载完之前我们可以使用一个loading加载图片来作为一个占位符，来提示用户该图片正在加载，等图片加载完后我们可以对该图片直接进行赋值即可；下面我们先不用代理模式来实现图片的预加载的情况下代码如下：</p>
<p><strong>第一种方案：不使用代理的预加载图片函数如下</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用代理的预加载图片函数如下</span></span><br><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        imgNode.src = <span class="built_in">this</span>.src;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">            imgNode.src = <span class="string">&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;</span>;</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">myImage.setSrc(<span class="string">&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如上代码是不使用代理模式来实现的代码；</p>
<p><strong>第二种方案：使用代理模式来编写预加载图片的代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">var</span> ProxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myImage.setSrc(<span class="built_in">this</span>.src);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">                         myImage.setSrc(<span class="string">&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;</span>);</span><br><span class="line">        img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">ProxyImage.setSrc(<span class="string">&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　第一种方案是使用一般的编码方式实现图片的预加载技术，首先创建imgNode元素，然后调用myImage.setSrc该方法的时候，先给图片一个预加载图片，当图片加载完的时候，再给img元素赋值，第二种方案是使用代理模式来实现的，myImage 函数只负责创建img元素，代理函数ProxyImage 负责给图片设置loading图片，当图片真正加载完后的话，调用myImage中的myImage.setSrc方法设置图片的路径；他们之间的优缺点如下：</p>
<p>　　1. 第一种方案一般的方法代码的耦合性太高，一个函数内负责做了几件事情，比如创建img元素，和实现给未加载图片完成之前设置loading加载状态等多项事情，未满足面向对象设计原则中单一职责原则；并且当某个时候不需要代理的时候，需要从myImage 函数内把代码删掉，这样代码耦合性太高。<br>　　2. 第二种方案使用代理模式，其中myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可；</p>
<p>　　从上面代理模式我们可以看到，代理模式和本体对象中有相同的方法setSrc,这样设置的话有如下2个优点：</p>
<p>　　1. 用户可以放心地请求代理，他们只关心是否能得到想要的结果。假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。<br>　　2. 在任何使用本体对象的地方都可以替换成使用代理。</p>
<p>　　当然如果代理对象和本体对象都返回一个匿名函数的话，那么也可以认为他们也具有一直的接口；比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        imgNode.src = src; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">var</span> ProxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myImage(<span class="built_in">this</span>.src);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">                myImage(<span class="string">&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;</span>);</span><br><span class="line">        img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">ProxyImage(<span class="string">&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　<strong>虚拟代理合并http请求的理解：</strong></p>
<p>　　比如在做后端系统中，有表格数据，每一条数据前面有复选框按钮，当点击复选框按钮时候，需要获取该id后需要传递给给服务器发送ajax请求，服务器端需要记录这条数据，去请求，如果我们每当点击一下向服务器发送一个http请求的话，对于服务器来说压力比较大，网络请求比较频繁，但是如果现在该系统的实时数据不是很高的话，我们可以通过一个代理函数收集一段时间内(比如说2-3秒)的所有id，一次性发ajax请求给服务器，相对来说网络请求降低了, 服务器压力减少了;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先html结构如下：</span></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;label&gt;选择框&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;j-input&quot;</span> data-id=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;label&gt;选择框&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;j-input&quot;</span> data-id = <span class="string">&quot;2&quot;</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;label&gt;选择框&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;j-input&quot;</span> data-id=<span class="string">&quot;3&quot;</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;label&gt;选择框&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;j-input&quot;</span> data-id = <span class="string">&quot;4&quot;</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>一般的情况下 JS如下编写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> checkboxs = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;j-input&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = checkboxs.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">            checkboxs[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.checked) &#123;</span><br><span class="line">                    <span class="keyword">var</span> id = <span class="built_in">this</span>.getAttribute(<span class="string">&quot;data-id&quot;</span>);</span><br><span class="line">                    <span class="comment">// 如下是ajax请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>　　下面我们通过虚拟代理的方式，延迟2秒，在2秒后获取所有被选中的复选框的按钮id，一次性给服务器发请求。</p>
<p>　　通过点击页面的复选框，选中的时候增加一个属性isflag，没有选中的时候删除该属性isflag，然后延迟个2秒，在2秒后重新判断页面上所有复选框中有isflag的属性上的id，存入数组，然后代理函数调用本体函数的方法，把延迟2秒后的所有id一次性发给本体方法，本体方法可以获取所有的id，可以向服务器端发送ajax请求，这样的话，服务器的请求压力相对来说减少了。</p>
<p>　　代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本体函数</span></span><br><span class="line"><span class="keyword">var</span> mainFunc = <span class="function"><span class="keyword">function</span>(<span class="params">ids</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ids); <span class="comment">// 即可打印被选中的所有的id</span></span><br><span class="line">    <span class="comment">// 再把所有的id一次性发ajax请求给服务器端</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理函数 通过代理函数获取所有的id 传给本体函数去执行</span></span><br><span class="line"><span class="keyword">var</span> proxyFunc = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = [],  <span class="comment">// 保存一段时间内的id</span></span><br><span class="line">        timer = <span class="literal">null</span>; <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">checkboxs</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断如果定时器有的话，不进行覆盖操作</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 在2秒内获取所有被选中的id，通过属性isflag判断是否被选中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = checkboxs.length; i &lt; ilen; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(checkboxs[i].hasAttribute(<span class="string">&quot;isflag&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">var</span> id = checkboxs[i].getAttribute(<span class="string">&quot;data-id&quot;</span>);</span><br><span class="line">                    cache[cache.length] = id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mainFunc(cache.join(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">// 2秒后需要给本体函数传递所有的id</span></span><br><span class="line">            <span class="comment">// 清空定时器</span></span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            cache = [];</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> checkboxs = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;j-input&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = checkboxs.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        checkboxs[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.checked) &#123;</span><br><span class="line">                <span class="comment">// 给当前增加一个属性</span></span><br><span class="line">                <span class="built_in">this</span>.setAttribute(<span class="string">&quot;isflag&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.removeAttribute(<span class="string">&#x27;isflag&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用代理函数</span></span><br><span class="line">            proxyFunc(checkboxs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>理解缓存代理：</strong></p>
<p>　　缓存代理的含义就是对第一次运行时候进行缓存，当再一次运行相同的时候，直接从缓存里面取，这样做的好处是避免重复一次运算功能，如果运算非常复杂的话，对性能很耗费，那么使用缓存对象可以提高性能;我们可以先来理解一个简单的缓存列子，就是网上常见的加法和乘法的运算。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算乘法</span></span><br><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = <span class="built_in">arguments</span>.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        a = a*<span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 计算加法</span></span><br><span class="line"><span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = <span class="built_in">arguments</span>.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        a += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理函数</span></span><br><span class="line"><span class="keyword">var</span> proxyFunc = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;  <span class="comment">// 缓存对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[args];   <span class="comment">// 使用缓存代理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[args] = fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxyMult = proxyFunc(mult);</span><br><span class="line"><span class="built_in">console</span>.log(proxyMult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyMult(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 缓存取 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyPlus = proxyFunc(plus);</span><br><span class="line"><span class="built_in">console</span>.log(proxyPlus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyPlus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));  <span class="comment">// 缓存取 10</span></span><br></pre></td></tr></table></figure>
<h1 id="五、理解职责链模式"><a href="#五、理解职责链模式" class="headerlink" title="五、理解职责链模式"></a>五、理解职责链模式</h1><p><strong>优点是：消除请求的发送者与接收者之间的耦合。</strong></p>
<p>　　职责连是由多个不同的对象组成的，发送者是发送请求的对象，而接收者则是链中那些接收这种请求并且对其进行处理或传递的对象。请求本身有时候也可以是一个对象，它封装了和操作有关的所有数据，基本实现流程如下：</p>
<p>　　1. 发送者知道链中的第一个接收者，它向这个接收者发送该请求。</p>
<p>　　2. 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递。</p>
<p>　　3. 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor)。</p>
<p>　　4. 如果没有任何接收者处理请求，那么请求会从链中离开。</p>
<p>　　我们可以理解职责链模式是处理请求组成的一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。比如对象A给对象B发请求，如果B对象不处理，它就会把请求交给C，如果C对象不处理的话，它就会把请求交给D，依次类推，直到有一个对象能处理该请求为止，当然没有任何对象处理该请求的话，那么请求就会从链中离开。</p>
<p>　　比如常见的一些外包公司接到一个项目，那么接到项目有可能是公司的负责项目的人或者经理级别的人，经理接到项目后自己不开发，直接把它交到项目经理来开发，项目经理自己肯定不乐意自己动手开发哦，它就把项目交给下面的码农来做，所以码农来处理它，如果码农也不处理的话，那么这个项目可能会直接挂掉了，但是最后完成后，外包公司它并不知道这些项目中的那一部分具体有哪些人开发的，它并不知道，也并不关心的，它关心的是这个项目已交给外包公司已经开发完成了且没有任何bug就可以了；所以职责链模式的优点就在这里：</p>
<p>　　消除请求的发送者(需要外包项目的公司)与接收者(外包公司)之间的耦合。</p>
<p>　　下面列举个列子来说明职责链的好处：</p>
<p>　　天猫每年双11都会做抽奖活动的，比如阿里巴巴想提高大家使用支付宝来支付的话，每一位用户充值500元到支付宝的话，那么可以100%中奖100元红包，</p>
<p>　　充值200元到支付宝的话，那么可以100%中奖20元的红包，当然如果不充值的话，也可以抽奖，但是概率非常低，基本上是抽不到的，当然也有可能抽到的。</p>
<p>　　我们下面可以分析下代码中的几个字段值需要来判断：</p>
<p>　　1. orderType(充值类型)，如果值为1的话，说明是充值500元的用户，如果为2的话，说明是充值200元的用户，如果是3的话，说明是没有充值的用户。</p>
<p>　　2. isPay(是否已经成功充值了): 如果该值为true的话，说明已经成功充值了，否则的话 说明没有充值成功；就当作普通用户来购买。</p>
<p>　　3. count(表示数量)；普通用户抽奖，如果数量有的话，就可以拿到优惠卷，否则的话，不能拿到优惠卷。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们一般写代码如下处理操作</span></span><br><span class="line"><span class="keyword">var</span> order =  <span class="function"><span class="keyword">function</span>(<span class="params">orderType,isPay,count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType == <span class="number">1</span>) &#123;  <span class="comment">// 用户充值500元到支付宝去</span></span><br><span class="line">        <span class="keyword">if</span>(isPay == <span class="literal">true</span>) &#123; <span class="comment">// 如果充值成功的话，100%中奖</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了100元红包了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 充值失败，就当作普通用户来处理中奖信息</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您已抽到10元优惠卷&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，请再接再厉哦&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType == <span class="number">2</span>) &#123;  <span class="comment">// 用户充值200元到支付宝去</span></span><br><span class="line">        <span class="keyword">if</span>(isPay == <span class="literal">true</span>) &#123;     <span class="comment">// 如果充值成功的话，100%中奖</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了20元红包了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 充值失败，就当作普通用户来处理中奖信息</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您已抽到10元优惠卷&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，请再接再厉哦&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 普通用户来处理中奖信息</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您已抽到10元优惠卷&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，请再接再厉哦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　上面的代码虽然可以实现需求，但是代码不容易扩展且难以阅读，假如以后我想一两个条件，我想充值300元成功的话，可以中奖150元红包，那么这时候又要改动里面的代码,这样业务逻辑与代码耦合性相对比较高，一不小心就改错了代码；这时候我们试着使用职责链模式来依次传递对象来实现；</p>
<p>　　如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">order500</span>(<span class="params">orderType,isPay,count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType == <span class="number">1</span> &amp;&amp; isPay == <span class="literal">true</span>)    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了100元红包了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自己不处理，传递给下一个对象order200去处理</span></span><br><span class="line">        order200(orderType,isPay,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">order200</span>(<span class="params">orderType,isPay,count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType == <span class="number">2</span> &amp;&amp; isPay == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了20元红包了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 自己不处理，传递给下一个对象普通用户去处理</span></span><br><span class="line">        orderNormal(orderType,isPay,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderNormal</span>(<span class="params">orderType,isPay,count</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 普通用户来处理中奖信息</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您已抽到10元优惠卷&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，请再接再厉哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　如上代码我们分别使用了三个函数order500，order200，orderNormal来分别处理自己的业务逻辑，如果目前的自己函数不能处理的事情，我们传递给下面的函数去处理，依次类推，直到有一个函数能处理他，否则的话，该职责链模式直接从链中离开，告诉不能处理，抛出错误提示，上面的代码虽然可以当作职责链模式，但是我们看上面的代码可以看到order500函数内依赖了order200这样的函数，这样就必须有这个函数，也违反了面向对象中的 开放-封闭原则。下面我们继续来理解编写 灵活可拆分的职责链节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">order500</span>(<span class="params">orderType,isPay,count</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType == <span class="number">1</span> &amp;&amp; isPay == <span class="literal">true</span>)    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了100元红包了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//我不知道下一个节点是谁,反正把请求往后面传递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">order200</span>(<span class="params">orderType,isPay,count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType == <span class="number">2</span> &amp;&amp; isPay == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您中奖了20元红包了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//我不知道下一个节点是谁,反正把请求往后面传递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderNormal</span>(<span class="params">orderType,isPay,count</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 普通用户来处理中奖信息</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，您已抽到10元优惠卷&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;亲爱的用户，请再接再厉哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面需要编写职责链模式的封装构造函数方法</span></span><br><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn;</span><br><span class="line">    <span class="built_in">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">successor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor = successor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把请求往下传递</span></span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="built_in">this</span>.fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret === <span class="string">&#x27;nextSuccessor&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在我们把3个函数分别包装成职责链节点：</span></span><br><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> Chain(order500);</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> Chain(order200);</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> Chain(orderNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后指定节点在职责链中的顺序</span></span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200);</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把请求传递给第一个节点：</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>,<span class="literal">true</span>,<span class="number">500</span>);  <span class="comment">// 亲爱的用户，您中奖了100元红包了</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">2</span>,<span class="literal">true</span>,<span class="number">500</span>);  <span class="comment">// 亲爱的用户，您中奖了20元红包了</span></span><br><span class="line">chainOrder500.passRequest(<span class="number">3</span>,<span class="literal">true</span>,<span class="number">500</span>);  <span class="comment">// 亲爱的用户，您已抽到10元优惠卷 </span></span><br><span class="line">chainOrder500.passRequest(<span class="number">1</span>,<span class="literal">false</span>,<span class="number">0</span>);   <span class="comment">// 亲爱的用户，请再接再厉哦</span></span><br></pre></td></tr></table></figure>
<p>　　如上代码;分别编写order500，order200，orderNormal三个函数，在函数内分别处理自己的业务逻辑，如果自己的函数不能处理的话，就返回字符串nextSuccessor 往后面传递，然后封装Chain这个构造函数，传递一个fn这个对象实列进来，且有自己的一个属性successor，原型上有2个方法 setNextSuccessor 和 passRequest;setNextSuccessor 这个方法是指定节点在职责链中的顺序的，把相对应的方法保存到this.successor这个属性上，chainOrder500.setNextSuccessor(chainOrder200);chainOrder200.setNextSuccessor(chainOrderNormal);指定链中的顺序，因此this.successor引用了order200这个方法和orderNormal这个方法，因此第一次chainOrder500.passRequest(1,true,500)调用的话，调用order500这个方法，直接输出，第二次调用chainOrder500.passRequest(2,true,500);这个方法从链中首节点order500开始不符合，就返回successor字符串，然后this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments);就执行这句代码；上面我们说过this.successor这个属性引用了2个方法 分别为order200和orderNormal，因此调用order200该方法，所以就返回了值，依次类推都是这个原理。那如果以后我们想充值300元的红包的话，我们可以编写order300这个函数，然后实列一下链chain包装起来，指定一下职责链中的顺序即可，里面的业务逻辑不需要做任何处理;</p>
<p>　　<strong>理解异步的职责链</strong></p>
<p>　　上面的只是同步职责链，我们让每个节点函数同步返回一个特定的值”nextSuccessor”，来表示是否把请求传递给下一个节点，在我们开发中会经常碰到ajax异步请求，请求成功后，需要做某某事情，那么这时候如果我们再套用上面的同步请求的话，就不生效了，下面我们来理解下使用异步的职责链来解决这个问题;我们给Chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的一下个节点。</p>
<p>　　如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;nextSuccessor&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        self.next();</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面需要编写职责链模式的封装构造函数方法</span></span><br><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn;</span><br><span class="line">    <span class="built_in">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">successor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor = successor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把请求往下传递</span></span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="built_in">this</span>.fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret === <span class="string">&#x27;nextSuccessor&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">Chain.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply(<span class="built_in">this</span>.successor,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在我们把3个函数分别包装成职责链节点：</span></span><br><span class="line"><span class="keyword">var</span> chainFn1 = <span class="keyword">new</span> Chain(Fn1);</span><br><span class="line"><span class="keyword">var</span> chainFn2 = <span class="keyword">new</span> Chain(Fn2);</span><br><span class="line"><span class="keyword">var</span> chainFn3 = <span class="keyword">new</span> Chain(Fn3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后指定节点在职责链中的顺序</span></span><br><span class="line">chainFn1.setNextSuccessor(chainFn2);</span><br><span class="line">chainFn2.setNextSuccessor(chainFn3);</span><br><span class="line"></span><br><span class="line">chainFn1.passRequest();  <span class="comment">// 打印出1，2 过1秒后 会打印出3</span></span><br></pre></td></tr></table></figure>
<p>　　调用函数 chainFn1.passRequest();后，会先执行发送者Fn1这个函数 打印出1，然后返回字符串 nextSuccessor;</p>
<p>　　接着就执行return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments);这个函数到Fn2，打印2，接着里面有一个setTimeout定时器异步函数，需要把请求给职责链中的下一个节点，因此过一秒后会打印出3;</p>
<p>　　<strong>职责链模式的优点是：</strong></p>
<p>　　1. 解耦了请求发送者和N个接收者之间的复杂关系，不需要知道链中那个节点能处理你的请求，所以你只需要把请求传递到第一个节点即可。</p>
<p>　　2. 链中的节点对象可以灵活地拆分重组，增加或删除一个节点，或者改变节点的位置都是很简单的事情。</p>
<p>　　3. 我们还可以手动指定节点的起始位置，并不是说非得要从其实节点开始传递的.</p>
<p>　　<strong>缺点：</strong>职责链模式中多了一点节点对象，可能在某一次请求过程中，大部分节点没有起到实质性作用，他们的作用只是让请求传递下去，从性能方面考虑，避免过长的职责链提高性能。</p>
<h1 id="六、命令模式的理解"><a href="#六、命令模式的理解" class="headerlink" title="六、命令模式的理解"></a>六、命令模式的理解</h1><p>　　命令模式中的命令指的是一个执行某些特定事情的指令。</p>
<p>　　命令模式使用的场景有：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道请求的操作是什么，此时希望用一种松耦合的方式来设计程序代码;使得请求发送者和请求接受者消除彼此代码中的耦合关系。</p>
<p>　　我们先来列举生活中的一个列子来说明下命令模式：比如我们经常会在天猫上购买东西，然后下订单，下单后我就想收到货，并且希望货物是真的，对于用户来讲它并关心下单后卖家怎么发货，当然卖家发货也有时间的，比如24小时内发货等，用户更不关心快递是给谁派送，当然有的人会关心是什么快递送货的; 对于用户来说，只要在规定的时间内发货，且一般能在相当的时间内收到货就可以，当然命令模式也有撤销命令和重做命令，比如我们下单后，我突然不想买了，我在发货之前可以取消订单，也可以重新下单（也就是重做命令）;比如我的衣服尺码拍错了，我取消该订单，重新拍一个大码的。</p>
<p>　　<strong>1. 命令模式的列子</strong></p>
<p>　　记得我以前刚做前端的那会儿，也就是刚毕业进的第一家公司，进的是做外包项目的公司，该公司一般外包淘宝活动页面及腾讯的游戏页面，我们那会儿应该叫切页面的前端，负责做一些html和css的工作，所以那会儿做腾讯的游戏页面，经常会帮他们做静态页面，比如在页面放几个按钮，我们只是按照设计稿帮腾讯游戏哪方面的把样式弄好，比如说页面上的按钮等事情，比如说具体说明的按钮要怎么操作，点击按钮后会发生什么事情，我们并不知道，我们不知道他们的业务是什么，当然我们知道的肯定会有点击事件，具体要处理什么业务我们并不知道，这里我们就可以使用命令模式来处理了：点击按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前我们并不知道接收者是什么对象，也不知道接受者究竟会做什么事情，这时候我们可以使用命令模式来消除发送者与接收者的代码耦合关系。</p>
<p>　　我们先使用传统的面向对象模式来设计代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">假设html结构如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span>&gt;</span>刷新菜单目录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button2&quot;</span>&gt;</span>增加子菜单<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button3&quot;</span>&gt;</span>删除子菜单<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JS代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button1&quot;</span>),</span><br><span class="line">     b2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button2&quot;</span>),</span><br><span class="line">     b3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button3&quot;</span>);</span><br><span class="line">     </span><br><span class="line"> <span class="comment">// 定义setCommand 函数，该函数负责往按钮上面安装命令。点击按钮后会执行command对象的execute()方法。</span></span><br><span class="line"> <span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button,command</span>)</span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 下面我们自己来定义各个对象来完成自己的业务操作</span></span><br><span class="line"> <span class="keyword">var</span> MenuBar = &#123;</span><br><span class="line">    refersh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;刷新菜单目录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> SubMenu = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;增加子菜单&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;删除子菜单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 下面是编写命令类</span></span><br><span class="line"> <span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line"> &#125;;</span><br><span class="line"> RefreshMenuBarCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver.refersh();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 增加命令操作</span></span><br><span class="line"> <span class="keyword">var</span> AddSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line"> &#125;;</span><br><span class="line"> AddSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver.add();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 删除命令操作</span></span><br><span class="line"> <span class="keyword">var</span> DelSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line"> &#125;;</span><br><span class="line"> DelSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver.del();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 最后把命令接收者传入到command对象中，并且把command对象安装到button上面</span></span><br><span class="line"> <span class="keyword">var</span> refershBtn = <span class="keyword">new</span> RefreshMenuBarCommand(MenuBar);</span><br><span class="line"> <span class="keyword">var</span> addBtn = <span class="keyword">new</span> AddSubMenuCommand(SubMenu);</span><br><span class="line"> <span class="keyword">var</span> delBtn = <span class="keyword">new</span> DelSubMenuCommand(SubMenu);</span><br><span class="line"> </span><br><span class="line"> setCommand(b1,refershBtn);</span><br><span class="line"> setCommand(b2,addBtn);</span><br><span class="line"> setCommand(b3,delBtn);</span><br></pre></td></tr></table></figure>
<p>　　从上面的命令类代码我们可以看到，任何一个操作都有一个execute这个方法来执行操作;上面的代码是使用传统的面向对象编程来实现命令模式的，命令模式过程式的请求调用封装在command对象的execute方法里。我们有没有发现上面的编写代码有点繁琐呢，我们可以使用javascript中的回调函数来做这些事情的，在面向对象中，命令模式的接收者被当成command对象的属性保存起来，同时约定执行命令的操作调用command.execute方法，但是如果我们使用回调函数的话，那么接收者被封闭在回调函数产生的环境中，执行操作将会更加简单，仅仅执行回调函数即可，下面我们来看看代码如下：</p>
<p>　　代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button,func</span>) </span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">var</span> MenuBar = &#123;</span><br><span class="line">    refersh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;刷新菜单界面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> SubMenu = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;增加菜单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 刷新菜单</span></span><br><span class="line"> <span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        receiver.refersh();    </span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 增加菜单</span></span><br><span class="line"> <span class="keyword">var</span> AddSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        receiver.add();    </span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> refershMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line"> <span class="comment">// 增加菜单</span></span><br><span class="line"> <span class="keyword">var</span> addSubMenuCommand = AddSubMenuCommand(SubMenu);</span><br><span class="line"> setCommand(b1,refershMenuBarCommand);</span><br><span class="line"> </span><br><span class="line"> setCommand(b2,addSubMenuCommand);</span><br></pre></td></tr></table></figure>
<p>　　我们还可以如下使用javascript回调函数如下编码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下代码上的四个按钮 点击事件</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button1&quot;</span>),</span><br><span class="line">    b2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button2&quot;</span>),</span><br><span class="line">    b3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button3&quot;</span>),</span><br><span class="line">    b4 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;button4&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> bindEnv函数负责往按钮上面安装点击命令。点击按钮后，会调用</span></span><br><span class="line"><span class="comment"> 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> bindEnv = <span class="function"><span class="keyword">function</span>(<span class="params">button,func</span>) </span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 现在我们来编写具体处理业务逻辑代码</span></span><br><span class="line"><span class="keyword">var</span> Todo1 = &#123;</span><br><span class="line">    test1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;我是来做第一个测试的&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现业务中的增删改操作</span></span><br><span class="line"><span class="keyword">var</span> Menu = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;我是来处理一些增加操作的&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;我是来处理一些删除操作的&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;我是来处理一些更新操作的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">bindEnv(b1,Todo1.test1);</span><br><span class="line"><span class="comment">// 增加按钮</span></span><br><span class="line">bindEnv(b2,Menu.add);</span><br><span class="line"><span class="comment">// 删除按钮</span></span><br><span class="line">bindEnv(b3,Menu.del);</span><br><span class="line"><span class="comment">// 更改按钮</span></span><br><span class="line">bindEnv(b4,Menu.update);</span><br></pre></td></tr></table></figure>
<p>　　<strong>2. 理解宏命令：</strong></p>
<p>　　宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。其实类似把页面的所有函数方法放在一个数组里面去，然后遍历这个数组，依次执行该方法的。</p>
<p>　　代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command1 = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> command2 = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> command3 = &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义宏命令，command.add方法把子命令添加进宏命令对象，</span></span><br><span class="line"><span class="comment">// 当调用宏命令对象的execute方法时，会迭代这一组命令对象，</span></span><br><span class="line"><span class="comment">// 并且依次执行他们的execute方法。</span></span><br><span class="line"><span class="keyword">var</span> command = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        commandsList: [],</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.commandsList.push(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,commands = <span class="built_in">this</span>.commandsList.length; i &lt; commands; i+=<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.commandsList[i].execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化宏命令</span></span><br><span class="line"><span class="keyword">var</span> c = command();</span><br><span class="line">c.add(command1);</span><br><span class="line">c.add(command2);</span><br><span class="line">c.add(command3);</span><br><span class="line">c.execute();  <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>
<h1 id="七、模板方法模式"><a href="#七、模板方法模式" class="headerlink" title="七、模板方法模式"></a>七、模板方法模式</h1><p>　　模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p>
<p>　　比如说我们要实现一个JS功能，比如表单验证等js，那么如果我们没有使用上一章讲的使用javascript中的策略模式来解决表单验证封装代码，而是自己写的临时表单验证功能，肯定是没有进行任何封装的，那么这个时候我们是针对两个值是否相等给用户弹出一个提示，如果再另外一个页面也有一个表单验证，他们判断的方式及业务逻辑基本相同的，只是比较的参数不同而已，我们是不是又要考虑写一个表单验证代码呢？那么现在我们可以考虑使用模板方法模式来解决这个问题；公用的方法提取出来，不同的方法由具体的子类是实现。这样设计代码也可扩展性更强，代码更优等优点~</p>
<p>　　我们不急着写代码，我们可以先来看一个列子，比如最近经常在qq群里面有很多前端招聘的信息，自己也接到很多公司或者猎头问我是否需要找工作等电话，当然我现在是没有打算找工作的，因为现在有更多的业余时间可以处理自己的事情，所以也觉得蛮不错的~ 我们先来看看招聘中面试这个流程；面试流程对于很多大型公司，比如BAT，面试过程其实很类似；因此我们可以总结面试过程中如下：</p>
<p>　　1. 笔试：(不同的公司有不同的笔试题目)。</p>
<p>　　2. 技术面试(一般情况下分为二轮)：第一轮面试你的有可能是你未来直接主管或者未来同事问你前端的一些专业方面的技能及以前做过的项目，在项目中遇到哪些问题及当时是如何解决问题的，还有根据你的简历上的基本信息来交流的，比如说你简历说精通JS，那么人家肯定得问哦~ 第二轮面试一般都是公司的牛人或者架构师来问的，比如问你计算机基本原理，或者问一些数据结构与算法等信息；第二轮面试可能会更深入的去了解你这个人的技术。</p>
<p>　　3. HR和总监或者总经理面试；那么这一轮的话，HR可能会问下你一些个人基本信息等情况，及问下你今后有什么打算的个人规划什么的，总监或者总经理可能会问下你对他们的网站及产品有了解过没有？及现在他们的产品有什么问题，有没有更好的建议或者如何改善的地方等信息；</p>
<p>　　4. 最后就是HR和你谈薪资及一般几个工作日可以得到通知，拿到offer(当然不符合的肯定是没有通知的哦)；及自己有没有需要了解公司的情况等等信息；</p>
<p>　　一般的面试过程都是如上四点下来的，对于不同的公司都差不多的流程的，当然有些公司可能没有上面的详细流程的，我这边这边讲一般的情况下，好了，这边就不扯了，这边也不是讲如何面试的哦，这边只是通过这个列子让我们更加的理解javascript中模板方法模式；所以我们现在回到正题上来；</p>
<p>　　我们先来分析下上面的流程；我们可以总结如下：</p>
<p>　　首先我们看一下百度的面试；因此我们可以先定义一个构造函数。</p>
<p>　　var BaiDuInterview = function(){};</p>
<p>　　那么下面就有百度面试的流程哦~</p>
<p>　　1. 笔试</p>
<p>　　那么我们可以封装一个笔试的方法，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// baidu 笔试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.writtenTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">&quot;我终于看到百度的笔试题了~&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　2. 技术面试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 技术面试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.technicalInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">&quot;我是百度的技术负责人&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　3.  HR和总监或者总经理面试，我们可以称之为leader面试；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// 领导面试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.leader = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">console</span>.log(<span class="string">&quot;百度leader来面试了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　4. 和HR谈期望的薪资待遇及HR会告诉你什么时候会有通知，因此我们这边可以称之为这个方法为 是否拿到offer(当然不符合要求肯定是没有通知的哦)；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等通知</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.waitNotice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;百度的人力资源太不给力了，到现在都不给我通知&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上看到代码的基本结构，但是我们还需要一个初始化方法；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码初始化</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.writtenTest();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.technicalInterview();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.leader();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.waitNotice();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baiDuInterview = <span class="keyword">new</span> BaiDuInterview();</span><br><span class="line"></span><br><span class="line">baiDuInterview.init();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　综合所述：所有的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> BaiDuInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// baidu 笔试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.writtenTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我终于看到百度的题目笔试题了~&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技术面试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.technicalInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是百度的技术负责人&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 领导面试</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.leader = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;百度leader来面试了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等通知</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.waitNotice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;百度的人力资源太不给力了，到现在都不给我通知&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码初始化</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.writtenTest();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.technicalInterview();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.leader();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.waitNotice();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baiDuInterview = <span class="keyword">new</span> BaiDuInterview();</span><br><span class="line"></span><br><span class="line">baiDuInterview.init();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　上面我们可以看到百度面试的基本流程如上面的代码，那么阿里和腾讯的也和上面的代码类似(这里就不一一贴一样的代码哦)，因此我们可以把公用代码提取出来；我们首先定义一个类，叫面试Interview</p>
<p>　　那么代码改成如下：</p>
<p><code>var Interview = function()&#123;&#125;;</code></p>
<p>　　1. 笔试：</p>
<p>　　我不管你是百度的笔试还是阿里或者腾讯的笔试题，我这边统称为笔试(WrittenTest)，那么你们公司有不同的笔试题，都交给子类去具体实现，父类方法不管具体如何实现，笔试题具体是什么样的 我都不管。代码变为如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 笔试</span></span><br><span class="line"></span><br><span class="line">Interview.prototype.writtenTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我终于看到笔试题了~&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　2. 技术面试，技术面试原理也一样，这里就不多说，直接贴代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 技术面试</span></span><br><span class="line"></span><br><span class="line">Interview.prototype.technicalInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是技术负责人负责技术面试&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　3. 领导面试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 领导面试</span></span><br><span class="line"></span><br><span class="line">Interview.prototype.leader = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;leader来面试了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　4. 等通知</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 等通知</span></span><br><span class="line"></span><br><span class="line">Interview.prototype.waitNotice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;人力资源太不给力了，到现在都不给我通知&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　代码初始化方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代码初始化</span></span><br><span class="line"></span><br><span class="line">Interview.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.writtenTest();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.technicalInterview();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.leader();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.waitNotice();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　<strong>一：创建子类</strong></p>
<p>　　现在我们来创建一个百度的子类来继承上面的父类；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> BaiDuInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype = <span class="keyword">new</span> Interview();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　现在我们可以在子类BaiDuInterview 重写父类Interview中的方法；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 子类重写方法 实现自己的业务逻辑</span></span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.writtenTest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我终于看到百度的笔试题了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.technicalInterview = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是百度的技术负责人，想面试找我&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.leader = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是百度的leader，不想加班的或者业绩提不上去的给我滚蛋&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BaiDuInterview.prototype.waitNotice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;百度的人力资源太不给力了，我等的花儿都谢了！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baiDuInterview = <span class="keyword">new</span> BaiDuInterview();</span><br><span class="line"></span><br><span class="line">baiDuInterview.init();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上看到，我们直接调用子类baiDuInterview.init()方法，由于我们子类baiDuInterview没有init方法，但是它继承了父类，所以会到父类中查找对应的init方法；所以会迎着原型链到父类中查找；对于其他子类，比如阿里类代码也是一样的，这里就不多介绍了，对于父类这个方法 Interview.prototype.init() 是模板方法，因为他封装了子类中算法框架，它作为一个算法的模板，指导子类以什么样的顺序去执行代码。</p>
<p>　　<strong>二： Javascript中的模板模式使用场景</strong></p>
<p>　　虽然在java中也有子类实现父类的接口，但是我认为javascript中可以和java中不同的，java中可能父类就是一个空的类，子类去实现这个父类的接口，在javascript中我认为完全把公用的代码写在父函数内，如果将来业务逻辑需要更改的话，或者说添加新的业务逻辑，我们完全可以使用子类去重写这个父类，这样的话代码可扩展性强，更容易维护。由于本人不是专业java的，所以描述java中的知识点有误的话，请理解~~</p>
<h1 id="八、理解javascript中的策略模式"><a href="#八、理解javascript中的策略模式" class="headerlink" title="八、理解javascript中的策略模式"></a>八、理解javascript中的策略模式</h1><p>　　<strong>1. 理解javascript中的策略模式</strong></p>
<p>　　策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<p>　　使用策略模式的优点如下：</p>
<p>　　优点：1. 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。</p>
<p>　　　　　2. 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。</p>
<p>　　　　　3. 策略模式中的代码可以复用。</p>
<p>　　一、使用策略模式计算奖金；</p>
<p>　　下面的demo是我在书上看到的，但是没有关系，我们只是来理解下策略模式的使用而已，我们可以使用策略模式来计算奖金问题；</p>
<p>　　比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；现在我们使用一般的编码方式会如下这样编写代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBouns = <span class="function"><span class="keyword">function</span>(<span class="params">salary,level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用如下：</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateBouns(<span class="number">4000</span>,<span class="string">&#x27;A&#x27;</span>)); <span class="comment">// 16000</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateBouns(<span class="number">2500</span>,<span class="string">&#x27;B&#x27;</span>)); <span class="comment">// 7500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　第一个参数为薪资，第二个参数为等级；</p>
<p>　　代码缺点如下：</p>
<p>　　calculateBouns 函数包含了很多if-else语句。</p>
<p>　　calculateBouns 函数缺乏弹性，假如还有D等级的话，那么我们需要在calculateBouns 函数内添加判断等级D的if语句；</p>
<p>　　算法复用性差，如果在其他的地方也有类似这样的算法的话，但是规则不一样，我们这些代码不能通用。</p>
<p>　　<strong>2. 使用组合函数重构代码</strong></p>
<p>　　组合函数是把各种算法封装到一个个的小函数里面，比如等级A的话，封装一个小函数，等级为B的话，也封装一个小函数，以此类推；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> performanceC = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBouns = <span class="function"><span class="keyword">function</span>(<span class="params">level,salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> performanceA(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> performanceB(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level === <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> performanceC(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用如下</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateBouns(<span class="string">&#x27;A&#x27;</span>,<span class="number">4500</span>)); <span class="comment">// 18000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　代码看起来有点改善，但是还是有如下缺点：</p>
<p>　　calculateBouns 函数有可能会越来越大，比如增加D等级的时候，而且缺乏弹性。</p>
<p>　　<strong>3. 使用策略模式重构代码</strong></p>
<p>　　策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；</p>
<p>　　一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。我们先使用传统面向对象来实现；</p>
<p>　　如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceA.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;      </span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceB.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceC = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceC.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 奖金类</span></span><br><span class="line"><span class="keyword">var</span> Bouns = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.salary = <span class="literal">null</span>;    <span class="comment">// 原始工资</span></span><br><span class="line">    <span class="built_in">this</span>.levelObj = <span class="literal">null</span>;  <span class="comment">// 绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bouns.prototype.setSalary = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;  <span class="comment">// 保存员工的原始工资</span></span><br><span class="line">&#125;;</span><br><span class="line">Bouns.prototype.setlevelObj = <span class="function"><span class="keyword">function</span>(<span class="params">levelObj</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.levelObj = levelObj;  <span class="comment">// 设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 取得奖金数</span></span><br><span class="line">Bouns.prototype.getBouns = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 把计算奖金的操作委托给对应的策略对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.levelObj.calculate(<span class="built_in">this</span>.salary);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bouns = <span class="keyword">new</span> Bouns();</span><br><span class="line">bouns.setSalary(<span class="number">10000</span>);</span><br><span class="line">bouns.setlevelObj(<span class="keyword">new</span> performanceA()); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log(bouns.getBouns());  <span class="comment">// 40000</span></span><br><span class="line">       </span><br><span class="line">bouns.setlevelObj(<span class="keyword">new</span> performanceB()); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log(bouns.getBouns());  <span class="comment">// 30000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上代码使用策略模式重构代码，可以看到代码职责更新分明，代码变得更加清晰。</p>
<p>　　<strong>4. Javascript版本的策略模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//代码如下：</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="string">&quot;A&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;B&quot;</span> : <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;C&quot;</span> : <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBouns =<span class="function"><span class="keyword">function</span>(<span class="params">level,salary</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(calculateBouns(<span class="string">&#x27;A&#x27;</span>,<span class="number">10000</span>)); <span class="comment">// 40000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　可以看到代码更加简单明了；</p>
<p>　　策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们；</p>
<p>　　<strong>表单效验</strong></p>
<p>　　比如我们经常来进行表单验证，比如注册登录对话框，我们登录之前要进行验证操作：比如有以下几条逻辑：</p>
<p>　　1. 用户名不能为空</p>
<p>　　2. 密码长度不能小于6位。</p>
<p>　　3. 手机号码必须符合格式。</p>
<p>　　比如HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">id</span>=<span class="string">&quot;registerForm&quot;</span> <span class="attr">method</span> = <span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>请输入用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>请输入密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>请输入手机号码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phoneNumber&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　我们正常的编写表单验证代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">&quot;registerForm&quot;</span>);</span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(registerForm.userName.value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        alert(<span class="string">&#x27;用户名不能为空&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(registerForm.password.value.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        alert(<span class="string">&quot;密码的长度不能小于6位&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(registerForm.phoneNumber.value)) &#123;</span><br><span class="line">        alert(<span class="string">&quot;手机号码格式不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　但是这样编写代码有如下缺点：</p>
<p>　　1.registerForm.onsubmit 函数比较大，代码中包含了很多if语句；</p>
<p>　　2.registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的效验规则，或者想把密码的长度效验从6改成8，我们必须改registerForm.onsubmit 函数内部的代码。违反了开放-封闭原则。</p>
<p>　　3. 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的效验，那么我们可能又需要复制代码了；</p>
<p>　　下面我们可以使用策略模式来重构表单效验；</p>
<p>　　第一步我们先来封装策略对象；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> strategy = &#123;</span><br><span class="line">    isNotEmpty: <span class="function"><span class="keyword">function</span>(<span class="params">value,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 限制最小长度</span></span><br><span class="line">    minLength: <span class="function"><span class="keyword">function</span>(<span class="params">value,length,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 手机号码格式</span></span><br><span class="line">    mobileFormat: <span class="function"><span class="keyword">function</span>(<span class="params">value,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　接下来我们准备实现Validator类，Validator类在这里作为Context，负责接收用户的请求并委托给strategy 对象，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Validator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = [];  <span class="comment">// 保存效验规则</span></span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">dom,rule,errorMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = rule.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// str 返回的是 minLength:6 </span></span><br><span class="line">        <span class="keyword">var</span> strategy = str.shift();</span><br><span class="line">        str.unshift(dom.value); <span class="comment">// 把input的value添加进参数列表</span></span><br><span class="line">        str.push(errorMsg);  <span class="comment">// 把errorMsg添加进参数列表</span></span><br><span class="line">        <span class="keyword">return</span> strategys[strategy].apply(dom,str);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, validatorFunc; validatorFunc = <span class="built_in">this</span>.cache[i++]; ) &#123;</span><br><span class="line">        <span class="keyword">var</span> msg = validatorFunc(); <span class="comment">// 开始效验 并取得效验后的返回信息</span></span><br><span class="line">        <span class="keyword">if</span>(msg) &#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　Validator类在这里作为Context，负责接收用户的请求并委托给strategys对象。上面的代码中，我们先创建一个Validator对象，然后通过validator.add方法往validator对象中添加一些效验规则，validator.add方法接收3个参数，如下代码：</p>
<p>　　validator.add(registerForm.password,’minLength:6’,’密码长度不能小于6位’);</p>
<p>　　registerForm.password 为效验的input输入框dom节点；</p>
<p>　　minLength:6： 是以一个冒号隔开的字符串，冒号前面的minLength代表客户挑选的strategys对象，冒号后面的数字6表示在效验过程中所必须验证的参数，minLength:6的意思是效验 registerForm.password 这个文本输入框的value最小长度为6位；如果字符串中不包含冒号，说明效验过程中不需要额外的效验信息；</p>
<p>　　第三个参数是当效验未通过时返回的错误信息；</p>
<p>　　当我们往validator对象里添加完一系列的效验规则之后，会调用validator.start()方法来启动效验。如果validator.start()返回了一个errorMsg字符串作为返回值，说明该次效验没有通过，此时需要registerForm.onsubmit方法返回false来阻止表单提交。下面我们来看看初始化代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> validateFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator(); <span class="comment">// 创建一个Validator对象</span></span><br><span class="line">    <span class="comment">/* 添加一些效验规则 */</span></span><br><span class="line">    validator.add(registerForm.userName,<span class="string">&#x27;isNotEmpty&#x27;</span>,<span class="string">&#x27;用户名不能为空&#x27;</span>);</span><br><span class="line">    validator.add(registerForm.password,<span class="string">&#x27;minLength:6&#x27;</span>,<span class="string">&#x27;密码长度不能小于6位&#x27;</span>);</span><br><span class="line">    validator.add(registerForm.userName,<span class="string">&#x27;mobileFormat&#x27;</span>,<span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> errorMsg = validator.start(); <span class="comment">// 获得效验结果</span></span><br><span class="line">    <span class="keyword">return</span> errorMsg; <span class="comment">// 返回效验结果</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">&quot;registerForm&quot;</span>);</span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> errorMsg = validateFunc();</span><br><span class="line">    <span class="keyword">if</span>(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　下面是所有的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var strategys &#x3D; &#123;</span><br><span class="line">    isNotEmpty: function(value,errorMsg) &#123;</span><br><span class="line">        if(value &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 限制最小长度</span><br><span class="line">    minLength: function(value,length,errorMsg) &#123;</span><br><span class="line">        if(value.length &lt; length) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 手机号码格式</span><br><span class="line">    mobileFormat: function(value,errorMsg) &#123;</span><br><span class="line">        if(!&#x2F;(^1[3|5|8][0-9]&#123;9&#125;$)&#x2F;.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">var Validator &#x3D; function()&#123;</span><br><span class="line">    this.cache &#x3D; [];  &#x2F;&#x2F; 保存效验规则</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add &#x3D; function(dom,rule,errorMsg) &#123;</span><br><span class="line">    var str &#x3D; rule.split(&quot;:&quot;);</span><br><span class="line">    this.cache.push(function()&#123;</span><br><span class="line">        &#x2F;&#x2F; str 返回的是 minLength:6 </span><br><span class="line">        var strategy &#x3D; str.shift();</span><br><span class="line">        str.unshift(dom.value); &#x2F;&#x2F; 把input的value添加进参数列表</span><br><span class="line">        str.push(errorMsg);  &#x2F;&#x2F; 把errorMsg添加进参数列表</span><br><span class="line">        return strategys[strategy].apply(dom,str);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start &#x3D; function()&#123;</span><br><span class="line">    for(var i &#x3D; 0, validatorFunc; validatorFunc &#x3D; this.cache[i++]; ) &#123;</span><br><span class="line">        var msg &#x3D; validatorFunc(); &#x2F;&#x2F; 开始效验 并取得效验后的返回信息</span><br><span class="line">        if(msg) &#123;</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var validateFunc &#x3D; function()&#123;</span><br><span class="line">    var validator &#x3D; new Validator(); &#x2F;&#x2F; 创建一个Validator对象</span><br><span class="line">    &#x2F;* 添加一些效验规则 *&#x2F;</span><br><span class="line">    validator.add(registerForm.userName,&#39;isNotEmpty&#39;,&#39;用户名不能为空&#39;);</span><br><span class="line">    validator.add(registerForm.password,&#39;minLength:6&#39;,&#39;密码长度不能小于6位&#39;);</span><br><span class="line">    validator.add(registerForm.userName,&#39;mobileFormat&#39;,&#39;手机号码格式不正确&#39;);</span><br><span class="line"></span><br><span class="line">    var errorMsg &#x3D; validator.start(); &#x2F;&#x2F; 获得效验结果</span><br><span class="line">    return errorMsg; &#x2F;&#x2F; 返回效验结果</span><br><span class="line">&#125;;</span><br><span class="line">var registerForm &#x3D; document.getElementById(&quot;registerForm&quot;);</span><br><span class="line">registerForm.onsubmit &#x3D; function()&#123;</span><br><span class="line">    var errorMsg &#x3D; validateFunc();</span><br><span class="line">    if(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上使用策略模式来编写表单验证代码可以看到好处了，我们通过add配置的方式就完成了一个表单的效验；这样的话，那么代码可以当做一个组件来使用，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用；</p>
<p>　　给某个文本输入框添加多种效验规则，上面的代码我们可以看到，我们只是给输入框只能对应一种效验规则，比如上面的我们只能效验输入框是否为空，validator.add(registerForm.userName,’isNotEmpty’,’用户名不能为空’);但是如果我们既要效验输入框是否为空，还要效验输入框的长度不要小于10位的话，那么我们期望需要像如下传递参数：</p>
<p>　　validator.add(registerForm.userName,[{strategy:’isNotEmpty’,errorMsg:’用户名不能为空’}，{strategy: ‘minLength:6’,errorMsg:’用户名长度不能小于6位’}])</p>
<p>　　我们可以编写代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 策略对象</span></span><br><span class="line"><span class="keyword">var</span> strategys = &#123;</span><br><span class="line">    isNotEmpty: <span class="function"><span class="keyword">function</span>(<span class="params">value,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 限制最小长度</span></span><br><span class="line">    minLength: <span class="function"><span class="keyword">function</span>(<span class="params">value,length,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 手机号码格式</span></span><br><span class="line">    mobileFormat: <span class="function"><span class="keyword">function</span>(<span class="params">value,errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Validator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = [];  <span class="comment">// 保存效验规则</span></span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">dom,rules</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, rule; rule = rules[i++]; )&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">rule</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> strategyAry = rule.strategy.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> errorMsg = rule.errorMsg;</span><br><span class="line">            self.cache.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> strategy = strategyAry.shift();</span><br><span class="line">                strategyAry.unshift(dom.value);</span><br><span class="line">                strategyAry.push(errorMsg);</span><br><span class="line">                <span class="keyword">return</span> strategys[strategy].apply(dom,strategyAry);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)(rule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, validatorFunc; validatorFunc = <span class="built_in">this</span>.cache[i++]; ) &#123;</span><br><span class="line">    <span class="keyword">var</span> msg = validatorFunc(); <span class="comment">// 开始效验 并取得效验后的返回信息</span></span><br><span class="line">    <span class="keyword">if</span>(msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代码调用</span></span><br><span class="line"><span class="keyword">var</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">&quot;registerForm&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> validateFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> validator = <span class="keyword">new</span> Validator(); <span class="comment">// 创建一个Validator对象</span></span><br><span class="line">    <span class="comment">/* 添加一些效验规则 */</span></span><br><span class="line">    validator.add(registerForm.userName,[</span><br><span class="line">        &#123;<span class="attr">strategy</span>: <span class="string">&#x27;isNotEmpty&#x27;</span>,<span class="attr">errorMsg</span>:<span class="string">&#x27;用户名不能为空&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">strategy</span>: <span class="string">&#x27;minLength:6&#x27;</span>,<span class="attr">errorMsg</span>:<span class="string">&#x27;用户名长度不能小于6位&#x27;</span>&#125;</span><br><span class="line">    ]);</span><br><span class="line">    validator.add(registerForm.password,[</span><br><span class="line">        &#123;<span class="attr">strategy</span>: <span class="string">&#x27;minLength:6&#x27;</span>,<span class="attr">errorMsg</span>:<span class="string">&#x27;密码长度不能小于6位&#x27;</span>&#125;,</span><br><span class="line">    ]);</span><br><span class="line">    validator.add(registerForm.phoneNumber,[</span><br><span class="line">        &#123;<span class="attr">strategy</span>: <span class="string">&#x27;mobileFormat&#x27;</span>,<span class="attr">errorMsg</span>:<span class="string">&#x27;手机号格式不正确&#x27;</span>&#125;,</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> errorMsg = validator.start(); <span class="comment">// 获得效验结果</span></span><br><span class="line">    <span class="keyword">return</span> errorMsg; <span class="comment">// 返回效验结果</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 点击确定提交</span></span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> errorMsg = validateFunc();</span><br><span class="line">    <span class="keyword">if</span>(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　<strong>注意：</strong>如上代码都是按照书上来做的，都是看到书的代码，最主要我们理解策略模式实现，比如上面的表单验证功能是这样封装的代码，我们平时使用jquery插件表单验证代码原来是这样封装的，为此我们以后也可以使用这种方式来封装表单等学习；</p>
<h1 id="九、Javascript中理解发布–订阅模式"><a href="#九、Javascript中理解发布–订阅模式" class="headerlink" title="九、Javascript中理解发布–订阅模式"></a>九、Javascript中理解发布–订阅模式</h1><p>　　<strong>1. 发布订阅模式介绍</strong></p>
<p>　　发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
<p>　　<strong>现实生活中的发布-订阅模式；</strong></p>
<p>　　比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们；</p>
<p>　　在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息；</p>
<p>　　<strong>发布订阅模式的优点：</strong></p>
<p>　　1. 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。</p>
<p>　　比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。</p>
<p>　　2. 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。</p>
<p>　　对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~</p>
<p>　　<strong>发布订阅模式的缺点：</strong></p>
<p>　　创建订阅者需要消耗一定的时间和内存。</p>
<p>　　虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。</p>
<p>　　<strong>如何实现发布–订阅模式？</strong></p>
<p>　　1. 首先要想好谁是发布者(比如上面的卖家)。</p>
<p>　　2. 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。</p>
<p>　　3. 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</p>
<p>　　我们还可以在回调函数里面添加一点参数，比如鞋子的颜色，鞋子尺码等信息；</p>
<p>　　我们先来实现下简单的发布-订阅模式；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;; <span class="comment">// 定义发布者</span></span><br><span class="line">shoeObj.list = []; <span class="comment">// 缓存列表 存放订阅者回调函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 增加订阅者</span></span><br><span class="line">shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    shoeObj.list.push(fn);  <span class="comment">// 订阅消息添加到缓存列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line">shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="built_in">this</span>.list[i++];) &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小红订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color,size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;颜色是：&quot;</span>+color);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码是：&quot;</span>+size);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小花订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color,size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印颜色是：&quot;</span>+color);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印尺码是：&quot;</span>+size); </span><br><span class="line">&#125;);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;红色&quot;</span>,<span class="number">40</span>);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;黑色&quot;</span>,<span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://images0.cnblogs.com/blog2015/561794/201507/300026322675388.png"></p>
<p>　　打印如上截图，我们看到订阅者接收到发布者的每个消息，但是呢，对于小红来说，她只想接收颜色为红色的消息，不想接收颜色为黑色的消息，为此我们需要对代码进行如下改造下，我们可以先增加一个key，使订阅者只订阅自己感兴趣的消息。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;; <span class="comment">// 定义发布者</span></span><br><span class="line">shoeObj.list = []; <span class="comment">// 缓存列表 存放订阅者回调函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 增加订阅者</span></span><br><span class="line">shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">        <span class="comment">// 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span></span><br><span class="line">        <span class="built_in">this</span>.list[key] = []; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.list[key].push(fn);  <span class="comment">// 订阅消息添加到缓存列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line">shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); <span class="comment">// 取出消息类型名称</span></span><br><span class="line">    <span class="keyword">var</span> fns = <span class="built_in">this</span>.list[key];  <span class="comment">// 取出该消息对应的回调函数的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有订阅过该消息的话，则返回</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++]; ) &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>); <span class="comment">// arguments 是发布消息时附送的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小红订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;red&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码是：&quot;</span>+size);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小花订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;block&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印尺码是：&quot;</span>+size); </span><br><span class="line">&#125;);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;red&quot;</span>,<span class="number">40</span>);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;block&quot;</span>,<span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　上面的代码，我们再来运行打印下 如下：</p>
<p><img src="http://images0.cnblogs.com/blog2015/561794/201507/300027129237602.png"></p>
<p>　　可以看到，订阅者只订阅自己感兴趣的消息了；</p>
<p>　　<strong>3. 发布—订阅模式的代码封装</strong></p>
<p>　　我们知道，对于上面的代码，小红去买鞋这么一个对象shoeObj 进行订阅，但是如果以后我们需要对买房子或者其他的对象进行订阅呢，我们需要复制上面的代码，再重新改下里面的对象代码；为此我们需要进行代码封装；</p>
<p>　　如下代码封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    listen: <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.list[key]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.list[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 订阅的消息添加到缓存列表中</span></span><br><span class="line">        <span class="built_in">this</span>.list[key].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> fns = <span class="built_in">this</span>.list[key];</span><br><span class="line">        <span class="comment">// 如果没有订阅过该消息的话，则返回</span></span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　我们再定义一个initEvent函数，这个函数使所有的普通对象都具有发布订阅功能，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> initEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event) &#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 我们再来测试下，我们还是给shoeObj这个对象添加发布-订阅功能；</span></span><br><span class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;;</span><br><span class="line">initEvent(shoeObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小红订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;red&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码是：&quot;</span>+size);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小花订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;block&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印尺码是：&quot;</span>+size); </span><br><span class="line">&#125;);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;red&quot;</span>,<span class="number">40</span>);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;block&quot;</span>,<span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　<strong>4. 如何取消订阅事件？</strong></p>
<p>　　比如上面的列子，小红她突然不想买鞋子了，那么对于卖家的店铺他不想再接受该店铺的消息，那么小红可以取消该店铺的订阅。</p>
<p>　　如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">event.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="built_in">this</span>.list[key];</span><br><span class="line">    <span class="comment">// 如果key对应的消息没有订阅过的话，则返回</span></span><br><span class="line">    <span class="keyword">if</span>(!fns) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅</span></span><br><span class="line">    <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">        fn &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">var</span> _fn = fns[i];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn) &#123;</span><br><span class="line">                fns.splice(i,<span class="number">1</span>); <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试代码如下：</span></span><br><span class="line"><span class="keyword">var</span> initEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event) &#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;;</span><br><span class="line">initEvent(shoeObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小红订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;red&#x27;</span>,fn1 = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码是：&quot;</span>+size);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小花订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="string">&#x27;red&#x27;</span>,fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印尺码是：&quot;</span>+size); </span><br><span class="line">&#125;);</span><br><span class="line">shoeObj.remove(<span class="string">&quot;red&quot;</span>,fn1);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;red&quot;</span>,<span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　运行结果如下：</p>
<p><img src="http://images0.cnblogs.com/blog2015/561794/201507/300029313607541.png"></p>
<p>　　<strong>5. 全局–发布订阅对象代码封装</strong></p>
<p>　　我们再来看看我们传统的ajax请求吧，比如我们传统的ajax请求，请求成功后需要做如下事情：</p>
<p>　　1. 渲染数据。</p>
<p>　　2. 使用数据来做一个动画。</p>
<p>　　那么我们以前肯定是如下写代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(“http:<span class="comment">//127.0.0.1/index.php”,function(data)&#123;</span></span><br><span class="line">    rendedData(data);  <span class="comment">// 渲染数据</span></span><br><span class="line">    doAnimate(data);  <span class="comment">// 实现动画 </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　假如以后还需要做点事情的话，我们还需要在里面写调用的方法；这样代码就耦合性很高，那么我们现在使用发布-订阅模式来看如何重构上面的业务需求代码；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(“http:<span class="comment">//127.0.0.1/index.php”,function(data)&#123;</span></span><br><span class="line">    Obj.trigger(‘success’,data);  <span class="comment">// 发布请求成功后的消息</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 下面我们来订阅此消息，比如我现在订阅渲染数据这个消息；</span></span><br><span class="line">Obj.listen(“success”,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   renderData(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 订阅动画这个消息</span></span><br><span class="line">Obj.listen(“success”,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   doAnimate(data); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　为此我们可以封装一个全局发布-订阅模式对象；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = &#123;&#125;,</span><br><span class="line">          listen,</span><br><span class="line">          trigger,</span><br><span class="line">          remove;</span><br><span class="line">          listen = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list[key]) &#123;</span><br><span class="line">                list[key] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            list[key].push(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">        trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>),</span><br><span class="line">                 fns = list[key];</span><br><span class="line">            <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[i++];) &#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        remove = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> fns = list[key];</span><br><span class="line">            <span class="keyword">if</span>(!fns) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!fn) &#123;</span><br><span class="line">                fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = fns.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                    <span class="keyword">var</span> _fn = fns[i];</span><br><span class="line">                    <span class="keyword">if</span>(_fn === fn) &#123;</span><br><span class="line">                        fns.splice(i,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            listen: listen,</span><br><span class="line">            trigger: trigger,</span><br><span class="line">            remove: remove</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 测试代码如下：</span></span><br><span class="line">Event.listen(<span class="string">&quot;color&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码为:&quot;</span>+size); <span class="comment">// 打印出尺码为42</span></span><br><span class="line">&#125;);</span><br><span class="line">Event.trigger(<span class="string">&quot;color&quot;</span>,<span class="number">42</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　<strong>6. 理解模块间通信</strong></p>
<p>　　我们使用上面封装的全局的发布-订阅对象来实现两个模块之间的通信问题；比如现在有一个页面有一个按钮，每次点击此按钮后，div中会显示此按钮被点击的总次数；如下代码：</p>
<p>　　<code>&lt;button id=&quot;count&quot;&gt;点将我&lt;/button&gt;</code></p>
<p>　　<code>&lt;div id=&quot;showcount&quot;&gt;&lt;/div&gt;</code></p>
<p>　　我们中的a.js 负责处理点击操作 及发布消息；如下JS代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Event.trigger(<span class="string">&quot;add&quot;</span>,count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　b.js 负责监听add这个消息，并把点击的总次数显示到页面上来；如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;showcount&quot;</span>);</span><br><span class="line">    Event.listen(<span class="string">&#x27;add&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">count</span>)</span>&#123;</span><br><span class="line">        div.innerHTML = count;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　下面是html代码如下，JS应用如下引用即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;global.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;count&quot;</span>&gt;点将我&lt;/button&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;showcount&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src = <span class="string">&quot;a.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src = <span class="string">&quot;b.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上代码，当点击一次按钮后，showcount的div会自动加1，如上演示的是2个模块之间如何使用发布-订阅模式之间的通信问题；</p>
<p>　　其中global.js 就是我们上面封装的全局-发布订阅模式对象的封装代码；</p>
<h1 id="十、理解中介者模式"><a href="#十、理解中介者模式" class="headerlink" title="十、理解中介者模式"></a>十、理解中介者模式</h1><p>　　先来理解这么一个问题，假如我们前端开发接的需求是需求方给我们需求，可能一个前端开发会和多个需求方打交道，所以会保持多个需求方的联系，那么在程序里面就意味着保持多个对象的引用，当程序的规模越大，对象会越来越多，他们之间的关系会越来越复杂，那现在假如现在有一个中介者(假如就是我们的主管)来对接多个需求方的需求，那么需求方只需要把所有的需求给我们主管就可以，主管会依次看我们的工作量来给我们分配任务，这样的话，我们前端开发就不需要和多个业务方联系，我们只需要和我们主管(也就是中介)联系即可，这样的好处就弱化了对象之间的耦合。</p>
<p>　　<strong>日常生活中的列子：</strong></p>
<p>　　中介者模式对于我们日常生活中经常会碰到，比如我们去房屋中介去租房，房屋中介人在租房者和房东出租者之间形成一条中介;租房者并不关心租谁的房，房东出租者也并不关心它租给谁，因为有中介，所以需要中介来完成这场交易。</p>
<p>　　中介者模式的作用是解除对象与对象之间的耦合关系，增加一个中介对象后，所有的相关对象都通过中介者对象来通信，而不是相互引用，所以当一个对象发送改变时，只需要通知中介者对象即可。中介者使各个对象之间耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>　　<strong>实现中介者的列子如下：</strong></p>
<p>　　不知道大家有没有玩过英雄杀这个游戏，最早的时候，英雄杀有2个人(分别是敌人和自己)；我们针对这个游戏先使用普通的函数来实现如下：</p>
<p>　　比如先定义一个函数，该函数有三个方法，分别是win(赢), lose(输)，和die(敌人死亡)这三个函数；只要一个玩家死亡该游戏就结束了，同时需要通知它的对手胜利了; 代码需要编写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.enemy = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;Won&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;lose&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.lose();</span><br><span class="line">    <span class="built_in">this</span>.enemy.win();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化2个对象</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero(<span class="string">&quot;朱元璋&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> h2 = <span class="keyword">new</span> Hero(<span class="string">&quot;刘伯温&quot;</span>);</span><br><span class="line"><span class="comment">// 给玩家设置敌人</span></span><br><span class="line">h1.enemy = h2;</span><br><span class="line">h2.enemy = h1;</span><br><span class="line"><span class="comment">// 朱元璋死了 也就输了</span></span><br><span class="line">h1.die();  <span class="comment">// 输出 朱元璋lose 刘伯温Won</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　<strong>现在我们再来为游戏添加队友</strong></p>
<p>　　比如现在我们来为游戏添加队友，比如英雄杀有6人一组，那么这种情况下就有队友，敌人也有3个；因此我们需要区分是敌人还是队友需要队的颜色这个字段，如果队的颜色相同的话，那么就是同一个队的，否则的话就是敌人；</p>
<p>　　我们可以先定义一个数组players来保存所有的玩家，在创建玩家之后，循环players来给每个玩家设置队友或者敌人;</p>
<p>　　<code>var players = [];</code></p>
<p>　　接着我们再来编写Hero这个函数；代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> players = []; <span class="comment">// 定义一个数组 保存所有的玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params">name,teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.friends = [];    <span class="comment">//保存队友列表</span></span><br><span class="line">    <span class="built_in">this</span>.enemies = [];    <span class="comment">// 保存敌人列表</span></span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;live&#x27;</span>;  <span class="comment">// 玩家状态</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;     <span class="comment">// 角色名字</span></span><br><span class="line">    <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍的颜色</span></span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 赢了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;win:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">Hero.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 输了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;lose:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">Hero.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 所有队友死亡情况 默认都是活着的</span></span><br><span class="line">    <span class="keyword">var</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;dead&#x27;</span>; <span class="comment">// 设置玩家状态为死亡</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = <span class="built_in">this</span>.friends.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历，如果还有一个队友没有死亡的话，则游戏还未结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.friends[i].state !== <span class="string">&#x27;dead&#x27;</span>) &#123;</span><br><span class="line">            all_dead = <span class="literal">false</span>; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(all_dead) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lose();  <span class="comment">// 队友全部死亡，游戏结束</span></span><br><span class="line">        <span class="comment">// 循环 通知所有的玩家 游戏失败</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>,jlen = <span class="built_in">this</span>.friends.length; j &lt; jlen; j+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.friends[j].lose();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知所有敌人游戏胜利</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>,jlen = <span class="built_in">this</span>.enemies.length; j &lt; jlen; j+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.enemies[j].win();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个工厂类来创建玩家 </span></span><br><span class="line"><span class="keyword">var</span> heroFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name,teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPlayer = <span class="keyword">new</span> Hero(name,teamColor);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,ilen = players.length; i &lt; ilen; i+=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是同一队的玩家</span></span><br><span class="line">        <span class="keyword">if</span>(players[i].teamColor === newPlayer.teamColor) &#123;</span><br><span class="line">            <span class="comment">// 相互添加队友列表</span></span><br><span class="line">            players[i].friends.push(newPlayer);</span><br><span class="line">            newPlayer.friends.push(players[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相互添加到敌人列表</span></span><br><span class="line">            players[i].enemies.push(newPlayer);</span><br><span class="line">            newPlayer.enemies.push(players[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    players.push(newPlayer);</span><br><span class="line">    <span class="keyword">return</span> newPlayer;</span><br><span class="line">&#125;;</span><br><span class="line">        <span class="comment">// 红队</span></span><br><span class="line"><span class="keyword">var</span> p1 = heroFactory(<span class="string">&quot;aa&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    p2 = heroFactory(<span class="string">&quot;bb&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    p3 = heroFactory(<span class="string">&quot;cc&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    p4 = heroFactory(<span class="string">&quot;dd&quot;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 蓝队</span></span><br><span class="line"><span class="keyword">var</span> p5 = heroFactory(<span class="string">&quot;ee&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">    p6 = heroFactory(<span class="string">&quot;ff&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">    p7 = heroFactory(<span class="string">&quot;gg&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">    p8 = heroFactory(<span class="string">&quot;hh&quot;</span>,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="comment">// 让红队玩家全部死亡</span></span><br><span class="line">p1.die();</span><br><span class="line">p2.die();</span><br><span class="line">p3.die();</span><br><span class="line">p4.die();</span><br><span class="line"><span class="comment">// lose:dd lose:aa lose:bb lose:cc</span></span><br><span class="line"><span class="comment">// win:ee win:ff win:gg win:hh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　如上代码：Hero函数有2个参数，分别是name(玩家名字)和teamColor(队颜色)，</p>
<p>　　首先我们可以根据队颜色来判断是队友还是敌人；同样也有三个方法win(赢)，lose(输)，和die(死亡)；如果每次死亡一个人的时候，循环下该死亡的队友有没有全部死亡，如果全部死亡了的话，就输了，因此需要循环他们的队友，分别告诉每个队友中的成员他们输了，同时需要循环他们的敌人，分别告诉他们的敌人他们赢了；因此每次死了一个人的时候，都需要循环一次判断他的队友是否都死亡了；因此每个玩家和其他的玩家都是紧紧耦合在一起了。</p>
<p>　　下面我们可以使用中介者模式来改善上面的demo；</p>
<p>　　首先我们仍然定义Hero构造函数和Hero对象原型的方法，在Hero对象的这些原型方法中，不再负责具体的执行的逻辑，而是把操作转交给中介者对象，中介者对象来负责做具体的事情，我们可以把中介者对象命名为playerDirector;</p>
<p>　　在playerDirector开放一个对外暴露的接口ReceiveMessage，负责接收player对象发送的消息，而player对象发送消息的时候，总是把自身的this作为参数发送给playerDirector，以便playerDirector 识别消息来自于那个玩家对象。</p>
<p>　　代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> players = []; <span class="comment">// 定义一个数组 保存所有的玩家</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params">name,teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;live&#x27;</span>;  <span class="comment">// 玩家状态</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;     <span class="comment">// 角色名字</span></span><br><span class="line">    <span class="built_in">this</span>.teamColor = teamColor; <span class="comment">// 队伍的颜色</span></span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 赢了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;win:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">Hero.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 输了</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;lose:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 死亡</span></span><br><span class="line">Hero.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;dead&#x27;</span>;</span><br><span class="line">    <span class="comment">// 给中介者发送消息，玩家死亡</span></span><br><span class="line">    playerDirector.ReceiveMessage(<span class="string">&#x27;playerDead&#x27;</span>,<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除玩家</span></span><br><span class="line">Hero.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 给中介者发送一个消息，移除一个玩家</span></span><br><span class="line">    playerDirector.ReceiveMessage(<span class="string">&#x27;removePlayer&#x27;</span>,<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 玩家换队</span></span><br><span class="line">Hero.prototype.changeTeam = <span class="function"><span class="keyword">function</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 给中介者发送一个消息，玩家换队</span></span><br><span class="line">    playerDirector.ReceiveMessage(<span class="string">&#x27;changeTeam&#x27;</span>,<span class="built_in">this</span>,color);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个工厂类来创建玩家 </span></span><br><span class="line"><span class="keyword">var</span> heroFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name,teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的玩家对象</span></span><br><span class="line">    <span class="keyword">var</span> newHero = <span class="keyword">new</span> Hero(name,teamColor);</span><br><span class="line">    <span class="comment">// 给中介者发送消息，新增玩家</span></span><br><span class="line">    playerDirector.ReceiveMessage(<span class="string">&#x27;addPlayer&#x27;</span>,newHero);</span><br><span class="line">    <span class="keyword">return</span> newHero;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> playerDirector = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> players = &#123;&#125;,  <span class="comment">// 保存所有的玩家</span></span><br><span class="line">        operations = &#123;&#125;; <span class="comment">// 中介者可以执行的操作</span></span><br><span class="line">    <span class="comment">// 新增一个玩家操作</span></span><br><span class="line">    operations.addPlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取玩家队友的颜色</span></span><br><span class="line">        <span class="keyword">var</span> teamColor = player.teamColor;</span><br><span class="line">        <span class="comment">// 如果该颜色的玩家还没有队伍的话，则新成立一个队伍</span></span><br><span class="line">        players[teamColor] = players[teamColor] || [];</span><br><span class="line">        <span class="comment">// 添加玩家进队伍</span></span><br><span class="line">        players[teamColor].push(player);</span><br><span class="line">     &#125;;</span><br><span class="line">    <span class="comment">// 移除一个玩家</span></span><br><span class="line">    operations.removePlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取队伍的颜色</span></span><br><span class="line">        <span class="keyword">var</span> teamColor = player.teamColor,</span><br><span class="line">        <span class="comment">// 获取该队伍的所有成员</span></span><br><span class="line">        teamPlayers = players[teamColor] || [];</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = teamPlayers.length - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(teamPlayers[i] === player) &#123;</span><br><span class="line">                teamPlayers.splice(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 玩家换队</span></span><br><span class="line">    operations.changeTeam = <span class="function"><span class="keyword">function</span>(<span class="params">player,newTeamColor</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 首先从原队伍中删除</span></span><br><span class="line">        operations.removePlayer(player);</span><br><span class="line">        <span class="comment">// 然后改变队伍的颜色</span></span><br><span class="line">        player.teamColor = newTeamColor;</span><br><span class="line">        <span class="comment">// 增加到队伍中</span></span><br><span class="line">        operations.addPlayer(player);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 玩家死亡</span></span><br><span class="line">operations.playerDead = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> teamColor = player.teamColor,</span><br><span class="line">    <span class="comment">// 玩家所在的队伍</span></span><br><span class="line">    teamPlayers = players[teamColor];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//遍历 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,player; player = teamPlayers[i++]; ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(player.state !== <span class="string">&#x27;dead&#x27;</span>) &#123;</span><br><span class="line">            all_dead = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果all_dead 为true的话 说明全部死亡</span></span><br><span class="line">    <span class="keyword">if</span>(all_dead) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[i++]; ) &#123;</span><br><span class="line">            <span class="comment">// 本队所有玩家lose</span></span><br><span class="line">            player.lose();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> color <span class="keyword">in</span> players) &#123;</span><br><span class="line">            <span class="keyword">if</span>(color !== teamColor) &#123;</span><br><span class="line">                <span class="comment">// 说明这是另外一组队伍</span></span><br><span class="line">                <span class="comment">// 获取该队伍的玩家</span></span><br><span class="line">                <span class="keyword">var</span> teamPlayers = players[color];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,player; player = teamPlayers[i++]; ) &#123;</span><br><span class="line">                    player.win(); <span class="comment">// 遍历通知其他玩家win了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ReceiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arguments的第一个参数为消息名称 获取第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    operations[message].apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    ReceiveMessage : ReceiveMessage</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 红队</span></span><br><span class="line"><span class="keyword">var</span> p1 = heroFactory(<span class="string">&quot;aa&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    p2 = heroFactory(<span class="string">&quot;bb&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">    p3 = heroFactory(<span class="string">&quot;cc&quot;</span>,<span class="string">&#x27;red&#x27;</span>),</span><br><span class="line">        p4 = heroFactory(<span class="string">&quot;dd&quot;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 蓝队</span></span><br><span class="line">    <span class="keyword">var</span> p5 = heroFactory(<span class="string">&quot;ee&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">        p6 = heroFactory(<span class="string">&quot;ff&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">        p7 = heroFactory(<span class="string">&quot;gg&quot;</span>,<span class="string">&#x27;blue&#x27;</span>),</span><br><span class="line">        p8 = heroFactory(<span class="string">&quot;hh&quot;</span>,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    <span class="comment">// 让红队玩家全部死亡</span></span><br><span class="line">    p1.die();</span><br><span class="line">    p2.die();</span><br><span class="line">    p3.die();</span><br><span class="line">    p4.die();</span><br><span class="line">    <span class="comment">// lose:aa lose:bb lose:cc lose:dd </span></span><br><span class="line">   <span class="comment">// win:ee win:ff win:gg win:hh</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　我们可以看到如上代码；玩家与玩家之间的耦合代码已经解除了，而把所有的逻辑操作放在中介者对象里面进去处理，某个玩家的任何操作不需要去遍历去通知其他玩家，而只是需要给中介者发送一个消息即可，中介者接受到该消息后进行处理，处理完消息之后会把处理结果反馈给其他的玩家对象。使用中介者模式解除了对象与对象之间的耦合代码; 使程序更加的灵活.</p>
<p>　　<strong>中介者模式实现购买商品的列子</strong></p>
<p>　　下面的列子是书上的列子，比如在淘宝或者天猫的列子不是这样实现的，也没有关系，我们可以改动下即可，我们最主要来学习下使用中介者模式来实现的思路。</p>
<p>　　首先先介绍一下业务：在购买流程中，可以选择手机的颜色以及输入购买的数量，同时页面中有2个展示区域，分别显示用户刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量小于这次的购买数量，按钮则被禁用并且显示库存不足的文案，反之按钮高亮且可以点击并且显示假如购物车。</p>
<p>　　HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">选择颜色:</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;colorSelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入购买的数量: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    你选择了的颜色：<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;colorInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你输入的数量: <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;nextBtn&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span>请选择手机颜色和购买数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　首先页面上有一个select选择框，然后有输入的购买数量输入框，还有2个展示区域，分别是选择的颜色和输入的数量的显示的区域，还有下一步的按钮操作；</p>
<p>　　我们先定义一下：</p>
<p>　　假设我们提前从后台获取到所有颜色手机的库存量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="comment">// 手机库存</span></span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　接着 我们下面分别来监听colorSelect的下拉框的onchange事件和numberInput输入框的oninput的事件，然后在这两个事件中作出相应的处理</p>
<p>　　常规的JS代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 假设我们提前从后台获取到所有颜色手机的库存量</span></span><br><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="comment">// 手机库存</span></span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们下面分别来监听colorSelect的下拉框的onchange事件和numberInput输入框的oninput的事件，</span></span><br><span class="line"><span class="comment">然后在这两个事件中作出相应的处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">&quot;colorSelect&quot;</span>),</span><br><span class="line">    numberInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;numberInput&quot;</span>),</span><br><span class="line">    colorInfo = <span class="built_in">document</span>.getElementById(<span class="string">&quot;colorInfo&quot;</span>),</span><br><span class="line">    numberInfo = <span class="built_in">document</span>.getElementById(<span class="string">&quot;numberInfo&quot;</span>),</span><br><span class="line">    nextBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;nextBtn&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 监听change事件</span></span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    select();</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    select();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.value,   <span class="comment">// 颜色</span></span><br><span class="line">        number = numberInput.value,  <span class="comment">// 数量</span></span><br><span class="line">        stock = goods[color];  <span class="comment">// 该颜色手机对应的当前库存</span></span><br><span class="line">            </span><br><span class="line">    colorInfo.innerHTML = color;</span><br><span class="line">    numberInfo.innerHTML = number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户没有选择颜色的话，禁用按钮</span></span><br><span class="line">    <span class="keyword">if</span>(!color) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">&quot;请选择手机颜色&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断用户输入的购买数量是否是正整数</span></span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/^\d+$/g</span>;</span><br><span class="line">    <span class="keyword">if</span>(!reg.test(number)) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">&quot;请输入正确的购买数量&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前选择的数量大于当前的库存的数量的话，显示库存不足</span></span><br><span class="line">    <span class="keyword">if</span>(number &gt; stock) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">&quot;库存不足&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">&quot;放入购物车&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　上面的代码虽然是完成了页面上的需求，但是我们的代码都耦合在一起了，目前虽然问题不是很多，假如随着以后需求的改变，SKU属性越来越多的话，比如页面增加一个或者多个下拉框的时候，代表选择手机内存，现在我们需要计算颜色，内存和购买数量，来判断nextBtn是显示库存不足还是放入购物车；代码如下：</p>
<p>　　HTML代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">选择颜色:</span><br><span class="line">    &lt;select id=<span class="string">&quot;colorSelect&quot;</span>&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;&quot;</span>&gt;请选择&lt;/option&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;red&quot;</span>&gt;红色&lt;/option&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;blue&quot;</span>&gt;蓝色&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    选择内存：</span><br><span class="line">    &lt;select id=<span class="string">&quot;memorySelect&quot;</span>&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;&quot;</span>&gt;请选择&lt;/option&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;32G&quot;</span>&gt;32G&lt;/option&gt;</span><br><span class="line">        &lt;option value=<span class="string">&quot;64G&quot;</span>&gt;64G&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;p&gt;输入购买的数量: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span>/&gt;</span></span>&lt;/p&gt;</span><br><span class="line">    你选择了的颜色：&lt;div id=<span class="string">&quot;colorInfo&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    你选择了内存：&lt;div id=<span class="string">&quot;memoryInfo&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;你输入的数量: <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &lt;/p&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;nextBtn&quot;</span> disabled=<span class="string">&quot;true&quot;</span>&gt;请选择手机颜色和购买数量&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　JS代码变为如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 假设我们提前从后台获取到所有颜色手机的库存量</span></span><br><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="comment">// 手机库存</span></span><br><span class="line">    <span class="string">&quot;red|32G&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;red|64G&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;blue|32G&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&quot;blue|64G&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们下面分别来监听colorSelect的下拉框的onchange事件和numberInput输入框的oninput的事件，</span></span><br><span class="line"><span class="comment">然后在这两个事件中作出相应的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">&quot;colorSelect&quot;</span>),</span><br><span class="line">    memorySelect = <span class="built_in">document</span>.getElementById(<span class="string">&quot;memorySelect&quot;</span>),</span><br><span class="line">    numberInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;numberInput&quot;</span>),</span><br><span class="line">    colorInfo = <span class="built_in">document</span>.getElementById(<span class="string">&quot;colorInfo&quot;</span>),</span><br><span class="line">    numberInfo = <span class="built_in">document</span>.getElementById(<span class="string">&quot;numberInfo&quot;</span>),</span><br><span class="line">    memoryInfo = <span class="built_in">document</span>.getElementById(<span class="string">&quot;memoryInfo&quot;</span>),</span><br><span class="line">    nextBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;nextBtn&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 监听change事件</span></span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    select();</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    select();</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    select();    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.value,   <span class="comment">// 颜色</span></span><br><span class="line">        number = numberInput.value,  <span class="comment">// 数量</span></span><br><span class="line">        memory = memorySelect.value, <span class="comment">// 内存</span></span><br><span class="line">        stock = goods[color + <span class="string">&#x27;|&#x27;</span> +memory];  <span class="comment">// 该颜色手机对应的当前库存</span></span><br><span class="line">            </span><br><span class="line">    colorInfo.innerHTML = color;</span><br><span class="line">    numberInfo.innerHTML = number;</span><br><span class="line">    memoryInfo.innerHTML = memory;</span><br><span class="line">    <span class="comment">// 如果用户没有选择颜色的话，禁用按钮</span></span><br><span class="line">    <span class="keyword">if</span>(!color) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">&quot;请选择手机颜色&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断用户输入的购买数量是否是正整数</span></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/^\d+$/g</span>;</span><br><span class="line">        <span class="keyword">if</span>(!reg.test(number)) &#123;</span><br><span class="line">            nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">            nextBtn.innerHTML = <span class="string">&quot;请输入正确的购买数量&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前选择的数量大于当前的库存的数量的话，显示库存不足</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; stock) &#123;</span><br><span class="line">            nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">            nextBtn.innerHTML = <span class="string">&quot;库存不足&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">&quot;放入购物车&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　一般的代码就是这样的，感觉使用中介者模式代码也类似，这里就不多介绍了，书上的代码说有优点，但是个人感觉没有什么很大的区别，因此这里就不再使用中介者模式来编写代码了。</p>
]]></content>
      <tags>
        <tag>JS javascript 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>React从入门到精通系列</title>
    <url>/2018/04/27/React%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="安装React"><a href="#安装React" class="headerlink" title="安装React"></a>安装React</h1><p>React是灵活的，可以在各种类型的项目中使用。<br>你可以使用它创建一个全新的应用程序，也可以逐步将其引入现有的项目中，而不需要重写整个项目。</p>
<a id="more"></a>

<h2 id="创建一个单页面应用"><a href="#创建一个单页面应用" class="headerlink" title="创建一个单页面应用"></a>创建一个单页面应用</h2><p><code>Create React App</code>是开始构建新的React单页应用程序的最佳方式。<br>它可以帮助您快速集成您的开发环境，以便您可以使用最新的JavaScript功能，它提供了一个很好的开发体验，并可以有效优化您的应用程序,提升开发效率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br><span class="line">$ create-react-app hello-world</span><br><span class="line">$ cd hello-world</span><br><span class="line">$ npm run start</span><br></pre></td></tr></table></figure>
<p>上面只是创建了一个React应用，不需要关心也需要不处理后端逻辑或数据库;<br>它只是一个React的前端环境集成工具,负责创建前端的开发环境，所以你可以使用它与你想要的任何后端进行交互。 它内部使用了webpack，Babel和ESLint，你可以单独配置它们，来达到定制化的效果。</p>
<h2 id="在已经开发的项目中使用React"><a href="#在已经开发的项目中使用React" class="headerlink" title="在已经开发的项目中使用React"></a>在已经开发的项目中使用React</h2><p>您不需要重新编写应用程序即可开始使用React。</p>
<p>我们建议将React添加到应用程序的一小部分，例如单个小部件，以便您可以看到它是否适合您的用例。</p>
<p>虽然React可以在没有构建工具的情况下使用，但我们建议使用并设置它，以便提高生产力。 现代构建工具通常包括：</p>
<ul>
<li><p>一个包管理器，例如<code>npm</code></p>
</li>
<li><p>一个打包工具，例如<code>webpack</code></p>
</li>
<li><p>一个编译工具，例如<code>Babel</code></p>
</li>
</ul>
<h2 id="安装React-1"><a href="#安装React-1" class="headerlink" title="安装React"></a>安装React</h2><p>我们建议使用Yarn或npm来管理React前端模块的依赖。</p>
<p>通过Yarn安装：</p>
<p><code>yarn add react react-dom</code></p>
<p>通过npm安装：</p>
<p><code>npm install --save react react-dom</code></p>
<h2 id="使用ES6和JSX"><a href="#使用ES6和JSX" class="headerlink" title="使用ES6和JSX"></a>使用ES6和JSX</h2><p>我们建议您使用Babel中的React配置让您在JavaScript代码中可以使用ES6和JSX。 ES6是一组现代JavaScript特性，使开发更容易，JSX是对React非常有效的JavaScript语言的扩展。</p>
<p>具体请百度Babel如何在许多不同的构建环境中配置Babel。首先确保你安装了<code>babel-preset-react</code>和<code>babel-preset-es2015</code>，并已经在<code>.babelrc</code>配置中启用它们。</p>
<h2 id="使用ES6和JSX写一个HelloWorld的例子"><a href="#使用ES6和JSX写一个HelloWorld的例子" class="headerlink" title="使用ES6和JSX写一个HelloWorld的例子"></a>使用ES6和JSX写一个HelloWorld的例子</h2><p>我们建议使用像<code>webpack</code>或<code>Browserify</code>这样的打包工具，以便您可以编写模块化代码，它们可以将不同的代码模块打包捆绑到一起，用来优化的代码加载时间。</p>
<p>一个简单的React示例如下所示：</p>
<p>这里我使用的是bower来安装react和react-dom。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir hello-world &amp; cd hello-world</span><br><span class="line">bower install react babel --save</span><br><span class="line">touch index.html</span><br></pre></td></tr></table></figure>
<p>然后在index.html中写入以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bower_components/react/react.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bower_components/react/react-dom.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bower_components/babel/browser.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> doc = <span class="built_in">document</span>;</span></span><br><span class="line">        ReactDOM.render(</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，react<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span></span><br><span class="line"><span class="javascript">                doc.getElementById(<span class="string">&#x27;app&#x27;</span>)</span></span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ReactDOM.render<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="JSX的介绍"><a href="#JSX的介绍" class="headerlink" title="JSX的介绍"></a>JSX的介绍</h1><p>首先，请考虑下面的变量声明：</p>
<p><code>const element = &lt;h1&gt;hello world&lt;/h1&gt;;</code></p>
<p>这个有趣的标签语法，因为它既不是<code>字符串</code>也不<code>是HTML</code>。</p>
<p>它被称为JSX，它是JavaScript的语法扩展。我们建议使用它和React一起使用，以便描述UI应该是什么样子的。JSX或许看上去像是一个模板语言，但是它具有JavaScript的全部能力。</p>
<p>JSX用来生成React元素。我们将在下一节中探讨将它们渲染到DOM。下面，你可以找到JSX的基础知识。</p>
<h2 id="JSX中的嵌入表达式"><a href="#JSX中的嵌入表达式" class="headerlink" title="JSX中的嵌入表达式"></a>JSX中的嵌入表达式</h2><p>你可以通过将表达式包含在一个大括号里，以便用来在JSX中嵌入任何JavaScript表达式。</p>
<p>例如，下面代码中的 <code>2+2</code>，<code>user.name</code>，还有<code>formatName(user)</code>都是可用的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.firstName + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;yatao&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;zhang&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Element = (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        hello, &#123;formatName(user)&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    Element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们将JSX拆分为多行以提高可读性。虽然它不是强制性的要求，但当执行此操作时，我们还建议将其括在括号中，以避免自动分号插入而引起不必要的bug。</p>
<h2 id="JSX也是一个表达式"><a href="#JSX也是一个表达式" class="headerlink" title="JSX也是一个表达式"></a>JSX也是一个表达式</h2><p>编译后，JSX表达式会成为常规JavaScript对象。</p>
<p>这意味着您可以在<code>if</code>语句和<code>for</code>循环中使用JSX，可以将其赋值给变量或者将其作为参数，然后从函数中返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用JSX指定属性"><a href="#使用JSX指定属性" class="headerlink" title="使用JSX指定属性"></a>使用JSX指定属性</h2><p>您可以使用引号将字符串文字指定为属性：</p>
<p><code>const element = &lt;div tabindex=&quot;0&quot;&gt;&lt;/div&gt;;</code></p>
<p>您还可以使用大括号在属性中嵌入JavaScript表达式：</p>
<p><code>const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</code></p>
<h2 id="使用JSX指定子元素"><a href="#使用JSX指定子元素" class="headerlink" title="使用JSX指定子元素"></a>使用JSX指定子元素</h2><p>如果标记为空，您可以使用<code> /&gt;</code> 立即关闭它，例如html：</p>
<p>JSX标签也可以包含子元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;Good to see you here.&lt;h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong><br/><br>由于JSX比HTML更接近JavaScript，ReactDOM使用驼峰命名法约定而不是HTML属性名称。<br>例如，<strong>class</strong>在JSX中变为<strong>className</strong>，<strong>tabindex</strong>变为<strong>tabIndex</strong>。</p>
</blockquote>
<h2 id="JSX防止注入攻击"><a href="#JSX防止注入攻击" class="headerlink" title="JSX防止注入攻击"></a>JSX防止注入攻击</h2><p>在JSX中嵌入用户输入是安全的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// 要接收到的可能含有危险内容的字符串放入大括号中，这是比较安全的做法</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下，ReactDOM在渲染它们之前<code>转义</code>嵌入在JSX中的任何值。 因此，它确保不能注入那些没有明确写在你的应用程序中的任何东西。 在渲染之前，一切都转换为字符串。 这有助于防止<code>XSS（跨站点脚本）</code>攻击。</p>
<h2 id="JSX表示对象"><a href="#JSX表示对象" class="headerlink" title="JSX表示对象"></a>JSX表示对象</h2><p>Babel将JSX编译为<code>React.createElement()</code>调用。</p>
<p>这两个例子是相同的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1 className=<span class="string">&quot;greeting&quot;</span>&gt;</span><br><span class="line">        hello world</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">    <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>React.createElement()</code>会进行一些检查，以帮助您编写无明显语法错误的代码，本质上，它创建的是一个像这样的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提示：这是一个简单对象结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">   type: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">   props: &#123;</span><br><span class="line">       className: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">       children: <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些对象称为“React元素”。你可以把它们想象成你想在屏幕上看到的样子。React读取这些对象，并使用它们构造成为DOM元素同时一直保持其为最新的。</p>
<h1 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h1><p>React元素是React应用程序的最小构建结构。</p>
<p>React元素描述了您想在屏幕上看到什么：</p>
<p><code>const element = &lt;h1&gt;hello world&lt;/h1&gt;;</code></p>
<p>与浏览器DOM元素不同，React元素是纯对象，创建起来很方便。ReactDOM负责匹配React元素并更新DOM。</p>
<blockquote>
<p><strong>note</strong><br/><br>人们可能将元素与更广为人知的“组件”概念混淆。我们将在下一节中介绍组件。元素是由什么组件组成的，我们建议您在向前跳过之前阅读此部分。</p>
</blockquote>
<h2 id="渲染元素到DOM中"><a href="#渲染元素到DOM中" class="headerlink" title="渲染元素到DOM中"></a>渲染元素到DOM中</h2><p>假设您的HTML文件中有一个<code>&lt;div&gt;</code>：</p>
<p><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></p>
<p>我们将其称为“root”DOM节点，接下来其中的所有内容将由React DOM来管理。</p>
<p>仅使用React构建的应用程序通常具有单个 root DOM节点。 如果你正在将React集成到现有的应用程序中，则可以创建尽可能多单独的 root DOM节点。</p>
<p>要将React元素渲染到 root DOM节点，可以将它们都传递给<code>ReactDOM.render()</code>方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="更新渲染元素"><a href="#更新渲染元素" class="headerlink" title="更新渲染元素"></a>更新渲染元素</h2><p>React元素是不可变的。 创建元素后，您不能更改其子元素或属性。 </p>
<p><strong>React元素就像电影中的单个帧：它表示某个时间点的UI。</strong></p>
<p>到目前为止，以我们的知识，更新UI的唯一方法是创建一个新的元素，并将其传递给<code>ReactDOM.render()</code>。</p>
<p>考虑这个滴答时钟示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;it is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        element,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>它每秒从<code>setInterval()</code>的回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p><strong>note</strong><br/><br>实际上，大多数React应用程序只调用ReactDOM.render()一次。在接下来的章节中，我们将学习如何将这样的代码封装成有状态的组件。</p>
</blockquote>
<h2 id="按需更新"><a href="#按需更新" class="headerlink" title="按需更新"></a>按需更新</h2><p>React DOM将元素及其子元素的内容与该元素变化之前的内容进行比较，并仅进行DOM更新以使DOM达到所需的状态。您可以通过使用浏览器工具检查最后一个示例来验证。</p>
<p>即使我们在每个tick上创建一个描述整个UI树的元素，只有内容发生改变的文本节点才被React DOM更新。</p>
<p>在我们的经验中，思考UI应该如何更新给定的时间，而不是随着时间的更改去修改整体的内容(DOM比较，按需更新)。</p>
<h1 id="组件化和属性-props"><a href="#组件化和属性-props" class="headerlink" title="组件化和属性(props)"></a>组件化和属性(props)</h1><p>组件允许您将UI拆分为独立的可重用的部分，并单独地考虑每个部分。从概念上讲，组件就像JavaScript函数。 它们接受任意输入（称为“props”），并返回应该出现在屏幕上的React元素。</p>
<h2 id="功能性组件-functional-和类组件-class-component"><a href="#功能性组件-functional-和类组件-class-component" class="headerlink" title="功能性组件(functional)和类组件(class component)"></a>功能性组件(functional)和类组件(class component)</h2><p>定义组件的最简单的方法是编写JavaScript函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数是个有效的React组件，因为它接收一个带有数据的“props”对象作为参数，并返回一个React元素。 我们把这样的组件称为“功能性组件(functional)”，因为它们是个JavaScript函数。</p>
<p>您还可以使用ES6类来定义组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个组件从React的角度来看是等效的。</p>
<p>类组件有一些额外的功能，我们将在下面的章节中讨论。 在那之前，我们将简单地使用功能组件。</p>
<h2 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h2><p>以前，我们只遇到使用DOM标签的React元素：</p>
<p><code>const element = &lt;div /&gt;;</code></p>
<p>但是，元素也可以表示用户自定义的组件：</p>
<p><code>const element = &lt;Welcome name=&quot;keith&quot; /&gt;;</code></p>
<p>当React看到表示用户定义组件的元素时，它将该JSX标签的所以属性放到一个对象中传递给组件。 我们称这个对象为“props”。</p>
<p>例如，此代码在页面上呈现“Hello，keith”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;keith&quot;</span> /&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>让我们回顾一下在这个例子中发生了什么：</p>
<ol>
<li><p>首先调用<code>ReactDOM.render()</code>方法，并处理<code>&lt;Welcome name =“keith”/&gt;</code>组件。</p>
</li>
<li><p>React使用<code>&#123;name：&#39;keith&#39;&#125;</code>作为props调用Welcome组件。</p>
</li>
<li><p>我们的Welcome组件返回一个<code>&lt;h1&gt; Hello，keith &lt;/ h1&gt;</code>元素作为结果。</p>
</li>
<li><p>React DOM有效地根据<code>&lt;h1&gt; Hello，keith &lt;/ h1&gt;</code>来更新DOM。</p>
</li>
</ol>
<blockquote>
<p><strong>警告</strong><br/><br>组件名称始终使用·首字母大写。例如，<code>&lt;div/&gt;</code>表示一个DOM标签，但<code>&lt;Welcome/&gt;</code>表示一个组件，并要求Welcome必须和ReactDOM在一个作用域内。</p>
</blockquote>
<h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>组件可以在其返回值中引用去其他组件。 这允许我们对任何级别的细节使用相同的组件抽象。 一个按钮，一个表单，一个对话框，一个屏幕：在React应用程序中，所有这些通常表示为组件。</p>
<p>例如，我们可以创建一个App组件，让它渲染多个<code>Welcome</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;Welcome name=<span class="string">&quot;keith&quot;</span> /&gt;</span><br><span class="line">           &lt;Welcome name=<span class="string">&quot;zhengwenbin&quot;</span> /&gt;</span><br><span class="line">           &lt;Welcome name=<span class="string">&quot;lisa&quot;</span> /&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;App /&gt;,</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个新的React应用程序在顶部有一个单独的App组件。 </p>
<p>但是，如果您将React集成到现有应用程序中，则可以使用Button这样的小组件自下而上开始逐步向上到达视图层次结构的顶部。</p>
<blockquote>
<p><strong>警告</strong><br/><br>引用多个组件时必须包裹在一个根元素中返回。这就是为什么我们添加了一个<code>&lt;div&gt;</code>来包含所有<code>&lt;Welcome /&gt;</code>元素。</p>
</blockquote>
<h2 id="抽离组件"><a href="#抽离组件" class="headerlink" title="抽离组件"></a>抽离组件</h2><p>永远不要害怕将组件拆分成更小的组件。</p>
<p>例如，考虑这个<code>Comment</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date.toISOString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;Comment&quot;</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;UserInfo&quot;</span>&gt;</span><br><span class="line">                &lt;img className=<span class="string">&quot;avatar&quot;</span></span><br><span class="line">                     src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">                     alt=&#123;props.author.name&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;UserInfo-name&quot;</span>&gt;</span><br><span class="line">                    &#123;props.author.name&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-text&quot;</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-date&quot;</span>&gt;</span><br><span class="line">                &#123;formatDate(props.date)&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Comment author=&#123;&#123;</span><br><span class="line">        avatarUrl: <span class="string">&#x27;https://ss0.bdstatic.com/7Ls0a8Sm1A5BphGlnYG/sys/portrait/item/3ae1dc06.jpg&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;zhangyatao&#x27;</span></span><br><span class="line">    &#125;&#125; text=&#123;<span class="string">&#x27;我的名字叫郑文斌&#x27;</span>&#125; date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>它接受<code>author</code>（作者），<code>text</code>（内容）和<code>date</code>（日期）作为<code>props</code>，用来描述社交媒体网站上的评论。</p>
<p>这个组件可能很难改变，因为所有的嵌套，它也很难重用其中的单个部分。让我们从中提取几个组件。</p>
<p>首先，我们将提取<code>avatar</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;img className=<span class="string">&quot;Avatar&quot;</span></span><br><span class="line">            src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">            alt=&#123;props.user.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>avatar</code>不需要知道它正在<code>Comment</code>中呈现。这就是为什么我们给它的prop一个更通用的名称：<code>user</code>而不是<code>author</code>。我们建议从组件自己的角度来命名<code>props</code>，而不是使用它的上下文。</p>
<p>我们现在可以对<code>Comment</code>组件做一点点简化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;Comment&quot;</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;UserInfo&quot;</span>&gt;</span><br><span class="line">                &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;UserInfo-name&quot;</span>&gt;</span><br><span class="line">                    &#123;props.user.name&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-text&quot;</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-date&quot;</span>&gt;</span><br><span class="line">                &#123;formatDate(props.date)&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将提取一个<code>UserInfo</code>组件，该组件在用户名称旁边呈现一个<code>avatar</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;UserInfo&quot;</span>&gt;</span><br><span class="line">            &lt;avatar uer=&#123;props.user&#125; /&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;UserInfo-name&quot;</span>&gt;</span><br><span class="line">                &#123;props.user.name&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这使我们可以进一步简化<code>Comment</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       &lt;div className=<span class="string">&quot;Comment&quot;</span>&gt;</span><br><span class="line">           &lt;UserInfo user=&#123;props.user&#125; /&gt;</span><br><span class="line">           &lt;div className=<span class="string">&quot;Comment-text&quot;</span>&gt;</span><br><span class="line">               &#123;props.text&#125;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">           &lt;div className=<span class="string">&quot;Comment-date&quot;</span>&gt;</span><br><span class="line">               &#123;formatDate(props.date)&#125;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date.toISOString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;img className=<span class="string">&quot;Avatar&quot;</span></span><br><span class="line">             src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">             alt=&#123;props.user.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;UserInfo&quot;</span>&gt;</span><br><span class="line">            &lt;Avatar user=&#123;props.user&#125;/&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;UserInfo-name&quot;</span>&gt;</span><br><span class="line">                &#123;props.user.name&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;Comment&quot;</span>&gt;</span><br><span class="line">            &lt;UserInfo user=&#123;props.user&#125;/&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-text&quot;</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;Comment-date&quot;</span>&gt;</span><br><span class="line">                &#123;formatDate(props.date)&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Comment author=&#123;&#123;</span><br><span class="line">        avatarUrl: <span class="string">&#x27;https://ss0.bdstatic.com/7Ls0a8Sm1A5BphGlnYG/sys/portrait/item/3ae1dc06.jpg&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;zhangyatao&#x27;</span></span><br><span class="line">    &#125;&#125; text=&#123;<span class="string">&#x27;我的名字叫郑文斌&#x27;</span>&#125; date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让一个个可重用组件在大型应用程序中交付使用的过程中，抽离组件起初可能看起来像又脏又累的活儿。 所以有一个好的经验法则：如果UI的一部分被使用了好几次（按钮，面板，头像），或者内部比较复杂的东西（App，FeedStory，评论），一个可重用的组件对它来说可以达到最大的发挥空间。</p>
<h2 id="Props是只读的"><a href="#Props是只读的" class="headerlink" title="Props是只读的"></a>Props是只读的</h2><p>无论是将组件声明为功能组件还是类组件，它都不能修改自己的props。考虑这个计算参数总和的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的函数被称为“纯函数”，因为它们不会改变它们的参数值，并且对于相同的输入总是返回相同的结果。（作者注：我理解的纯函数归纳为3点：1、同样的输入必定有同样的输出，2、不会产生副作用，3、不依赖任何外部的状态）</p>
<p>相反，这个函数是不纯的，因为它改变自己的参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">    account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React非常灵活，但它有一个严格的规则：</p>
<p><strong>所有React组件必须像它们的porps的纯函数那样运行。</strong></p>
<p>当然，应用中的UI大部分是动态的，随时间变化。 在下一节中，我们将介绍一个“state”的新概念。 状态允许React组件响应用户操作，网络响应和其他任何内容，随时间更改其输出，而不违反此规则。</p>
<h1 id="State和生命周期"><a href="#State和生命周期" class="headerlink" title="State和生命周期"></a>State和生命周期</h1><p>考虑前面部分中的滴答时钟示例（第三章）。</p>
<p>到目前为止，我们只学习了一种更新UI的方法。</p>
<p>我们调用<code>ReactDOM.render()</code>来改变渲染输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hell world&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        element,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在本节中，我们将学习如何使·Clock·组件真正可重用和封装。它将设置自己的计时器并每秒更新一次。<br>我们可以从封装时钟的外观开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line"></span><br><span class="line">function Clock(props) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;hello world&lt;&#x2F;h1&gt;</span><br><span class="line">            &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tick() &#123;</span><br><span class="line">   ReactDOM.render(</span><br><span class="line">       &lt;Clock date&#x3D;&#123;new Date()&#125; &#x2F;&gt;,</span><br><span class="line">       document.getElementById(&#39;root&#39;)</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
<p>然而，它缺少了一个关键要求：时钟设置一个定时器和每秒更新UI的事实应该是时钟的实现细节。</p>
<p>理想情况下，我们要写这一次，并由时钟本身来更新时间：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>要实现这一点，我们需要添加“state”到时钟组件。</p>
<p><strong>state类似于props，但它是私有的，完全由组件控制。</strong></p>
<p>我们之前提到，定义为类组件具有一些附加功能。 内部state就是：一个只有类组件可用的功能。</p>
<h2 id="将函数形式组件改为类形式组件"><a href="#将函数形式组件改为类形式组件" class="headerlink" title="将函数形式组件改为类形式组件"></a>将函数形式组件改为类形式组件</h2><p>您可以通过五个步骤将功能组件（如Clock）转换为类组件 ：</p>
<ol>
<li><p>创建一个与扩展React.Component相同名称的ES6类。</p>
</li>
<li><p>为它添加一个单一的空方法render()。</p>
</li>
<li><p>将函数的主体移动到render()方法中。</p>
</li>
<li><p>在render()主体中用this.props替换props。</p>
</li>
<li><p>删除剩余的空函数声明。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">               &lt;h2&gt;It is &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       )</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Clock</code>现在已经重新定义为类组件而不是之前的功能组件了。</p>
<p>这使我们可以使用额外的功能，如内部state和生命周期钩子。</p>
<h2 id="向类组件中添加state"><a href="#向类组件中添加state" class="headerlink" title="向类组件中添加state"></a>向类组件中添加state</h2><p>我们将分为三个步骤把<code>date</code>从<code>props</code>移动到<code>state</code>：</p>
<p>1）在<code>render()</code>方法中将<code>this.props.date</code>替换为<code>this.state.date</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）添加一个赋值初始this.state的类构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocalTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们如何将props传递给基类的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类组件应该总是用props调用基类构造函数。</p>
<p>3）从<code>&lt;Clock /&gt;</code>元素中删除<code>date</code> prop：</p>
<p>我们稍后将定时器代码添加回组件本身。</p>
<p>结果如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">               &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来，我们将使时钟设置自己的定时器，并每秒更新一次。</p>
<h2 id="向类中添加声明周期方法"><a href="#向类中添加声明周期方法" class="headerlink" title="向类中添加声明周期方法"></a>向类中添加声明周期方法</h2><p>在具有许多组件的应用程序中，释放组件在销毁时占用的资源非常重要。</p>
<p>我们想要在第一次将时钟渲染到DOM时设置一个计时器。 这在React中称为<code>“安装（mounting）”</code>。</p>
<p>我们还想清除定时器，当时钟产生的DOM被删除。 这在React中称<code>为“卸载（unmounting）&quot;</code>。</p>
<p>我们可以在组件类上声明特殊方法，以便在组件装入和卸载时运行一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 组件已经安装完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 组件将要被卸载</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">               &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法称为<code>“生命周期钩子”</code>。<code>componentDidMount()</code>只在组件输出呈现到DOM之后运行。这是设置计时器的好地方：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">        () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">        <span class="number">1000</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们如何保存计时器ID就在这。</p>
<p>虽然<code>this.props</code>是由React本身设置的，并且<code>this.state</code>有一个特殊的含义，如果你需要存储不用于视觉输出的东西，你可以手动地添加额外的字段到类中。</p>
<p>如果你不使用<code>render()</code>中的东西，它不应该放置在<code>state</code>中。</p>
<p>我们将拆除<code>componentWillUnmount()</code>生命周期钩子中的计时器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们将实现每秒运行的<code>tick()</code>方法。</p>
<p>它将使用<code>this.setState()</code>来调度组件本地state的更新：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">            () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">            <span class="number">1000</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">               &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在时钟每秒钟都在滴答地走，棒不棒。。。。</p>
<p>让我们快速回顾一下发生了什么以及调用方法的顺序：</p>
<ul>
<li><p>1）当将<code>&lt;Clock /&gt;</code>传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，它使用包括当前时间的对象初始化<code>this.state</code>。我们稍后将更新此state。</p>
</li>
<li><p>2）React然后调用Clock组件的<code>render()</code>方法。这是React如何学习应该在屏幕上显示什么。 React然后更新DOM以匹配时钟的渲染输出。</p>
</li>
<li><p>3）当时钟输出插入到DOM中时，React调用<code>componentDidMount()</code>生命周期钩子。在其中，时钟组件要求浏览器设置一个定时器，每秒调用<code>tick()</code>一次。</p>
</li>
<li><p>4）每秒钟浏览器调用<code>tick()</code>方法。在其中，Clock组件通过调用<code>setState()</code>和包含当前时间的对象来调度UI更新。由于<code>setState()</code>调用，React知道state已更改，并再次调用<code>render()</code>方法来了解屏幕上应该显示的内容。这个时候，<code>render()</code>方法中的<code>this.state.date</code>将会不同，因此渲染输出将包括更新的时间。 React相应地更新DOM。</p>
</li>
<li><p>5）如果时钟组件从DOM中被移除，React将调用<code>componentWillUnmount()</code>生命周期钩子，因此定时器停止。</p>
</li>
</ul>
<h2 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h2><p>关于<code>setState()</code>你应该了解三件事情:</p>
<h3 id="不要直接修改state"><a href="#不要直接修改state" class="headerlink" title="不要直接修改state"></a>不要直接修改state</h3><p>例如，这将不会重新渲染组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是错误的</span></span><br><span class="line"><span class="built_in">this</span>.state.comment = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>应该使用<code>setState()</code>代替：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是正确的</span><br><span class="line">this.setState(&#123;comment: &#39;hello&#39;&#125;);</span><br></pre></td></tr></table></figure>
<p>唯一可以分配<code>this.state</code>的地方是构造函数。</p>
<h3 id="state更新可能是异步的"><a href="#state更新可能是异步的" class="headerlink" title="state更新可能是异步的"></a>state更新可能是异步的</h3><p>React可以将多个<code>setState()</code>用批处理为单个更新以实现较高的性能。</p>
<p>因为<code>this.props</code>和<code>this.state</code>可能是异步更新的，你不应该依赖它们的值来计算下一个state。</p>
<p>例如，此代码可能无法更新计数器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是错误的</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.state.counter + <span class="built_in">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要解决它，应该使用回调函数而不是对象来调用<code>setState()</code>。回调函数将接收先前的state作为第一个参数，并将应用更新时的props作为第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是正确的</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>我们使用上面的箭头函数，但它也可以与常规函数一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这同样也是正确的，将剪头函数改为普通函数</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">       counter: prevState.counter + prps.increment</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>state更新是经过合并的</p>
<p>当调用<code>setState()</code>时，React会将您提供的对象合并到当前state。例如，您的state可能包含几个独立变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        posts: [],</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以使用单独的<code>setState()</code>来独立地更新它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            posts: response.posts</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            comments: response.comments</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并很浅，所以<code>this.setState(&#123;comments&#125;)</code>不会波及<code>this.state.posts</code>。仅仅只是完全替换了<code>this.state.comments</code>而已。</p>
<h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="headerlink" title="数据是向下流动的"></a>数据是向下流动的</h3><p>父组件和子组件都不能知道某个组件是有State的还是无State的，并且它们不应该关心它是否为功能组件或类组件。</p>
<p>这就是为什么State通常被设置为局部变量或封装到组件内部。除了拥有和设置它的组件之外的其他任何组件都不能访问它。</p>
<p>组件可以选择将其state作为props传递给其子组件：</p>
<p><code>&lt;h2&gt;Is is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</code></p>
<p>这也适用于用户定义的组件：</p>
<p><code>&lt;formattedDate date=&#123;this.state.data&#125; /&gt;</code></p>
<p><code>FormattedDate</code>组件将在其<code>props</code>中接收<code>date</code>，并且不知道它是来自时钟的<code>state</code>，<code>props</code>还是<code>手动输入</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedData</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Is is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这通常被称为<strong>自顶向下</strong>或<strong>单向</strong>数据流。任何state总是由一些特定组件拥有，并且从该state派生的任何数据或UI只能影响树中的“下面”组件。</p>
<p>如果你想象一个组件树作为props的瀑布流，每个组件的state就像一个额外的水源，它可以在任意点连接它，但也向下流。</p>
<p>为了显示所有组件都是真正隔离的，我们可以创建一个App组件来渲染三个<code>&lt;Clock&gt;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>每个时钟设置自己的定时器并独立更新。</p>
<p>在React应用程序中，组件是有状态还是无状态被视为可能随时间更改的组件的实现细节。您可以在有状态组件内使用无状态组件，反之亦然。</p>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>使用React元素处理事件与处理DOM元素上的事件非常相似。不过有一些语法上的差异：</p>
<ul>
<li><p>React事件使用驼峰命名法，而不是全部小写命名。</p>
</li>
<li><p>使用JSX你传递一个函数作为事件处理程序，而不是一个字符串。</p>
</li>
</ul>
<p>例如，HTML：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;activeLasers()&quot;</span>&gt;</span><br><span class="line">    Active Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>在React中略有不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;activateLasers&#125;&gt;</span><br><span class="line">    Active Lasers</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>另一个区别是，你不能返回false来防止React中的默认行为。 您必须显式调用preventDefault。 例如，使用纯HTML，为了防止打开新页面的默认链接行为，您可以写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#&quot;</span> onclick=<span class="string">&quot;console.log(&#x27;The link was clicked&#x27;); return false;&quot;</span>&gt;</span><br><span class="line">    Click me</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>在React中，这可以改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActiveLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The link was clicked&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;a href=<span class="string">&#x27;#&#x27;</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">            click me</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，e是合成过的event。React根据W3C规范定义这些event，因此你不需要担心浏览器兼容性的问题。</p>
<p>当使用React时，在创建后向DOM元素添加通常不需要调用addEventListener监听器。相反，只是在最初渲染元素时提供事件监听器。</p>
<p>当您使用ES6类定义组件时，常见的模式是将事件处理程序作为类上的公共方法。例如，此Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个绑定是必要的，要不然该事件中的this就会是当前实例</span></span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>你必须十分注意JSX中事件函数的意义。 在JavaScript中，类中的方法默认不绑定this。 如果你忘记绑定<code>this.handleClick</code>中的this关键字并将它传递给了<code>onClick</code>事件，当函数实际被调用时，会报出<code>undefined</code>的错误。</p>
<p>这不是React中特定的行为;它是JavaScript中函数正常工作的一部分。一般来说，如果你引用一个方法是后面没有<code>()</code>，如<code>onClick=&#123;this.handleClick&#125;</code>，就会绑定该方法。</p>
<p>如果调用<code>bind</code>会使你烦恼，有两种方法可以解决这个问题。 您可以使用属性初始值设定props来正确处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用剪头函数绑定this</span></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is:&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，在<code>Create React App</code>中启用此语法。</p>
<p>如果不使用属性初始化语法，可以在回调中使用箭头函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&#39;this is:&#39;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 给事件传入一个剪头函数也可以绑定this</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此语法的问题是，每次<code>LoggingButton</code>渲染时都会创建不同的回调函数。在大多数情况下，这是要被罚款的。 然而，如果这个回调作为一个prop传递给较低的组件，这些组件可能会做额外的重新渲染。我们一般建议在构造函数中绑定以避免这种性能问题。</p>
<h1 id="根据条件选择性渲染元素"><a href="#根据条件选择性渲染元素" class="headerlink" title="根据条件选择性渲染元素"></a>根据条件选择性渲染元素</h1><p>在React中，您可以根据所需行为来创建并封装的不同组件。 然后，您可以根据某些条件来仅仅渲染其中的某一些。当然，这具体取决于当前应用程序的状态。</p>
<p>React中的分条件渲染与JavaScript中的分条件工作方式相同。 使用JavaScript运算符（如if或条件运算符）来创建一个表示当前状态的元素，让React匹配它们然后更新UI。</p>
<p>考虑这两个组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将创建一个<code>Greeting</code>组件，根据用户是否登录显示这些组件中的其中一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    <span class="comment">// 可以尝试将isLoggedIn改为true</span></span><br><span class="line">    &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此示例根据<code>isLoggedIn prop</code>的值呈现不同的问候语。</p>
<p>当然还有另外一种情况，就是满足某个条件之后显示具体的内容，否则不显示，可以参考一下组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoSomething</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello everybody!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Amazing</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isShow = props.isShow;</span><br><span class="line">    <span class="keyword">if</span> (isShow) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">DoSomething</span> /&gt;</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回null即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Amazing isShow=&#123;<span class="literal">true</span>&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h2><p>您可以使用变量来存储React元素。这可以帮助您有条件地渲染组件的一部分，其余输出也不会更改。</p>
<p>考虑这两个代表注销和登录按钮的新组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">            Login</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogoutButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">            Logout</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下面的示例中，我们将创建一个名为LoginControl的有状态组件。</p>
<p>它将根据其当前state呈现<LoginButton/>或<LogoutButton />。 它还将呈现来自前面示例的<Greeting/>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">isLogin</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.loginClick = <span class="built_in">this</span>.loginClick.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.logoutClick = <span class="built_in">this</span>.logoutClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">loginClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">isLogin</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">logoutClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">isLogin</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isLoggedIn = <span class="built_in">this</span>.state.isLogin;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">            button = <span class="xml"><span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.logoutClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button = <span class="xml"><span class="tag">&lt;<span class="name">LoginButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.loginClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">                &#123;button&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;LoginControl /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然<code>声明变量</code>并使用<code>if</code>语句是一个有条件地渲染组件的好方法，但有时您可能需要使用较短的语法。 有几种方法来内联JSX中的条件，如下所述。</p>
<h2 id="通过逻辑运算符『-amp-amp-』内联if判断"><a href="#通过逻辑运算符『-amp-amp-』内联if判断" class="headerlink" title="通过逻辑运算符『 &amp;&amp;』内联if判断"></a>通过逻辑运算符『 &amp;&amp;』内联if判断</h2><p>您可以在JSX中嵌入任何表达式，将它们括在大括号中。 这包括JavaScript逻辑&amp;&amp;运算符。它可以方便地有条件地包括一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">            &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            &lt;h2&gt;</span><br><span class="line">                You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">            &lt;/h2&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages =[<span class="string">&#x27;zhangyatao&#x27;</span>, <span class="string">&#x27;Re: zhangyatao&#x27;</span>, <span class="string">&#x27;Re:Re: zhangyatao&#x27;</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>它的工作原理如下：<br>因为在JavaScript中，<code>true&amp;&amp;expression</code>总是返回为<code>expression</code>，而<code>false&amp;&amp;expression</code>总是返回为false。</p>
<p>因此，如果条件为<code>true</code>，紧接在<code>&amp;&amp;</code>之后的元素将出现在输出中。如果它为<code>false</code>，React将忽略并跳过它。</p>
<h2 id="内联if-else进行条件判断操作"><a href="#内联if-else进行条件判断操作" class="headerlink" title="内联if-else进行条件判断操作"></a>内联if-else进行条件判断操作</h2><p>根据条件进行内联元素判断的另一种方法是使用JavaScript三元运算符<code>判断 ? 真 : 假 </code>。</p>
<p>在下面的例子中，我们使用它来有条件地渲染一小块文本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="built_in">this</span>.state.isLoggedIn;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The user is &lt;b&gt;&#123;isLoggedIn ? <span class="string">&#x27;已登录&#x27;</span> : <span class="string">&#x27;未登录&#x27;</span>&#125;&lt;/b&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它也可以用于较大的表达式，虽然不太明显发生了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="built_in">this</span>.state.isLoggedIn;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;isLoggedIn ? (</span><br><span class="line">                &lt;LogoutButton onClick=&#123;<span class="built_in">this</span>.logoutClick&#125; /&gt;</span><br><span class="line">            ) : (</span><br><span class="line">                &lt;LoginButton onClick=&#123;<span class="built_in">this</span>.loginClick&#125; /&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像在JavaScript中一样，它取决于你和你的团队考虑更多的可读性，选择一个适当的风格。还要记住，当条件变得太复杂时，可能是提取组件的好时机。</p>
<h2 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h2><p>在极少数情况下，您可能希望由另一个组件呈现的情况下该组件仍然隐藏自身。这样的话，返回null即可。</p>
<p>在下面的示例中，<code>&lt;WarningBanner/&gt;</code>根据称为<code>warn</code>的props的值来渲染。如果prop的值为false，则组件不渲染到页面中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;warning&quot;</span>&gt;</span><br><span class="line">            warning!</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">showWarning</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.toggleClick = <span class="built_in">this</span>.toggleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">toggleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">            showWarning: !prevState.showWarning</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;WarningBanner warn=&#123;<span class="built_in">this</span>.state.showWarning&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.toggleClick&#125;&gt;</span><br><span class="line">                   &#123;<span class="built_in">this</span>.state.showWarning ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125;</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Page /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="Lists和Keys的处理"><a href="#Lists和Keys的处理" class="headerlink" title="Lists和Keys的处理"></a>Lists和Keys的处理</h1><p>首先，让我们回顾一下如何在JavaScript中遍历lists。</p>
<p>下面的代码，我们使用<code>map()</code>函数获取一个<code>数字</code>数组，并将它们的值加倍。我们将<code>map()</code>返回的新数组赋给变量<code>doubled</code>并记录下来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">//=&gt; [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会在控制台打印<code>[2, 4, 6, 8, 10]</code>。</p>
<p>在React中，将数组转换为<code>元素集合</code>几乎和上面的代码是一样的。</p>
<h2 id="渲染多个组件"><a href="#渲染多个组件" class="headerlink" title="渲染多个组件"></a>渲染多个组件</h2><p>您可以自己一个创建元素集合，并使用花括号{}将它们包含在JSX中。</p>
<p>下面，我们使用Javascript <code>map()</code>函数循环一个数字数组。我们为每个<code>item</code>返回一个<code>&lt;li&gt;</code>元素。最后，我们将结果数组的元素赋给<code>listItems</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>我们将整个<code>listItems</code>数组包含在<code>&lt;ul&gt;</code>元素中，并将其渲染到DOM：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此代码将会显示1到5之间的数字。</p>
<h2 id="基础的List组件"><a href="#基础的List组件" class="headerlink" title="基础的List组件"></a>基础的List组件</h2><p>通常你会将List放在组件中。</p>
<p>我们可以将前面的例子重构为接受数字数组的组件，并输出一个无序的元素列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">    <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当您运行此代码时，将会收到一条警告，<code>Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of &quot;NumberList&quot;.</code></p>
</blockquote>
<p>提示指出应该为列表的每一项提供一个属性<code>key</code>。 <code>“key”</code>是创建元素列表时需要包含的特殊字符串属性。 我们将在下一节讨论为什么它很重要。</p>
<p>让我们给<code>numbers.map()</code>的列表项分配一个<code>key</code>，并修复那个提示缺少<code>key</code>的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">-    <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">+    <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.toString()&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="Key的用法"><a href="#Key的用法" class="headerlink" title="Key的用法"></a>Key的用法</h2><p><code>keys</code>帮助确定哪些<code>item</code>已更改，已添加或已删除。 应该给数组中的元素设置上<code>key</code>属性，以便给元素一个稳定的身份：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers =[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> </span><br><span class="line">    &lt;li key=&#123;item.toString()&#125;&gt;</span><br><span class="line">        &#123;item&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>最好的方法是使用一个<code>字符串</code>来选择<code>key</code>，它是其兄弟之间一个列表项的<code>唯一标识</code>。通常，您会使用数据中的ID作为key：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span></span><br><span class="line">    &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line">        &#123;todo.text&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当您对已渲染的item没有稳定的ID时，您可以将项目index用作关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 如果todo没有一个稳定的id，可以使用这种方法</span></span><br><span class="line">    &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">        &#123;todo&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果项目需要实现重新排序，我们不建议为key使用索引，因为这将很慢。</p>
<h2 id="合理提取组件中的Keys"><a href="#合理提取组件中的Keys" class="headerlink" title="合理提取组件中的Keys"></a>合理提取组件中的Keys</h2><p><strong>Keys仅在循环时的上下文中有意义。</strong></p>
<p>例如，如果您提取了一个<code>ListItem</code>组件，则应该将该key保存在数组中的<code>&lt;ListItem/&gt;</code>元素上，而不是<code>ListItem</code>本身的根<code>&lt;li&gt;</code>元素上。</p>
<p><strong>示例：key的错误用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = props.value;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class="line">            &#123;value&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">    <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">        <span class="comment">// 这是错误的，这里应该设置上key</span></span><br><span class="line">        &lt;ListItem value=&#123;item&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125;&gt; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>实例：key的正确用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这才是正确的，在这里不需要设置key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">    <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span> </span><br><span class="line">        <span class="comment">// 这才是正确的，在这里设置key</span></span><br><span class="line">        &lt;ListItem key=&#123;item.toString()&#125; value=&#123;item&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;listItems&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>注意：map()中的元素都需要属性key。在哪儿循环就在哪儿设置key。</strong></p>
<h2 id="key在兄弟组件中必须是唯一的"><a href="#key在兄弟组件中必须是唯一的" class="headerlink" title="key在兄弟组件中必须是唯一的"></a>key在兄弟组件中必须是唯一的</h2><p>数组中使用的<code>key</code>在其兄弟组件之间应该是唯一的。 但是，它们不需要是全局唯一的。 当我们生成两个不同的数组时，我们可以使用相同的键：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> sidebar = (</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">           &#123;props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> </span><br><span class="line">               &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">                   &#123;post.title&#125;</span><br><span class="line">               &lt;/li&gt;</span><br><span class="line">           )&#125;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line">   );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">const</span> content = props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span></span><br><span class="line">      &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;&#123;post.content&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">   );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &#123;sidebar&#125;</span><br><span class="line">           &lt;hr /&gt;</span><br><span class="line">           &#123;content&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;hello zhangyatao&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;you\&#x27;re so handsome!&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;hi jiangyanyun&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;you\&#x27;re so beautiful!&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Blog posts=&#123;posts&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>key用来作为React的观察点，但它们不会传递给您的组件。 如果你需要在组件中使用相同的值，则使用不同的名称显式地将它作为props传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map(<span class="function"><span class="params">post</span> =&gt;</span></span><br><span class="line">    &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用上面的示例，Post组件可以读取<code>props.id</code>，但不能读取<code>props.key</code>。</p>
<h2 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h2><p>在上面的示例中，我们声明了一个单独的<code>listItems</code>变量并将其包含在JSX中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">   <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">       &lt;ListItem key=&#123;item.toString()&#125; value=&#123;item&#125; /&gt;</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">       &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSX允许在大括号中嵌入任何表达式，所以我们可以内联<code>map()</code>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;numbers.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">                &lt;ListItem key=&#123;item.toString()&#125; value=&#123;item&#125; /&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会让我们的代码更清晰，这种风格可以被随意使用。 </p>
<p>就像在JavaScript中，它是由你决定是否值得提取一个变量的可读性。</p>
<p>请记住，如果<code>map()</code>主体嵌套太多层，那么它是抽出一个组件的好时机。</p>
<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><p>HTML表单元素与React中的其他DOM元素有点不同，因为表单元素自然地保留一些内部状态。例如，这种采用纯HTML格式的表单接受单个name：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>此表单具有在用户提交表单时浏览到新页面的默认HTML表单行为。</p>
<p>如果你想在React中这个行为，它是可以工作的。但在大多数情况下，使用JavaScript函数处理表单的提交并访问用户在表单中输入的数据很方便。实现这一点的标准方法是使用称为“可控组件”的技术。</p>
<h2 id="可控组件"><a href="#可控组件" class="headerlink" title="可控组件"></a>可控组件</h2><p>在HTML中，诸如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>的表单元素通常保持它们自己的状态并且是基于用户输入来更新它的。在React中，可变state通常保存在组件的state属性中，并且仅使用<code>setState()</code>更新。</p>
<p>我们可以通过使React state是<code>“真理的唯一来源”</code>来结合这两者。 后续用户在该表单进行输入时依然受React组件控制。 其值由React以这种方式控制的可输入表单元素被称为<code>“可控组件”</code>。</p>
<p>例如，如果我们想让前面的示例日志在提交时记录下名称，我们可以将表单作为<code>可控组件</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.submit = <span class="built_in">this</span>.submit.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">submit</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A name was submitted: &#x27;</span>, <span class="built_in">this</span>.state.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;form onSubmit=&#123;<span class="built_in">this</span>.submit&#125; &gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    Name:</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                           value=&#123;<span class="built_in">this</span>.state.value&#125;</span><br><span class="line">                           onChange=&#123;<span class="built_in">this</span>.change&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;NameForm/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>因为<code>value</code>属性是在<code>form</code>元素上设置的，所以显示的值将总是为<code>this.state.value</code>，让React <code>state</code>成其<code>value</code>的为真正来源。由于<code>change</code>在每次击键时运行并更新React <code>state</code>，因此显示的值将随用户键入而更新。</p>
<p>使用<code>受控组件</code>，使得直接修改或验证用户输入的时候，每个<code>state</code>变量都将具有关联的处理函数。例如，如果我们想强制执行<code>name全部用大写字母写</code>，我们可以写change为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h2><p>在HTML中，<code>&lt;textarea&gt;</code>元素的子元素就是它的文本内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line">    Hello there, my name is zhangyatao!</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>
<p>在React中，<code>&lt;textarea&gt;</code>改为使用<code>value</code>属性。 这样，使用<code>&lt;textarea&gt;</code>的表单可以非常类似于使用单行输入的表单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EssayForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;请填写一个你喜欢的dom元素&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.submit = <span class="built_in">this</span>.submit.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">submit</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;有东西被提交了：&#x27;</span>, <span class="built_in">this</span>.state.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;form onSubmit=&#123;<span class="built_in">this</span>.submit&#125;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    Name:</span><br><span class="line">                    &lt;textarea value=&#123;<span class="built_in">this</span>.state.value&#125; onChange=&#123;<span class="built_in">this</span>.change&#125; /&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>this.state.value</code>在构造函数中初始化，因此<code>textarea</code>默认显示其中的文本。</p>
<h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>在HTML中，<code>&lt;select&gt;</code>创建一个下拉列表。例如，此HTML创建一个下拉列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;fruit&quot;&gt;fruit&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;lime&quot;&gt;lime&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option selected value&#x3D;&quot;coconut&quot;&gt;coconut&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;mango&quot;&gt;mango&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，由于<code>selected</code>属性<code>coconut</code>选项默认被选中的。</p>
<p>在React中在一般是在根<code>select</code>标签上使用<code>value</code>属性而不是使用<code>selected</code>属性。这在受控组件中很方便，因为您只需要在一个地方更新它。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlavorForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;coconut&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.submit = <span class="built_in">this</span>.submit.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">submit</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;你喜欢的是：&#x27;</span>, <span class="built_in">this</span>.state.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;form onSubmit=&#123;<span class="built_in">this</span>.submit&#125;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    请选择一个你喜欢的水果</span><br><span class="line">                    &lt;select value=&#123;<span class="built_in">this</span>.state.value&#125; onChange=&#123;<span class="built_in">this</span>.change&#125;&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;fruit&quot;</span>&gt;fruit&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;lime&quot;</span>&gt;lime&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;coconut&quot;</span>&gt;coconut&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;mango&quot;</span>&gt;mango&lt;/option&gt;</span><br><span class="line">                    &lt;/select&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;FlavorForm/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>总的来说，这使得<code>&lt;input type =“text”&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>都非常类似 - 它们都接受一个<code>value</code>属性，您可以使用它来实现<code>可控组件</code>。</p>
<h2 id="可控组件的备选方案"><a href="#可控组件的备选方案" class="headerlink" title="可控组件的备选方案"></a>可控组件的备选方案</h2><p>使用受控组件有时可能很乏味，因为您每次都需要为数据更改去编写事件处理程序，并通过React组件管理所有输入状态。 </p>
<p>当您将已经存在的项目转换为React或将React应用程序与非React库集成时，这可能会变得特别烦人。在这些情况下，您可能想要选择那些<code>不可控组件</code>(后续会有详细讲解)，一种用于实现输入表单的替代技术。</p>
<h2 id="提升state"><a href="#提升state" class="headerlink" title="提升state"></a>提升state</h2><p>通常，如果有几个组件需要反映相同的变化数据。 我们建议将共享state提升到层级最近的，并且是共同的父组件上。 让我们看看这是如何工作的。</p>
<p>在本节中，我们将创建一个温度计算器来计算水是否在给定温度下沸腾。</p>
<p>我们将从一个名为<code>BoilingVerdict</code>的组件开始。 它接受<code>celsius(摄氏温度)</code>作为props，并打印是否足以煮沸水：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水沸腾了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水没有沸腾<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们创建一个名字叫<code>Calculator</code>的组件。它渲染一个<code>&lt;input&gt;</code>，让您输入温度，并将其值保存在<code>this.state.value</code>中。</p>
<p>此外，它还会根据当前输入值渲染<code>BoilingVerdict</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水沸腾了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水没有沸腾<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.state.value;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                &lt;legend&gt;请输入温度&lt;/legend&gt;</span><br><span class="line">                &lt;input</span><br><span class="line">                    value=&#123;value&#125;</span><br><span class="line">                    onChange=&#123;<span class="built_in">this</span>.change&#125;/&gt;</span><br><span class="line">                &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(value)&#125;/&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Calculator /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="添加第二个input"><a href="#添加第二个input" class="headerlink" title="添加第二个input"></a>添加第二个input</h2><p>我们的新需求是，除了输入<code>摄氏温度</code>，我们提供一个输入<code>华氏温度</code>，并保持同步。</p>
<p>我们可以从<code>Calculator</code>提取一个<code>TemperatureInput</code>组件。 我们将添加一个新的<code>scale</code> prop，可以是<code>“c”</code>或<code>“f”</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">    c: <span class="string">&#x27;Celsius&#x27;</span>,</span><br><span class="line">    f: <span class="string">&#x27;Fahrenheit&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.state.value;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="built_in">this</span>.props.scale;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                 &lt;legend&gt;输入&#123;scaleName[scale]&#125;温度&lt;/legend&gt;</span><br><span class="line">                 &lt;input value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.change&#125; /&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在可以更改计算器来渲染两个单独的温度输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;TemperatureInput scale=<span class="string">&#x27;f&#x27;</span> /&gt;</span><br><span class="line">                &lt;TemperatureInput scale=<span class="string">&#x27;c&#x27;</span> /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Calculator /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们现在有两个输入框，但是当您在其中一个输入温度时，另一个不更新。 这违反了我们的要求：我们希望保持它们同步。</p>
<p>我们也不能从<code>Calculator</code>显示<code>BoilingVerdict</code>。 计算器不知道当前温度，因为它隐藏在<code>TemperatureInput</code>中。</p>
<h2 id="提升state-1"><a href="#提升state-1" class="headerlink" title="提升state"></a>提升state</h2><p>首先，我们将写两个函数来将摄氏度转换为华氏度，然后返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将华氏度转换为摄氏度</span><br><span class="line">function toCelsius(f) &#123;</span><br><span class="line">    return (f - 32) * 5 &#x2F; 9;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将摄氏度转换为华氏度</span><br><span class="line">function toFahrenheit(c) &#123;</span><br><span class="line">    return (c * 9 &#x2F; 5) + 32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数转换数字。我们将写另一个函数，它接受一个字符串值和一个转换函数作为参数，并返回一个字符串。 我们将使用它来计算一个输入基于另一个输入的值。</p>
<p>如果传入一个无效的<code>value</code>，那么会返回一个空字符串，并且保持输出四舍五入到小数点后第三位：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">value, convert</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> output = convert(input);</span><br><span class="line">    <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(rounded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，<code>tryConvert(&#39;abc&#39;, toCelsius)</code>返回一个空字符串，<code>tryConvert(&#39;10.22&#39;, toFahrenheit)</code>返回<code>50.396</code>。<br>接下来，我们会从<code>TemperatureInput</code>中移除<code>state</code>。同时从props接收一个<code>value</code>和一个<code>onChange</code>事件来代替。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.onChange(e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.props.value;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="built_in">this</span>.props.scale;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                &lt;legend&gt;请输入&#123;scaleName[scale]&#125;温度&lt;/legend&gt;</span><br><span class="line">                &lt;input value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.change&#125; /&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果几个组件需要访问相同的state，这是一个state应该提升到层级最近的共同父级组件的标志。 在我们的例子中，这是那个<code>Calculator</code>组件。 我们将在其state中存储当前<code>value</code>和<code>scale</code>。</p>
<p>我们可以存储两个输入框的值，但事实证明这是没有必要的。 它足以存储最近更改的输入的<code>value</code>及其表示的<code>scale</code>。然后，我们可以基于当前<code>value</code>和<code>scale</code>单独推断其他输入的值。</p>
<p>输入保持同步，因为它们的值是从相同的<code>state</code>计算的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.CelsiusChange = <span class="built_in">this</span>.CelsiusChange.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.FahrenheitChange = <span class="built_in">this</span>.FahrenheitChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">CelsiusChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">FahrenheitChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">scale</span>: <span class="string">&#x27;f&#x27;</span>, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="built_in">this</span>.state.scale;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.state.value;</span><br><span class="line">        <span class="keyword">const</span> celsius = scale === <span class="string">&#x27;f&#x27;</span> ? tryConvert(value, toCelsius) : value;</span><br><span class="line">        <span class="keyword">const</span> fahrenheit = scale === <span class="string">&#x27;c&#x27;</span> ? tryConvert(value, toFahrenheit) : value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Temperature scale=<span class="string">&quot;c&quot;</span> value=&#123;celsius&#125; onChange=&#123;<span class="built_in">this</span>.CelsiusChange&#125; /&gt;</span><br><span class="line">                &lt;Temperature scale=<span class="string">&quot;f&quot;</span> value=&#123;fahrenheit&#125; onChange=&#123;<span class="built_in">this</span>.FahrenheitChange&#125; /&gt;</span><br><span class="line">                &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">    c: <span class="string">&#x27;Celsius&#x27;</span>,</span><br><span class="line">    f: <span class="string">&#x27;Fahrenheit&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水沸腾了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水没有沸腾<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCelsius</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">value, convert</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> output = convert(input);</span><br><span class="line">    <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(rounded);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.change = <span class="built_in">this</span>.change.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">change</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.onChange(e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.props.value;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="built_in">this</span>.props.scale;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                &lt;legend&gt;请输入&#123;scaleNames[scale]&#125;温度&lt;/legend&gt;</span><br><span class="line">                &lt;input value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.change&#125;/&gt;</span><br><span class="line">            &lt;/fieldset&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.CelsiusChange = <span class="built_in">this</span>.CelsiusChange.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.FahrenheitChange = <span class="built_in">this</span>.FahrenheitChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">CelsiusChange</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">scale</span>: <span class="string">&#x27;c&#x27;</span>, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">FahrenheitChange</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">scale</span>: <span class="string">&#x27;f&#x27;</span>, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="built_in">this</span>.state.scale;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="built_in">this</span>.state.value;</span><br><span class="line">        <span class="keyword">const</span> celsius = scale === <span class="string">&#x27;f&#x27;</span> ? tryConvert(value, toCelsius) : value;</span><br><span class="line">        <span class="keyword">const</span> fahrenheit = scale === <span class="string">&#x27;c&#x27;</span> ? tryConvert(value, toFahrenheit) : value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;TemperatureInput scale=<span class="string">&quot;c&quot;</span> value=&#123;celsius&#125; onChange=&#123;<span class="built_in">this</span>.CelsiusChange&#125;/&gt;</span><br><span class="line">                &lt;TemperatureInput scale=<span class="string">&quot;f&quot;</span> value=&#123;fahrenheit&#125; onChange=&#123;<span class="built_in">this</span>.FahrenheitChange&#125;/&gt;</span><br><span class="line">                &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Calculator /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在，无论您编辑哪个输入框，<code>Calculator</code>中的<code>this.state.value</code>和<code>this.state.scale</code>都会更新。 其中一个输入框获取value为原样，所以任何用户输入都被保留，另一个输入值总是基于它重新计算。</p>
<h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>对于在React应用程序中更改的任何数据，都应该有一个唯一的<code>“数据来源”</code>，也就是<code>state</code>。通常，首先将state添加到需要渲染的组件。如果其他组件也需要它，你可以将其提升到它们层级最近的共同父级组件中。而不是尝试在不同组件之间去同步状态，总归就一句话：<code>你应该依赖于自上而下的数据流</code>。</p>
<p>提升state会涉及编写比双向绑定方法更多的“样板”代码。但这样做有一个好处，就是开发者可以很快就找到错误。由于所有的state都<code>“保存”</code>在这些组件中并且只有该组件可以改变它，所以大大减少了错误的出现概率。此外，你可以实现任何自定义逻辑来拒绝或转换用户输入。</p>
<p>如果某些东西可以从prps或state派生，它都不应该再继续呆在state里。例如，不是同时存储<code>celsiusValue</code>和<code>fahrenheitValue</code>，而是只存储最后一次编辑的<code>value</code>和<code>scale</code>。另一个输入的值总是可以从<code>render()</code>方法中计算出来。这允许我们清除或应用四舍五入到其他字段，而不会丢失用户输入。</p>
<p>当您在UI中看到错误时，可以使用<code>React Developer Tools</code>检查props，并向上逐个排查DOM树，直到找到负责更新<code>state</code>的组件。这使你可以轻松地跟踪错误来源。</p>
<h1 id="组合-VS-继承"><a href="#组合-VS-继承" class="headerlink" title="组合 VS 继承"></a>组合 VS 继承</h1><p>React具有强大的组合模式，我们建议使用组合而不是继承来重用组件之间的代码。</p>
<p>在本节中，我们将考虑一些新的React常常遇到的开发继承的问题，并展示如何使用组合来解决它们。</p>
<h2 id="有容乃大"><a href="#有容乃大" class="headerlink" title="有容乃大"></a>有容乃大</h2><p>一些组件提前不知道它们的子组件是什么的。这对于像<code>Sidebar</code>或<code>Dialog</code>这样的代表通用<code>“框”</code>的组件是特别常见的。</p>
<p>我们建议这些组件使用特殊的<code>children属性</code>将子组件元素直接传递到他们中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;<span class="string">&#x27;FancyBorder FancyBorder-&#x27;</span> + props.color&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这让其他组件通过嵌套JSX传递任意到他们的<code>children</code>中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;FancyBorder color=<span class="string">&quot;blue&quot;</span>&gt;</span><br><span class="line">            &lt;h1 className=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span><br><span class="line">                Welcome</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">            &lt;p className=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span><br><span class="line">                感谢参观鹏寰国际大厦</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/FancyBorder&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的html结构为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">    &lt;div data-reactroot=<span class="string">&quot;&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;FancyBorder FancyBorder-blue&quot;</span>&gt;</span><br><span class="line">        &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;Welcome&lt;/h1&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;感谢参观鹏寰国际大厦&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>任何在<code>&lt;FancyBorder&gt;</code>JSX标签内部的东西都会作为<code>children props</code>被传递到<code>FancyBorder</code>组件中。 由于<code>FancyBorder</code>在<code>&lt;div&gt;</code>中渲染<code>&#123;props.children&#125;</code>，所以所传递的元素将显示在这个<code>div</code>当中。</p>
<p>虽然这不常见，有时你可能需要在组件中有多个<code>“窟窿”</code>。 在这种情况下，你可以提出自己的规范，而不是使用<code>children</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Contacts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>tel:182012322**<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>chat content<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPanel</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;SplitPane&quot;</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span><br><span class="line">                &#123;props.left&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span><br><span class="line">                &#123;props.right&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;SplitPanel left=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Contacts</span> /&gt;</span></span>&#125; right=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Chat</span> /&gt;</span></span>&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>像<code>&lt;Contacts/&gt;</code>和<code>&lt;Chat/&gt;</code>等React元素只是一个对象，所以你可以像任何其他数据一样把它们当做props去传递。</p>
<h2 id="用的专业一点"><a href="#用的专业一点" class="headerlink" title="用的专业一点"></a>用的专业一点</h2><p>有时我们认为某个组件是其他组件的<code>“special cases”</code>。 例如，我们可能会说<code>WelcomeDialog</code>是<code>Dialog</code>的一个<code>“special cases”</code>。</p>
<p>在React中，这也通过组合实现，其中更<code>“特殊”</code>的组件渲染更<code>“通用”</code>的组件并用<code>props</code>配置它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;FancyBorder color=<span class="string">&quot;blue&quot;</span>&gt;</span><br><span class="line">            &lt;h1 className=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span><br><span class="line">                &#123;props.title&#125;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">            &lt;p className=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span><br><span class="line">                &#123;props.message&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/FancyBorder&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Dialog title=<span class="string">&quot;Welcome&quot;</span> message=<span class="string">&quot;欢迎参观鹏寰国际大厦&quot;</span> /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合对于定义为类的组件同样有效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=&#123;<span class="string">&#x27;FancyBorder FancyBorder-&#x27;</span> + props.color&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;FancyBorder color=<span class="string">&quot;blue&quot;</span>&gt;</span><br><span class="line">            &lt;h1 className=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span><br><span class="line">                &#123;props.title&#125;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">            &lt;p className=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span><br><span class="line">                &#123;props.message&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/FancyBorder&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpDialog</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.handleSignUp = <span class="built_in">this</span>.handleSignUp.bind(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">login</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Dialog title=<span class="string">&quot;Mars Exploration Program&quot;</span></span><br><span class="line">                    message=<span class="string">&quot;How should we refer to you?&quot;</span>&gt;</span><br><span class="line">                &lt;input value=&#123;<span class="built_in">this</span>.state.login&#125;</span><br><span class="line">                       onChange=&#123;<span class="built_in">this</span>.handleChange&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.handleSignUp&#125;&gt;</span><br><span class="line">                    Sign Me Up!</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/Dialog&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">login</span>: e.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleSignUp</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="built_in">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;SignUpDialog /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>在Facebook，使用了React在数千个组件，他们没有发现一个必须实现组件继承层次结构的用例。</p>
<p>props和组合给你所有的灵活性，你需要以一个明确和安全的方式自定义组件的外观和行为。请记住，组件可以接受任意props，包括原始值，React元素或函数。</p>
<p>如果要在组件之间重用非UI功能，建议您将其提取到单独的JavaScript模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。</p>
<h1 id="深入理解JSX"><a href="#深入理解JSX" class="headerlink" title="深入理解JSX"></a>深入理解JSX</h1><p>从根本上讲，JSX就是提供了一个<code>React.createElement</code>(component,props,…children)`函数的语法糖。就像下面的JSX代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">&quot;blue&quot;</span> shadow=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">    Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br></pre></td></tr></table></figure>
<p>经过编译后为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    MyButton,</span><br><span class="line">    &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">shadow</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;Click Me&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果一个标签没有子元素的话，你可以使用<code>/&gt;</code>来自动闭合。例如：</p>
<p><code>&lt;div className=&quot;sidebar&quot; /&gt;</code></p>
<p>经过编译后为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">className</span>: <span class="string">&#x27;sidebar&#x27;</span>&#125;,</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果你想测试一些特定的JSX是如何转换成JavaScript的话，你可以试试在线Babel编译器。</p>
<h2 id="指定React元素类型"><a href="#指定React元素类型" class="headerlink" title="指定React元素类型"></a>指定React元素类型</h2><p>JSX标记的第一部分决定了React元素的类型。</p>
<p>首字母大写的类型表示JSX标记指的为React组件。 这些标签被编译为对指定变量的直接引用，因此如果使用JSX <code>&lt;Foo/&gt;</code>表达式，Foo必须在当前的作用域内。</p>
<h2 id="React必须在作用域内"><a href="#React必须在作用域内" class="headerlink" title="React必须在作用域内"></a>React必须在作用域内</h2><p>由于JSX编译的本质是对<code>React.createElement</code>的调用，因此React库也必须始终在JSX代码的作用域中。<br>例如，虽然<code>CustomButton</code>没有直接引用<code>React</code>，但是这两个导入的模块在这段代码中也还是很有必要的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return React.createElement(CustomButton, &#123;color: &#x27;red&#x27;&#125;, null);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomButton</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用JavaScript打包工具并将React通过script标签引入，那么它就会作为一个全局变量<code>React</code>。</p>
<h2 id="对JSX类型使用『点』表示符"><a href="#对JSX类型使用『点』表示符" class="headerlink" title="对JSX类型使用『点』表示符"></a>对JSX类型使用『点』表示符</h2><p>您还可以使用JSX中的点表示符来引用React组件。 如果您有一个模块会导出很多React组件的话，使用这种方法就会十分方便。例如，如果<code>MyComponents.DatePicker</code>是一个组件，您可以直接从JSX使用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponents = &#123;</span><br><span class="line">    <span class="function"><span class="title">DatePicker</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这里有一个颜色为&#123;props.color&#125;的日期选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueDataPicker</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponents.DatePicker</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;BlueDataPicker /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="用户自定义组件必须是首字母大写"><a href="#用户自定义组件必须是首字母大写" class="headerlink" title="用户自定义组件必须是首字母大写"></a>用户自定义组件必须是首字母大写</h2><p>当元素类型以是小写字母开头时，它指向一个内置组件，如<code>&lt;div&gt;</code>或<code>&lt;span&gt;</code>，并生成一个字符串<code>&#39;div&#39;</code>或<code>&#39;span&#39;</code>传递给<code>React.createElement</code>。以大写字母开头的类型，如<Foo/>编译为<code>React.createElement(Foo)</code>，并且在当前作用域内寻找这个名称为Foo的已定义或已导入组件。</p>
<p>我们建议使用<code>首字母大写</code>命名组件。如果你有一个以小写字母开头的组件，请在JSX中使用它之前请将它赋值给一个首字母大写的变量。</p>
<p>下面代码不会按预期运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是错误的，这个组件应该为首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是正确的，因为div是一个有效的html标签</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是错误的，因为它是首字母小写，所以React认为&lt;hello /&gt;是一个html标签</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">name</span>=<span class="string">&quot;zhangyatao&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要修复上面的问题，我们必须将<code>hello</code>重命名为<code>Hello</code>，通过<code>&lt;Hello /&gt;</code>来使用该组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">&quot;zhangyatao&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在运行的时候选择组件类型"><a href="#在运行的时候选择组件类型" class="headerlink" title="在运行的时候选择组件类型"></a>在运行的时候选择组件类型</h2><p>不能将常规的javascript表达式用作React元素类型。 如果你想使用一个通用表达式来表示元素的类型，只需将它赋值给一个首字母大写的变量即可。</p>
<p>这通常出现在当你想基于同一个props渲染一个不同的组件的情况下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Com1, Com2&#125; <span class="keyword">from</span> <span class="string">&#x27;./Components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">    myCom1: Com1,</span><br><span class="line">    myCom2: Com2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RunCom</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是错误的，JSX的类型不能这么写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml">&lt;components[props.comType] type=&#123;props.type&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要解决上面的问题，只需要将它们赋值给一个首字母大写的变量即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Com1, Com2&#125; <span class="keyword">from</span> <span class="string">&#x27;./Components&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">    myCom1: Com1,</span><br><span class="line">    myCom2: Com2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RunCom</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是正确的，将它们赋值给一个首字母大写的变量</span></span><br><span class="line">    <span class="keyword">const</span> MyCom = components[props.comType];</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyCom</span> <span class="attr">type</span>=<span class="string">&#123;props.type&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSX中的Props"><a href="#JSX中的Props" class="headerlink" title="JSX中的Props"></a>JSX中的Props</h2><p>在JSX中指定Props有以下几种不同的方法。</p>
<h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><p>你可以传递任何JavaScript表达式作为Props，用{}括住它们就可以使用。 例如，在这个JSX中：</p>
<p><code>&lt;MyComponents foo=&#123;1 + 2 + 3 + 4&#125; /&gt;</code></p>
<p>对于<code>MyComponent</code>来说，<code>props.foo</code>的值将为<code>10</code>，因为是通过表达式<code>1 + 2 + 3 + 4</code>计算得到的。</p>
<p><code>if</code>语句和<code>for</code>循环在JavaScript中不是表达式，因此它们不能在JSX中直接使用。相反，写完它们之后你可以把JSX放在里面。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberDescriber</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> description;</span><br><span class="line">    <span class="keyword">if</span> (props.number % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        description = <span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>偶数<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        description = <span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>奇数<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.number&#125;是一个&#123;description&#125;.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h3><p>你可以传递一个字符串内容作为props。 这两个JSX表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">&quot;hi zhangyatao&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">&#x27;hi zhangyatao&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>当你传递一个字符串直接量时，它的值是经过html转义的。 所以这两个JSX表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">&#x27;&amp;lt;3&#x27;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">&#x27;&lt;3&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Props默认值为true"><a href="#Props默认值为true" class="headerlink" title="Props默认值为true"></a>Props默认值为true</h3><p>如果你没有给Props传入一个值，那么它的默认值为<code>true</code>，这两个JSX表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们不建议使用它，因为它可以使用ES6对象的简写<code>&#123;foo&#125;</code>，也就是<code>&#123;foo：foo&#125;</code>的简称会和<code>&#123;foo：true&#125;</code>混淆。这种行为在这里只是方便它匹配到HTML行为。</p>
<h3 id="Props传递"><a href="#Props传递" class="headerlink" title="Props传递"></a>Props传递</h3><p>如果你有一个对象类似的数据作为props，并且想在JSX中传递它，你可以使用<code>...</code>作为一个<code>“spread”</code>运算符传递整个props对象。 这两个组件是等效的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">firstName</span>=<span class="string">&quot;yatao&quot;</span> <span class="attr">lastName</span>=<span class="string">&quot;zhang&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;yatao&#x27;</span>, <span class="attr">lastName</span>: <span class="string">&#x27;zhang&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当创建一个通用容器时，<code>spread props</code>很有用。 </p>
<p>然而，他们也可以让你的代码变得有点凌乱，这样很容易使大量不相关的prps传递给那些不关心它们的组件。 建议您谨慎使用此语法。</p>
<h2 id="JSX中的子元素和子组件"><a href="#JSX中的子元素和子组件" class="headerlink" title="JSX中的子元素和子组件"></a>JSX中的子元素和子组件</h2><p>在包含开始标记和结束标记的JSX表达式中，这些标记之间的内容通过一种特殊的prop：<code>props.children</code>传递。 有几种不同的方式传递子组件：</p>
<h3 id="字符串直接量-1"><a href="#字符串直接量-1" class="headerlink" title="字符串直接量"></a>字符串直接量</h3><p>你可以在开始和结束标签之间放一个字符串，那么<code>props.children</code>就是那个字符串。这对许多内置的HTML元素很有用。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.children&#125;&lt;div&gt;; //=&gt; &lt;div&gt;hello zhangyatao&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&gt;Hello zhangyatao&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>
<p>这是有效的JSX，并且<code>MyComponent</code>中的<code>props.children</code>将是字符串<code>“Hello zhangyatao”</code>。 HTML标签是不会经过转义的，所以你一般可以写JSX就像你写HTML一样：</p>
<p><code>&lt;div&gt;这是一个html标签 &amp;amp; 同时也是个JSX&lt;/div&gt;</code></p>
<p>JSX会删除行的开始和结尾处的空格。它也会删除中间的空行。 与标签相邻的空行被会被删除;<br>在字符串文本中间出现的空行会缩合成一个空格。所以这些都渲染相同的事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;hello zhangyatao&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    hello zhangyatao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    hello</span><br><span class="line">    zhangyatao</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">hello zhangyatao</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JSX子元素"><a href="#JSX子元素" class="headerlink" title="JSX子元素"></a>JSX子元素</h3><p>你可以使用很多个JSX元素作为子元素。这对需要嵌套的显示类型组件很有用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Dialog&gt;</span><br><span class="line">    &lt;DialogHeader /&gt;</span><br><span class="line">    &lt;DialogBody /&gt;</span><br><span class="line">    &lt;DialogFooter /&gt;</span><br><span class="line">&lt;/Dialog&gt;</span><br></pre></td></tr></table></figure>
<p>你可以将不同类型的子元素混合在一起，因此JSX子元素可以与字符串直接量一起使用。这是JSX的另一种方式，就像一个HTML一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    这是一个列表</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;item <span class="number">1</span>&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;item <span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>一个React组件不可能返回多个React元素，但是一个JSX表达式可以包含多个子元素，因此如果你想让一个组件渲染多个东西，你可以将它们统一放置在就像上面那样的div中。</p>
<h3 id="Javascript表达式"><a href="#Javascript表达式" class="headerlink" title="Javascript表达式"></a>Javascript表达式</h3><p>您可以将任何JavaScript表达式放在{}中作为子组件传递。 例如，下面这些表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.children&#125;&lt;div&gt;; //=&gt; &lt;div&gt;hi zhangyatao&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&gt;hi zhangyatao&lt;/MyComponent&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&gt;&#123;&#x27;hi zhangyatao&#x27;&#125;&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure>
<p>这通常用于渲染任意长度的JSX表达式列表。例如，这将渲染一个HTML列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Item</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> todos = [<span class="string">&#x27;完成文档&#x27;</span>, <span class="string">&#x27;出去逛街&#x27;</span>, <span class="string">&#x27;打一局dota&#x27;</span>];</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;todos.map(<span class="function"><span class="params">message</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;message&#125;</span> <span class="attr">message</span>=<span class="string">&#123;message&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript表达式可以与其他类型的子元素混合使用。 这通常用于替换字符串模板：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用函数作为子元素"><a href="#使用函数作为子元素" class="headerlink" title="使用函数作为子元素"></a>使用函数作为子元素</h3><p>通常，插入JSX中的JavaScript表达式都最终返回为一个字符串、React元素、一个列表。</p>
<p>当然，<code>props.children</code>可以像任何其他props那样工作，它可以传递任何类型的数据，并不局限于那些告诉React应该如何渲染的东东。例如，如果您有一个自定义组件，您可以将<code>props.children</code>作为一个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Repeat</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = [];</span><br><span class="line">    <span class="keyword">let</span> callback = props.children;</span><br><span class="line">    <span class="keyword">var</span> numTimes = props.numTimes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; numTimes ; i++ )&#123;</span><br><span class="line">        items.push(callback(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListOfTenThings</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Repeat numTimes=&#123;<span class="number">10</span>&#125;&gt;</span><br><span class="line">            &#123;<span class="function"><span class="params">index</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>这是列表中的第&#123;index&#125;项<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">        &lt;/Repeat&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ListOfTenThings/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>传递给自定义组件的子元素可以是任何东西，只要在React在渲染之前，该组件将它们转换为可以理解的东西即可。 这种用法并不常见，如果你想扩展JSX的其他能力，可以通过这个例子了解下它的工作原理。</p>
<h3 id="布尔值、null、undefined在渲染时会被自动忽略"><a href="#布尔值、null、undefined在渲染时会被自动忽略" class="headerlink" title="布尔值、null、undefined在渲染时会被自动忽略"></a>布尔值、null、undefined在渲染时会被自动忽略</h3><p><code>false</code>，<code>null</code>，<code>undefined</code>和<code>true</code>是有效的子元素，不过他们从根本上讲是不参与渲染的。这些JSX表达式将渲染处相同的东西：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">false</span>&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">null</span>&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">true</span>&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这对于有条件地呈现React元素很有用。 如果<code>showHeader</code>为<code>true</code>，那么这个JSX只渲染一个<code>&lt;Header /&gt;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;showHeader &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如果返回一些<code>“假的”</code>值就会收到一个警告，如数字<code>0</code>，不过React仍然会渲染。例如，此代码将不会像您预期的那样工作，因为当<code>props.messages</code>是空数组时将打印<code>0</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;props.messages.length &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">messages</span>=<span class="string">&#123;props.messages&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>想要修复上面的问题，你要确定这个表达式在&amp;&amp;之前总返回<code>布尔值</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;props.messages.length &gt; <span class="number">0</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">messages</span>=<span class="string">&#123;props.messages&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>相反，如果你想要一个值如<code>false</code>，<code>true</code>，<code>null</code>或<code>undefined</code>出现在输出中，你必须先将它转换为<code>字符串</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVariable</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> myVariable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果这里不把false转换为字符串，这只会输出『我的javascript变量是』</span></span><br><span class="line">    <span class="keyword">const</span> convertedVar = <span class="built_in">String</span>(myVariable);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我的javascript变量是&#123;convertedVar&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyVariable/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="使用PropTypes进行类型检测"><a href="#使用PropTypes进行类型检测" class="headerlink" title="使用PropTypes进行类型检测"></a>使用PropTypes进行类型检测</h1><p>随着你的应用的变得越来越大，你可以通过<code>typechecking</code>来找到更多的bug。 对于某些应用，您可以使用JavaScript扩展（如<code>Flow</code>或<code>TypeScript</code>）对整个应用程序进行类型检查。</p>
<p>即使你不使用这些，React也有一些内置的<code>typechecking</code>能力。 要在组件的<code>props</code>上运行<code>typechecking</code>，可以分配特殊的<code>propTypes</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;h1&gt;Hello &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Greeting.propTypes = &#123;</span><br><span class="line">    name: React.PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes</code>返回的是一系列验证函数，用于确保接收的数据类似是否是有效的。 </p>
<p>在这个例子中，我们使用<code>React.PropTypes.string.isRequire</code>检测<code>name</code>是否为字符串，并且是必填的。 </p>
<p>当为prop提供无效值时，JavaScript控制台中将显示警告。 出于性能原因，仅在开发模式下检查<code>propTypes</code>。</p>
<h2 id="React-PropTypes"><a href="#React-PropTypes" class="headerlink" title="React.PropTypes"></a>React.PropTypes</h2><p>下面是一个示例，其中提供了不同的验证函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 你可以定义一个js原始类型的prop,默认请情况下，这是都是可选的</span></span><br><span class="line">  optionalArray: React.PropTypes.array,</span><br><span class="line">  optionalBool: React.PropTypes.bool,</span><br><span class="line">  optionalFunc: React.PropTypes.func,</span><br><span class="line">  optionalNumber: React.PropTypes.number,</span><br><span class="line">  optionalObject: React.PropTypes.object,</span><br><span class="line">  optionalString: React.PropTypes.string,</span><br><span class="line">  optionalSymbol: React.PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可以渲染的东西：数字，字符串，元素或数组（或片段）。</span></span><br><span class="line">  optionalNode: React.PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React元素</span></span><br><span class="line">  optionalElement: React.PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明prop是某个类的实例。 内部使用的是JS的instanceof运算符。</span></span><br><span class="line">  optionalMessage: React.PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以通过将它作为枚举来确保你的prop被限制到特定的值。</span></span><br><span class="line">  optionalEnum: React.PropTypes.oneOf([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以是许多类型之一的对象</span></span><br><span class="line">  optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">    React.PropTypes.string,</span><br><span class="line">    React.PropTypes.number,</span><br><span class="line">    React.PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 某种类型的数组</span></span><br><span class="line">  optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具有某种类型的属性值的对象</span></span><br><span class="line">  optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采取特定样式的对象</span></span><br><span class="line">  optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">    color: React.PropTypes.string,</span><br><span class="line">    fontSize: React.PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以用`isRequired`来连接到上面的任何一个类型，以确保如果没有提供props的话会显示一个警告。</span></span><br><span class="line">  requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何数据类型</span></span><br><span class="line">  requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 您还可以指定自定义类型检查器。 如果检查失败，它应该返回一个Error对象。 不要`console.warn`或throw，因为这不会在`oneOfType`内工作。</span></span><br><span class="line">  customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 您还可以为`arrayOf`和`objectOf`提供自定义类型检查器。 如果检查失败，它应该返回一个Error对象。 </span></span><br><span class="line">  <span class="comment">// 检查器将为数组或对象中的每个键调用验证函数。 </span></span><br><span class="line">  <span class="comment">// 检查器有两个参数，第一个参数是数组或对象本身，第二个是当前项的键。</span></span><br><span class="line">  customArrayProp: React.PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="要求只能是单个子元素"><a href="#要求只能是单个子元素" class="headerlink" title="要求只能是单个子元素"></a>要求只能是单个子元素</h2><p>使用<code>React.PropTypes.element</code>，您可以指定只有一个子元素可以作为内容传递的组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 只能包含一个子元素，否则会给出警告</span></span><br><span class="line">        <span class="keyword">const</span> children = <span class="built_in">this</span>.props.children;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    children: React.PropTypes.element.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置Prop默认值"><a href="#设置Prop默认值" class="headerlink" title="设置Prop默认值"></a>设置Prop默认值</h2><p>您可以通过使用<code>defaultProps</code>属性来定义props的默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果name没有传值，则会将name设置为默认的zhangyatao</span></span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangyatao&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会渲染处&lt;h1&gt;hi zhangyatao&lt;/h1&gt;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Greeting /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果父组件没有设置并传入<code>name</code>，<code>defaultProps</code>将确保<code>this.props.name</code>将有一个默认值。 <code>propTypes</code>类型检查发生在<code>defaultProps</code>解析之后，因此类型检查也将应用于<code>defaultProps</code>。</p>
<h1 id="refs和DOM元素"><a href="#refs和DOM元素" class="headerlink" title="refs和DOM元素"></a>refs和DOM元素</h1><p>在典型的React数据流中，props是父组件与其子组件交互的唯一方式。 要修改子组件，需要使用一个新的props进行重新渲染。</p>
<p>但是，在某些情况下，您需要在典型数据流之外强制修改子组件。 要修改的子组件可以是React组件实例，也可以是DOM元素。 对于这两种情况，React提供了一个以下这样的功能。</p>
<h2 id="通过ref属性设置回调函数"><a href="#通过ref属性设置回调函数" class="headerlink" title="通过ref属性设置回调函数"></a>通过ref属性设置回调函数</h2><p>React提供可以附加到任何组件的特殊属性。<code>ref</code>属性接受一个回调函数，回调函数将在组件被挂载或卸载后立即执行。</p>
<p>当在HTML元素上使用<code>ref</code>属性时，<code>ref</code>回调函数接收一个基础的DOM元素作为其参数。例如，此代码使用<code>ref</code>回调函数来存储对DOM节点的引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.focus = <span class="built_in">this</span>.focus.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">focus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// textInput是一个标准的DOM元素</span></span><br><span class="line">        <span class="built_in">this</span>.textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.textInput = input;</span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;选中上面的text input&quot;</span> onClick=&#123;<span class="built_in">this</span>.focus&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;CustomTextInput/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当组件装载(mounting)时，React将使用DOM元素调用<code>ref</code>回调函数，并在卸载时用null调用它。</p>
<p>使用<code>ref</code>回调函数是为类设置一个属性来访问DOM元素的常见模式。 如果您目前正在使用<code>this.refs.myRefName</code>来访问DOM引用的话，我会建议你使用此模式。</p>
<p>当在自定义组件上使用<code>ref</code>属性时，<code>ref</code>回调接收组件的已装入的组件实例作为其参数。例如，如果我们想要包装上面的<code>CustomTextInput</code>来模拟它在装载(mounting)后立即被点击：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;CustomTextInput ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123;<span class="built_in">this</span>.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您不能在功能性组件上使用<code>ref</code>属性，因为它们没有实例。 但是，您可以使用功能性组件的render函数内的<code>ref</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里必须提前顶一个textInput，只有这样才可以正常执行ref回调函数</span></span><br><span class="line">    <span class="keyword">let</span> textInput = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123; textInput = input; &#125;&#125; /&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;选中这个输入框&quot;</span> onClick=&#123;click&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不要过度使用ref"><a href="#不要过度使用ref" class="headerlink" title="不要过度使用ref"></a>不要过度使用ref</h2><p>你的第一个倾向可能是使用<code>refs</code>在你的应用中<code>“make things happen”</code>。</p>
<p>如果是这种情况，你必须花一点时间，关键去考虑在组件层次结构中应该拥有什么状态。</p>
<p>通常，在层次结构中处于更高级别的组件“拥有”状态是一个让一切便清除的最适当位置。有关示例，请参阅本系列的《提升state》。</p>
<h1 id="不可控组件"><a href="#不可控组件" class="headerlink" title="不可控组件"></a>不可控组件</h1><p>在大多数情况下，我们建议使用<code>可控组件</code>(参考本系列《表单处理》)来实现表单功能。在可控组件中，表单数据由React组件处理。 替代方法是使用<code>不可控组件</code>，其中表单数据是由DOM本身处理。</p>
<p>要编写不可控组件，不需要为每个状态更新都去编写事件处理程序，你可以直接使用ref从DOM获取表单值。</p>
<p>例如，此代码在不可控组件中接受一个name：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.submit = <span class="built_in">this</span>.submit.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">submit</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;有一个name提交了：&#x27;</span>,<span class="built_in">this</span>.input.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;form onSubmit=&#123;<span class="built_in">this</span>.submit&#125;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    Name:</span><br><span class="line">                    &lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123; <span class="built_in">this</span>.input = input; &#125;&#125; /&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不可控组件在DOM中保持『真实的唯一来源』，因此当使用不可控组件时，有时更容易集成React和非React代码。 如果你想要快速创建并且不顾代码质量的话，它也可以稍微少写一些代码。 否则，通常都应该使用<code>受控组件</code>。</p>
<p>如果仍然不清楚在特定的情况下应该使用哪种类型<code>(受控组件/不受控组件)</code>的组件，您可能会发现这篇文章中的<code>控制输入</code>和<code>不可控输入</code>对加深你的理解是很有帮助的。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>在React渲染生命周期中，表单元素的<code>value</code>属性将覆盖DOM中的值。 对于不可控组件，您通常希望React指定初始值，但不去控制DOM的后续更新。要处理这种情况，可以指定<code>defaultValue</code>属性，而不是<code>value</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;form onSubmit=&#123;<span class="built_in">this</span>.submit&#125;&gt;</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                Name:</span><br><span class="line">                &lt;input defaultValue=<span class="string">&quot;zhangyatao&quot;</span> type=<span class="string">&quot;text&quot;</span></span><br><span class="line">                    ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123; <span class="built_in">this</span>.input = input; &#125;&#125; /&gt;</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span> /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，<code>&lt;input type =“checkbox”&gt;</code>和<code>&lt;input type =“radio”&gt;</code>支持<code>defaultChecked</code>，并且<code>&lt;select&gt;</code>也同样支持<code>defaultValue</code>。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>在React内部，React使用了几种比较聪明的技术来实现<code>最小化更新UI所需的昂贵的DOM操作</code>的数量。</p>
<p>对于许多应用来说，使用React将很快速的渲染出用户界面，从而无需进行大量工作来专门做优化性能的工作。</p>
<p>大概有以下有几种方法来加快你的React应用程序。</p>
<h2 id="使用生产环境的配置进行构建"><a href="#使用生产环境的配置进行构建" class="headerlink" title="使用生产环境的配置进行构建"></a>使用生产环境的配置进行构建</h2><p>如果你在React应用中进行基准测试或这遇到了性能问题，请首先确保你是使用的压缩后线上版本js文件来进行的测试：</p>
<ul>
<li><p>对于<code>Create React App</code>来说，你需要在构建时运行<code>npm run build</code>。</p>
</li>
<li><p>对于单文件来说，我们提供了生产环境版本<code>.min.js</code>。</p>
</li>
<li><p>使用的是Browserify，你先设置<code>NODE_ENV=production</code>然后运行。</p>
</li>
<li><p>使用的是webpack，你需要在生产环境配置中加入以下插件：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    <span class="string">&#x27;process.env&#x27;</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;production&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> webpack.optimize.UglifyJSPlugin();</span><br></pre></td></tr></table></figure>
<p>在构建应用程序时开发构建工具可以打印一些有帮助的额外警告。</p>
<p>但是由于需要额外地记录这些警告信息，所以它也会变得更慢。</p>
<h2 id="避免重复处理DOM"><a href="#避免重复处理DOM" class="headerlink" title="避免重复处理DOM"></a>避免重复处理DOM</h2><p>React会创建并维护所渲染的UI内部表示信息。其中包括从组件返回的React元素。 此表示信息使React避免创建DOM节点和访问那些没有必要的节点，因为这样做可能会比JavaScript对象上的一些操作更慢。 有时它被称为<code>“虚拟DOM”</code>。</p>
<p>当组件的<code>props</code>或<code>state</code>更改时，React通过将最新返回的元素与先前渲染的元素进行比较来决定是否需要实际的DOM更新。 当它们不相等时，React将更新DOM。</p>
<p>在某些情况下，您的组件可以通过重写生命周期函数<code>shouldComponentUpdate</code>来加快所有这些操作。这个函数会在重新渲染之前触发。 此函数的默认实现返回<code>true</code>，让React执行更新：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你知道在某些情况下你的组件不需要更新，你可以从<code>shouldComponentUpdate</code>中返回<code>false</code>，而不是跳过整个渲染过程，其中包括调用当前组件和下面的<code>render()</code>。</p>
<h2 id="shouldComponentUpdate的应用"><a href="#shouldComponentUpdate的应用" class="headerlink" title="shouldComponentUpdate的应用"></a>shouldComponentUpdate的应用</h2><p>这里是一个组件的子树。对于其中每一个子树来说，<code>SCU</code>指示<code>shouldComponentUpdate</code>返回什么，<code>vDOMEq</code>指示渲染的React元素是否相等。 最后，圆圈的颜色表示组件是否必须重新处理。</p>
<p><img src="https://segmentfault.com/img/bVGXZA?w=977&h=692"></p>
<p>因为<code>shouldComponentUpdate</code>对于以C2为根的子树返回了<code>false</code>，所以React没有尝试渲染C2，因此甚至不必在C4和C5上调用<code>shouldComponentUpdate</code>。</p>
<p>对于C1和C3，<code>shouldComponentUpdate</code>返回true，因此React必须下到子树中并检查它们。对于C6子树<code>shouldComponentUpdate</code>返回<code>true</code>，并且因为渲染的元素不是相同的，React不得不更新DOM。</p>
<p>最后一个有趣的例子是C8。React不得不渲染这个组件，不过由于React元素返回的元素等于之前渲染的元素，所以它不必更新DOM。</p>
<p>注意，React只需要做C6的DOM重新处理，这是不可避免的。<br>对于C8，它通过比较渲染的React元素来决定是否重新处理DOM。至于C2的子树和C7，我们在<code>shouldComponentUpdate</code>返回<code>false</code>时它甚至都不需要比较元素，并且也没有调用<code>render()</code>。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如果你的组件的唯一的改变方式就是改变<code>props.color</code>或<code>state.count</code>，你可以用<code>shouldComponentUpdate</code>检查：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.click = <span class="built_in">this</span>.click.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">            count: prevState.count + <span class="number">1</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.props.color !== nextProps.color) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state.count !== nextState.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button color=&#123;<span class="built_in">this</span>.props.color&#125; onClick=&#123;<span class="built_in">this</span>.click&#125;&gt;</span><br><span class="line">                Count：&#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;CounterButton color=<span class="string">&quot;blue&quot;</span>/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>shouldComponentUpdate</code>只是检查<code>props.color</code>或<code>state.count</code>是否有任何变化。如果它们的值没有更改，则组件不更新。 如果你的组件比这个例子中的组件更复杂，你可以使用类似的模式在props和state的所有字段之间做一个<code>“浅比较”</code>，以确定组件是否应该更新。</p>
<p>比较常见的模式是使用React提供的一个帮助对象来使用这个逻辑，可以直接继承<code>React.PureComponent</code>。所以上面这段代码有一个更简单的方法来实现同样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.click = <span class="built_in">this</span>.click.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">            count: prevState.count + <span class="number">1</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button color=&#123;<span class="built_in">this</span>.props.color&#125; onClick=&#123;<span class="built_in">this</span>.click&#125;&gt;</span><br><span class="line">                Count: &#123;<span class="built_in">this</span>.state.count&#125;</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;CounterButton color=<span class="string">&quot;blue&quot;</span>/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>大多数时候，你可以使用<code>React.PureComponent</code>而不是编写自己的<code>shouldComponentUpdate</code>。 它只做一个浅层的比较，所以你不需要直接使用它，如果你的组件内部<code>props</code>或<code>state</code>的数据有可能会<code>突然变化</code>，那么<code>浅比较</code>将失效。</p>
<p><code>浅比较</code>的失效可能是一个更加复杂的数据结构问题<code>(突然变化)</code>。 例如，假设您想要一个以逗号分隔单词列表的<code>ListOfWords</code>组件，使用一个父<code>WordAdder</code>组件，当你单击一个按钮用来添加一个单词到列表中时。 下面的代码将无法正常工作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PureComponent在内部会帮我们对props和state进行简单对比(浅比较)</span></span><br><span class="line"><span class="comment">// 值类型比较值，引用类型比较引用，但是不会比较引用类型的内部数据是否改变。</span></span><br><span class="line"><span class="comment">// 所以就会出现一个bug，不管你怎么点button，div是不会增加的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListOfWords</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.words.join(&#x27;,&#x27;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordAdder</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">words</span>: [<span class="string">&#x27;zhangyatao&#x27;</span>]&#125;;</span><br><span class="line">        <span class="built_in">this</span>.click = <span class="built_in">this</span>.click.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这么写是不对的，因为state的更新是异步的，所以可能会导致一些不必要的bug</span></span><br><span class="line">        <span class="keyword">const</span> words = <span class="built_in">this</span>.state.word;</span><br><span class="line">        words.push(<span class="string">&#x27;zhangyatao&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">words</span>: words&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.click&#125; /&gt;</span><br><span class="line">                &lt;ListOfWords words=&#123;<span class="built_in">this</span>.state.words&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题是<code>PureComponent</code>将对<code>this.props.words</code>的旧值和新值进行简单比较。 由于这个代码在<code>WordAdder</code>的<code>click</code>方法中改变了单词数组，所以即使数组中的实际单词已经改变，<code>ListOfWords</code>组件中的<code>this.props.words</code>的旧值和新值还是相等的。因此即便<code>ListOfWords</code>具有要被渲染出来的新单词它也还是不更新任何内容。</p>
<h2 id="超能力之『不会突然变化的数据』"><a href="#超能力之『不会突然变化的数据』" class="headerlink" title="超能力之『不会突然变化的数据』"></a>超能力之『不会突然变化的数据』</h2><p>避免此问题的最简单的方法就是避免将那些可能突然变化的数据作为你的<code>props</code>或<code>state</code>。例如，上面的<code>click</code>方法里面使用<code>concat</code>代替<code>push</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">        count: prevState.words.concat([<span class="string">&#x27;zhangyatao&#x27;</span>])</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6支持数组的<code>spread</code>语法可以让这变得更容易。如果您使用的是<code>Create React App</code>，那么此语法默认可以使用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">        words: [...prevState.words, <span class="string">&#x27;zhangyatao&#x27;</span>]</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以把那部分有可能突然变化的数据的代码按照上面的方式给重写下，从而以避免这种问题。 </p>
<p>例如，假设我们有一个名为<code>colormap</code>的对象，我们要写一个函数，将<code>colormap.right</code>改为<code>&#39;blue&#39;</code>。 我们可以写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(colormap, &#123;<span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将上面的代码写成不会濡染改变的对象，我们可以使用<code>Object.assign</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(colormap, &#123;<span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateColorMap</code>现在会返回一个新对象，而不是改变之前的旧对象。 <code>Object.assign</code>在ES6中，需要<code>polyfill</code>。</p>
<p>有一个<code>JavaScript</code>提议来添加对象<code>spread</code>属性，以便不会突然变化的更新对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;...colormap, <span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>Create React App</code>，默认情况下<code>Object.assign</code>和对象<code>spread</code>语法都可用。</p>
<h2 id="使用不突变的数据结构"><a href="#使用不突变的数据结构" class="headerlink" title="使用不突变的数据结构"></a>使用不突变的数据结构</h2><p><code>Immutable.js</code>是另一种解决这个问题的方法。它提供不可变的，持久的集合，通过结构共享工作：</p>
<ul>
<li><p>不可变：一旦创建，集合不能在另一个时间点更改。</p>
</li>
<li><p>持久性：可以从先前的集合和类集合的突变中创建处一个新集合。创建新集合后，原始集合仍然有效。</p>
</li>
<li><p>结构共享：使用尽可能多的与原始集合相同的结构创建新集合，从而将最低程度的减少复制来提高性能。</p>
</li>
</ul>
<h1 id="不使用ES6编写React应用"><a href="#不使用ES6编写React应用" class="headerlink" title="不使用ES6编写React应用"></a>不使用ES6编写React应用</h1><p>通常你可以使用一个JavaScript的class功能来定义一个React组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要是你还没有使用ES6的话，你就得使用<code>React.createClass</code>来创建一个组件了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeting = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用ES6的<code>class</code>来创建一个组件有点类似于<code>React.createClass</code>，但是会有一些例外。</p>
<h2 id="定义PropTypes和Props默认值"><a href="#定义PropTypes和Props默认值" class="headerlink" title="定义PropTypes和Props默认值"></a>定义PropTypes和Props默认值</h2><p>对于<code>功能性组件</code>和通过ES6的<code>class</code>创建的<code>类组件</code>，<code>propTypes</code>和<code>defaultProps</code>都可以定义组件的自身属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">Greeting.propTypes = &#123;</span><br><span class="line">    name: React.PropTypes.string.isRequired</span><br><span class="line">&#125;</span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangyatao&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>React.createClass</code>,你需要在传递的对象上定义一个<code>propTypes</code>的属性和一个<code>getDefaultProps()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeting = React.createClass(&#123;</span><br><span class="line">    propTypes: &#123;</span><br><span class="line">        name: React.PropTypes.name.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangyatao&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="设置初始化state"><a href="#设置初始化state" class="headerlink" title="设置初始化state"></a>设置初始化state</h2><p>在ES6的<code>class</code>中，你只需要在构造函数中通过<code>this.state</code>设置初始化<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangyatao&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>React.createClass</code>，你需要写一个单独的方法<code>getInitialState()</code>来返回初始化的<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeting = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangyatao&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="设置初始化state-1"><a href="#设置初始化state-1" class="headerlink" title="设置初始化state"></a>设置初始化state</h2><p>在ES6的<code>class</code>中，你只需要在构造函数中通过<code>this.state</code>设置初始化<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangyatao&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>React.createClass</code>，你需要写一个单独的方法<code>getInitialState()</code>来返回初始化的<code>state</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeting = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangyatao&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="自动绑定this"><a href="#自动绑定this" class="headerlink" title="自动绑定this"></a>自动绑定this</h2><p>在通过ES6的<code>class</code>定义的组件中，内部方法必须与ES6的<code>class</code>保持相同的语义。这意味着它们不会自动将<code>this</code>绑定到当前实例。 你必须在构造函数中明确使用<code>.bind(this)</code>来绑定<code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowMyName</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;zhangyatao&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.showName = <span class="built_in">this</span>.showName.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.showName&#125;&gt;</span><br><span class="line">                打印我的名字</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>React.createClass</code>你就不需要给每个内部方法绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ShowName = React.createClass(&#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangyatao&#x27;</span>,</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showName&#125;</span>&gt;</span>打印我的名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这意味着编写通过ES6的<code>class</code>定义的组件，会写一些更多的代码用于处理内部方法（就像一些事件处理函数）中的<code>this</code>，但是好在大型的应用中上面的那种写法性能略好。</p>
<p>如果代码这么写的话太不吸引你，你大可以在使用Babel时启用那些处于<code>实验阶段（stage-2）</code>的<code>类属性</code>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowName</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;zhangyatao&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用箭头函数，因为剪头函数会直接绑定this</span></span><br><span class="line">    click = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.click&#125;</span>&gt;</span>打印我的名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想安全地摆弄这些东西，你有几个选择：</p>
<ul>
<li><p>在构造函数中绑定<code>this</code>关键字</p>
</li>
<li><p>使用箭头函数,就像例子中的<code>click = () =&gt; &#123;console.log(&#39;我的名字是&#39;, this.name)&#125;</code></p>
</li>
<li><p>一直使用<code>React.createClass</code></p>
</li>
</ul>
<h2 id="混合-mixins-属性"><a href="#混合-mixins-属性" class="headerlink" title="混合(mixins)属性"></a>混合(mixins)属性</h2><blockquote>
<p><strong>note：</strong><br/><br>ES6对<code>mixins</code>没有任何支持。 因此，在使用ES6的<code>class</code>编写React组件时，不支持<code>mixins</code>。<br><strong>我在代码中使用<code>mixins</code>时发现了许多问题，因此不建议在新代码中使用。</strong></p>
</blockquote>
<p>有时，一些不同的组件需要共享一些常见的功能。一般称为<code>横切</code>。<code>React.createClass</code>允许你使用一个<code>mixins</code>属性来实现这个需求。</p>
<p>一个比较常见的用例就是你希望通过一定的时间间隔来更新组件自身。 </p>
<p>这很容易使用<code>setInterval()</code>来实现，但重要的是当你不再需要它的时候如何取消<code>setInterval</code>来节省内存。 </p>
<p>React提供了<code>生命周期函数</code>，让你知道具体在什么时候去创建或销毁组件。下面让我们创建一个简单的<code>mixins</code>，这些方法提供一个简单的<code>setInterval()</code>，当你的组件被销毁时，它会自动清理<code>setInterval</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SetIntervalMixin =&#123;</span><br><span class="line">    <span class="comment">// 组件将要被装载到DOM中</span></span><br><span class="line">    componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.intervals = [];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">setInterval</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.intervals.push(<span class="built_in">setInterval</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 组件将要从DOM中卸载</span></span><br><span class="line">    componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.intervals.forEach(<span class="built_in">clearInterval</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TickTock = React.createClass(&#123;</span><br><span class="line">    <span class="comment">// 更新mixins</span></span><br><span class="line">    mixins: [SetIntervalMixin],</span><br><span class="line">    <span class="comment">// 获取并设置默认state</span></span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">seconds</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 组件已经被加载到DOM中</span></span><br><span class="line">    componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setInterval(<span class="built_in">this</span>.tick, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    tick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">seconds</span>: prevState.seconds + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>已经运行了&#123;this.state.seconds&#125;秒<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;TickTock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果一个组件使用多个<code>mixins</code>，并且一些<code>mixins</code>定义了相同的生命周期函数（即，当组件被销毁时，一些<code>mixins</code>想要做一些清理），所有的生命周期函数保证都可以被调用到。 React会列出在mixins中运行的那些在公共mixins上定义的方法，然后在组件上依次调用这些方法。</p>
<h1 id="不使用JSX编写React应用"><a href="#不使用JSX编写React应用" class="headerlink" title="不使用JSX编写React应用"></a>不使用JSX编写React应用</h1><p>React并不是强制要求使用JSX来编写应用。 当您不想在构建时设置并编译JSX，那么在开发阶段只是单独使用React而不去使用JSX会让应用在构建时变得特别方便。</p>
<p>每个JSX元素只是调用<code>React.createElement(component，props，... children)</code>的语法糖。 所以，你用JSX做的任何事也可以使用纯Javascript来完成。</p>
<p>例如，使用JSX编写一个组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello zhangyatao<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>上面这段代码会被编译为下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> React.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello zhangyatao&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>如果你很想看到更多的JSX如何转换成JavaScript的例子，你可以试试在线Babel编译器。</p>
<p>组件可以是一个字符串，也可以是继承了<code>React.Component</code>的子类，或者是一个没有内部状态的纯函数。</p>
<p>如果您不喜欢一直重复地写<code>React.createElement</code>，可以使用一个变量代替它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> makeE = React.createElement;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    makeE(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello zhangyatao&#x27;</span>),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果您在使用<code>React.createElement</code>时用了这种方式，那么即便不使用JSX来编写React也是很方便的。</p>
<h1 id="彻底理解React如何重新处理DOM-Diffing算法"><a href="#彻底理解React如何重新处理DOM-Diffing算法" class="headerlink" title="彻底理解React如何重新处理DOM(Diffing算法)"></a>彻底理解React如何重新处理DOM(Diffing算法)</h1><p>React提供了一个声明式的API，所以你不必担心每次DOM更新时内部会修改哪些东西。虽然在React中并不是那么明显地告诉你具体如何实现的，不过这也让编写应用变得更加容易。</p>
<p>本文会详细解释在React中的<code>“diffing”</code>算法是怎么做的，以便组件更新是可预测的，从而让高性能应用变得足够快。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>当使用React时，在单个时间点，您可以将<code>render()</code>函数看做是在创建React元素树。 在下一个<code>state</code>或<code>props</code>更新时<code>render()</code>函数将返回一个不同的React元素树。 React需要弄清楚如何高效地更新UI去匹配上最新的元素树。</p>
<p>对于将一个树变换成另一个树的最小操作数的算法问题，现在已经存在一些比较通用的解决方案。 然而，那些现有的最先进的技术算法都有<code>O(n^3)</code>的复杂度（n是树中的元素的数量）。</p>
<p>如果在React中使用这些算法，显示1000个元素将需要大约十亿次比较。 这个真的代价太昂贵了。 相反，React实现了一个<code>基于两个假设</code>直观推断出的O(n)算法：</p>
<ul>
<li><p>不同类型的两个元素将产生不同的树。</p>
</li>
<li><p>开发人员可以在不同渲染之间使用<code>key</code>属性来表示哪些子元素是稳定的。</p>
</li>
</ul>
<p>实际上，这两条假设对几乎所有的实际使用都是有效的。</p>
<h2 id="Diffing算法"><a href="#Diffing算法" class="headerlink" title="Diffing算法"></a>Diffing算法</h2><p>当比较两棵DOM树的差异时，React首先比较两个根元素。如果根元素的类型不同，那么行为也是不同的。</p>
<h3 id="不同类型的DOM元素"><a href="#不同类型的DOM元素" class="headerlink" title="不同类型的DOM元素"></a>不同类型的DOM元素</h3><p>每当根元素是不同的类型时，React将删除旧的DOM树并从头开始重新构建新的DOM树。 从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>、从<code>&lt;Article&gt;</code>到<code>&lt;Comment&gt;</code>、从<code>&lt;Button&gt;</code>到<code>&lt;div&gt;</code>，只要不一样就会完全重新构建。</p>
<p>当删除就的DOM树时，旧的DOM节点也被删掉。这个时候组件实例触发<code>componentWillUnmount()</code>函数 。当构建一个新的DOM树时，新的DOM节点会被插入到DOM中。组件实例触发<code>componentWillMoun()</code>和<code>componentDidMount()</code>。 与之前旧的DOM树相关联的任何<code>state</code>也都将丢失。</p>
<p>在根元素之下的任何组件将被卸载并且它们的<code>state</code>也会全部丢失。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Counter /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 变为</span></span><br><span class="line">&lt;span&gt;</span><br><span class="line">    &lt;Counter /&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>因为根元素从<code>div</code>变为了<code>span</code>，所以旧的<code>Counter</code>组件将被销毁，然后再重新构建一个新的。</p>
<h3 id="相同类型的DOM元素"><a href="#相同类型的DOM元素" class="headerlink" title="相同类型的DOM元素"></a>相同类型的DOM元素</h3><p>当比较相同类型的两个React DOM元素时，React会先查看两者的属性差异，然后保留相同的底层DOM节点，仅仅去更新那些被更改的属性。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;before&quot;</span> title=<span class="string">&quot;hello&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=<span class="string">&quot;after&quot;</span> title=<span class="string">&quot;hello&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>通过比较这两个元素属性，React就会知道只需要修改底层DOM节点上的<code>className</code>即可。</p>
<p>当更新<code>style</code>属性时，React也会知道只需要更新<code>style</code>中的那些已更改的属性。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">width</span>: <span class="string">&#x27;300px&#x27;</span>&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">width</span>: <span class="string">&#x27;400px&#x27;</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>当在这两个元素之间转换时，React知道只需修改<code>width</code>，而不是<code>color</code>。</p>
<p><strong>处理根DOM节点后，React会根据上面的判断逻辑对子节点进行递归扫描。</strong></p>
<h3 id="相同类型的组件元素"><a href="#相同类型的组件元素" class="headerlink" title="相同类型的组件元素"></a>相同类型的组件元素</h3><p>当组件更新时，实例保持不变，因此在不同的渲染之间组件内的<code>state</code>是保持不变的。React会更新底层组件实例的<code>props</code>来匹配新元素，并在底层实例上调用<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>。</p>
<p>接下来，调用<code>render()</code>方法，<code>diff</code>算法就会对上一个结果和新结果进行递归比较。</p>
<h3 id="递归子元素"><a href="#递归子元素" class="headerlink" title="递归子元素"></a>递归子元素</h3><p>默认情况下，当对DOM节点的子元素进行递归时，React只是同时迭代两个子元素lists，并在有差异时产生变化。</p>
<p>例如，当在子元素的末尾再添加一个元素时，这两个树之间就会有一个的很好转换效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;l1&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;two&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;two&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;three&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>React将匹配两个<code>&lt;li&gt;one&lt;/li&gt;</code>树，匹配两个<code>&lt;li&gt;two&lt;/li&gt;</code>树，然后插入一个<code>&lt;li&gt;three&lt;/li&gt;</code>树。</p>
<p>但是，不要太天真了。如果在子元素的开头部分插入一个元素的话，性能会便的很差。例如，这两棵树之间的转换效果就很差：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;two&lt;/li&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;zero&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;two&lt;/li&gt;</span><br><span class="line">&lt;ul&gt;</span><br></pre></td></tr></table></figure>
<p>这种情况React将更改每个子元素，而不会意识到它可以保持<code>&lt;li&gt;one&lt;/li&gt;</code>和<code>&lt;li&gt;two&lt;/li&gt;</code>子元素树完好无损。 这种低效率的情况是一个必须注意的问题。</p>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>为了解决上面的问题，React提供了一个<code>key</code>属性。当子元素有<code>key</code>属性时，React使用<code>key</code>将原始树中的子元素与后续树中的子元素进行匹配。例如，上面的那个低效例子添加一个<code>key</code>就可以让子元素树转换变的很有效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=<span class="string">&quot;1&quot;</span>&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li key=<span class="string">&quot;2&quot;</span>&gt;two&lt;/li&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li key=<span class="string">&quot;0&quot;</span>&gt;zero&lt;/li&gt;</span><br><span class="line">    &lt;li key=<span class="string">&quot;1&quot;</span>&gt;one&lt;/li&gt;</span><br><span class="line">    &lt;li key=<span class="string">&quot;2&quot;</span>&gt;two&lt;/li&gt;</span><br><span class="line">&lt;ul&gt;</span><br></pre></td></tr></table></figure>
<p>现在React就可以知道<code>key=&quot;0&quot;</code>的元素是新的，并且<code>key=&quot;1&quot;</code>和<code>key=&quot;2&quot;</code>的元素只需移动即可。</p>
<p>在实践中，使用一个唯一的<code>key</code>并不难。您要显示的元素可能已具有唯一的<code>ID</code>，因此<code>key</code>可以来自你自己的数据中：</p>
<p><code>&lt;li key=&#123;item.id&gt;&#123;item.name&#125;&lt;/li&gt;</code></p>
<p>如果不是这样，你可以向数据模型中给每一项数据添加一个新的<code>ID</code>属性，或者对内容的某些部分进行哈希生成<code>key</code>。 <code>key</code>属性只有在其兄弟元素之间是唯一的，并不是全局唯一的。</p>
<p>最后一种方式是可以将数组中的索引作为<code>key</code>。如果数组中的每一项不需要重新排序，同样也可以很好地工作，但是万一需要重新排序的话，这会变的很慢。</p>
<h2 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h2><p>要记住重要的是，<code>diffing</code>算法是一个具体的实现细节。React可以在每个操作上去重新渲染应用; 最终结果都是一样的。</p>
<p>在当前的实现中，你可以看到一个事实是一个子树已经成功移动到它的兄弟元素当中，但你不能告诉它已经移动到别的地方。 该算法将重新渲染这个完整的子元素树。</p>
<p>因为React很依赖这个直观推断的算法来判断DOM是否需要重新处理，如果不能满足这个算法的那两个假设条件前提，应用的性能将会受到很大影响。</p>
<ul>
<li><p>该算法不会去尝试匹配那些不同组件类型的子元素树。如果你看到自己在返回相似输出结果的两个组件类型之间来来回回，你可能需要把它们改为相同的类型组件。</p>
</li>
<li><p><code>key</code>属性应该是稳定，可预测和唯一的。不稳定的键(如使用<code>Math.random()</code>生的<code>key</code>)将导致许多组件实例和DOM节点进行不必要地重复创建，这可能导致子组件中的性能降低和<code>state</code>丢失。</p>
</li>
</ul>
<h1 id="用上下文管理应用"><a href="#用上下文管理应用" class="headerlink" title="用上下文管理应用"></a>用上下文管理应用</h1><p>使用React可以很容易通过React组件跟踪数据流。当你看到一个组件，你就可以看到哪些<code>props</code>正在传递，这使得你的应用很容易知道在做什么。</p>
<p>在某些情况下，你希望通过组件树传递数据，而不是在每个级别的中组件手动传递<code>props</code>，你可以直接在React中使用强大的<code>“context”</code>来做到这一点。</p>
<h2 id="为什么不去使用Context"><a href="#为什么不去使用Context" class="headerlink" title="为什么不去使用Context"></a>为什么不去使用Context</h2><p>绝大多数的应用不需要直接使用Context。</p>
<p>如果你希望你的应用是稳定的，那么就不要使用Context。 因为这是一个实验性质的API，它可能会在未来的React版本中移除。</p>
<p>如果你不熟悉state管理库如<code>Redux</code>或<code>MobX</code>，不要使用Context。对于许多实际的应用，这些state管理库和React一起使用来管理那些与组件相关的state一个很不错的选择。很多情况下使用<code>Redux</code>就可以解决你的问题，而不是使用Context。</p>
<p>如果你不是一个有经验的React开发人员，不要使用Context。使用<code>props</code>和<code>state</code>来实现功能是一个更好的方法。</p>
<p>尽管有上面这些警告你还坚持使用Context，那么请将Context单独隔离到一个小区域中，并尽可能地避免直接使用Context，以便在这个API更改时应用能更容易升级。</p>
<h2 id="如何使用Context"><a href="#如何使用Context" class="headerlink" title="如何使用Context"></a>如何使用Context</h2><p>假设你有一个结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> style = &#123;<span class="attr">backgroundColor</span>: <span class="built_in">this</span>.props.color&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.text&#125;</span><br><span class="line">                &lt;MyButton color=&#123;<span class="built_in">this</span>.props.color&#125;&gt;删除&lt;/MyButton&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> children = <span class="built_in">this</span>.props.messages.map(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">text</span>=<span class="string">&#123;msg&#125;</span> <span class="attr">color</span>=<span class="string">&#123;color&#125;/</span>&gt;</span></span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">&#x27;zhangyato&#x27;</span>, <span class="string">&#x27;Re: zhangyatao&#x27;</span>, <span class="string">&#x27;Re:Re:zhangyatao&#x27;</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MessageList messages=&#123;messages&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们手动传入一个<code>color</code> props进行传递，以便适当地设置<code>MyButton</code>和<code>Message</code>组件的样式。使用Context，我们可以让<code>color</code>自动在组件树中传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> style = &#123;<span class="attr">backgroundColor</span>: <span class="built_in">this</span>.context.color&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyButton.contextTypes = &#123;</span><br><span class="line">    color: React.PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.text&#125;</span><br><span class="line">                &lt;MyButton&gt;删除&lt;/MyButton&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = <span class="built_in">this</span>.props.messages.map(<span class="function"><span class="params">msg</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">text</span>=<span class="string">&#123;msg&#125;/</span>&gt;</span></span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MessageList.childContextTypes = &#123;</span><br><span class="line">    color: React.PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">&#x27;zhangyato&#x27;</span>, <span class="string">&#x27;Re: zhangyatao&#x27;</span>, <span class="string">&#x27;Re:Re:zhangyatao&#x27;</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MessageList messages=&#123;messages&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>通过向<code>MessageList</code>（Context提供者）添加<code>childContextTypes</code>和<code>getChildContext</code>，React就会自动传递Context信息，子组件树中的任何组件（<code>Button</code>）都可以通过定义<code>contextTypes</code>来访问它。</p>
<p>如果未定义<code>contextTypes</code>，那么Context将是一个空对象。</p>
<h2 id="父子组件之间的耦合"><a href="#父子组件之间的耦合" class="headerlink" title="父子组件之间的耦合"></a>父子组件之间的耦合</h2><p>Context还可以让你实现父组件和子组件之间的交互。例如，以这种方式工作的一个比较知名的库为<code>React Router V4</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RouterExample = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                 &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">                 &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/recyclebin&quot;</span>&gt;</span>回收站<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">                 &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/timeline&quot;</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">            &lt;hr /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Match exactly pattern=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">            &lt;Match pattern=<span class="string">&quot;/recyclebin&quot;</span> component=&#123;RecycleBin&#125; /&gt;</span><br><span class="line">            &lt;Match pattern=<span class="string">&quot;/timeline&quot;</span> component=&#123;TimeLine&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过从<code>RouterExample</code>组件传递一些信息，每个<code>Link</code>和<code>Match</code>可以回传到包含的<code>Router</code>中。</p>
<p>在使用类似于此的API进行构建组件之前，请考虑是否有更好的替代品。例如，你可以传递整个React组件作为props。</p>
<h2 id="生命周期方法中使用Context"><a href="#生命周期方法中使用Context" class="headerlink" title="生命周期方法中使用Context"></a>生命周期方法中使用Context</h2><p>如果在一个组件中定义了<code>contextTypes</code>，则以下生命周期方法将多接收个参数，就是Context对象：</p>
<ul>
<li><p><code>constructor(props, context)</code></p>
</li>
<li><p><code>componentWillReceiveProps(nextProps, nextContext)</code></p>
</li>
<li><p><code>shouldComponentUpdate(nextProps, nextState, nextContext)</code></p>
</li>
<li><p><code>componentWillUpdate(nextProps, nextState, nextContext)</code></p>
</li>
<li><p><code>componentDidUpdate(prevProps, prevState, prevContext)</code></p>
</li>
</ul>
<h2 id="在无状态功能性组件中使用Context"><a href="#在无状态功能性组件中使用Context" class="headerlink" title="在无状态功能性组件中使用Context"></a>在无状态功能性组件中使用Context</h2><p>如果<code>contextTypes</code>被定义为无状态功能性组件的属性，无状态功能性组件也能够引用Context。 下面的代码显示了被写成一个无状态的功能组件的<code>MyButton</code>组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyButton</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> children = props.children;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         &lt;button style=&#123;&#123;<span class="attr">backgroundColor</span>: context.color&#125;&#125;&gt;</span><br><span class="line">             &#123;children&#125;</span><br><span class="line">         &lt;/button&gt;</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br><span class="line">MyButton.contextTypes = &#123;</span><br><span class="line">    color: React.PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="更新Context"><a href="#更新Context" class="headerlink" title="更新Context"></a>更新Context</h2><p><strong>千万不要这么做！！！</strong></p>
<p>React有一个API来更新Context，但它从根本上破坏了Context，所以你不应该使用它。</p>
<p>当state或props改变时，<code>getChildContext</code>函数将被调用。为了更新Context中的数据，使用<code>this.setState()</code>触发组件内的state更新。这也将触发一个新的Context，并且Context改变的内容也会被子组件接收到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaType</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>type is &#123;this.context.type&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MediaType.contextTypes = &#123;</span><br><span class="line">    type: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaQuery</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">type</span>: <span class="string">&#x27;PC端&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.checkMediaQuery = <span class="built_in">this</span>.checkMediaQuery.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="built_in">this</span>.state.type&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">checkMediaQuery</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> type = <span class="built_in">window</span>.matchMedia(<span class="string">&#x27;&lt;code&gt;zhangyatao&lt;/code&gt;(max-width: 760px)&#x27;</span>).matches ? <span class="string">&#x27;移动端&#x27;</span> : <span class="string">&#x27;PC端&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">type</span>: type&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="built_in">this</span>.checkMediaQuery, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">this</span>.checkMediaQuery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MediaQuery.childContextTypes = &#123;</span><br><span class="line">    type: React.PropTypes.string</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MediaQuery&gt;</span><br><span class="line">        &lt;MediaType /&gt;</span><br><span class="line">    &lt;/MediaQuery&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>问题是，Context的值通过组件更新来提供，如果中间的父组件在<code>shouldComponentUpdate()</code>返回false，那么使用该Context值的后代组件永远不会被更新。使用Context完全不受组件的控制，所以基本上没有办法可靠地更新Context。这篇文章很好的解释了为什么这是一个问题，以及你应该如何摆脱它。</p>
<h1 id="React顶级API"><a href="#React顶级API" class="headerlink" title="React顶级API"></a>React顶级API</h1><p>全局变量<code>React</code>是React库的入口。如果你通过一个script标签使用的React，那么它的顶级API都会在全局环境下一个名称为React的变量上。如果你是通过npm使用的ES6，你可以这样写：<code>import React from &#39;react&#39;</code>;。你是通过npm使用的ES5，你可以这样写<code>var React = require(&#39;react&#39;);</code>。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>React组件可以让你将UI部分独立出来，成为可重用的部分。从而单独考虑分离出来的每一部分功能。可以通过<code>React.Component</code>或者<code>React.PureComponent</code>来创建React组件。</p>
<ul>
<li><p>React.Component</p>
</li>
<li><p>React.PureComponent</p>
</li>
</ul>
<p>如果你不是用ES6的class功能,你可以使用以下代替:</p>
<ul>
<li>React.createClass()</li>
</ul>
<h3 id="创建一个React元素"><a href="#创建一个React元素" class="headerlink" title="创建一个React元素"></a>创建一个React元素</h3><p>我们推荐使用JSX来定义UI。每个JSX元素都是<code>React.createElement(component, props, children)</code>的语法糖。使用<code>JSX</code>就意味着你不需要直接调用下面的方法:</p>
<ul>
<li><p>React.createElement()</p>
</li>
<li><p>React.createFactory()</p>
</li>
</ul>
<h3 id="处理React元素"><a href="#处理React元素" class="headerlink" title="处理React元素"></a>处理React元素</h3><p><code>React</code>同时还为处理元素提供了一些其他APIs:</p>
<ul>
<li><p>React.cloneElement()</p>
</li>
<li><p>React.isValidElement()</p>
</li>
<li><p>React.Children</p>
</li>
</ul>
<h3 id="使用PropTypes进行类型检测-1"><a href="#使用PropTypes进行类型检测-1" class="headerlink" title="使用PropTypes进行类型检测"></a>使用PropTypes进行类型检测</h3><p>你可以使用<code>React.PropTypes</code>为一个组件上的props进行类型检测。</p>
<ul>
<li><p>React.PropTypes</p>
</li>
<li><p>React.PropTypes.array</p>
</li>
<li><p>React.PropTypes.bool</p>
</li>
<li><p>React.PropType.func</p>
</li>
<li><p>React.PropTypes.number</p>
</li>
<li><p>React.PropTypes.object</p>
</li>
<li><p>React.PropTypes.string</p>
</li>
<li><p>React.PropTypes.symbol</p>
</li>
<li><p>React.PropTypes.node</p>
</li>
<li><p>React.PropTypes.element</p>
</li>
<li><p>React.PropTypes.instanceOf()</p>
</li>
<li><p>React.PropType.oneOf()</p>
</li>
<li><p>React.PropType.oneOfType()</p>
</li>
<li><p>React.PropType.arrayOf()</p>
</li>
<li><p>React.PropType.objectOf()</p>
</li>
<li><p>React.PropTypes.shape()</p>
</li>
<li><p>React.PropTypes.any</p>
</li>
</ul>
<p>以上的验查器默认都是可选的。你可以使用<code>isRequired</code>来标记一个必填属性。如果用户没有根据指定类型传入props或者压根没有传入props的话则会给出一个错误提示。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如果你使用了<code>react-with-addons.js</code>,那么React组件可以通过变量<code>React.addons</code>使用。</p>
<ul>
<li>React.addons</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h3><p><code>React.Component</code>是所有React组件的基类,当使用ES6 <code>classes</code>定义一个组件的用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Greeting name=&#123;<span class="string">&quot;zhangyatao&quot;</span>&#125;/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root)</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
<h3 id="React-PureComponet"><a href="#React-PureComponet" class="headerlink" title="React.PureComponet"></a>React.PureComponet</h3><p><code>React.PureComponent</code>表面上很像<code>React.Component</code>,但是它实现了<code>shouldComponentUpdate()</code>对<code>props</code>和<code>state</code>的进行浅比较。</p>
<p>如果你React组件的<code>render()</code>方法每次使用相同的props和state并且渲染出相同的结果。这种情况你可以使用<code>React.PureComponent</code>来提升性能。</p>
<blockquote>
<p>提示<br/><br>React.PureComponent的shouldComponentUpdate()仅会对对象进行浅比较,如果对象包含复杂的数据结构,对于深层次的差异有可能会产生false-negatives(假阴性,相当于医院中的错诊)。</p>
</blockquote>
<h3 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass()"></a>React.createClass()</h3><p><code>React.createClass(specification)</code></p>
<p>如果你还没有使用ES6,你可以使用<code>React.createClass()</code>来创建一个组件类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Greeting = React.createClass(&#123;</span><br><span class="line">    setInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement()"></a>React.createElement()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.ceateElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>通过传入的类型和属性以及子元素来创建并返回一个新的<code>React元素</code>。其中type参数可以传入一个html标签名称字符串(例如’div’或者’span’)，或者传入一个<code>React组件</code>(一个类组件或功能性组件)。</p>
<p><code>React.DOM</code>提供了DOM组件可以比较便捷地通过<code>React.createElement()</code>包装的方法。例如，<code>React.DOM.a(...)</code>就是<code>React.createElement(&#39;a&#39;,...)</code>的便捷包装。这种方法可以是历史版本遗留产物，所以我们推荐你是用JSX或者使用<code>React.createElement()</code>来直接代替。</p>
<p>使用JSX写的代码会被转换为<code>React.createElement()</code>。如果你使用了JSX的话，通常不需要直接调用<code>React.createElement()</code>。</p>
<h3 id="React-cloneElement"><a href="#React-cloneElement" class="headerlink" title="React.cloneElement()"></a>React.cloneElement()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">    element,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>传入一个React元素进行克隆并返回一个新的React元素。</p>
<h3 id="React-createFactory"><a href="#React-createFactory" class="headerlink" title="React.createFactory()"></a>React.createFactory()</h3><p><code>React.createFactory(type)</code></p>
<p>返回一个生成给定类型的React元素的函数。就像<code>React.createElement()</code>，其中type参数可以传入一个html标签名称字符串(例如’div’或者’span’)，或者传入一个<code>React组件</code>类型(一个类型组件或功能性组件)。</p>
<p>这种方法可以是一个历史版本遗留产物，我们推荐你是用JSX或者使用<code>React.createElement()</code>来直接代替。</p>
<p>使用JSX写的代码会被转换为<code>React.createElement()</code>。如果你使用了JSX的话，通常不需要直接调用<code>React.createElement()</code>。</p>
<h3 id="React-isValidElement"><a href="#React-isValidElement" class="headerlink" title="React.isValidElement()"></a>React.isValidElement()</h3><p><code>React.isValidElement(Object)</code></p>
<p>验证一个对象是否是React元素，返回<code>true</code>或者<code>false</code>。</p>
<h3 id="React-Children"><a href="#React-Children" class="headerlink" title="React.Children"></a>React.Children</h3><p>React.children提供了处理<code>this.props.children</code>中那些不透明的数据结构的一些工具函数。</p>
<p>React.Children.map</p>
<p><code>React.Children.map(children, function[(thisArg))</code></p>
<h3 id="React-Children-forEach"><a href="#React-Children-forEach" class="headerlink" title="React.Children.forEach"></a>React.Children.forEach</h3><p><code>React.Children.forEach(children, function[(thisArg)])</code></p>
<p>和<code>React.Children.map</code>相同，只不过不会返回一个数组。</p>
<h3 id="React-Children-count"><a href="#React-Children-count" class="headerlink" title="React.Children.count"></a>React.Children.count</h3><p><code>React.Children.count(children)</code></p>
<p>返回children中的组件总数。</p>
<p>React.Children.only</p>
<p><code>React.Children.only(children)</code></p>
<p>然会children中的只出现一次的子元素。否则抛出。</p>
<p>React.Children.toArray</p>
<p><code>React.Children.toArray(children)</code></p>
<p>将子元素中的不透明数据结构作为一个一维数组返回。如果你想在<code>render</code>方法中操作children集合，特别是如果你想在传递它之前重新排序或切割<code>this.props.children</code>，这歌方法将非常有用。</p>
<h3 id="React-PropTypes-1"><a href="#React-PropTypes-1" class="headerlink" title="React.PropTypes"></a>React.PropTypes</h3><p><code>React.PropTypes</code>是一系列类型验证器的集合，可以与组件的propTypes对象一起使用，以验证传递到组件的props。</p>
<p><code>React.PropTypes.array</code></p>
<p>验证prop是一个数组类型。</p>
<p><code>React.PropTypes.bool</code></p>
<p>验证prop是一个布尔值。</p>
<p><code>React.PropTypes.func</code></p>
<p>验证prop是一个函数。</p>
<p><code>React.PropTypes.number</code></p>
<p>验证prop是一个数字。</p>
<p><code>React.PropTypes.object</code></p>
<p>验证prop是一个对象。</p>
<p><code>React.PropTypes.string</code></p>
<p>验证prop是一个字符串。</p>
<p><code>React.PropTypes.symbol</code></p>
<p>验证prop是一个symbol。</p>
<p><code>React.PropTypes.node</code></p>
<p>验证prop是一个可以渲染的东西：数字，字符串，元素 或者包含这些类型的数组（或片段）。</p>
<p><code>React.PropTypes.element</code></p>
<p>验证prop是一个React元素。</p>
<p><code>React.PropTypes.instanceOf(class)</code></p>
<p>验证prop是否是class的实例，使用Javascript中的instaceof操作符。</p>
<p><code>React.PropTypes.oneOf(arrayOfValues)</code></p>
<p>通过将其视为枚举来验证prop是否受限于特定值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    optionalEnum: React.PropTypes.oneOf([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes.oneOfType()</code></p>
<p>验证prop是可以是多种类型之一的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">        React.PropTypes.string,</span><br><span class="line">        React.PropTypes.number,</span><br><span class="line">        React.PropTypes.instanceOf(Message)</span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes.arrayOf(propType)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证porp是一个特定类型的数组。</p>
<p><code>React.PropTypes.objectOf(propType)</code></p>
<p>验证prop是具有某个类型的属性值的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes.shape(object)</code></p>
<p>验证prop是采取特定形状的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">        color: React.PropTypes.string,</span><br><span class="line">        fontSize: React.PropTypes.number</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.PropTypes.any</code></p>
<p>验证prop具有任何数据类型的值。 通常后面是<code>isRequired</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>propTypes.isRequired</code></p>
<p>您可以使用isRequired链接上述任何验证器，以确保在未提供prop的情况下显示警告。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">    requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.addons</code></p>
<p><code>React.addons</code>导出一系列附加组件，只有在使用<code>react-with-addons.js</code>时才可用。</p>
<h1 id="React-Component用法"><a href="#React-Component用法" class="headerlink" title="React.Component用法"></a>React.Component用法</h1><p><code>组件(Components)</code>允许您将UI拆分为独立的可重用的部分，并单独的考虑每个部分。</p>
<h2 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h2><p><code>React.Component</code>是一个抽象基类。这意味着直接引用<code>React.Component</code>是毫无意义的。你可以实现一个它的子类，并且至少定义一个<code>render()</code>方法即可使用。</p>
<p>你可以使用ES6中<code>class</code>定义一个React组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;<span class="built_in">this</span>.props.name&#125;&lt;/hr&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你还没有使用ES6，你可以使用<code>React.createClass()</code>。</p>
<h2 id="组件的生命周期方法"><a href="#组件的生命周期方法" class="headerlink" title="组件的生命周期方法"></a>组件的生命周期方法</h2><p>每个组件都有几个『生命周期方法』，您可以重写这些方法，已便在React执行过程中的指定时间运行自己的代码。前缀为<code>Will</code>的生命周期方法会在在一些事情发生之前被调用，带有<code>Did</code>前缀的方法在某些事情发生之后被调用。</p>
<p><strong>Mounting(加载组件)</strong></p>
<p>当创建组件的实例并将其插入DOM时，会依次调用这些方法：</p>
<ul>
<li><p>constructor()</p>
</li>
<li><p>componentWillMount()</p>
</li>
<li><p>render()</p>
</li>
<li><p>componentDidMount()</p>
</li>
</ul>
<p><strong>Updating(更新状态)</strong></p>
<p>更新可以由prop或者state的改变引起。在重新渲染组件时依次调用这些方法：</p>
<ul>
<li><p>componentWillReceiveProps()</p>
</li>
<li><p>shouldComponentUpdate()</p>
</li>
<li><p>componentWillUpdate()</p>
</li>
<li><p>render()</p>
</li>
<li><p>componentDidUpdate()</p>
</li>
</ul>
<p><strong>Unmounting(卸载组件)</strong></p>
<p>当从DOM中删除组件时，将调用此方法：</p>
<ul>
<li>componentWillUnmount()</li>
</ul>
<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><p>每个组件还提供了一些其他API：</p>
<ul>
<li><p>setState()</p>
</li>
<li><p>forceUpdate()</p>
</li>
</ul>
<p>组件属性</p>
<ul>
<li><p>defaultProps</p>
</li>
<li><p>displayName</p>
</li>
<li><p>propTypes</p>
</li>
</ul>
<p>实例内部属性</p>
<ul>
<li><p>props</p>
</li>
<li><p>state</p>
</li>
</ul>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return React Elements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>render()</code>方法是必须写的。</p>
<p>当这个方法被调用时，它会检测<code>this.props</code>和<code>this.state</code>并返回一个React元素。此元素可以是本地DOM组件的形式，例如<code>&lt;div/&gt;</code>，也可以是您自己定义的一个复合组件。</p>
<p>你也可以返回<code>null</code>或<code>false</code>来表示你不想做任何渲染操作。当返回<code>null</code>或<code>false</code>时，<code>ReactDOM.findDOMNode(this)</code>将返回<code>null</code>。</p>
<p><code>render()</code>方法应该是纯的<code>(pure function</code>，见函数式编程)，这意味着它并不会修改组件state，每次调用它时都会返回相同的结果，它不会直接与浏览器交互。如果您需要与浏览器直接交互，请改用<code>componentDidMount()</code>方法或者其他生命周期方法来执行你的逻辑。保持<code>render()</code>的纯可以让组件更容易去思考自己应该做什么。</p>
<blockquote>
<p>提示<br>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，那么<code>render()</code>不会被执行。</p>
</blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><p><code>constructor(props)</code></p>
<p>在装载组件(mounting)之前调用会React组件的构造函数。当实现<code>React.Component</code>子类的构造函数时，应该在任何其他语句之前调用<code>super(props)</code>。否则，<code>this.props</code>将在构造函数中未定义，这可能导致错误。</p>
<p>构造函数是初始化state的标准位置。如果不初始化state，并且不绑定组件内部方法的this指向，则不需要为React组件实现构造函数。</p>
<p>如果你知道你在做什么的话，你可以根据props来初始化state。这里有一个有效的<code>React.Component</code>子类构造函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        color: props.initialColor</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这种模式，因为它会将props复制一份在state中，这就可能导致一个意外的bug。所以不应该将props复制到state中。相反，你需要使用<code>提升state</code>的技巧，该技巧我们在前面的文章提到过。</p>
<p>如果你使用props复制到state中，你还需要实现<code>componentWillReceiveProps(nextProps)</code>来保持state是最新的。这个时候使用提升state的方法反而会更容易，也能产生更少的bug。</p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p><code>componentWillMount()</code></p>
<p><code>componentWillMount()</code>是在装载(mounting)发生之前被调用。它在<code>render()</code>之前调用，所以在此方法中的设置state不会造成重新渲染。另外，应该避免在此方法中引入有任何<code>副作用的东西(见函数式编程)</code>。</p>
<p>在服务器渲染上这是唯一一个调用的生命周期钩子函数。一般来说，我们建议使用<code>constructor()</code>。</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p><code>componentDidMount()</code></p>
<p><code>componentDidMount()</code>在组件装载到DOM后立即调用。如果需要进行DOM节点的初始化则应该在这里来执行该逻辑。如果需要从远程端点加载数据(<code>ajax</code>)，那么这是处理网络请求的最好地方。在此方法中设置state会去重新渲染DOM。</p>
<h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps()"></a>componentWillReceiveProps()</h3><p><code>componentWillReceiveProps(nextProps)</code></p>
<p><code>componentWillReceiveProps()</code>在安装好的组件接收新props之前被调用。如果你需要更新state用来响应props的更改（例如，重置它），你可以在此方法中比较<code>this.props</code>和<code>nextProps</code>并使用this.setState()来替换并重置state。</p>
<p>注意，即使props没有改变，<code>React</code>也可以调用这个方法，因此如果你只想处理props改变的情况，请确保比较当前值和下一个值是否不同。当父组件引起你的组件重新渲染时，就有可能会发生这种情况。</p>
<p>如果你只是调用<code>this.setState()</code>，那么<code>componentWillReceiveProps()</code>不会被调用。</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h3><p><code>shouldComponentUpdate(nextProps, netState)</code></p>
<p>使用<code>shouldComponentUpdate()</code>让React知道组件是否受当前state或props变化的影响。 默认行为是在每次state更改时都会去重新渲染DOM，在绝大多数情况下，你应该依赖于这个默认行为。</p>
<p>当接收到新的props或state时，<code>shouldComponentUpdate()</code>在渲染之前被调用。 默认为<code>true</code>对于初始渲染或使用<code>forceUpdate()</code>，不调用此方法。</p>
<p>返回<code>false</code>不会阻止子组件在state更改时重新渲染。</p>
<p>目前，如果<code>shouldComponentUpdate()</code>返回<code>false</code>，那么将不会调用<code>componentWillUpdate()</code>，<code>render()</code>和<code>componentDidUpdate()</code>。 注意，在将来React可以将<code>shouldComponentUpdate()</code>作为提示而不是严格的操作指令，返回false仍然可能导致组件的重新渲染。</p>
<p>如果你确定某些组件在某些操作时有点缓慢，你可以让它继承<code>React.PureComponent</code>，而不是继承<code>React.Component</code>。</p>
<p><code>React.PureComponent</code>实现了<code>props</code>和<code>state</code>进行浅比较的<code>shouldComponentUpdate()</code>方法。 如果你确定想人肉处理这个浅比较操作，你可以自己在这个函数中比较<code>this.props和nextProps</code>、<code>this.state</code>和<code>nextState</code>是否相同。相同返回false，不同返回true，那么React就会根据返回值来确认是否跳过本次DOM渲染。</p>
<h3 id="componentWilUpdate"><a href="#componentWilUpdate" class="headerlink" title="componentWilUpdate()"></a>componentWilUpdate()</h3><p><code>componentWillUpdate(nextProps, nextState)</code></p>
<p>当组件在收到新的props或state时，<code>componentWillUpdate()</code>在渲染之前会立即调用这个方法。 使用这个方法来判断是非需要重新渲染DOM。 第一次渲染DOM不调用此方法。</p>
<p>注意，<code>this.setState()</code>不会调用此方法。 如果你需要根据state和props来进行重新渲染DOM，请改用<code>componentWillReceiveProps()</code>。</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p><code>componentDidUpdate(prevProps, prevState)</code></p>
<p><code>componentDidUpdate()</code>在重新渲染DOM之后被调用。 第一次渲染不调用此方法。</p>
<p>当组件已经重新渲染后，此方法是一个执行DOM操作的好机会，同时也是一个处理网络请求的好地方，前提是你需要比较当前props与之前的props是否相同（例如，如果props没有改变，那么可能不需要进行网络请求）。</p>
<blockquote>
<p><strong>note</strong><br/><br>如果shouldComponentUpdate()返回false，则不会调用componentDidUpdate()。</p>
</blockquote>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p><code>componentWillUnmount()</code></p>
<p><code>componentWillUnmount()</code>在组件被卸载和销毁之前立即被调用。此方法可以执行任何有必要的清理工作，例如清理计时器，取消网络请求或清理在<code>componentDidMount()</code>中创建的DOM元素。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h3><p><code>setState(nextState, callback)</code></p>
<p>将nextState和当前state进行浅合并。这是用于从事件处理函数和服务器请求回调中触发UI重新渲染的主要方法。</p>
<p>第一个参数可以是一个对象（包含一个或多个要更新的state属性），也可以是返回将要引起重新渲染的对象（state和props）。</p>
<p>这里有一个简单的用法：</p>
<p><code>this.setState(&#123;myKey: &#39;my new value&#39;&#125;);</code></p>
<p>它也可以传入一个带有参数的函数<code>function（state，props）=&gt; newState</code>。例如，假设我们想要当前state中的myInteger加上<code>props.step</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(prevState, props) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">myInteger</span>: prevState.myInteger + props.step&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种参数是回调函数，一旦<code>setState</code>完成并且组件被重新渲染，它就会被执行。 通常我们建议使用<code>componentDidUpdate()</code>代替这样的逻辑。</p>
<p><code>setState()</code>不会立即改变<code>this.state</code>，但会创建并挂起state的修改。所以在调用此方法中访问<code>this.state</code>可能会返回现有值。</p>
<p>不能保证对<code>setState</code>的所以调用都是同步操作，因为这样做是为了将多次state修改合并为一次以便提高性能。</p>
<p><code>setState()</code>总会重新渲染DOM，除非<code>shouldComponentUpdate()</code>回false。 如果你正在使用可突变对象，并且无法在<code>shouldComponentUpdate()</code>实现条件渲染逻辑，则只有当新state与先前state不同时调用<code>setState()</code>才能避免不必要的重新渲染。</p>
<h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate()"></a>forceUpdate()</h3><p><code>component.forceUpdate(callback)</code></p>
<p>默认情况下，当组件的state或props改变时，组件将重新渲染。 如果你的render()方法依赖于一些其他数据，你可以告诉React组件需要通过调用<code>forceUpdate()</code>来重新渲染。</p>
<p>调用forceUpdate()会导致在组件上调用render()，跳过<code>shouldComponentUpdate()</code> 这将触发子组件的正常生命周期方法，包括每个子组件的<code>shouldComponentUpdate()</code>方法。 如果标记更改，React仍将更新DOM。</p>
<p>通常你应该尽量避免<code>forceUpdate()</code>的所有使用，并且只能从<code>render()</code>中的<code>this.props</code>和<code>this.state</code>中读取。</p>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p><code>defaultProps</code>是类组件本身的属性，用来设置类组件的默认props。可以用来给未传入值的props设置默认值。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">CustomButton.defaultProps = &#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>props.color</code>没有定义，就是将它设置为默认值<code>blue</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomButton</span> /&gt;</span></span>; <span class="comment">// props.color will be set to blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>props.color</code>被设置为<code>null</code>，那么它将会被重新赋值为<code>null</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomButton</span> <span class="attr">color</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>; <span class="comment">// props.color will remain null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h3><p><code>displayName</code>字符串用于调试消息。 JSX自动设置此值;</p>
<h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><p><code>propTypes</code>也是类组件本身上的一个属性，用来规范props应该是什么类型。它是从props的名称到<code>React.PropTypes</code>中定义的类型的映射。在开发模式下，当为prop设置一个不是指定格式的无效值时，会在JavaScript控制台中显示警告信息。在生产模式下，为了提高效率，不会进行propTypes检查。</p>
<p>例如，此代码确保颜色prop是一个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">CustomButton.propTypes = &#123;</span><br><span class="line">   color: React.PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们建议尽可能使用<code>Flow</code>，以便在编译时进行类型检查，而不是在运行时进行类型检查。Flow在React中内置支持，因此可以轻松地在React应用程序上运行静态分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.length;</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>this.props</code>包含由此组件的调用者定义的props。</p>
<p>特别地，<code>this.props.children</code>是一个特殊的props，通常由JSX表达式中的子标签而不是标签本身定义。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><code>state</code>包含特定于此组件的数据，可能随时间更改。<code>state</code>是用户定义的，它应该是纯JavaScript对象。</p>
<p>如果你不在render()中使用它，它不应该设置state。 例如，您可以将定时器ID直接放在实例上。</p>
<p>永远不要直接改变<code>this.state</code>，因为调用<code>setState()</code>之后可以替换你所做的各种变化，通常应该把<code>this.state</code>看作是不可变的。</p>
<h1 id="ReactDOM的用法"><a href="#ReactDOM的用法" class="headerlink" title="ReactDOM的用法"></a>ReactDOM的用法</h1><p>如果你使用script标签引用React，那么这些顶级API在全局变量ReactDOM上可直接使用。如果你使用了ES6和npm，你可以这么写<code>import ReactDOM from &#39;react-dom&#39;</code>。如果你使用ES5和npm，你可以这写<code>var ReactDOM = require(&#39;react-dom&#39;)</code>。</p>
<h2 id="总览-2"><a href="#总览-2" class="headerlink" title="总览"></a>总览</h2><p><code>react-dom</code>包提供了DOM特定的方法，如果你需要，可以在你的应用中使用并作为一个交互获取外面的React数据。 大多数你的组件不需要使用此模块。</p>
<ul>
<li><p>render()</p>
</li>
<li><p>unmountComponentAtNode()</p>
</li>
<li><p>findDOMNode()</p>
</li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>React支持所有流行的浏览器，包括Internet Explorer 9及更高版本。</p>
<blockquote>
<p><strong>note</strong><br/><br>React无法在那些不支持ES5方法的旧版浏览器上运行，但如果页面中包括诸如es5-shim和es5-sham之类的polyfills，您就会发现您的应用在旧版浏览器中可以正常工作。当然，你对你自己选择的路由完全的选择权，我们也管不了你。。。</p>
</blockquote>
<h2 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="render-1"><a href="#render-1" class="headerlink" title="render()"></a>render()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    [callback]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>将React元素呈现到提供的<code>container</code>中的DOM中，并返回对组件的引用（或对无状态组件返回null）。</p>
<p>如果React元素之前已经被渲染到容器中，这么做会对它执行重新渲染操作，并且只需要根据需要修改DOM以返回最新的React元素。</p>
<p>如果提供了可选的回调，它将在组件渲染或重新渲染后执行。</p>
<blockquote>
<p><strong>note</strong><br/><br>ReactDOM.render()用来控制传入的container节点中的内容。当第一次调用时，内部的任何现有DOM元素都将被替换。 后面的操纵使用React的DOM diffing算法来进行有效的更新。<br>ReactDOM.render()会修改container的内部DOM节点（只修改容器的子节点）。也可以将组件插入现有DOM节点中，而不覆盖现有子项。</p>
</blockquote>
<h3 id="unmountComponentAtNode"><a href="#unmountComponentAtNode" class="headerlink" title="unmountComponentAtNode()"></a>unmountComponentAtNode()</h3><p><code>ReactDOM.unmountComponentAtNode(container)</code></p>
<p>从DOM中删除已安装(mounted)React组件，并清除其event handle和state。 如果在container中没有mounted组件，调用此函数什么也不做。 如果组件被unmounted，则返回true，如果没有要卸载的组件，则返回false。</p>
<h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><p><code>ReactDOM.findDOMNode(component)</code></p>
<p>如果此组件已装载到DOM中，则返回相应的html DOM元素。 此方法对于从DOM中读取值（例如表单字段值和执行DOM测量）很有用。当<code>render</code>返回<code>null</code>或<code>false</code>时，<code>findDOMNode</code>返回<code>null</code>。</p>
<p><strong>在大多数情况下，你可以使用refs处理DOM节点，并避免使用findDOMNode。</strong></p>
<blockquote>
<p><strong>note</strong><br/><br><code>findDOMNode</code>是一个用于访问底层DOM节点的接口。 在大多数情况下，不建议使用此就接口。<br><code>findDOMNode</code>仅适用于已安装的组件（即已放置在DOM中的组件）。如果你试图在一个尚未安装的组件上调用它（就像在一个尚未创建的组件<code>render()</code>方法里调用<code>findDOMNode()</code>），将抛出一个异常。<code>findDOMNode</code>不能用于功能组件。</p>
</blockquote>
<h1 id="DOM-Elements"><a href="#DOM-Elements" class="headerlink" title="DOM Elements"></a>DOM Elements</h1><p>React实现了一个独立于浏览器的DOM系统，用于提高性能和处理浏览器兼容性。React作者借此机会在浏览器DOM实现中清理了一些粗糙的实现（恶心的原生DOM操作）。</p>
<p>在React中，所有<code>DOM properties</code>和<code>attributes</code>（包括<code>event handle</code>）都应该是<code>驼峰命名法</code>。 例如，HTML属性<code>tabindex</code>对应于React中的<code>tabIndex</code>属性。 特殊的是<code>aria- *</code>和<code>data- *</code>属性，应该是全部小写的。</p>
<h2 id="Attributes的区别"><a href="#Attributes的区别" class="headerlink" title="Attributes的区别"></a>Attributes的区别</h2><p>有许多属性在React和HTML之间有不同的表现：</p>
<h3 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h3><p>checked属性在<code>&lt;input type=&quot;checkbox&quot;&gt;</code>或<code>&lt;input type=&quot;radio&quot;&gt;</code>中使用。您可以使用它来设置是否选中该组件。 这对可控组件很有用。<code>defaultChecked</code>是默认选中，它在首次装入组件时是默认选中的。</p>
<h3 id="className"><a href="#className" class="headerlink" title="className"></a>className</h3><p>因为<code>class</code>是Javascript的关键字，所以在指定CSS类时，使用<code>className</code>属性。这适用于所有常规DOM和SVG元素，就像<code>&lt;div&gt;</code>，<code>&lt;a&gt;</code>或者其他标签。<br>如果使用React 和 <code>Web Components</code>（这是不常见的），请把<code>ClassName</code>改为<code>class</code>属性。</p>
<h3 id="dangerouslySetInnerHTML"><a href="#dangerouslySetInnerHTML" class="headerlink" title="dangerouslySetInnerHTML"></a>dangerouslySetInnerHTML</h3><p><code>dangerouslySetInnerHTML</code>是<code>React</code>替换在浏览器DOM中使用<code>innerHTML</code>。<br>一般来说，从代码设置HTML是有风险的，因为很容易无意中将用户暴露于<code>跨站点脚本（XSS）</code>攻击。 所以，你可以直接从React设置HTML，但是你必须输入<code>dangerouslySetInnerHTML</code>并使用<code>__html</code>键传递一个对象，提醒自己这是危险的。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMarkup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">__html</span>: <span class="string">&#x27;First &lt;&lt;&gt;&gt; Second&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyComponent /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="htmlFor"><a href="#htmlFor" class="headerlink" title="htmlFor"></a>htmlFor</h3><p>由于<code>for</code>是JavaScript中的保留字，React元素使用<code>htmlFor</code>。</p>
<h3 id="onChanged"><a href="#onChanged" class="headerlink" title="onChanged"></a>onChanged</h3><p><code>onChange</code>事件的行为与您期望的一样：每当表单字段更改时，将触发此事件。我们故意不使用现有的浏览器行为，因为<code>onChange</code>是其行为的误称，React依赖此事件来实时处理用户输入。</p>
<h3 id="selected"><a href="#selected" class="headerlink" title="selected"></a>selected</h3><p><code>selected</code>属性在<code>&lt;option&gt;</code>中使用。您可以使用它来设置是否选择了组件。这对控制类的组件很有用。</p>
<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p><code>style</code>属性接受一个驼峰命名法的JavaScript对象，而不是CSS字符串。这与DOM元素style的JavaScript属性一致，更高效，并防止XSS安全漏洞。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divStyle = &#123;</span><br><span class="line">    color: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">    backgroundImage: <span class="string">&#x27;url&#x27;</span> + imgUrl + <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorldComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;divStyle&#125;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，样式不自动设置css的前缀。要支持旧版本的浏览器，您需要提供相应的样式属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divStyle = &#123;</span><br><span class="line">    WebkitTransition: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    msTransition: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentWithTransition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;divStyle&#125;</span>&gt;</span>This should work cross-browser<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>style的key是驼峰命名法，以便与从JS访问DOM节点上的属性（例如<code>node.style.backgroundImage</code>）一致。 ms以外的浏览器前缀应以大写字母开头。这就是为什么<code>WebkitTransition</code>有一个大写“W”。</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p><code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>支持value属性。您可以使用它来设置元素的值。这对控制类组件很有用。<code>defaultValue</code>是默认值，在组件首次装入时将会设置这个默认值。</p>
]]></content>
      <tags>
        <tag>React 学习 库 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript高级程序设计（第三版）学习摘录</title>
    <url>/2017/08/27/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>把近期看高程这本书做的笔记摘录整理出来了，总归对原生javascript理论有了一个比较全面的的认识，这次把书中的一些知识要点摘录出来了，便于以后查阅的时候有方向，也更有效率！！</p>
<a id="more"></a>

<h1 id="第一章、javascript简介"><a href="#第一章、javascript简介" class="headerlink" title="第一章、javascript简介"></a>第一章、javascript简介</h1><ul>
<li><p>0101、完整的javascript有三部分组成：核心ECMAScript，DOM和BOM</p>
</li>
<li><p>0102、ECMAScript规定了语言的下列组成部分：语法，类型，语句，关键字，保留字，操作符，对象</p>
</li>
</ul>
<hr>
<h1 id="第二章、在html中使用javascript"><a href="#第二章、在html中使用javascript" class="headerlink" title="第二章、在html中使用javascript"></a>第二章、在html中使用javascript</h1><ul>
<li><p>0201、HTML4.01为script定义了下列6个属性：async：可选，表示立即下载脚本，不阻塞；charset：可选，指定字符集；defer：可选，延迟到文档完全被解析和显示之后再执行；language：已废弃；src：可选，包含要执行代码的外部文件；type：可选，脚本语言的内容类型</p>
</li>
<li><p>0202、标签的位置：所有script元素都应该放在页面的<body>元素页面内容的后面</p>
</li>
<li><p>0203、IE8以后不支持defer属性</p>
</li>
<li><p>0204、async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容</p>
</li>
<li><p>0205、&lt;小于号在XHTML中会被当作开始一个新标签来解析</p>
</li>
<li><p>0206、noscript包含该元素的内容只有在以下情况才会显示出来：不支持脚本，支持脚本但被禁用</p>
</li>
</ul>
<hr>
<h1 id="第三章、基本概念"><a href="#第三章、基本概念" class="headerlink" title="第三章、基本概念"></a>第三章、基本概念</h1><ul>
<li><p>0301、标识符，就是指变量、函数、属性的名字，或者函数的参数：第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）；<br>其他字符可以是字母、下划线、美元符号或数字</p>
</li>
<li><p>0302、严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行</p>
</li>
<li><p>0303、加上这个分号可以避免很多错误，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了</p>
</li>
<li><p>0304、用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误</p>
</li>
<li><p>0305、ECMAScript 中有 5 种简单数据类型（也称为基本数据类型）：Undefined 、Null、Boolean 、Number和 String 。还有 1种复杂数据类型—— Object ， Object 本质上是由一组无序的名值对组成的</p>
</li>
<li><p>0306、Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回 “function” ，而其他浏览器在这种情况下会返回”object”</p>
</li>
<li><p>0307、对未经声明的变量调用 delete 不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误</p>
</li>
<li><p>0308、对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作</p>
</li>
<li><p>0309、如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分null和undefined </p>
</li>
<li><p>0310、要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean() </p>
</li>
<li><p>0311、八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析</p>
</li>
<li><p>0312、十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F可以大写，也可以小写</p>
</li>
<li><p>0313、保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript会不失时机地将浮点数值转换为整数值</p>
</li>
<li><p>0314、在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值（例如，0.0000003 会被转换成 3e-7）</p>
</li>
<li><p>0315、浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值</p>
</li>
<li><p>0316、要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回 true</p>
</li>
<li><p>0317、NaN 与任何值都不相等，包括 NaN本身18、 isNaN() 在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串 “10” 或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true</p>
</li>
<li><p>0318、尽管有点儿不可思议，但 isNaN() 确实也适用于对象。在基于对象调用 isNaN()函数时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。而这个过程也是 ECMAScript中内置函数和操作符的一般执行流程</p>
</li>
<li><p>0319、由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt() 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN ；也就是说，用 parseInt() 转换空字符串会返回 NaN （ Number() 对空字符返回 0）。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如， “1234blue” 会被转换为 1234，因为 “blue” 会被完全忽略。类似地， “22.5”会被转换为 22，因为小数点并不是有效的数字字符。</p>
</li>
<li><p>0320、除了第一个小数点有效之外， parseFloat() 与 parseInt() 的第二个区别在于它始终都会忽略前导的零， parseFloat() 只解析十进制值</p>
</li>
<li><p>0321、ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量</p>
</li>
<li><p>0322、Object 的每个实例都具有下列属性和方法：constructor ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()； hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty(“name”) ）；isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型；propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定；toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应；toString() ：返回对象的字符串表示；valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同</p>
</li>
<li><p>0323、在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或） toString() 方法，以便取得可以操作的值</p>
</li>
<li><p>0324、使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说， for 循环只是把与循环有关的代码集中在了一个位置</p>
</li>
<li><p>0325、Safari 3 以前版本的 for-in 语句中存在一个 bug，该 bug 会导致某些属性被返回两次。</p>
</li>
<li><p>0326、break 和 continue 语句用于在循环中精确地控制代码的执行。其中， break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行</p>
</li>
<li><p>0327、with 语句的作用是将代码的作用域设置到一个特定的对象中。严格模式下不允许使用 with 语句，否则将视为语法错误。由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">var</span> hostName = hostname;</span><br><span class="line">	<span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>0328、通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字。虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (i) &#123;</span><br><span class="line">    case 25:</span><br><span class="line">    &#x2F;*  合并两种情形 *&#x2F;</span><br><span class="line">    case 35:</span><br><span class="line">        alert(&quot;25 or 35&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 45:</span><br><span class="line">        alert(&quot;45&quot;);</span><br><span class="line">    break;</span><br><span class="line">    default:</span><br><span class="line">        alert(&quot;Other&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>0329、switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串 “10” 不等于数值 10）</p>
</li>
<li><p>0330、函数会在执行完 return 语句之后停止并立即退出。因此，位于 return 语句之后的任何代码都永远不会执行</p>
</li>
<li><p>0331、 return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下</p>
</li>
<li><p>0332、严格模式对函数有一些限制：不能把函数命名为 eval 或 arguments ；不能把参数命名为 eval 或 arguments ； 不能出现两个命名参数同名的情况。如果发生以上情况，就会导致语法错误，代码无法执行</p>
</li>
<li><p>0333、函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。 arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0] ，第二个元素是 argumetns[1] ，以此类推），使用 length 属性来确定传递进来多少个参数</p>
</li>
<li><p>0334、没有传递值的命名参数将自动被赋予 undefined 值</p>
</li>
<li><p>0335、严格模式对如何使用 arguments 对象做出了一些限制。把 arguments[1] 设置为 10 ， num2 的值仍然还是 undefined 。其次，重写arguments 的值会导致语法错误（代码将不会执行）</p>
</li>
<li><p>0336、ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数</p>
</li>
<li><p>0337、通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载</p>
</li>
<li><p>0338、 ECMAScript 中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 和 String</p>
</li>
<li><p>0339、与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可用于表示所有数值</p>
</li>
<li><p>0340、ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基础类型</p>
</li>
<li><p>0341、未指定返回值的函数返回的是一个特殊的 undefined 值</p>
</li>
<li><p>0342、 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数</p>
</li>
<li><p>0343、当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象</p>
</li>
</ul>
<hr>
<h1 id="第四章、变量、作用域和内存问题"><a href="#第四章、变量、作用域和内存问题" class="headerlink" title="第四章、变量、作用域和内存问题"></a>第四章、变量、作用域和内存问题</h1><ul>
<li><p>0401、 typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具</p>
</li>
<li><p>0402、通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符</p>
</li>
<li><p>0403、函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同</p>
</li>
<li><p>0404、在catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。换句话说，即使是在 catch 块的外部也可以访问到错误对象</p>
</li>
<li><p>0405、变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了</p>
</li>
<li><p>0406、一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）</p>
</li>
<li><p>0407、基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中</p>
</li>
<li><p>0408、 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本</p>
</li>
<li><p>0409、引用类型的值是对象，保存在堆内存中</p>
</li>
<li><p>0410、包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针</p>
</li>
<li><p>0411、从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象</p>
</li>
<li><p>0412、确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符</p>
</li>
<li><p>0413、 “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存</p>
</li>
<li><p>0414、解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用</p>
</li>
<li><p>0415、除非必须使用变量来访问属性，否则我们建议使用点表示法</p>
</li>
</ul>
<hr>
<h1 id="第五章、引用类型"><a href="#第五章、引用类型" class="headerlink" title="第五章、引用类型"></a>第五章、引用类型</h1><ul>
<li><p>0501、与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数（Firefox 3及更早版本除外）</p>
</li>
<li><p>0502、数组最多可以包含 4 294 967 295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误</p>
</li>
<li><p>0503、所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。其中，调用数组的 toString() 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 valueOf() 返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的 toString() 方法</p>
</li>
<li><p>0504、 toLocaleString() 方法经常也会返回与 toString() 和 valueOf() 方法相同的值，但也不总是如此</p>
</li>
<li><p>0505、如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、toLocaleString() 、 toString() 和 valueOf() 方法返回的结果中以空字符串表示</p>
</li>
<li><p>0506、push() 方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop() 方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</p>
</li>
<li><p>0507、栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）</p>
</li>
<li><p>0508、结合使用 shift() 和 push() 方法，可以像使用队列一样使用数组</p>
</li>
<li><p>0509、同时使用 unshift() 和 pop() 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
</li>
<li><p>0510、alert([0, 1, 5, 10, 15].sort());//0,1,10,15,5。可见，即使例子中值的顺序没有问题，但 sort() 方法也会根据测试字符串的结果改变原来的顺序。因为数值 5 虽然小于 10，但在进行字符串比较时， “10” 则位于 “5” 的前面，于是数组的顺序就被修改了。不用说，这种排序方式在很多情况下都不是最佳方案。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数</p>
</li>
<li><p>0511、由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况</p>
</li>
<li><p>0512、 concat() 方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 concat() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾</p>
</li>
<li><p>0513、slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意， slice() 方法不会影响原始数组</p>
</li>
<li><p>0514、如果 slice() 方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组</p>
</li>
<li><p>0515、splice() 方法可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数；可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项；可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等</p>
</li>
<li><p>0516、splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）</p>
</li>
<li><p>0517、 indexOf() 和 lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， indexOf() 方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。支持它们的浏览器包括 IE9+、Firefox 2+、Safari3+、Opera 9.5+和 Chrome</p>
</li>
<li><p>0518、ECMAScript 5 为数组定义了5个迭代方法，这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；forEach()：对数组中的每一项运行给定函数。这个方法没有返回值；map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组；some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。以上方法都不会修改数组中的包含的值</p>
</li>
<li><p>0519、这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有IE9+、Firefox2+、Safari 3+、Opera 9.5+和 Chrome</p>
</li>
<li><p>0520、 reduce() 和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。使用reduce()方法可以执行求数组中所有值之和的操作</p>
</li>
<li><p>0521、使用 reduce() 还是 reduceRight() ，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同</p>
</li>
<li><p>0522、在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间</p>
</li>
<li><p>0523、 Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异</p>
</li>
<li><p>0524、如果传入 Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse() 。换句话说，下面的代码与前面的例子是等价的：var someDate = new Date(“May 25, 2004”);</p>
</li>
<li><p>0525、Date.UTC() 方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于 0 的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为 0。</p>
</li>
<li><p>0526、ECMAScript 5 添加了 Data.now() 方法，返回表示调用这个方法时的日期和时间的毫秒数</p>
</li>
<li><p>0527、支持 Data.now() 方法的浏览器包括IE9+、Firefox3+、Safari3+、Opera10.5和Chrome。在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的</p>
</li>
<li><p>0528、正则表达式。字面量声明和构造函数声明的区别，字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例</p>
</li>
<li><p>0529、RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。 exec() 接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。其中， index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）</p>
</li>
<li><p>0530、正则表达式的第二个方法是 test() ，它接受一个字符串参数。在模式与该参数匹配的情况下返回true ；否则，返回 false 。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便</p>
</li>
<li><p>0531、正则表达式的 valueOf() 方法返回正则表达式本身。</p>
</li>
<li><p>0532、即使 test() 方法只返回一个布尔值，但RegExp 构造函数的属性$1和$2也会被匹配相应捕获组的字符串自动填充</p>
</li>
<li><p>0533、每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</p>
</li>
<li><p>0534、Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能</p>
</li>
<li><p>0535、函数声明式与函数表达式的区别。解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</p>
</li>
<li><p>0536、因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回</p>
</li>
<li><p>0537、arguments是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数</p>
</li>
<li><p>0538、this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）</p>
</li>
<li><p>0539、函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一个函数</p>
</li>
<li><p>0540、ECMAScript5也规范化了另一个函数对象的属性： caller 。除了Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。为了实现更松散的耦合，也可以通过 arguments.callee.caller来访问相同的信息</p>
</li>
<li><p>0541、IE、Firefox、Chrome和Safari的所有版本以及 Opera 9.6 都支持 caller 属性</p>
</li>
<li><p>0542、当函数在严格模式下运行时，访问arguments.callee 会导致错误。ECMAScript5还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清 arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了</p>
</li>
<li><p>0543、ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性： length和prototype 。其中，length属性表示函数希望接收的命名参数的个数</p>
</li>
<li><p>0544、在ECMAScript5中，prototype属性是不可枚举的，因此使用 for-in 无法发现</p>
</li>
<li><p>0545、每个函数都包含两个非继承而来的方法：apply() 和 call() 。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先， apply() 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象</p>
</li>
<li><p>0546、在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window 。除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是undefined</p>
</li>
<li><p>0547、call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是 this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来</p>
</li>
<li><p>0548、事实上，传递参数并非 apply() 和 call() 真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域</p>
</li>
<li><p>0549、使用 call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系</p>
</li>
<li><p>0550、ECMAScript 5 还定义了一个方法： bind() 。这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。支持 bind() 方法的浏览器有 IE9+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome</p>
</li>
<li><p>0551、为了便于操作基本类型值，ECMAScript还提供了 3 个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据</p>
</li>
<li><p>0552、引用类型与基本包装类型的主要区别就是对象的生存期。使用 new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</p>
</li>
<li><p>0553、Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。var obj = new Object(“some text”); alert(obj instanceof String); //true</p>
</li>
<li><p>0554、使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的</p>
</li>
<li><p>0555、 toFixed()方法会按照指定的小数位返回数值的字符串表示。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入。可以利用round配合toFixed加爵该方法的在ie浏览器上的兼容问题</p>
</li>
<li><p>0556、对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。实际上，toPrecision()会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() </p>
</li>
<li><p>0557、在使用typeof操作符测试基本类型数值时，始终会返回 “number” ，而在测试 Number 对象时，则会返回 “object” 。类似地，Number对象是Number类型的实例，而基本类型的数值则不是</p>
</li>
<li><p>0558、两个用于访问字符串中特定字符的方法是：charAt() 和 charCodeAt()。这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript中没有字符类型）</p>
</li>
<li><p>0559、ECMAScript5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。使用方括号表示法访问个别字符的语法得到了 IE8 及 Firefox、Safari、Chrome 和 Opera 所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值（尽管根本不是特殊的undefined 值）</p>
</li>
<li><p>0560、ECMAScript还提供了三个基于子字符串创建新字符串的方法： slice() 、 substr() 和 substring() 。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说， slice() 和substring() 的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat() 方法一样， slice() 、 substr() 和 substring() 也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中， slice() 方法会将传入的负值与字符串的长度相加， substr() 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0。最后， substring() 方法会把所有负值参数都转换为 0</p>
</li>
<li><p>0561、IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，它会返回原始的字符串。IE9 修复了这个问题</p>
</li>
<li><p>0562、有两个可以从字符串中查找子字符串的方法： indexOf() 和 lastIndexOf() 。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回 -1 ）。这两个方法的区别在于： indexOf() 方法从字符串的开头向后搜索子字符串，而 lastIndexOf() 方法是从字符串的末尾向前搜索子字符串。这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索</p>
</li>
<li><p>0563、ECMAScript 5 为所有字符串定义了 trim() 方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。由于 trim() 返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox 3.5+、Safari 5+和 Chrome 8+还支持非标准的 trimLeft() 和 trimRight() 方法，分别用于删除字符串开头和末尾的空格</p>
</li>
<li><p>0564、接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方法有 4 个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase() 。其中， toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自 java.lang.String 中的同名方法。而 toLocaleLowerCase() 和 toLocaleUpperCase() 方法则是针对特定地区的实现。一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些</p>
</li>
<li><p>0565、String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 match() ，在字符串上调用这个方法，本质上与调用 RegExp 的 exec() 方法相同。 match() 方法只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象</p>
</li>
<li><p>0566、另一个用于查找模式的方法是 search() 。这个方法的唯一参数与 match() 方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。 search() 方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回 -1 。而且， search() 方法始终是从字符串开头向后查找模式</p>
</li>
<li><p>0567、ECMAScript 提供了 replace() 方法。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志</p>
</li>
<li><p>0568、replace() 方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第二个参数可以实现更加精细的替换操作</p>
</li>
<li><p>0569、最后一个与模式匹配有关的方法是 split() ，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。 split() 方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了</p>
</li>
<li><p>0570、与操作字符串有关的最后一个方法是 localeCompare() ，这个方法比较两个字符串，并返回下列值中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1 ，具体的值要视实现而定）； 如果字符串等于字符串参数，则返回 0 ；如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1 ，具体的值同样要视实现而定）。localeCompare() 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为</p>
</li>
<li><p>0571、另外， String 构造函数本身还有一个静态方法： fromCharCode() 。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()执行的是相反的操作</p>
</li>
<li><p>0572、 encodeURI() 主要用于整个 URI（例如，<a href="http://www.wrox.com/illegal">http://www.wrox.com/illegal</a> value.htm），而 encode-URIComponent() 主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm ）进行编码。它们的主要区别在于， encodeURI() 不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而 encodeURIComponent() 则会对它发现的任何非标准字符进行编码</p>
</li>
<li><p>0573、一 般 来 说 ， 我 们 使 用 encodeURIComponent() 方 法 的 时 候 要 比 使 用encodeURI() 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。</p>
</li>
<li><p>0574、与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和decodeURIComponent()</p>
</li>
<li><p>0575、现在，我们介绍最后一个——大概也是整个 ECMAScript语言中最强大的一个方法： eval() 。 eval()方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript （或 JavaScript）字符串</p>
</li>
<li><p>0576、能够解释代码字符串的能力非常强大，但也非常危险。因此在使用 eval() 时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）</p>
</li>
<li><p>0577、其中， min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数</p>
</li>
<li><p>0578、要找到数组中的最大或最小值，可以像下面这样使用 apply() 方法。Math.max.apply(Math,[1,2,4,65,8,4)//65</p>
</li>
<li><p>0579、下面来介绍将小数值舍入为整数的几个方法： Math.ceil() 、 Math.floor() 和 Math.round()</p>
</li>
<li><p>0580、Math.random() 方法返回大于等于 0 小于 1 的一个随机数</p>
</li>
<li><p>0581、 引用类型与传统面向对象程序设计中的类相似，但实现不同</p>
</li>
<li><p>0582、Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为</p>
</li>
<li><p>0583、Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能</p>
</li>
<li><p>0584、Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能</p>
</li>
<li><p>0585、RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能</p>
</li>
<li><p>0586、函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为</p>
</li>
<li><p>0587、因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类型分别是： Boolean 、 Number 和 String 。以下是它们共同的特征</p>
</li>
<li><p>0588、在所有代码执行之前，作用域中就已经存在两个内置对象： Global 和 Math 。在大多数 ECMAScript实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。 Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务</p>
</li>
</ul>
<hr>
<h1 id="第六章、面向对象的程序设计"><a href="#第六章、面向对象的程序设计" class="headerlink" title="第六章、面向对象的程序设计"></a>第六章、面向对象的程序设计</h1><ul>
<li><p>0601、ECMAScript中有两种属性：数据属性和访问器属性。数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]] 、[[Enumerable]]和[[Writable]]特性都被设置为 true ，而[[Value]]特性被设置为指定的值。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable 、 writable和value。设置其中的一或多个值，可以修改对应的特性值。可以多次调用Object.defineProperty() 方法修改同一个属性，但在把configurable特性设置为 false 之后就会有限制了。在调用Object.defineProperty() 方法时，如果不指定，configurable、enumerable 和writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能</p>
</li>
<li><p>0602、访问器属性不包含数据值；它们包含一对儿getter 和 setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性：[[Configurable]]、[[Enumerable]]、[[Get]]、[[Set]]</p>
</li>
<li><p>0603、在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]和[[Enumerable]]</p>
</li>
<li><p>0604、支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome</p>
</li>
<li><p>0605、在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnProperty-Descriptor() 方法。支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome</p>
</li>
<li><p>0606、工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p>
</li>
<li><p>0607、构造器模式。没有显式地创建对象；直接将属性和方法赋给了 this 对象；没有 return 语句。以这种方式调用构造函数实际上会经历以下 4个步骤：创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；执行构造函数中的代码（为这个新对象添加属性）；返回新对象。以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 window 对象）中的。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中， person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例</p>
</li>
<li><p>0608、 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象我们创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中</p>
</li>
<li><p>0609、无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针</p>
</li>
<li><p>0610、使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 12+和 Chrome</p>
</li>
<li><p>0611、使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性</p>
</li>
<li><p>0612、使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true</p>
</li>
<li><p>0613、ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnProperty-Descriptor() 方法</p>
</li>
<li><p>0614、有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时， in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中</p>
</li>
<li><p>0615、由于 in 操作符只要通过对象能够访问到属性就返回 true ， hasOwnProperty() 只在属性存在于实例中时才返回 true ，因此只要 in 操作符返回 true 而 hasOwnProperty() 返回 false ，就可以确定属性是原型中的属性</p>
</li>
<li><p>0616、要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys() 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组</p>
</li>
<li><p>0617、如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。 Object.keys() 和 Object.getOwnProperty-Names() 方法都可以用来替代 for-in 循环。支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera12+和 Chrome</p>
</li>
<li><p>0618、实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数</p>
</li>
<li><p>0619、原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的</p>
</li>
<li><p>0620、混合模式。创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。这种构造函数与原型混成的模式，是目前在 ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式</p>
</li>
<li><p>0621、使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系</p>
</li>
<li><p>0622、关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式</p>
</li>
<li><p>0623、继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在 ECMAScript 中无法实现接口继承。ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的</p>
</li>
<li><p>0624、构造函数、原型和实例的关系。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针</p>
</li>
<li><p>0625、谨慎地定义方法。子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后</p>
</li>
<li><p>0626、通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链</p>
</li>
<li><p>0627、在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 方法也可以在（将来）新创建的对象上执行构造函数</p>
</li>
<li><p>0628、相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数</p>
</li>
<li><p>0629、如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的</p>
</li>
<li><p>0630、ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同。Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性</p>
</li>
<li><p>0631、寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</p>
</li>
<li><p>0632、 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代</p>
</li>
<li><p>0633、 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数</p>
</li>
<li><p>0634、原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法</p>
</li>
<li><p>0635、JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式</p>
</li>
<li><p>0636、当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境</p>
</li>
</ul>
<hr>
<h1 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h1><ul>
<li><p>0701、由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包</p>
</li>
<li><p>0702、在闭包中使用 this 对象也可能会导致一些问题。我们知道， this 对象是在运行时基于函数的执行环境绑定的：在全局函数中， this 等于 window ，而当函数被作为某个对象的方法调用时， this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显</p>
</li>
<li><p>0703、如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁</p>
</li>
<li><p>0704、闭包会引用包含函数的整个活动对象，而其中包含着 element 。即使闭包不直接引用 element ，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把 element 变量设置为 null 。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存</p>
</li>
<li><p>0705、函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要像下面这样给它加上一对圆括号即可</p>
</li>
<li><p>0706、一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域</p>
</li>
<li><p>0707、严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>
</li>
<li><p>0708、构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题</p>
</li>
<li><p>0709、初始化未经声明的变量，总是会创建一个全局变量</p>
</li>
<li><p>0710、多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个显明的不足之处</p>
</li>
<li><p>0711、 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数</p>
</li>
<li><p>0712、在无法确定如何引用函数的情况下，递归函数就会变得比较复杂</p>
</li>
<li><p>0713、 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化</p>
</li>
<li><p>0714、当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量：在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止</p>
</li>
<li><p>0715、使用闭包可以在 JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念）</p>
</li>
<li><p>0716、JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存</p>
</li>
</ul>
<hr>
<h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><ul>
<li><p>0801、抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以</p>
</li>
<li><p>0802、刚才使用 var 语句添加的 window 属性有一个名为 [[Configurable]] 的特性，这个特性的值被设置为 false ，因此这样定义的属性不可以通过 delete 操作符删除。IE8及更早版本在遇到使用 delete删除 window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误</p>
</li>
<li><p>0803、尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在202、窗口位置。用来确定和修改 window 对象位置的属性和方法有很多。IE、Safari、Opera 和 Chrome 都提供了screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox 则在screenX 和 screenY 属性中提供相同的窗口位置信息，Safari 和 Chrome 也同时支持这两个属性。Opera虽然也支持 screenX 和 screenY 属性，但与 screenLeft 和 screenTop 属性并不对应，因此建议大家不要在 Opera 中使用它们</p>
</li>
<li><p>0804、最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用 moveTo()和 moveBy() 方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo() 接收的是新位置的 x 和 y 坐标值，而 moveBy() 接收的是在水平和垂直方向上移动的像素数。</p>
</li>
<li><p>0805、需要注意的是，这两个方法可能会被浏览器禁用；而且，在 Opera 和 IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的 window 对象使用</p>
</li>
<li><p>0806、跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和 Chrome 均为此提供了 4个属性： innerWidth、 innerHeight 、 outerWidth 和 outerHeight 。在 IE9+、Safari和 Firefox中， outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的 window 对象还是从某个框架访问）。在Opera中，这两个属性的值表示页面视图容器① 的大小。而innerWidth 和 innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在 Chrome 中， outerWidth 、 outerHeight 与innerWidth 、 innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小</p>
</li>
<li><p>0807、在 IE、Firefox、Safari、Opera 和 Chrome 中， document.documentElement.clientWidth 和document.documentElement.clientHeight 中保存了页面视口的信息。在 IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body.clientHeight 取得相同信息。而对于混杂模式下的 Chrome，则无论通过 document.documentEle-ment 还是 document.body 中的 clientWidth 和 clientHeight 属性，都可以取得视口的大小</p>
</li>
<li><p>0808、对于移动设备， window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。移动 IE 浏览器不支持这些属性，但通过 document.documentElement.client-Width 和 document.documentElement.clientHeihgt 提供了相同的信息。随着页面的缩放，这些值也会相应变化</p>
</li>
<li><p>0809、有关移动设备视口的话题比较复杂，有很多非常规的情形，也有各种各样的建议。移动开发咨询师 Peter-Paul Koch 记述了他对这个问题的研究：<a href="http://t.cn/zOZs0Tz%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E5%81%9A%E7%A7%BB%E5%8A%A8">http://t.cn/zOZs0Tz。如果你在做移动</a> Web 开发，推荐你读一读这篇文章</p>
</li>
<li><p>0810、 window.open() 方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。后面这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为 400×400 像素，并且距屏幕上沿和左边各 10 像素。window.open(“<a href="http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;">http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</a>);</p>
</li>
<li><p>0811、wroxWin.close()这个方法仅适用于通过 window.open() 打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。不过，弹出窗口倒是可以调用 top.close() 在不经用户允许的情况下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其 closed 属性之外，已经没有其他用处了</p>
</li>
<li><p>0812、超时调用需要使用 window 对象的 setTimeout() 方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数</p>
</li>
<li><p>0813、JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。 setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</p>
</li>
<li><p>0814、超时调用的代码都是在全局作用域中执行的，因此函数中 this 的值在非严格模式下指向 window 对象，在严格模式下是 undefined</p>
</li>
<li><p>0815、一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用</p>
</li>
<li><p>0816、通过 JavaScript 打开的对话框，即“查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。而在 JavaScript 中则可以像下面这样通过 window 对象的 find() 和 print() 方法打开它们</p>
</li>
<li><p>0817、URL获取参数并封装成对象。这个函数的第一步是先去掉查询字符串开头的问号。当然，前提是 location.search 中必须要包含一或多个字符。然后，所有参数将被保存在 args 对象中，该对象以字面量形式创建。接下来，根据和号（&amp;）来分割查询字符串，并返回 name=value 格式的字符串数组。下面的 for 循环会迭代这个数组，然后再根据等于号分割每一项，从而返回第一项为参数名，第二项为参数值的数组。再使用 decodeURIComponent() 分别解码 name 和 value （因为查询字符串应该是被编码过的）。最后，将 name 作为 args 对象的属性，将 value 作为相应属性的值</p>
</li>
<li><p>0818、每次修改 location 的属性（ hash 除外），页面都会以新 URL 重新加载</p>
</li>
<li><p>0819、在 IE8、Firefox 1、Safari 2+、Opera 9+和 Chrome 中，修改 hash 的值会在浏览器的历史记录中生成一条新记录。在 IE 的早期版本中， hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含 hash 的 URL 时才会被更新</p>
</li>
<li><p>0820、replace() 方法。这个方法只接受一个参数，即要导航到的 URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用 replace() 方法之后，用户不能回到前一个页面</p>
</li>
<li><p>0821、与位置有关的最后一个方法是 reload() ，作用是重新加载当前显示的页面。如果调用 reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数 true。位于 reload() 调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将 reload() 放在代码的最后一行</p>
</li>
<li><p>0822、检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非 IE 浏览器，可以使用plugins 数组来达到这个目的。</p>
</li>
<li><p>0823、检测 IE 中的插件比较麻烦，因为 IE 不支持 Netscape 式的插件。在 IE 中检测插件的唯一方式就是使用专有的 ActiveXObject 类型，并尝试创建一个特定插件的实例。IE 是以 COM对象的方式实现插件的，而 COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 COM 标识符。例如，Flash 的标识符是 ShockwaveFlash.ShockwaveFlash </p>
</li>
<li><p>0824、plugins 集合有一个名叫 refresh() 的方法，用于刷新 plugins 以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为 true ，则会重新加载包含插件的所有页面；否则，只更新 plugins集合，不重新加载页面</p>
</li>
<li><p>0825、history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 history 对象与特定的window 对象关联</p>
</li>
<li><p>0826、使用 go() 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给 go() 方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做</p>
</li>
<li><p>0827、另外，还可以使用两个简写方法 back() 和 forward() 来代替 go() 。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮</p>
</li>
<li><p>0828、当页面的 URL 改变时，就会生成一条历史记录。在 IE8 及更高版本、Opera、Firefox、Safari 3 及更高版本以及 Chrome 中，这里所说的改变包括 URL 中 hash 的变化（因此，设置 location.hash 会在这些浏览器中生成一条新的历史记录）</p>
</li>
<li><p>0829、浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面可见区域。同时， window对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下</p>
</li>
</ul>
<hr>
<h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><ul>
<li><p>0901、检测 Web 客户端的手段很多，而且各有利弊。但最重要的还是要知道，不到万不得已，就不要使用客户端检测。只要能找到更通用的方法，就应该优先采用更通用的方法。一言以蔽之，先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案</p>
</li>
<li><p>0902、在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器</p>
</li>
<li><p>0903、与能力检测类似，怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）</p>
</li>
<li><p>0904、能力检测：在编写代码之前先检测特定浏览器的能力</p>
</li>
<li><p>0905、 怪癖检测：怪癖实际上是浏览器实现中存在的 bug</p>
</li>
<li><p>0906、用户代理检测：通过检测用户代理字符串来识别浏览器</p>
</li>
<li><p>0907、在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性</p>
</li>
</ul>
<hr>
<h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><ul>
<li><p>1001、每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型</p>
</li>
<li><p>1002、JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法</p>
</li>
<li><p>1003、所有节点都有的最后一个属性是 ownerDocument ，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点</p>
</li>
<li><p>1004、如果需要把节点放在 childNodes 列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore() 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（ previousSibling ），同时被方法返回。如果参照节点是null ，则 insertBefore() 与 appendChild() 执行相同的操作</p>
</li>
<li><p>1005、 replaceChild() 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置</p>
</li>
<li><p>1006、如果只想移除而非替换节点，可以使用 removeChild() 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值</p>
</li>
<li><p>1007、要使用这几个方法必须先取得父节点（使用 parentNode 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生</p>
</li>
<li><p>1008、 cloneNode() ，用于创建调用这个方法的节点的一个完全相同的副本。 cloneNode() 方法接受一个布尔值参数，表示是否执行深复制</p>
</li>
<li><p>1009、cloneNode() 方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。IE 在此存在一个 bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序</p>
</li>
<li><p>1010、最后一个方法是 normalize() ，这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点</p>
</li>
<li><p>1011、虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType 、 Element 、 ProcessingIn-struction 或 Comment ，但还有两个内置的访问其子节点的快捷方式。第一个就是 documentElement属性，该属性始终指向 HTML 页面中的 <html> 元素。另一个就是通过 childNodes 列表访问文档元素，但通过 documentElement 属性则能更快捷、更直接地访问该元素</p>
</li>
<li><p>1012、所有浏览器都支持 document.documentElement 和 document.body 属性</p>
</li>
<li><p>1013、作为 HTMLDocument 的一个实例， document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title ，包含着<title> 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变 <title>元素</p>
</li>
<li><p>1014、 URL 属性中包含页面完整的 URL（即地址栏中显示的 URL）， domain 属性中只包含页面的域名，而 referrer属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下， referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在JavaScrip 中访问它们而已</p>
</li>
<li><p>1015、当页面中包含来自其他子域的框架或内嵌框架时，能够设置 document.domain 就非常方便了。由于 跨 域 安 全 限 制 ， 来 自 不 同 子 域 的 页 面 无 法 通 过 JavaScript 通 信 。 而 通 过 将 每 个 页 面 的document.domain 设置为相同的值，这些页面就可以互相访问对方包含的 JavaScript 对象了</p>
</li>
<li><p>1016、假设有一个页面加载自 <a href="http://www.wrox.com,其中包含一个内嵌框架,框架内的页面加载自/">www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自</a> p2p.wrox.com。由于 document.domain 字符串不一样，内外两个页面之间无法相互访问对方的 JavaScript 对象。但如果将这两个页面的 document.domain 值都设置为 “wrox.com” ，它们之间就可以通信了。浏览器对 domain 属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。换句话说，在将 document.domain 设置为 “wrox.com” 之后，就不能再将其设置回 “p2p.wrox.com” ，否则将会导致错误</p>
</li>
<li><p>1017、HTMLCollection 对象还有一个方法，叫做 namedItem() ，使用这个方法可以通过元素的 name特性取得集合中的项。对 HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item() ，而对字符串索引就会调用 namedItem()</p>
</li>
<li><p>1018、有一个 document 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列 4 个方法中： write() 、 writeln() 、 open() 和 close() 。其中， write() 和 writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。 write() 会原样写入，而 writeln() 则会在字符串的末尾添加一个换行符（ \n ）。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容</p>
</li>
<li><p>1019、方法 open() 和 close() 分别用于打开和关闭网页的输出流</p>
</li>
<li><p>1020、每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的DOM 方法主要有三个，分别是 getAttribute() 、 setAttribute() 和 removeAttribute()</p>
</li>
<li><p>1021、与 getAttribute() 对应的方法是 setAttribute() ，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在， setAttribute() 会以指定的值替换现有的值；如果特性不存在， setAttribute()则创建该属性并设置相应的值</p>
</li>
<li><p>1022、 removeAttribute() ，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性</p>
</li>
<li><p>1023、使用 document.createElement() 方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在 HTML 文档中不区分大小写，而在 XML（包括 XHTML）文档中，则是区分大小写的</p>
</li>
<li><p>1024、文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML 字符，但不能包含 HTML 代码</p>
</li>
<li><p>1025、可以使用 document.createTextNode() 创建新文本节点，这个方法接受一个参数——要插入节点中的文本</p>
</li>
<li><p>1026、使用 document.createComment() 并为其传递注释文本也可以创建注释节点</p>
</li>
<li><p>1027、虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。要创建文档片段，可以使用 document.createDocumentFragment() 方法</p>
</li>
<li><p>1028、文档片段继承了 Node 的所有方法，通常用于执行那些针对文档的 DOM操作。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树。可以通过 appendChild() 或insertBefore() 将文档片段中内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有子节点添加到相应位置上；文档片段本身永远不会成为文档树的一部分</p>
</li>
<li><p>1029、Attr 对象有 3 个属性： name 、 value 和 specified 。其中， name 是特性名称（与 nodeName 的值相同）， value 是特性的值（与 nodeValue 的值相同），而 specified 是一个布尔值，用以区别特性是在代码中指定的，还是默认的</p>
</li>
<li><p>1030、理解 NodeList 及其“近亲” NamedNodeMap 和 HTMLCollection ，是从整体上透彻理解 DOM 的关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上说，所有 NodeList 对象都是在访问 DOM文档时实时运行的查询</p>
</li>
<li><p>1031、一般来说，应该尽量减少访问 NodeList 的次数。因为每次访问 NodeList ，都会运行一次基于文档的查询。所以，可以考虑将从 NodeList 中取得的值缓存起来</p>
</li>
<li><p>1032、querySelector() 方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null 。</p>
</li>
<li><p>1033、querySelectorAll() 方法接收的参数与 querySelector() 方法一样，都是一个 CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例</p>
</li>
<li><p>1034、如果传入了浏览器不支持的选择符或者选择符中有语法错误，querySelectorAll() 会抛出错误</p>
</li>
<li><p>1035、Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector() 。这个方法接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true ；否则，返回 false</p>
</li>
<li><p>1036、对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点</p>
</li>
<li><p>1037、支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+</p>
</li>
<li><p>1038、新增了 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点</p>
</li>
<li><p>1039、使用 document.readyState 的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。支持 readyState 属性的浏览器有 IE4+、Firefox 3.6+、Safari、Chrome和 Opera 9+</p>
</li>
<li><p>1040、自从 IE6 开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能。IE 为此给 document 添加了一个名为 compatMode 的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。就像下面例子中所展示的那样，在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下， document.compatMode 的值等于 “BackCompat”。</p>
</li>
<li><p>1041、HTML5规定可以为元素添加非标准的属性，但要添加前缀 data- ，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data- 开头即可</p>
</li>
<li><p>1042、在读模式下， innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。在写模式下， innerHTML 会根据指定的值创建新的 DOM树，然后用这个 DOM 树完全替换调用元素原先的所有子节点</p>
</li>
<li><p>1043、在写模式下， innerHTML 的值会被解析为 DOM 子树，替换调用元素原来的所有子节点。因为它的值被认为是 HTML，所以其中的所有标签都会按照浏览器处理 HTML 的标准方式转换为元素（同样，这里的转换结果也因浏览器而异）。如果设置的值仅是文本而没有 HTML 标签，那么结果就是设置纯文本</p>
</li>
<li><p>1044、 innerHTML 字符串一开始（而且整个）就是一个“无作用域的元素”，所以这个字符串会变成空字符串</p>
</li>
<li><p>1045、不支持 innerHTML 的元素有：<code> &lt;col&gt; 、 &lt;colgroup&gt; 、&lt;frameset&gt; 、 &lt;head&gt; 、 &lt;html&gt; 、 &lt;style&gt; 、 &lt;table&gt; 、&lt;tbody&gt; 、&lt;thead&gt; 、&lt;tfoot&gt; 和 &lt;tr&gt;</code> 。此外，在 IE8 及更早版本中， <title> 元素也没有 innerHTML 属性</p>
</li>
<li><p>1046、在读模式下， outerHTML 返回调用它的元素及所有子节点的 HTML 标签。在写模式下， outerHTML会根据指定的 HTML 字符串创建新的 DOM子树，然后用这个 DOM 子树完全替换调用元素。</p>
</li>
<li><p>1047、由于 IE9 之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了 children属性。这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children 属性与 childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同</p>
</li>
<li><p>1048、在实际开发中，经常需要知道某个节点是不是另一个节点的后代。调用 contains() 方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回 true ；否则，返回 false 。</p>
</li>
<li><p>1049、innerText 与 textContent 返回的内容并不完全一样。比如，innerText 会忽略行内的样式和脚本，而 textContent 则会像返回其他文本一样返回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的 DOM 子树副本或 DOM 片段中读取文本</p>
</li>
<li><p>1050、scrollIntoViewIfNeeded(alignCenter) ：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的 alignCenter 参数设置为 true ，则表示尽量将元素显示在视口中部（垂直方向）。Safari 和 Chrome 实现了这个方法</p>
</li>
<li><p>1051、在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将style.width 设置为 “20” ，浏览器会假设它是 “20px” ；但在标准模式下，将style.width 设置为 “20” 会导致被忽略——因为没有度量单位。在实践中，最好始终都指定度量单位</p>
</li>
<li><p>1052、通过 cssText 属性可以访问style特性中的CSS代码。在读取模式下， cssText 返回浏览器对 style特性中 CSS 代码的内部表示。在写入模式下，赋给 cssText 的值会重写整个 style 特性的值；也就是说，以前通过 style 特性指定的样式信息都将丢失</p>
</li>
<li><p>1053、如果你需要更多信息，可以使用 getPropertyCSSValue() 方法，它返回一个包含两个属性的 CSSValue 对象，这两个属性分别是： cssText 和 cssValueType 。其中， cssText 属性的值与 getPropertyValue() 返回的值相同，而 cssValueType 属性则是一个数值常量，表示值的类型：0 表示继承的值，1 表示基本的值，2 表示值列表，3 表示自定义的值</p>
</li>
<li><p>1054、要从元素的样式中移除某个 CSS 属性，需要使用 removeProperty() 方法。使用这个方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）。例如，要移除通过 style特性设置的  border 属性</p>
</li>
<li><p>1055、 getComputedStyle() 方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型相同），其中包含当前元素的所有计算的样式。IE 不支持 getComputedStyle() 方法，但它有一种类似的概念。在 IE 中，每个具有 style 属性的元素还有一个 currentStyle 属性。这个属性是 CSSStyleDeclaration 的实例，包含当前元素全部计算后的样式</p>
</li>
<li><p>1056、无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的 CSS 属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的 CSS 属性都会表现在计算后的样式中。例如，所有浏览器中的 visibility 属性都有一个默认值，但这个值会因实现而异</p>
</li>
<li><p>1057、CSSStyleSheet 类型表示的是样式表，包括通过 <code>&lt;link&gt;</code> 元素包含的样式表和在 <code>&lt;style&gt;</code> 元素中定义的样式表</p>
</li>
<li><p>1058、从样式表中删除规则的方法是 deleteRule() ，这个方法接受一个参数：要删除的规则的位置</p>
</li>
<li><p>1059、首先要介绍的属性涉及偏移量（offset dimension），包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）</p>
</li>
<li><p>1060、所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。</p>
</li>
</ul>
<hr>
<h1 id="第十一章-DOM扩展、第十二章-DOM2和DOM3"><a href="#第十一章-DOM扩展、第十二章-DOM2和DOM3" class="headerlink" title="第十一章 DOM扩展、第十二章 DOM2和DOM3"></a>第十一章 DOM扩展、第十二章 DOM2和DOM3</h1><ul>
<li><p>1101、querySelector() 方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回 null</p>
</li>
<li><p>1102、querySelectorAll() 方法接收的参数与 querySelector() 方法一样，都是一个 CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例。返回的值实际上是带有所有属性和方法的 NodeList ，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询</p>
</li>
<li><p>1103、childElementCount ：返回子元素（不包括文本节点和注释）的个数；firstElementChild ：指向第一个子元素； firstChild 的元素版；lastElementChild ：指向最后一个子元素； lastChild 的元素版； previousElementSibling ：指向前一个同辈元素； previousSibling 的元素版；nextElementSibling ：指向后一个同辈元素； nextSibling 的元素版</p>
</li>
<li><p>1104、getElementsByClassName() 方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的 NodeList。传入多个类名时，类名的先后顺序不重要。因为返回的对象是 NodeList ，所以使用这个方法与使用 getElementsByTagName()。以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题。支持 getElementsByClassName() 方法的浏览器有 IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+</p>
</li>
<li><p>1105、div.classList.remove(“user”)  =&gt;   add(value) ：将给定的字符串值添加到列表中。如果值已经存在，就不添加了；contains(value) ：表示列表中是否存在给定的值，如果存在则返回 true ，否则返回 false；remove(value) ：从列表中删除给定的字符串；toggle(value) ：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome</p>
</li>
<li><p>1106、 document.activeElement 属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null</p>
</li>
<li><p>1107、 document.hasFocus() 方法，这个方法用于确定文档是否获得了焦点。</p>
</li>
<li><p>1108、实现了这两个属性的浏览器的包括 IE 4+、Firefox 3+、Safari 4+、Chrome 和 Opera 8+</p>
</li>
<li><p>1109、使用 document.readyState 的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器</p>
</li>
<li><p>1110、在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下， document.compatMode 的值等于 “BackCompat”</p>
</li>
<li><p>1111、HTML5 新增了 document.head 属性，引用文档的 <head> 元素。实现 document.head 属性的浏览器包括 Chrome 和 Safari 5</p>
</li>
<li><p>1112、HTML5规定可以为元素添加非标准的属性，但要添加前缀 data- ，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data- 开头即可</p>
</li>
<li><p>1113、添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。 dataset 属性的值是 DOMStringMap 的一个实例，也就是一个名值对儿的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀（比如，自定义属性是 data-myname ，那映射中对应的属性就是 myname ）</p>
</li>
<li><p>1114、在读模式下， innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。在写模式下， innerHTML 会根据指定的值创建新的 DOM树，然后用这个 DOM 树完全替换调用元素原先的所有子节点</p>
</li>
<li><p>1115、使用 innerHTML 属性也有一些限制。比如，在大多数浏览器中，通过 innerHTML 插入 <code>&lt;script&gt;</code>元素并不会执行其中的脚本。IE8 及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为 <code>&lt;script&gt;</code> 元素指定 defer 属性，二是 <code>&lt;script&gt;</code> 元素必须位于（微软所谓的）“有作用域的元素”（scoped element）之后。 <code>&lt;script&gt;</code> 元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与 <code>&lt;style&gt;</code> 元素或注释类似。如果通过 innerHTML 插入的字符串开头就是一个“无作用域的元素”，那么 IE 会在解析这个字符串前先删除该元素。<code>div.innerHTML = &quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script defer&gt;alert(&#39;hi&#39;);&lt;\/script&gt;&quot;</code></p>
</li>
<li><p>1116、并不是所有元素都支持 innerHTML 属性。不支持 innerHTML 的元素有： <code>&lt;col&gt; 、 &lt;colgroup&gt; 、&lt;frameset&gt; 、 &lt;head&gt; 、 &lt;html&gt; 、 &lt;style&gt; 、 &lt;table&gt; 、 &lt;tbody&gt; 、 &lt;thead&gt; 、 &lt;tfoot&gt; 和 &lt;tr&gt;</code> 。此外，在 IE8 及更早版本中， <title> 元素也没有 innerHTML 属性</p>
</li>
<li><p>1117、IE8 为此提供了 window.toStaticHTML() 方法，这个方法接收一个参数，即一个 HTML 字符串；返回一个经过无害处理后的版本——从源 HTML 中删除所有脚本节点和事件处理程序属性</p>
</li>
<li><p>1118、如果在<div>元素上调用outerHTML，会返回与上面相同的代码，包括<div>本身。支持outerHTML属性的浏览器有IE4+、Safari 4+、Chrome和Opera 8+。Firefox 7及之前版本都不支持outerHTML属性</p>
</li>
<li><p>1119、插入标记的最后一个新增方式是 insertAdjacentHTML() 方法。这个方法最早也是在IE中出现的，它接收两个参数：插入位置和要插入的 HTML 文本。”beforebegin” ，在当前元素之前插入一个紧邻的同辈元素；”afterbegin” ，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；”beforeend” ，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；”afterend” ，在当前元素之后插入一个紧邻的同辈元素。第二个参数是一个 HTML 字符串（与 innerHTML 和 outerHTML的值相同）。支持insertAdjacentHTML() 方法的浏览器有 IE、Firefox 8+、Safari、Opera 和 Chrome</p>
</li>
<li><p>1120、scrollIntoView() 可以在所有 HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。如果给这个方法传入 true 作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入 false 作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐）。支持 scrollIntoView() 方法的浏览器有 IE、Firefox、Safari 和 Opera</p>
</li>
<li><p>1121、children这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children 属性与 childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。支持 children 属性的浏览器有 IE5、Firefox 3.5、Safari 2（但有 bug）、Safari 3（完全支持）、Opera8和 Chrome（所有版本）。IE8 及更早版本的 children 属性中也会包含注释节点，但 IE9 之后的版本则只返回元素节点</p>
</li>
<li><p>1122、调用 contains() 方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回 true ；否则，返回 false。支持 contains() 方法的浏览器有 IE、Firefox 9+、Safari、Opera 和 Chrome</p>
</li>
<li><p>1123、多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的 CSS 属性就是 float 。由于 float 是 JavaScript 中的保留字，因此不能用作属性名。“DOM2 级样式”规范规定样式对象上相应的属性名应该是 cssFloat ；Firefox、Safari、Opera 和 Chrome 都支持这个属性，而 IE支持的则是 styleFloat</p>
</li>
<li><p>1124、通过 cssText 属性可以访问style特性中的CSS代码。在读取模式下， cssText 返回浏览器对 style特性中 CSS 代码的内部表示。在写入模式下，赋给 cssText 的值会重写整个 style 特性的值；也就是说，以前通过 style 特性指定的样式信息都将丢失</p>
</li>
<li><p>1125、getPropertyValue() 方法取得的始终都是 CSS 属性值的字符串表示。如果你需要更多信息，可以使用 getPropertyCSSValue() 方法，它返回一个包含两个属性的 CSSValue 对象，这两个属性分别是： cssText 和 cssValueType 。其中， cssText 属性的值与getPropertyValue() 返回的值相同，而 cssValueType 属性则是一个数值常量，表示值的类型：0 表示继承的值，1 表示基本的值，2 表示值列表，3 表示自定义的值。在实际开发中， getPropertyCSSValue() 使用得比 getPropertyValue() 少得多。IE9+、Safarie3+以及 Chrome 支持这个方法。Firefox 7 及之前版本也提供这个访问，但调用总返回 null</p>
</li>
<li><p>1126、要从元素的样式中移除某个 CSS 属性，需要使用 removeProperty() 方法。使用这个方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式表经层叠而来）</p>
</li>
<li><p>1127、getComputedStyle() 方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如 “:after” ）。如果不需要伪元素信息，第二个参数可以是 null 。 getComputedStyle() 方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型相同），其中包含当前元素的所有计算的样式。IE 不支持 getComputedStyle() 方法，但它有一种类似的概念。在 IE 中，每个具有 style 属性的元素还有一个 currentStyle 属性。这个属性是 CSSStyleDeclaration 的实例，包含当前元素全部计算后的样式。与 DOM 版本的方式一样，IE 也没有返回 border 样式，因为这是一个综合属性。无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的 CSS 属性。此外，计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的 CSS 属性都会表现在计算后的样式中</p>
</li>
<li><p>1128、CSSStyleSheet 类型表示的是样式表，包括通过 <link> 元素包含的样式表和在 <code>&lt;style&gt;</code> 元素中定义的样式表。有读者可能记得，这两个元素本身分别是由 HTMLLinkElement 和 HTMLStyleElement 类型表示的。但是， CSSStyleSheet 类型相对更加通用一些，它只表示样式表，而不管这些样式表在 HTML中是如何定义的。此外，上述两个针对元素的类型允许修改 HTML特性，但 CSSStyleSheet 对象则是一套只读的接口（有一个属性例外）。disabled ：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为 true 可以禁用样式表</p>
</li>
<li><p>1129、其中三个最常用的属性是 cssText 、 selectorText 和 style 。 cssText 属性与 style.cssText属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息（类似于元素的 style.cssText ）。此外， cssText 是只读的，而 style.cssText 也可以被重写</p>
</li>
<li><p>1130、 insertRule() 方法接受两个参数：规则文本和表示在哪里插入规则的索引。Firefox、Safari、Opera 和 Chrome都支持 insertRule() 方法。IE8 及更早版本支持一个类似的方法，名叫 addRule() ，也接收两必选参数：选择符文本和 CSS样式信息；一个可选参数：插入规则的位置</p>
</li>
<li><p>1131、从样式表中删除规则的方法是 deleteRule() ，这个方法接受一个参数：要删除的规则的位置；IE 支持的类似方法叫 removeRule() ，使用方法相同。与添加规则相似，删除规则也不是实际 Web 开发中常见的做法。考虑到删除规则可能会影响 CSS层叠的效果，因此请大家慎重使用</p>
</li>
<li><p>1132、偏移量。offsetHeight ：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度；offsetWidth ：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度；offsetLeft ：元素的左外边框至包含元素的左内边框之间的像素距离；offsetTop ：元素的上外边框至包含元素的上内边框之间的像素距离。要想知道某个元素在页面上的偏移量，将这个元素的 offsetLeft 和 offsetTop 与其 offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值</p>
</li>
<li><p>1133、所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能</p>
</li>
<li><p>1134、元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个： clientWidth 和 clientHeight 。其中， clientWidth 属性是元素内容区宽度加上左右内边距宽度； clientHeight 属性是元素内容区高度加上上下内边距高度。注意这两个属性不包含边框（border）</p>
</li>
<li><p>1135、与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的</p>
</li>
<li><p>1136、有些元素（例如<html> 元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过 CSS 的overflow 属性进行设置才能滚动。scrollHeight ：在没有滚动条的情况下，元素内容的总高度；scrollWidth ：在没有滚动条的情况下，元素内容的总宽度；scrollLeft ：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置；scrollTop ：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置</p>
</li>
<li><p>1137、对于 不 包含 滚动 条 的页 面而 言 ， scrollWidth 和 scrollHeight 与 clientWidth 和clientHeight 之间的关系并不十分清晰</p>
</li>
<li><p>1138、在确定文档的总高度时（包括基于视口的最小高度时），必须取得 scrollWidth/clientWidth 和scrollHeight/clientHeight 中的最大值，才能保证在跨浏览器的环境下得到精确的结果</p>
</li>
<li><p>1139、通过 scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于 0。如果元素被垂直滚动了，那么 scrollTop 的值会大于 0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么 scrollLeft 的值会大于 0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的scrollLeft 和 scrollTop 设置为 0，就可以重置元素的滚动位置</p>
</li>
<li><p>1140、IE、Firefox 3+、Safari 4+、Opera 9.5及 Chrome为每个元素都提供了一个 getBoundingClientRect() 方法。这个方法返回会一个矩形对象，包含 4 个属性： left 、 top 、 right 和 bottom 。这些属性给出了元素在页面中相对于视口的位置。但是，浏览器的实现稍有不同。IE8 及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括 IE9 则将传统的(0,0)作为起点坐标。因此，就需要在一开始检查一下位于(0,0)处的元素的位置，在 IE8 及更早版本中，会返回(2,2)，而在其他浏览器中会返回(0,0)</p>
</li>
<li><p>1141、对于不支持 getBoundingClientRect() 的浏览器，可以通过其他手段取得相同的信息。一般来说， right 和 left 的差值与 offsetWidth 的值相等，而 bottom 和 top 的差值与 offsetHeight相等。而且， left 和 top 属性大致等于使用本章前面定义的 getElementLeft() 和 getElementTop()函数取得的值</p>
</li>
<li><p>1142、DOM2 级在 Document 类型中定义了 createRange() 方法。在兼容 DOM 的浏览器中，这个方法属于 document 对象。使用 hasFeature() 或者直接检测该方法，都可以确定浏览器是否支持范围</p>
</li>
<li><p>1143、要使用范围来选择文档中的一部分，最简的方式就是使用 selectNode() 或 selectNodeContents() 。这两个方法都接受一个参数，即一个 DOM 节点，然后使用该节点中的信息来填充范围。其中，selectNode() 方法选择整个节点，包括其子节点；而 selectNodeContents() 方法则只选择节点的子节点</p>
</li>
<li><p>1144、要创建复杂的范围就得使用 setStart() 和 setEnd() 方法。这两个方法都接受两个参数：一个参照节点和一个偏移量值。对 setStart() 来说，参照节点会变成 startContainer ，而偏移量值会变成startOffset 。对于 setEnd() 来说，参照节点会变成 endContainer ，而偏移量值会变成 endOffset</p>
</li>
<li><p>1145、使用 insertNode()方法可以向范围选区的开始处插入一个节点。<code>&lt;span&gt;</code> 正好被插入到了 “Hello” 中的 “llo” 前面，而该位置就是范围选区的开始位置。还要注意的是，由于这里没有使用上一节介绍的方法，结果原始的 HTML 并没有添加或删除 <code>&lt;b&gt;</code> 元素。使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像</p>
</li>
<li><p>1146、除了向范围内部插入内容之外，还可以环绕范围插入内容，此时就要使用 surroundContents()方法。这个方法接受一个参数，即环绕范围内容的节点。在环绕范围插入内容时，后台会执行下列步骤：提取出范围中的内容（类似执行 extractContent() ）；将给定节点插入到文档中原来范围所在的位置上；将文档片段的内容添加到给定节点中</p>
</li>
<li><p>1147、所谓折叠范围，就是指范围中未选择文档的任何部分。使用 collapse() 方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数 true 表示折叠到范围的起点，参数 false 表示折叠到范围的终点。要确定范围已经折叠完毕，可以检查 collapsed 属性</p>
</li>
<li><p>1148、可以使用 cloneRange() 方法复制范围。这个方法会创建调用它的范围的一个副本。新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围</p>
</li>
<li><p>1149、在使用完范围之后，最好是调用 detach() 方法，以便从创建范围的文档中分离出该范围。调用detach() 之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了</p>
</li>
<li><p>1150、IE9、Firefox、Opera、Safari 和 Chrome 全都已经实现了“DOM2 级事件”模块的核心部分。IE8 是最后一个仍然使用其专有事件系统的主要浏览器</p>
</li>
</ul>
<hr>
<h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><ul>
<li><p>1301、事件流描述的是从页面中接收事件的顺序。但有意思的是，IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流</p>
</li>
<li><p>1302、IE 的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）</p>
</li>
<li><p>1303、Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它</p>
</li>
<li><p>1304、虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但 IE9、Safari、Chrome、Opera和 Firefox 目前也都支持这种事件流模型。尽管“DOM2 级事件”规范要求事件应该从 document 对象开始传播，但这些浏览器都是从 window 对象开始捕获事件的。</p>
</li>
<li><p>1305、由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议读者放心地使用事件冒泡，在有特殊需要时再使用事件捕获</p>
</li>
<li><p>1306、“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应</p>
</li>
<li><p>1307、在 DOM 事件流中，实际的目标（ <div> 元素）在捕获阶段不会接收到事件</p>
</li>
<li><p>1308、多数支持 DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2 级事件”规范明确要求捕获阶段不会涉及事件目标，但 IE9、Safari、Chrome、Firefox 和 Opera 9.5 及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。</p>
</li>
<li><p>1309、将事件处理程序设置为 null 之后，再单击按钮将不会有任何动作发生</p>
</li>
<li><p>1310、“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作： addEventListener()和 removeEventListener() 。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true ，表示在捕获阶段调用事件处理程序；如果是 false ，表示在冒泡阶段调用事件处理程序</p>
</li>
<li><p>1311、通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener() 添加的匿名函数将无法移除。把传入的匿名函数赋给一个变量，在添加事件监听或移除事件监听使用该变量可以移除</p>
</li>
<li><p>1312、大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序</p>
</li>
<li><p>1313、IE 实现了与 DOM 中类似的两个方法： attachEvent() 和 detachEvent() 。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过attachEvent() 添加的事件处理程序都会被添加到冒泡阶段。注意， attachEvent() 的第一个参数是 “onclick” ，而非 DOM 的 addEventListener() 方法中的 “click”</p>
</li>
<li><p>1314、在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window</p>
</li>
<li><p>1315、这里调用了两次 attachEvent() ，为同一个按钮添加了两个不同的事件处理程序。不过，与 DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发</p>
</li>
<li><p>1316、使用 attachEvent() 添加的事件可以通过 detachEvent() 来移除，条件是必须提供相同的参数。与 DOM 方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给 detachEvent() ，就可以移除相应的事件处理程序</p>
</li>
<li><p>1317、在触发 DOM 上的某个事件时，会产生一个事件对象 event ，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 event 对象，但支持方式不同</p>
</li>
<li><p>1318、在事件处理程序内部，对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this 、 currentTarget 和 target 包含相同的值。如果事件处理程序存在于按钮的父节点中（例如 document.body ），那么这些值是不相同的</p>
</li>
<li><p>1319、事件委托是通过事件冒泡来实现的</p>
</li>
<li><p>1320、要阻止特定事件的默认行为，可以使用 preventDefault() 方法。例如，链接的默认行为就是在被单击时会导航到其 href 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的onclick 事件处理程序可以取消它</p>
</li>
<li><p>1321、只有 cancelable 属性设置为 true 的事件，才可以使用 preventDefault() 来取消其默认行为</p>
</li>
<li><p>1322、 stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡</p>
</li>
<li><p>1323、事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么 eventPhase 等于 1 ；如果事件处理程序处于目标对象上，则event-Phase等于2；如果是在冒泡阶段调用的事件处理程序， eventPhase 等于 3</p>
</li>
<li><p>1324、只有在事件处理程序执行期间， event 对象才会存在；一旦事件处理程序执行完成， event 对象就会被销毁</p>
</li>
<li><p>1325、 returnValue 属性相当于 DOM中的 preventDefault() 方法，它们的作用都是取消给定事件的默认行为。只要将 returnValue 设置为 false ，就可以阻止默认行为</p>
</li>
<li><p>1326、cancelBubble 属性与 DOM 中的 stopPropagation() 方法作用相同，都是用来停止事件冒泡的。由于 IE 不支持事件捕获，因而只能取消事件冒泡；但 stopPropagatioin() 可以同时取消事件捕获和冒泡</p>
</li>
<li><p>1327、在 onclick 事件处理程序中将 cancelBubble 设置为 true ，就可阻止事件通过冒泡而触发document.body 中注册的事件处理程序</p>
</li>
<li><p>1328、JavaScript 中最常用的一个事件就是 load 。当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件</p>
</li>
<li><p>1329、与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件</p>
</li>
<li><p>1330、当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件。这个事件在 window （窗口）上面触发，因此可以通过 JavaScript 或者 <body> 元素中的 onresize 特性来指定事件处理程序</p>
</li>
<li><p>1331、关于何时会触发 resize 事件，不同浏览器有不同的机制。IE、Safari、Chrome 和 Opera 会在浏览器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调整窗口大小时才会触发 resize 事件。由于存在这个差别，应该注意不要在这个事件的处理程序中加入大计算量的代码，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。浏览器窗口最小化或最大化时也会触发 resize 事件</p>
</li>
<li><p>1332、焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与document.hasFocus()方法及document.activeElement 属性配合，可以知晓用户在页面上的行踪</p>
</li>
<li><p>1333、 focus 和 blur ，它们都是 JavaScript 早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。因此，IE 的 focusin 和 focusout 与 Opera 的 DOMFocusIn和 DOMFocusOut 才会发生重叠。IE 的方式最后被 DOM3 级事件采纳为标准方式</p>
</li>
<li><p>1334、鼠标事件中还有一类滚轮事件。而说是一类事件，其实就是一个 mousewheel 事件。这个事件跟踪鼠标滚轮，类似于 Mac 的触控板</p>
</li>
<li><p>1335、鼠标事件都是在浏览器视口中的特定位置上发生的。这个位置信息保存在事件对象的 clientX 和clientY 属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。</p>
</li>
<li><p>1336、页面坐标通过事件对象的pageX和pageY属性，能告诉你事件是在页面中的什么位置发生的。换句话说，这两个属性表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的</p>
</li>
<li><p>1337、IE8 及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。这时候需要用到 document.body （混杂模式）或 document.documentElement （标准模式）中的scrollLeft 和 scrollTop 属性</p>
</li>
<li><p>1338、通过 screenX 和 screenY 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息</p>
</li>
<li><p>1339、虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键就是 Shift、Ctrl、Alt 和 Meta（在 Windows键盘中是 Windows键，在苹果机中是 Cmd 键），它们经常被用来修改鼠标事件的行为。DOM 为此规定了 4 个属性，表示这些修改键的状态： shiftKey 、 ctrlKey 、 altKey 和 metaKey 。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为 true ，否则值为 false 。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键</p>
</li>
<li><p>1340、DOM通过 event 对象的 relatedTarget 属性提供了相关元素的信息。这个属性只对于 mouseover和 mouseout 事件才包含值；对于其他事件，这个属性的值是 null</p>
</li>
<li><p>1341、只有在主鼠标按钮被单击（或键盘回车键被按下）时才会触发 click事件，因此检测按钮的信息并不是必要的。但对于 mousedown 和 mouseup 事件来说，则在其 event 对象存在一个 button 属性，表示按下或释放的按钮。DOM 的 button 属性可能有如下 3 个值： 0 表示主鼠标按钮， 1 表示中间的鼠标按钮（鼠标滚轮按钮）， 2 表示次鼠标按钮</p>
</li>
<li><p>1342、“DOM2 级事件”规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说， detail 中包含了一个数值，表示在给定位置上发生了多少次单击。在同一个元素上相继地发生一次 mousedown 和一次 mouseup 事件算作一次单击。 detail 属性从 1 开始计数，每次单击发生后都会递增</p>
</li>
<li><p>1343、IE 6.0 首先实现了 mousewheel 事件。此后，Opera、Chrome 和 Safari 也都实现了这个事件。当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发 mousewheel事件。这个事件可以在任何元素上面触发，最终会冒泡到 document （IE8）或 window （IE9、Opera、Chrome 及 Safari）对象。与 mousewheel 事件对应的 event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的 wheelDelta 属性。当用户向前滚动鼠标滚轮时， wheelDelta 是 120 的倍数；当用户向后滚动鼠标滚轮时， wheelDelta 是120 的倍数。</p>
</li>
<li><p>1344、多数情况下，只要知道鼠标滚轮滚动的方向就够了，而这通过检测 wheelDelta 的正负号就可以确定。有一点要注意：在 Opera 9.5 之前的版本中， wheelDelta 值的正负号是颠倒的。如果你打算支持早期的 Opera 版本，就需要使用浏览器检测技术来确定实际的值</p>
</li>
<li><p>1345、键盘事件keydown、keypress、keyup与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中也有 shiftKey 、 ctrlKey 、 altKey 和 metaKey 属性。IE 不支持 metaKey</p>
</li>
<li><p>1346、键码在发生 keydown 和 keyup 事件时， event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键， keyCode 属性的值与 ASCII 码中对应小写字母或数字的编码相同</p>
</li>
<li><p>1347、发生 keypress 事件意味着按下的键会影响到屏幕中文本的显示。在所有浏览器中，按下能够插入或删除字符的键都会触发 keypress 事件；按下其他键能否触发此事件因浏览器而异</p>
</li>
<li><p>1348、IE8及之前版本和Opera则是在 keyCode 中保存字符的ASCII编码。要想以跨浏览器的方式取得字符编码，必须首先检测 charCode 属性是否可用，如果不可用则使用 keyCode。在取得了字符编码之后，就可以使用 String.fromCharCode() 将其转换成实际的字符</p>
</li>
<li><p>1349、尽管所有浏览器都实现了某种形式的键盘事件，DOM3 级事件还是做出了一些改变。比如，DOM3级事件中的键盘事件，不再包含 charCode 属性，而是包含两个新属性： key 和 char。其中， key 属性是为了取代 keyCode 而新增的，它的值是一个字符串。在按下某个字符键时， key的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时，  key 的值是相应键的名（如“Shift”或“Down”）。而 char 属性在按下字符键时的行为与 key 相同，但在按下非字符键时值为 null。由于存在跨浏览器问题，因此本书不推荐使用 key 、 keyIdentifier 或 char</p>
</li>
<li><p>1350、 event 对象上还有一个属性，叫 inputMethod ，表示把文本输入到文本框中的方式。 1，表示是使用键盘输入的；2，表示文本是粘贴进来的； 3，表示文本是拖放进来的； 7，表示文本是通过语音输入的</p>
</li>
<li><p>1351、支持 textInput 属性的浏览器有 IE9+、Safari 和 Chrome。只有 IE 支持 inputMethod 属性</p>
</li>
<li><p>1352、在所有浏览器中都可以取消这个事件：在兼容 DOM 的浏览器中，使用 event.preventDefalut() ；在 IE 中，将 event.returnValue 的值设置为 false 。因为 contextmenu 事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。通常使用 contextmenu 事件来显示自定义的上下文菜单，而使用 onclick 事件处理程序来隐藏该菜单。支持 contextmenu 事件的浏览器有 IE、Firefox、Safari、Chrome 和 Opera 11+</p>
</li>
<li><p>1353、之所以有发生在 window 对象上的 beforeunload 事件，是为了让开发人员有可能在页面卸载前阻止这一操作。这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。为此，这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载（正因为如此才会显示这个消息），询问用户是否真的要关闭页面，还是希望继续留下来。IE 和 Firefox、Safari 和 Chrome 都支持 beforeunload 事件，也都会弹出这个对话框询问用户是否真想离开。Opera 11 及之前的版本不支持 beforeunload 事件</p>
</li>
<li><p>1354、touchstart ：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。touchmove ：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 preventDefault()可以阻止滚动。touchend ：当手指从屏幕上移开时触发。touchcancel ：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。上面这几个事件都会冒泡，也都可以取消</p>
</li>
<li><p>1355、gesturestart ：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。gesturechange ：当触摸屏幕的任何一个手指的位置发生变化时触发。gestureend ：当任何一个手指从屏幕上面移开时触发。</p>
</li>
<li><p>1356、事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。使用事件委托，只需在DOM 树中尽量最高的层次上添加一个事件处理程序。最适合采用事件委托技术的事件包括 click 、 mousedown 、 mouseup 、 keydown 、 keyup 和 keypress 。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置</p>
</li>
<li><p>1357、第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的 DOM 操作，例如使用 removeChild() 和 replaceChild() 方法，但更多地是发生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收；导致“空事件处理程序”的另一种情况，就是卸载页面的时候</p>
</li>
</ul>
<hr>
<h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><ul>
<li><p>1401、在以调用 submit() 方法的形式提交表单时，不会触发 submit 事件，因此要记得在调用此方法之前先验证表单数据</p>
</li>
<li><p>1402、提交表单时可能出现的最大问题，就是重复提交表单。在第一次提交表单后，如果长时间没有反应，用户可能会变得不耐烦。这时候，他们也许会反复单击提交按钮。结果往往很麻烦（因为服务器要处理重复的请求），或者会造成错误（如果用户是下订单，那么可能会多订好几份）。解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用 onsubmit 事件处理程序取消后续的表单提交操作</p>
</li>
<li><p>1403、每个表单都有elements 属性，该属性是表单中所有表单元素（字段）的集合。这个 elements 集合是一个有序列表，其中包含着表单中的所有字段，例如 <code>&lt;input&gt; 、 &lt;textarea&gt; 、 &lt;button&gt; 和 &lt;fieldset&gt;</code> 。每个表单字段在 elements 集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和 name 特性来访问它们。如果有多个表单控件都在使用一个 name （如单选按钮），那么就会返回以该 name 命名的一个NodeList</p>
</li>
<li><p>1404、很多用户可能会重复单击表单的提交按钮。在涉及信用卡消费时，这就是个问题：因为会导致费用翻番。为此，最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听 submit 事件，并在该事件发生时禁用提交按钮即可</p>
</li>
<li><p>1405、HTML5 为表单字段新增了一个 autofocus 属性。在支持这个属性的浏览器中，只要设置这个属性，不用 JavaScript 就能自动把焦点移动到相应字段</p>
</li>
<li><p>1406、在默认情况下，只有表单字段可以获得焦点。对于其他元素而言，如果先将其tabIndex 属性设置为1，然后再调用 focus() 方法，也可以让这些元素获得焦点。只有 Opera 不支持这种技术</p>
</li>
<li><p>1407、关于 blur 和 change 事件的关系，并没有严格的规定。在某些浏览器中， blur事件会先于 change 事件发生；而在其他浏览器中，则恰好相反。为此，不能假定这两个事件总会以某种顺序依次触发，这一点要特别注意</p>
</li>
<li><p>1408、要表现文本框，必须将 <code>&lt;input&gt;</code> 元素的 type 特性设置为 “text” 。而通过设置 size 特性，可以指定文本框中能够显示的字符数。通过 value 特性，可以设置文本框的初始值，而 maxlength 特性则用于指定文本框可以接受的最大字符数</p>
</li>
<li><p>1409、<code>&lt;textarea&gt;</code> 元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用 rows和 cols 特性。其中， rows 特性指定的是文本框的字符行数，而 cols 特性指定的是文本框的字符列数（类似于 <code>&lt;inpu&gt;</code> 元素的 size 特性）。与 <code>&lt;input&gt;</code> 元素不同， <code>&lt;textarea&gt;</code> 的初始值必须要放在<code>&lt;textarea&gt;</code> 和 <code>&lt;/textarea&gt;</code> 之间</p>
</li>
<li><p>1410、 select() 方法，这个方法用于选择文本框中的所有文本。在调用 select()方法时，大多数浏览器（Opera 除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何时候被调用<br>420、 select 事件。在选择了文本框中的文本时，就会触发 select事件。不过，到底什么时候触发 select 事件，还会因浏览器而异。在 IE9+、Opera、Firefox、Chrome和 Safari 中，只有用户选择了文本（而且要释放鼠标），才会触发 select 事件。而在 IE8 及更早版本中，只要用户选择了一个字母（不必释放鼠标），就会触发 select 事件。另外，在调用 select() 方法时也会触发 select 事件</p>
</li>
<li><p>1411、取得选择的文本。HTML5 通过一些扩展方案解决了这个问题，以便更顺利地取得选择的文本。该规范采取的办法是添加两个属性： selectionStart 和 selectionEnd 。这两个属性中保存的是基于 0 的数值，表示所选择文本的范围（即文本选区开头和结尾的偏移量）</p>
</li>
<li><p>1412、HTML5也为选择文本框中的部分文本提供了解决方案 ， 即 最 早 由 Firefox 引 入 的setSelectionRange() 方法。现在除 select() 方法之外，所有文本框都有一个 setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引（类似于 substring() 方法的两个参数）</p>
</li>
<li><p>1413、 clipboardData 对象有三个方法： getData() 、 setData() 和 clearData() 。其中， getData()用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式； setData() 方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本</p>
</li>
<li><p>1414、任何标注有 required 的字段，在提交表单时都不能空着。这个属性适用于 <code>&lt;input&gt; 、 &lt;textarea&gt;和 &lt;select&gt;</code> 字段（Opera 11 及之前版本还不支持 <code>&lt;select&gt;</code> 的 required 属性）。在 JavaScript 中，通过对应的 required 属性，可以检查某个表单字段是否为必填字段</p>
</li>
<li><p>1415、HTML5 为文本字段新增了 pattern 属性。这个属性的值是一个正则表达式，用于匹配文本框中的值</p>
</li>
<li><p>1416、使用 checkValidity() 方法可以检测表单中的某个字段是否有效。所有表单字段都有个方法，如果字段的值有效，这个方法返回 true ，否则返回 false 。字段的值是否有效的判断依据是本节前面介绍过的那些约束。换句话说，必填字段中如果没有值就是无效的，而字段中的值与 pattern 属性不匹配也是无效的</p>
</li>
<li><p>1417、要检测整个表单是否有效，可以在表单自身调用 checkValidity() 方法。如果所有表单字段都有效，这个方法返回 true ；即使有一个字段无效，这个方法也会返回 false </p>
</li>
<li><p>1418、对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的 selectedIndex 属性</p>
</li>
<li><p>1419、与 selectedIndex 不同，在允许多选的选择框中设置选项的 selected 属性，不会取消对其他选中项的选择，因而可以动态选中任意多个项。但是，如果是在单选选择框中，修改某个选项的 selected 属性则会取消对其他选项的选择。需要注意的是，将 selected 属性设置为 false 对单选选择框没有影响</p>
</li>
<li><p>1420、 contenteditable 属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。document.body.contentEditable=’true’</p>
</li>
</ul>
<hr>
<h1 id="第十五章-使用canvas绘图"><a href="#第十五章-使用canvas绘图" class="headerlink" title="第十五章 使用canvas绘图"></a>第十五章 使用canvas绘图</h1><hr>
<h1 id="第十六章-HTML5脚本编程"><a href="#第十六章-HTML5脚本编程" class="headerlink" title="第十六章 HTML5脚本编程"></a>第十六章 HTML5脚本编程</h1><hr>
<h1 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h1><ul>
<li><p>1701、在 IE7 及更早版本中，如果错误发生在位于外部文件的脚本中，行号通常会与错误所在的行号差 1。如果是嵌入在页面中的脚本发生错误，则行号就是错误所在的行号</p>
</li>
<li><p>1702、ECMA-262 第 3 版引入了 try-catch 语句，作为 JavaScript 中处理异常的一种标准方式。也就是说，我们应该把所有可能会抛出错误的代码都放在 try 语句块中，而把那些用于错误处理的代码放在 catch 块中。如果 try 块中的任何代码发生了错误，就会立即退出代码执行过程，然后接着执行 catch 块。此时， catch 块会接收到一个包含错误信息的对象。与在其他语言中不同的是，即使你不想使用这个错误对象，也要给它起个名字。这个对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误消息的 message 属性。ECMA-262 还规定了一个保存错误类型的 name 属性；当前所有浏览器都支持这个属性（Opera 9 之前的版本不支持这个属性）。因此，在发生错误时，就可以像下面这样实事求是地显示浏览器给出的消息</p>
</li>
<li><p>1703、只要代码中包含 finally 子句，那么无论 try 还是 catch 语句块中的 return 语句都将被忽略。因此，在使用 finally 子句之前，一定要非常清楚你想让代码怎么样</p>
</li>
<li><p>1704、TypeError 类型在 JavaScript 中会经常用到，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。错误的原因虽然多种多样，但归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致</p>
</li>
<li><p>1705、使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函数的调用放在 try-catch 语句当中，万一有什么错误发生，也好恰当地处理它们</p>
</li>
<li><p>1706、在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才会继续执行<br>437、利用原型链还可以通过继承 Error 来创建自定义错误类型（原型链在第 6 章中介绍）。此时，需要为新创建的错误类型指定 name 和 message 属性</p>
</li>
<li><p>1707、说到抛出错误与捕获错误，我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息</p>
</li>
<li><p>1708、图像也支持 error 事件。只要图像的 src 特性中的 URL 不能返回可以被识别的图像格式，就会触发 error 事件。此时的 error 事件遵循 DOM格式，会返回一个以图像为目标的 event 对象</p>
</li>
<li><p>1709、通过在 for 循环中添加 try-catch 语句，任何模块初始化时出错，都不会影响其他模块的初始化。在以上重写的代码中，如果有错误发生，相应的错误将会得到独立的处理，并不会影响到用户的体验</p>
</li>
<li><p>1710、console对象具有下列方法：error(message) ：将错误消息记录到控制台；info(message) ：将信息性消息记录到控制台；log(message) ：将一般消息记录到控制台；warn(message) ：将警告消息记录到控制台</p>
</li>
<li><p>1711、还有一种方案是使用 LiveConnect，也就是在 JavaScript 中运行 Java 代码。Firefox、Safari 和 Opera都支持 LiveConnect，因此可以操作 Java 控制台：java.lang.System.out.println(“Your message”)</p>
</li>
<li><p>1712、记录消息要比使用 alert() 函数更可取，因为警告框会阻断程序的执行，而在测定异步处理对时间的影响时，使用警告框会影响结果</p>
</li>
<li><p>1713、抛出错误例子：throw new Error(“divide(): Both arguments must be numbers.”)</p>
</li>
<li><p>1714、在可能发生错误的地方使用 try-catch 语句，这样你还有机会以适当的方式对错误给出响应，而不必沿用浏览器处理错误的机制</p>
</li>
<li><p>1715、使用 window.onerror 事件处理程序，这种方式可以接受 try-catch 不能处理的所有错误（仅限于 IE、Firefox 和 Chrome）</p>
</li>
</ul>
<hr>
<h1 id="第十八章-JavaScript-与-XML"><a href="#第十八章-JavaScript-与-XML" class="headerlink" title="第十八章 JavaScript 与 XML"></a>第十八章 JavaScript 与 XML</h1><hr>
<h1 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h1><hr>
<h1 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h1><ul>
<li><p>2001、JavaScript 字符串与 JSON 字符串的最大区别在于，JSON 字符串必须使用双引号（单引号会导致语法错误）</p>
</li>
<li><p>2002、JSON 中的对象要求给属性加引号</p>
</li>
<li><p>2003、JSON 中没有变量的概念</p>
</li>
<li><p>2004、JSON没有末尾的分号</p>
</li>
<li><p>2005、 eval() 函数可以解析、解释并返回 JavaScript 对象和数组</p>
</li>
<li><p>2006、JSON 对象有两个方法： stringify() 和 parse() 。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值</p>
</li>
<li><p>2007、将 JSON 字符串直接传递给 JSON.parse() 就可以得到相应的 JavaScript 值</p>
</li>
<li><p>2008、 JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进</p>
</li>
<li><p>2009、有时候， JSON.stringify() 还是不能满足对某些对象进行自定义序列化的需求。在这些情况下，可以给对象定义 toJSON() 方法，返回其自身的 JSON 数据格式</p>
</li>
</ul>
<hr>
<h1 id="第二十一章-Ajax-与-Comet"><a href="#第二十一章-Ajax-与-Comet" class="headerlink" title="第二十一章 Ajax 与 Comet"></a>第二十一章 Ajax 与 Comet</h1><ul>
<li><p>2101、在使用 XHR 对象时，要调用的第一个方法是 open() ，它接受 3 个参数：要发送的请求的类型（ “get” 、 “post” 等）、请求的 URL 和表示是否异步发送请求的布尔值</p>
</li>
<li><p>2102、要发送特定的请求，必须调用 send() 方法。这里的 send() 方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入 null ，因为这个参数对有些浏览器来说是必需的。调用 send() 之后，请求就会被分派到服务器</p>
</li>
<li><p>2103、调用 XHR 对象的 getResponseHeader() 方法并传入头部字段名称，可以取得相应的响应头部信息。而调用 getAllResponseHeaders() 方法则可以取得一个包含所有头部信息的长字符串</p>
</li>
<li><p>2104、使用 GET 请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用 encodeURIComponent() 进行编码，然后才能放到 URL 的末尾；而且所有名-值对儿都必须由和号（&amp;）分隔</p>
</li>
<li><p>2105、 POST 请求应该把数据作为请求的主体提交，而 GET 请求传统上不是这样。 POST 请求的主体可以包含非常多的数据，而且格式不限</p>
</li>
<li><p>2106、如果不设置 Content-Type 头部信息，那么发送给服务器的数据就不会出现在 $_POST 超级全局变量中。这时候，要访问同样的数据，就必须借助 $HTTP_RAW_POST_DATA</p>
</li>
<li><p>2107、与 GET 请求相比， POST 请求消耗的资源会更多一些。从性能角度来看，以发送相同的数据计， GET 请求的速度最多可达到 POST 请求的两倍</p>
</li>
<li><p>2108、XMLHttpRequest 2 级为此定义了FormData 类型。 FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利</p>
</li>
<li><p>2109、使用 FormData 的方便之处体现在不必明确地在 XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息</p>
</li>
<li><p>2110、支持 FormData 的浏览器有 Firefox 4+、Safari 5+、Chrome 和 Android 3+版 WebKit</p>
</li>
<li><p>2111、IE8 为 XHR 对象添加了一个 timeout 属性，表示请求在等待响应多少毫秒之后就终止。在给timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。这项功能后来也被收入了 XMLHttpRequest 2 级规范中。IE 8+是唯一支持超时设定的浏览器</p>
</li>
<li><p>2112、Firefox 最早引入了 overrideMimeType() 方法，用于重写 XHR 响应的 MIME 类型。这个方法后来也被纳入了 XMLHttpRequest 2 级规范。因为返回响应的 MIME 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 MIME 类型是很有用的</p>
</li>
<li><p>2113、微软在 IE8 中引入了 XDR（ XDomainRequest ）类型。这个对象与 XHR 类似，但能实现安全可靠的跨域通信。XDR 对象的安全机制部分实现了 W3C 的 CORS 规范</p>
</li>
<li><p>2114、即使浏览器对 CORS 的支持程度并不都一样，但所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求，因此有必要实现一个跨浏览器的方案。检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性。再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了</p>
</li>
<li><p>2115、第一种跨域请求技术是使用 <img> 标签，但该方法只能用于浏览器与服务器间的单向通信</p>
</li>
<li><p>2116、JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，是应用 JSON 的一种新方法，在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多，只不过是被包含在函数调用中的 JSON</p>
</li>
<li><p>2117、JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求</p>
</li>
<li><p>2118、JSONP 是通过动态 <code>&lt;script&gt;</code> 元素（要了解详细信息，请参考第 13 章）来使用的，使用时可以为src 属性指定一个跨域 URL。这里的 <code>&lt;script&gt;</code> 元素与 <img> 元素类似，都有能力不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript 代码，所以在请求完成后，即在 JSONP 响应加载到页面中以后，就会立即执行</p>
</li>
<li><p>2119、Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价</p>
</li>
<li><p>2120、SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API 或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME类型必须是 text/event-stream ，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接</p>
</li>
<li><p>2121、Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用 HTTP 升级从 HTTP 协议交换为 WebSocket 协议。也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作</p>
</li>
<li><p>2122、使用自定义协议而非 HTTP 协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。由于传递的数据包很小，因此 Web Sockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定JavaScript API 的时间还要长。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性的问题。Firefox 4 和 Opera 11 都曾默认启用 Web Sockets，但在发布前夕又禁用了，因为又发现了安全隐患。目前支持 Web Sockets 的浏览器有 Firefox 6+、Safari 5+、Chrome 和 iOS 4+版 Safari</p>
</li>
<li><p>2123、因为 Web Sockets只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化</p>
</li>
<li><p>2124、面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先，你是否有自由度建立和维护 Web Sockets服务器？因为 Web Socket 协议不同于 HTTP，所以现有服务器不能用于 Web Socket 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（如比赛成绩），那么 SSE 比较容易实现。如果用例必须双向通信（如聊天室），那么 Web Sockets 显然更好。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的</p>
</li>
<li><p>2125、同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8 通过 XDomainRequest 对象支持CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥</p>
</li>
<li><p>2126、Comet 是对 Ajax 的进一步扩展，让服务器几乎能够实时地向客户端推送数据。实现 Comet 的手段主要有两个：长轮询和 HTTP 流。所有浏览器都支持长轮询，而只有部分浏览器原生支持 HTTP 流。SSE（Server-Sent Events，服务器发送事件）是一种实现 Comet 交互的浏览器 API，既支持长轮询，也支持HTTP 流</p>
</li>
<li><p>2127、Web Sockets是一种与服务器进行全双工、双向通信的信道。与其他方案不同，Web Sockets 不使用HTTP 协议，而使用一种自定义的协议。这种协议专门为快速传输小数据设计。虽然要求使用不同的Web 服务器，但却具有速度上的优势</p>
</li>
</ul>
<hr>
<h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><ul>
<li><p>2201、函数绑定可以在特定的 this 环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境</p>
</li>
<li><p>2202、一个简单的 bind() 函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去</p>
</li>
<li><p>2203、ECMAScript 5 为所有函数定义了一个原生的 bind() 方法，进一步简单了操作<br>485、原生的 bind() 方法与前面介绍的自定义 bind() 方法类似，都是要传入作为 this 值的对象。支持原生 bind() 方法的浏览器有 IE9+、Firefox 4+和 Chrome</p>
</li>
<li><p>2204、与函数绑定紧密相关的主题是函数柯里化（function currying），它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数</p>
</li>
<li><p>2205、JavaScript 共享的本质一直是开发人员心头的痛。因为任何对象都可以被在同一环境中运行的代码修改。开发人员很可能会意外地修改别人的代码，甚至更糟糕地，用不兼容的功能重写原生对象。ECMAScript 5致力于解决这个问题，可以让开发人员定义防篡改对象（tamper-proof object）</p>
</li>
<li><p>2206、第一行代码已经完整定义 person 对象，但第二行代码仍然能给它添加属性。使用Object.preventExtensions() 方法可以改变这个行为，让你不能再给对象添加属性和方法</p>
</li>
<li><p>2207、虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。你仍然还可以修改和删除已有的成员。另外，使用 Object.istExtensible() 方法还可以确定对象是否可以扩展</p>
</li>
<li><p>2208、密封对象不可扩展，而且已有成员的 [[Configurable]] 特性将被设置为 false 。这就意味着不能删除属性和方法。要密封对象，可以使用 Object.seal() 方法</p>
</li>
<li><p>2209、冻结的对象既不可扩展，又是密封的，而且对象数据属性的 [[Writable]] 特性会被设置为 false 。如果定义 [[Set]] 函数，访问器属性仍然是可写的。ECMAScript 5定义的 Object.freeze() 方法可以用来冻结对象</p>
</li>
<li><p>2210、除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。随着页面在其生命周期中的推移，代码会按照执行顺序添加入队列。例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到队列中，并在下一个可能的时间里执行。当接收到某个 Ajax 响应时，回调函数的代码会被添加到队列。在 JavaScript 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行</p>
</li>
<li><p>2211、定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。设定一个 150ms 后执行的定时器不代表到了 150ms代码就立刻执行，它表示代码会在 150ms 后被加入到队列中。如果在这个时间点上，队列中没有其他东西，那么这段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下，代码可能明显地等待更长时间才执行</p>
</li>
<li><p>2212、使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。幸好，JavaScript 引擎够聪明，能避免这个问题。当使用 setInterval() 时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中</p>
</li>
<li><p>2213、这种重复定时器的规则有两个问题：(1) 某些间隔会被跳过；(2) 多个定时器的代码执行之间的间隔可能会比预期的小</p>
</li>
<li><p>2214、运行在浏览器中的 JavaScript 都被分配了一个确定数量的资源。不同于桌面应用往往能够随意控制他们要的内存大小和处理器时间，JavaScript 被严格限制了，以防止恶意的 Web 程序员把用户的计算机搞挂了。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的时间或者特定语句数量就不让它继续执行。如果代码达到了这个限制，会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它</p>
</li>
<li><p>2215、浏览器中某些计算和处理要比其他的昂贵很多。例如，DOM 操作比起非 DOM 交互需要更多的内存和 CPU 时间。连续尝试进行过多的 DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。尤其在 IE 中使用 onresize 事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在 onresize 事件处理程序内部如果尝试进行 DOM 操作，其高频率的更改可能会让浏览器崩溃。为了绕开这个问题，你可以使用定时器对该函数进行节流</p>
</li>
<li><p>2216、只要代码是周期性执行的，都应该使用节流，但是你不能控制请求执行的速率</p>
</li>
<li><p>2217、事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。对象可以发布事件，用来表示在该对象生命周期中某个有趣的时刻到了。然后其他对象可以观察该对象，等待这些有趣的时刻到来并通过运行代码来响应</p>
</li>
<li><p>2218、观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正常运作即使观察者不存在。从另一方面来说，观察者知道主体并能注册事件的回调函数（事件处理程序）。涉及 DOM 上时，DOM 元素便是主体，你的事件处理代码便是观察者</p>
</li>
<li><p>2219、拖放是一种非常流行的用户界面模式。它的概念很简单：点击某个对象，并按住鼠标按钮不放，将鼠标移动到另一个区域，然后释放鼠标按钮将对象“放”在这里。拖放功能也流行到了 Web 上，成为了一些更传统的配置界面的一种候选方案</p>
</li>
<li><p>2220、JavaScript 中的函数非常强大，因为它们是第一类对象。使用闭包和函数环境切换，还可以有很多使用函数的强大方法。可以创建作用域安全的构造函数，确保在缺少 new 操作符时调用构造函数不会改变错误的环境对象</p>
</li>
</ul>
<hr>
<h1 id="第二十三章-离线应用与客户端存储"><a href="#第二十三章-离线应用与客户端存储" class="headerlink" title="第二十三章 离线应用与客户端存储"></a>第二十三章 离线应用与客户端存储</h1><hr>
<h1 id="第二十四章-最-佳-实-践"><a href="#第二十四章-最-佳-实-践" class="headerlink" title="第二十四章 最 佳 实 践"></a>第二十四章 最 佳 实 践</h1><ul>
<li><p>2401、变量和函数命名：变量名应为名词如 car 或 person；函数名应该以动词开始，如 getName() 。返回布尔类型值的函数一般以 is 开头，如isEnable()； 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩（本章后面会讲到）来缓解</p>
</li>
<li><p>2402、由于在 JavaScript 中变量是松散类型的，很容易就忘记变量所应包含的数据类型。合适的命名方式可以一定程度上缓解这个问题，但放到所有的情况下看，还不够。有三种表示变量数据类型的方式。第一种方式是初始化；第二种方法是使用匈牙利标记法来指定变量类型；最后一种指定变量类型的方式是使用类型注释</p>
</li>
<li><p>2403、只要应用的某个部分过分依赖于另一部分，代码就是耦合过紧，难于维护。典型的问题如：对象直接引用另一个对象，并且当修改其中一个的同时需要修改另外一个。紧密耦合的软件难于维护并且需要经常重写</p>
</li>
<li><p>2404、编程实践：尊重对象所有权；避免全局量；避免与 null 进行比较；使用常量</p>
</li>
<li><p>2405、性能：注意作用域，避免全局查找，，避免 with 语句；选择正确方法，避免不必要的属性查找，优化循环，展开循环，避免双重解释，原生方法较快， Switch 语句较快，位运算符较快；最小化语句数，多个变量声明，插入迭代值，使用数组和对象字面量；优化DOM交互，最小化现场更新，使用  innerHTML，使用事件委托，注意 HTMLCollection；部署，构建过程，验证，压缩</p>
</li>
</ul>
<hr>
<h1 id="第二十五章-新兴的API"><a href="#第二十五章-新兴的API" class="headerlink" title="第二十五章 新兴的API"></a>第二十五章 新兴的API</h1><ul>
<li><p>2501、requestAnimationFrame() ：是一个着眼于优化 JavaScript 动画的 API，能够在动画运行期间发出信号。通过这种机制，浏览器就能够自动优化屏幕重绘操作。</p>
</li>
<li><p>2502、Page Visibility API：让开发人员知道用户什么时候正在看着页面，而什么时候页面是隐藏的。</p>
</li>
<li><p>2503、Geolocation API：在得到许可的情况下，可以确定用户所在的位置。在移动 Web 应用中，这个API 非常重要而且常用。</p>
</li>
<li><p>2504、File API：可以读取文件内容，用于显示、处理和上传。与 HTML5 的拖放功能结合，很容易就能创造出拖放上传功能。</p>
</li>
<li><p>2505、Web Timing：给出了页面加载和渲染过程的很多信息，对性能优化非常有价值。</p>
</li>
<li><p>2506、Web Workers：可以运行异步 JavaScript 代码，避免阻塞用户界面。在执行复杂计算和数据处理的时候，这个 API 非常有用；要不然，这些任务轻则会占用很长时间，重则会导致用户无法与页面交互。</p>
</li>
</ul>
<hr>
<h1 id="附录-A"><a href="#附录-A" class="headerlink" title="附录 A"></a>附录 A</h1><ul>
<li>常量</li>
<li>块级作用域及其他作用域</li>
<li>剩余参数与分布参数</li>
<li>默认参数值</li>
<li>生成器</li>
<li>迭代器</li>
<li>数组领悟</li>
<li>解构赋值</li>
<li>代理对象</li>
<li>代理函数</li>
<li>映射与集合</li>
<li>WeakMap</li>
<li>StructType</li>
<li>ArrayType</li>
<li>类，私有成员</li>
<li>getter 和 setter</li>
<li>继承</li>
<li>模块</li>
</ul>
<h1 id="附录-B"><a href="#附录-B" class="headerlink" title="附录 B"></a>附录 B</h1><ul>
<li>选择使用</li>
<li>变量</li>
<li>对象</li>
<li>函数</li>
<li>eval()</li>
<li>eval 与 arguments</li>
<li>抑制 this</li>
<li>其他变化</li>
</ul>
<h1 id="附录-C"><a href="#附录-C" class="headerlink" title="附录 C"></a>附录 C</h1><ul>
<li>JavaScript 库</li>
</ul>
<h1 id="附录-D"><a href="#附录-D" class="headerlink" title="附录 D"></a>附录 D</h1><ul>
<li>JavaScript工具</li>
</ul>
]]></content>
      <tags>
        <tag>js javascript 高程 高级 程序 编程 开发 学习 笔记 摘录</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化原理与实践</title>
    <url>/2020/08/10/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>提起性能优化，大家现在脑海里第一时间会映射出什么内容呢？</p>
<p>可能是类似<a href="https://developer.yahoo.com/performance/rules.html?guccounter=1">“雅虎军规”</a>和<a href="https://book.douban.com/subject/5362856/">《高性能 JavaScript》</a>这样历久弥香的经典之作，也可能是搜索引擎聚合给你的一篇又一篇以性能优化为主题的个人或团队实践而来的“私货”。至少当我确定自己的研发方向、并接到第一个性能优化任务时，我做的第一件事是向搜索引擎求助，第二件事是买书，然后开始了摸着石头过河，前后花费了大量的时间和精力。我深感性能优化实在是前端知识树中特别的一环——当你需要学习前端框架时，文档和源码几乎可以告诉你所有问题的答案，当你需要学习 Git 时，你也可以找到放之四海皆准的实践方案。但性能优化却不一样，它好像只能是一个摸索的过程。</p>
<p>这个摸索的过程是痛苦的、漫长的，也是紧要的。因为在如今的互联网环境下，一个前端团队如果只把性能优化这个任务写在纸上，而不投入实践，它将缺失最基本的竞争力。</p>
<p>笔者写这本小册，是希望通过短短十数个章节的讲解，尽可能降低一些大家学习性能优化的成本。</p>
<p>一方面，这本小册为没有接触过性能优化的新同学建立起一个正确的前端性能优化的“世界观”，知道性能优化是什么、为什么、怎么做，从而使性能优化这件事情有迹可循，有路可走。这样在面试现场被问到性能优化层面的问题时，能够做到滔滔不绝、言之有物，而非像背书一样罗列干巴巴的知识点，最终淹没在茫茫的求职大军中。另一方面，小册可以为在职的工程师们提供一线团队已经实践过的“方法论”，知道什么场景下该做什么事情，最终在脑海中留下一张涵盖核心原理和实践的、可随时查阅并且高度可扩展的性能优化思路索引表。然后在今后的开发生活中可以去践行它，更进一步去挖掘它。把性能优化变作你前端工程师生涯的一门必修课，进而演化为自己研发方面的核心竞争力。</p>
<p>同时，相信大家可以明确这样一个学习观念：任何技术的掌握，都离不开一定比例的理论基础和实际操作的支撑。</p>
<p>具体到前端性能优化这件事情上，我认为它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。所以希望大家阅读本小册时，能够读到一些“书本之外的东西”——最好是一边读一边回忆自己既有的开发经历，尝试去留意哪些知识是已知的，哪些是未知的。</p>
<p>这样读完之后，就可以有的放矢地把这些知识转换为自己的项目实践——前端技术日新月异，性能方案永远都在更迭，所以一定要形成自己的学习思路。</p>
<p>建议每一位读者都带着“学了就要用”的心态去读这本小册。如果阅读结束，能够为你带来哪怕一个小小的开发习惯或者优化观念上的改变，这数小时的阅读时间就算没有白费。</p>
<h2 id="知识体系：-从一道面试题说起"><a href="#知识体系：-从一道面试题说起" class="headerlink" title="知识体系： 从一道面试题说起"></a>知识体系： 从一道面试题说起</h2><p>在展开性能优化的话题之前，我想先抛出一个老生常谈的面试问题：</p>
<blockquote>
<p>从输入 URL 到页面加载完成，发生了什么？</p>
</blockquote>
<p>这个问题非常重要，因为我们后续的内容都将以这个问题的答案为骨架展开。我希望正在阅读这本小册的各位可以在心里琢磨一下这个问题——无须你调动太多计算机的专业知识，只需要你用最快的速度在脑海中架构起这个抽象的过程——我们接下来所有的工作，就是围绕这个过程来做文章。</p>
<p>我们现在站在性能优化的角度，一起简单地复习一遍这个经典的过程：首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作（如下图所示）。</p>
<p><img src="https://i.loli.net/2021/01/11/bngLF1xGJBAwq38.png" alt="img"></p>
<p>我们将这个过程切分为如下的过程片段：</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求抛出</li>
<li>服务端处理请求，HTTP 响应返回</li>
<li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li>
</ol>
<p>大家谨记，我们任何一个用户端的产品，都需要把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</p>
<h2 id="从原理到实践：各个击破"><a href="#从原理到实践：各个击破" class="headerlink" title="从原理到实践：各个击破"></a>从原理到实践：各个击破</h2><p>我们接下来要做的事情，就是针对这五个过程进行分解，各个提问，各个击破。</p>
<p>具体来说，DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？能——浏览器 DNS 缓存和 DNS prefetch。TCP 每次的三次握手都急死人，有没有解决方案？有——长连接、预连接、接入 SPDY 协议。如果说这两个过程的优化往往需要我们和团队的服务端工程师协作完成，前端单方面可以做的努力有限，那么 HTTP 请求呢？——在减少请求次数和减小请求体积方面，我们应该是专家！再者，服务器越远，一次请求就越慢，那部署时就把静态资源放在离我们更近的 CDN 上是不是就能更快一些？</p>
<p>以上提到的都是网络层面的性能优化。再往下走就是浏览器端的性能优化——这部分涉及资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等——这正是前端工程师可以真正一展拳脚的地方。学习这些知识，不仅可以帮助我们从根本上提升页面性能，更能够大大加深个人对浏览器底层原理、运行机制的理解，一举两得！</p>
<p>我们整个的知识图谱，用思维导图展示如下：</p>
<p><img src="https://i.loli.net/2021/01/11/Nfnv1sLqVd9bjHU.png" alt="img"></p>
<h2 id="小册格局"><a href="#小册格局" class="headerlink" title="小册格局"></a>小册格局</h2><p>总的来说，我们将从<strong>网络层面</strong>和<strong>渲染层面</strong>两个大的维度来逐个点亮前端性能优化的技能树。</p>
<p>这两个维度的知识面貌各有千秋：在网络层面，我们需要学习一些必需的理论基础作为前置知识。这部分的学习或许不需要大家写特别多的代码，但需要大家对每一个知识点理解透彻，进而应用到自己日常优化的决策中去。网络层面结束后，由本地存储开始，我们会渐渐过渡到浏览器这一端的优化，大家喜闻乐见的“真代码”就会相应地多起来。</p>
<p>为了使同学们耐心学习一些理论性稍强的知识，我也会尽自己所能去讲述得有趣、易读、可用，同时希望大家可以真的沉下心去理解这些知识，它们与大家喜闻乐见的框架和工具无异，一样是实实在在的生产力。</p>
<p>“经验丰富的人读书用两只眼睛，一只眼睛看到纸面上的话，另一只眼睛看到纸的背面”。在这本小册，代码片段固然有用，它们是“纸面上的话”，我自然希望大家可以记下来、用起来。而代码之外那些反复讲解的原理，则是“纸的背面”，同样是我希望引起大家重视的内容。</p>
<p>现在相信大家已经对我们的优化观念、知识结构、小册格局都有了基本认知，那么我们就赶快趁热打铁，进入实战技能的学习吧~</p>
<a id="more"></a>

<h1 id="网络篇-1：webpack-性能调优与-Gzip-原理"><a href="#网络篇-1：webpack-性能调优与-Gzip-原理" class="headerlink" title="网络篇 1：webpack 性能调优与 Gzip 原理"></a>网络篇 1：webpack 性能调优与 Gzip 原理</h1><p>从本节开始，我们进入网络层面的性能优化世界。</p>
<p>大家可以从第一节的示意图中看出，我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程：</p>
<ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求/响应</li>
</ul>
<p>对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。因此我们开门见山，抓主要矛盾，直接从 HTTP 开始讲起。</p>
<p>HTTP 优化有两个大的方向：</p>
<ul>
<li>减少请求次数</li>
<li>减少单次请求所花费的时间</li>
</ul>
<p>这两个优化点直直地指向了我们日常开发中非常常见的操作——资源的压缩与合并。没错，这就是我们每天用构建工具在做的事情。而时下最主流的构建工具无疑是 webpack，所以我们这节的主要任务就是围绕业界霸主 webpack 来做文章。</p>
<h2 id="webpack-的性能瓶颈"><a href="#webpack-的性能瓶颈" class="headerlink" title="webpack 的性能瓶颈"></a>webpack 的性能瓶颈</h2><p>相信每个用过 webpack 的同学都对“打包”和“压缩”这样的事情烂熟于心。这些老生常谈的特性，我更推荐大家去阅读文档。而关于 webpack 的详细操作，则推荐大家读读这本 <a href="https://juejin.im/book/5a6abad5518825733c144469/section/5a6abad5518825732e2f8546#heading-2">关于 webpack 的掘金小册</a>，这里我们把注意力放在 webpack 的性能优化上。</p>
<p>webpack 的优化瓶颈，主要是两个方面：</p>
<ul>
<li>webpack 的构建过程太花时间</li>
<li>webpack 打包的结果体积太大</li>
</ul>
<h2 id="webpack-优化方案"><a href="#webpack-优化方案" class="headerlink" title="webpack 优化方案"></a>webpack 优化方案</h2><h3 id="构建过程提速策略"><a href="#构建过程提速策略" class="headerlink" title="构建过程提速策略"></a>构建过程提速策略</h3><h4 id="不要让-loader-做太多事情——以-babel-loader-为例"><a href="#不要让-loader-做太多事情——以-babel-loader-为例" class="headerlink" title="不要让 loader 做太多事情——以 babel-loader 为例"></a>不要让 loader 做太多事情——以 babel-loader 为例</h4><p>babel-loader 无疑是强大的，但它也是慢的。</p>
<p>最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码帮我们规避了对庞大的 node_modules 文件夹或者 bower_components 文件夹的处理。但通过限定文件范围带来的性能提升是有限的。除此之外，如果我们选择开启缓存将转译结果缓存至文件系统，则至少可以将 babel-loader 的工作效率提升两倍。要做到这点，我们只需要为 loader 增加相应的参数设定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loader: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以上都是在讨论针对 loader 的配置，但我们的优化范围不止是 loader 们。</p>
<p>举个🌰，尽管我们可以在 loader 配置时通过写入 exclude 去避免 babel-loader 对不必要的文件的处理，但是考虑到这个规则仅作用于这个 loader，像一些类似 UglifyJsPlugin 的 webpack 插件在工作时依然会被这些庞大的第三方库拖累，webpack 构建速度依然会因此大打折扣。所以针对这些庞大的第三方库，我们还需要做一些额外的努力。</p>
<h4 id="不要放过第三方库"><a href="#不要放过第三方库" class="headerlink" title="不要放过第三方库"></a>不要放过第三方库</h4><p>第三方库以 node_modules 为代表，它们庞大得可怕，却又不可或缺。</p>
<p>处理第三方库的姿势有很多，其中，Externals 不够聪明，一些情况下会引发重复打包的问题；而 CommonsChunkPlugin 每次构建时都会重新构建一次 vendor；出于对效率的考虑，我们这里为大家推荐 DllPlugin。</p>
<p>DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。<strong>这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包</strong>。</p>
<p>用 DllPlugin 处理文件，要分两步走：</p>
<ul>
<li>基于 dll 专属的配置文件，打包 dll 库</li>
<li>基于 webpack.config.js 文件，打包业务代码</li>
</ul>
<p>以一个基于 React 的简单项目为例，我们的 dll 的配置文件可以编写如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      <span class="comment">// 依赖的库数组</span></span><br><span class="line">      vendor: [</span><br><span class="line">        <span class="string">&#x27;prop-types&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;babel-polyfill&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;react-dom&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;react-router-dom&#x27;</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">      filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">      library: <span class="string">&#x27;[name]_[hash]&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">        <span class="comment">// DllPlugin的name属性需要和libary保持一致</span></span><br><span class="line">        name: <span class="string">&#x27;[name]_[hash]&#x27;</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name]-manifest.json&#x27;</span>),</span><br><span class="line">        <span class="comment">// context需要和webpack.config.js保持一致</span></span><br><span class="line">        context: __dirname,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完成之后，运行这个配置文件，我们的 dist 文件夹里会出现这样两个文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vendor-manifest.json</span><br><span class="line">vendor.js</span><br></pre></td></tr></table></figure>
<p>vendor.js 不必解释，是我们第三方库打包的结果。这个多出来的 vendor-manifest.json，则用于描述每个第三方库对应的具体路径，我这里截取一部分给大家看下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vendor_397f9e25e49947b8675d&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./node_modules/core-js/modules/_export.js&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;buildMeta&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;providedExports&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./node_modules/prop-types/index.js&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;buildMeta&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;providedExports&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>随后，我们只需在 webpack.config.js 里针对 dll 稍作配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="comment">// 编译入口</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 目标文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// dll相关配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      <span class="comment">// manifest就是我们第一步中打包出来的json文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">&#x27;./dist/vendor-manifest.json&#x27;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一次基于 dll 的 webpack 构建过程优化，便大功告成了！</p>
<h4 id="Happypack——将-loader-由单进程转为多进程"><a href="#Happypack——将-loader-由单进程转为多进程" class="headerlink" title="Happypack——将 loader 由单进程转为多进程"></a>Happypack——将 loader 由单进程转为多进程</h4><p>大家知道，webpack 是单线程的，就算此刻存在多个任务，你也只能排队一个接一个地等待处理。这是 webpack 的缺点，好在我们的 CPU 是多核的，Happypack 会充分释放 CPU 在多核并发方面的优势，帮我们把任务分解给多个子进程去并发执行，大大提升打包效率。</p>
<p>HappyPack 的使用方法也非常简单，只需要我们把对 loader 的配置转移到 HappyPack 中去就好，我们可以手动告诉 HappyPack 我们需要多少个并发的进程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>)</span><br><span class="line"><span class="comment">// 手动创建进程池</span></span><br><span class="line"><span class="keyword">const</span> happyThreadPool =  HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 问号后面的查询参数指定了处理这类文件的HappyPack实例的名字</span></span><br><span class="line">        loader: <span class="string">&#x27;happypack/loader?id=happyBabel&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应</span></span><br><span class="line">      id: <span class="string">&#x27;happyBabel&#x27;</span>,</span><br><span class="line">      <span class="comment">// 指定进程池</span></span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">      loaders: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建结果体积压缩"><a href="#构建结果体积压缩" class="headerlink" title="构建结果体积压缩"></a>构建结果体积压缩</h3><h4 id="文件结构可视化，找出导致体积过大的原因"><a href="#文件结构可视化，找出导致体积过大的原因" class="headerlink" title="文件结构可视化，找出导致体积过大的原因"></a>文件结构可视化，找出导致体积过大的原因</h4><p>这里为大家介绍一个非常好用的包组成可视化工具——<a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a>，配置方法和普通的 plugin 无异，它会以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来，格局如官方所提供这张图所示：</p>
<p><img src="https://i.loli.net/2021/01/11/Eawfzq8M9boXh5A.gif" alt="img"></p>
<p>在使用时，我们只需要将其以插件的形式引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拆分资源"><a href="#拆分资源" class="headerlink" title="拆分资源"></a>拆分资源</h4><p>这点仍然围绕 DllPlugin 展开，可参考上文。</p>
<h4 id="删除冗余代码"><a href="#删除冗余代码" class="headerlink" title="删除冗余代码"></a>删除冗余代码</h4><p>一个比较典型的应用，就是 <code>Tree-Shaking</code>。</p>
<p>从 webpack2 开始，webpack 原生支持了 ES6 的模块系统，并基于此推出了 Tree-Shaking。webpack 官方是这样介绍它的：</p>
<blockquote>
<p>Tree shaking is a term commonly used in the JavaScript context for dead-code elimination, or more precisely, live-code import. It relies on ES2015 module import/export for the static structure of its module system.</p>
</blockquote>
<p>意思是基于 import/export 语法，Tree-Shaking 可以在编译的过程中获悉哪些模块并没有真正被使用，这些没用的代码，在最后打包的时候会被去除。</p>
<p>举个🌰，假设我的主干文件（入口文件）是这么写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; page1, page2 &#125; <span class="keyword">from</span> <span class="string">&#x27;./pages&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// show是事先定义好的函数，大家理解它的功能是展示页面即可</span></span><br><span class="line">show(page1)</span><br></pre></td></tr></table></figure>
<p>pages 文件里，我虽然导出了两个页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page1 = xxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page2 = xxx</span><br></pre></td></tr></table></figure>
<p>但因为 page2 事实上并没有被用到（这个没有被用到的情况在静态分析的过程中是可以被感知出来的），所以打包的结果里会把这部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page2 = xxx;</span><br></pre></td></tr></table></figure>
<p>直接删掉，这就是 Tree-Shaking 帮我们做的事情。</p>
<p>相信大家不难看出，Tree-Shaking 的针对性很强，它更适合用来处理模块级别的冗余代码。至于<strong>粒度更细</strong>的冗余代码的去除，往往会被整合进 JS 或 CSS 的压缩或分离过程中。</p>
<p>这里我们以当下接受度较高的 UglifyJsPlugin 为例，看一下如何在压缩过程中对碎片化的冗余代码（如 console 语句、注释等）进行自动化删除：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> plugins: [</span><br><span class="line">   <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">     <span class="comment">// 允许并发</span></span><br><span class="line">     parallel: <span class="literal">true</span>,</span><br><span class="line">     <span class="comment">// 开启缓存</span></span><br><span class="line">     cache: <span class="literal">true</span>,</span><br><span class="line">     compress: &#123;</span><br><span class="line">       <span class="comment">// 删除所有的console语句    </span></span><br><span class="line">       drop_console: <span class="literal">true</span>,</span><br><span class="line">       <span class="comment">// 把使用多次的静态值自动定义为变量</span></span><br><span class="line">       reduce_vars: <span class="literal">true</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     output: &#123;</span><br><span class="line">       <span class="comment">// 不保留注释</span></span><br><span class="line">       comment: <span class="literal">false</span>,</span><br><span class="line">       <span class="comment">// 使输出的代码尽可能紧凑</span></span><br><span class="line">       beautify: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有心的同学会注意到，这段手动引入 UglifyJsPlugin 的代码其实是 webpack3 的用法，webpack4 现在已经默认使用 uglifyjs-webpack-plugin 对代码做压缩了——在 webpack4 中，我们是通过配置 optimization.minimize 与 optimization.minimizer 来自定义压缩相关的操作的。</p>
<p>这里也引出了我们学习性能优化的一个核心的理念——用什么工具，怎么用，并不是我们这本小册的重点，因为所有的工具都存在用法迭代的问题。但现在大家知道了在打包的过程中做一些如上文所述的“手脚”可以实现打包结果的最优化，那下次大家再去执行打包操作，会不会对这个操作更加留心，从而自己去寻找彼时操作的具体实现方案呢？我最希望大家掌握的技能就是，先在脑海中留下“这个xx操作是对的，是有用的”，在日后的实践中，可以基于这个认知去寻找把正确的操作落地的具体方案。</p>
<h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>大家想象这样一个场景。我现在用 React 构建一个单页应用，用 React-Router 来控制路由，十个路由对应了十个页面，这十个页面都不简单。如果我把这整个项目打一个包，用户打开我的网站时，会发生什么？有很大机率会卡死，对不对？更好的做法肯定是先给用户展示主页，其它页面等请求到了再加载。当然这个情况也比较极端，但却能很好地引出按需加载的思想：</p>
<ul>
<li>一次不加载完所有的文件内容，只加载此刻需要用到的那部分（会提前做拆分）</li>
<li>当需要更多内容时，再对用到的内容进行即时加载</li>
</ul>
<p>好，既然说到这十个 Router 了，我们就拿其中一个开刀，假设我这个 Router 对应的组件叫做 BugComponent，来看看我们如何利用 webpack 做到该组件的按需加载。</p>
<p>当我们不需要按需加载的时候，我们的代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BugComponent <span class="keyword">from</span> <span class="string">&#x27;../pages/BugComponent&#x27;</span></span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">&quot;/bug&quot;</span> component=&#123;BugComponent&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>为了开启按需加载，我们要稍作改动。</p>
<p>首先 webpack 的配置文件要走起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;/../dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;app.js&#x27;</span>,</span><br><span class="line">    publicPath: defaultSettings.publicPath,</span><br><span class="line">    <span class="comment">// 指定 chunkFilename</span></span><br><span class="line">    chunkFilename: <span class="string">&#x27;[name].[chunkhash:5].chunk.js&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>路由处的代码也要做一下配合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getComponent =&gt; (location, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], <span class="function">(<span class="params"><span class="built_in">require</span></span>) =&gt;</span> &#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">&#x27;../pages/BugComponent&#x27;</span>).default)</span><br><span class="line">  &#125;, <span class="string">&#x27;bug&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">&quot;/bug&quot;</span> getComponent=&#123;getComponent&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>对，核心就是这个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies, callback, chunkName)</span><br></pre></td></tr></table></figure>
<p>这是一个异步的方法，webpack 在打包时，BugComponent 会被单独打成一个文件，只有在我们跳转 bug 这个路由的时候，这个异步方法的回调才会生效，才会真正地去获取 BugComponent 的内容。这就是按需加载。</p>
<p>按需加载的粒度，还可以继续细化，细化到更小的组件、细化到某个功能点，都是 ok 的。</p>
<p>等等，这和说好的不一样啊？不是说 Code-Splitting 才是 React-Router 的按需加载实践吗？</p>
<p>没错，在 React-Router4 中，我们确实是用 Code-Splitting 替换掉了楼上这个操作。而且如果有使用过 React-Router4 实现过路由级别的按需加载的同学，可能会对 React-Router4 里用到的一个叫“Bundle-Loader”的东西印象深刻。我想很多同学读到按需加载这里，心里的预期或许都是时下大热的 Code-Splitting，而非我呈现出来的这段看似“陈旧”的代码。</p>
<p>但是，如果大家稍微留个心眼，去看一下 Bundle Loader 并不长的源代码的话，你会发现它竟然还是使用 require.ensure 来实现的——这也是我要把 require.ensure 单独拎出来的重要原因。所谓按需加载，根本上就是在正确的时机去触发相应的回调。理解了这个 require.ensure 的玩法，大家甚至可以结合业务自己去修改一个按需加载模块来用。</p>
<p>这也应了我之前跟大家强调那段话，工具永远在迭代，唯有掌握核心思想，才可以真正做到举一反三——唯“心”不破！</p>
<h2 id="彩蛋：Gzip-压缩原理"><a href="#彩蛋：Gzip-压缩原理" class="headerlink" title="彩蛋：Gzip 压缩原理"></a>彩蛋：Gzip 压缩原理</h2><p>恭喜大家迎来了本小册的第一个彩蛋。彩蛋为选学内容，以原理性知识为主。意在拓宽大家的技术视野，加深大家对优化相关知识的理解。</p>
<p>前面说了不少 webpack 的故事，目的还是帮大家更好地实现压缩和合并。说到压缩，可不只是构建工具的专利。我们日常开发中，其实还有一个便宜又好用的压缩操作：开启 Gzip。</p>
<p>具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">accept-encoding:gzip</span><br></pre></td></tr></table></figure>
<p>相信很多同学对 Gzip 也是了解到这里。之所以为大家开这个彩蛋性的小节，绝不是出于炫技要来给大家展示一下 Gzip 的压缩算法，而是想和大家聊一个和我们前端关系更密切的话题：HTTP 压缩。</p>
<blockquote>
<p>HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。</p>
</blockquote>
<p>以上是摘自百科的解释，事实上，大家可以这么理解：</p>
<p><strong>HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程</strong></p>
<p>Gzip 的内核就是 Deflate，目前我们压缩文件用得最多的就是 Gzip。可以说，Gzip 就是 HTTP 压缩的经典例题。</p>
<h3 id="该不该用-Gzip"><a href="#该不该用-Gzip" class="headerlink" title="该不该用 Gzip"></a>该不该用 Gzip</h3><p>如果你的项目不是极端迷你的超小型文件，我都建议你试试 Gzip。</p>
<p>有的同学或许存在这样的疑问：压缩 Gzip，服务端要花时间；解压 Gzip，浏览器要花时间。中间节省出来的传输时间，真的那么可观吗？</p>
<p>答案是肯定的。如果你手上的项目是 1k、2k 的小文件，那确实有点高射炮打蚊子的意思，不值当。但更多的时候，我们处理的都是具备一定规模的项目文件。实践证明，这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说，可以说是微不足道的。</p>
<h3 id="Gzip-是万能的吗"><a href="#Gzip-是万能的吗" class="headerlink" title="Gzip 是万能的吗"></a>Gzip 是万能的吗</h3><p>首先要承认 Gzip 是高效的，压缩后<strong>通常</strong>能帮我们减少响应 70% 左右的大小。</p>
<p>但它并非万能。Gzip 并不保证针对每一个文件的压缩都会使其变小。</p>
<p>Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大。反之亦然。</p>
<h3 id="webpack-的-Gzip-和服务端的-Gzip"><a href="#webpack-的-Gzip-和服务端的-Gzip" class="headerlink" title="webpack 的 Gzip 和服务端的 Gzip"></a>webpack 的 Gzip 和服务端的 Gzip</h3><p>一般来说，Gzip 压缩是服务器的活儿：服务器了解到我们这边有一个 Gzip 压缩的需求，它会启动自己的 CPU 去为我们完成这个任务。而压缩文件这个过程本身是需要耗费时间的，大家可以理解为我们以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销。</p>
<p>既然存在着这样的交换，那么就要求我们学会权衡。服务器的 CPU 性能不是无限的，如果存在大量的压缩需求，服务器也扛不住的。服务器一旦因此慢下来了，用户还是要等。Webpack 中 Gzip 压缩操作的存在，事实上就是为了在构建过程中去做一部分服务器的工作，为服务器分压。</p>
<p>因此，这两个地方的 Gzip 压缩，谁也不能替代谁。它们必须和平共处，好好合作。作为开发者，我们也应该结合业务压力的实际强度情况，去做好这其中的权衡。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，我们都在讨论文件——准确地说，是文本文件及其构建过程的优化。</p>
<p>但一个完整的现代前端应用，除了要包含 HTML、CSS 和 JS，往往还需要借助图片来提高用户的视觉体验。而图片优化的思路、场景与措施，又是另外一个说来话长的故事了。下面，我们就一起进入图片的小天地，一窥究竟。</p>
<h1 id="网络篇-2：图片优化——质量与性能的博弈"><a href="#网络篇-2：图片优化——质量与性能的博弈" class="headerlink" title="网络篇 2：图片优化——质量与性能的博弈"></a>网络篇 2：图片优化——质量与性能的博弈</h1><p>《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 <a href="http://www.stevesouders.com/blog/2013/04/26/i/">博客</a> 中提到：</p>
<blockquote>
<p>我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。</p>
<p>几个月后，我意识到这是错误的。图片才是页面上最重要的部分。</p>
<p>我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。</p>
</blockquote>
<p>这段话可谓字字珠玑。此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。</p>
<p>就图片这块来说，与其说我们是在做“优化”，不如说我们是在做“权衡”。因为我们要做的事情，就是去压缩图片的体积（或者一开始就选取体积较小的图片格式）。但这个优化操作，是以牺牲一部分成像质量为代价的。因此我们的主要任务，是尽可能地去寻求一个质量与性能之间的平衡点。</p>
<h2 id="2018-年，图片依然很大"><a href="#2018-年，图片依然很大" class="headerlink" title="2018 年，图片依然很大"></a>2018 年，图片依然很大</h2><p>这里先给大家介绍 <a href="https://httparchive.org/reports/page-weight#bytesTotal">HTTP-Archive</a> 这个网站，它会定期抓取 Web 上的站点，并记录资源的加载情况、Web API 的使用情况等页面的详细信息，并会对这些数据进行处理和分析以确定趋势。通过它我们可以实时地看到世界范围内的 Web 资源的统计结果。</p>
<p>截止到 2018 年 8 月，过去一年<strong>总的 web 资源</strong>的平均请求体积是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/QiwOJgSZXUIvpDC.png" alt="img"></p>
<p>而具体到<strong>图片</strong>这一类的资源，平均请求体积是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/uXpJNa6KFrmEenw.png" alt="img"></p>
<p>当然，随着我们工程师在性能方面所做的努力越来越有成效，平均来说，不管是资源总量还是图片体积，都在往越来越轻量的方向演化。这是一种值得肯定的进步。</p>
<p>但同时我们不得不承认，如图所示的这个图片体积，依然是太大了。图片在所有资源中所占的比重，也足够“触目惊心”了。为了改变这个现状，我们必须把图片优化提上日程。</p>
<h2 id="不同业务场景下的图片方案选型"><a href="#不同业务场景下的图片方案选型" class="headerlink" title="不同业务场景下的图片方案选型"></a>不同业务场景下的图片方案选型</h2><p>时下应用较为广泛的 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等，这些格式都是很有故事的，值得我们好好研究一把。此外，老生常谈的雪碧图（CSS Sprites）至今也仍在一线的前端应用中发光发热，我们也会有所提及。</p>
<p>不谈业务场景的选型都是耍流氓。下面我们就结合具体的业务场景，一起来解开图片选型的神秘面纱！</p>
<h3 id="前置知识：二进制位数与色彩的关系"><a href="#前置知识：二进制位数与色彩的关系" class="headerlink" title="前置知识：二进制位数与色彩的关系"></a>前置知识：二进制位数与色彩的关系</h3><p>在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。</p>
<p>一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</p>
<h3 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG/JPG"></a>JPEG/JPG</h3><p>关键字：<strong>有损压缩、体积小、加载快、不支持透明</strong></p>
<h4 id="JPG-的优点"><a href="#JPG-的优点" class="headerlink" title="JPG 的优点"></a>JPG 的优点</h4><p>JPG 最大的特点是<strong>有损压缩</strong>。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p>
<p>两大电商网站对大图的处理，是 JPG 图片应用场景的最佳写照：</p>
<p>打开淘宝首页，我们可以发现页面中最醒目、最庞大的图片，一定是以 .jpg 为后缀的：</p>
<p><img src="https://i.loli.net/2021/01/11/6htR7WCxBenOFc1.png" alt="img"></p>
<p>京东首页也不例外：</p>
<p><img src="https://i.loli.net/2021/01/11/OAuwNm3aSjr78Zo.png" alt="img"></p>
<p>使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。</p>
<h4 id="JPG-的缺陷"><a href="#JPG-的缺陷" class="headerlink" title="JPG 的缺陷"></a>JPG 的缺陷</h4><p>有损压缩在上文所展示的轮播图上确实很难露出马脚，但当它处理<strong>矢量图形</strong>和 <strong>Logo</strong> 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。</p>
<p>此外，JPEG 图像<strong>不支持透明度处理</strong>，透明图片需要召唤 PNG 来呈现。</p>
<h3 id="PNG-8-与-PNG-24"><a href="#PNG-8-与-PNG-24" class="headerlink" title="PNG-8 与 PNG-24"></a>PNG-8 与 PNG-24</h3><p>关键字：<strong>无损压缩、质量高、体积大、支持透明</strong></p>
<h4 id="PNG-的优点"><a href="#PNG-的优点" class="headerlink" title="PNG 的优点"></a>PNG 的优点</h4><p>PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。</p>
<p>PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是<strong>体积太大</strong>。</p>
<h4 id="PNG-8-与-PNG-24-的选择题"><a href="#PNG-8-与-PNG-24-的选择题" class="headerlink" title="PNG-8 与 PNG-24 的选择题"></a>PNG-8 与 PNG-24 的选择题</h4><p>什么时候用 PNG-8，什么时候用 PNG-24，这是一个问题。</p>
<p>理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。</p>
<p>但实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。</p>
<p>如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，基于对比的结果去做判断。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面我们提到，复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储。</p>
<p>考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</p>
<p>此时我们再次把目光转向性能方面堪称业界楷模的淘宝首页，我们会发现它页面上的 Logo，无论大小，还真的都是 PNG 格式：</p>
<p>主 Logo：</p>
<p><img src="https://i.loli.net/2021/01/11/YN3Zauf9MvWFLIe.png" alt="img"></p>
<p>较小的 Logo：</p>
<p><img src="https://i.loli.net/2021/01/11/fAt5dnQLPWcb2gI.png" alt="img"></p>
<p>颜色简单、对比度较强的透明小图也在 PNG 格式下有着良好的表现：</p>
<p><img src="https://i.loli.net/2021/01/11/oMAQPbWypvl1iGn.png" alt="img"></p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>关键字：<strong>文本文件、体积小、不失真、兼容性好</strong></p>
<p>SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。</p>
<h4 id="SVG-的特性"><a href="#SVG-的特性" class="headerlink" title="SVG 的特性"></a>SVG 的特性</h4><p>和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，<strong>文件体积更小，可压缩性更强</strong>。</p>
<p>当然，作为矢量图，它最显著的优势还是在于<strong>图片可无限放大而不失真</strong>这一点上。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。</p>
<p>此外，<strong>SVG 是文本文件</strong>。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的<strong>灵活性</strong>。</p>
<p>SVG 的局限性主要有两个方面，一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。</p>
<h4 id="SVG-的使用方式与应用场景"><a href="#SVG-的使用方式与应用场景" class="headerlink" title="SVG 的使用方式与应用场景"></a>SVG 的使用方式与应用场景</h4><p>SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。</p>
<ul>
<li><p>将 SVG 写入 HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>   <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将 SVG 写入独立文件后引入 HTML:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;文件名.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们更多用到的是后者。很多情况下设计师会给到我们 SVG 文件，就算没有设计师，我们还有非常好用的 <a href="http://www.iconfont.cn/">在线矢量图形库</a>。对于矢量图，我们无须深究过多，只需要对其核心特性有所掌握、日后在应用时做到有迹可循即可。</p>
</li>
</ul>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>关键字：<strong>文本文件、依赖编码、小图标解决方案</strong></p>
<p>Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。在了解 Base64 之前，我们先来了解一下雪碧图。</p>
<h4 id="前置知识：最经典的小图标解决方案——雪碧图（CSS-Sprites）"><a href="#前置知识：最经典的小图标解决方案——雪碧图（CSS-Sprites）" class="headerlink" title="前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）"></a>前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）</h4><p>雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西——一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。</p>
<p>MDN 对雪碧图的解释已经非常到位：</p>
<blockquote>
<p>图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。</p>
</blockquote>
<p>我们几乎可以在每一个有小图标出现的网站里找到雪碧图的影子（下图截取自京东首页）：</p>
<p><img src="https://i.loli.net/2021/01/11/S8yR4jF76CNn3uJ.png" alt="img"></p>
<p>和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。<strong>Base64 是作为雪碧图的补充而存在的。</strong></p>
<h4 id="理解-Base64"><a href="#理解-Base64" class="headerlink" title="理解 Base64"></a>理解 Base64</h4><p>通过我们上文的演示，大家不难看出，每次加载图片，都是需要单独向服务器请求这个图片对应的资源的——这也就意味着一次 HTTP 请求的开销。</p>
<p><strong>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</strong></p>
<p>我们来一起看一个实例，现在我有这么一个小小的放大镜 Logo：</p>
<p><img src="https://i.loli.net/2021/01/11/D86AjGN1vzliVdo.png" alt="img"></p>
<p>它对应的链接如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680</span><br></pre></td></tr></table></figure>
<p>按照一贯的思路，我们加载图片需要把图片链接写入 img 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器就会针对我们的图片链接去发起一个资源请求。</p>
<p>但是如果我们对这个图片进行 Base64 编码，我们会得到一个这样的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAMJGlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU8kagOeWJCQktEAEpITeBCnSpdfQpQo2QhJIKDEkBBU7uqjgWlARwYquitjWAshiw14Wwd4fiKgo62LBhsqbFNDV89477z9n7v3yzz9&#x2F;mcydMwOAehxbJMpFNQDIExaI48MCmeNT05ikR4AECIAKRgEamyMRBcTFRQEoQ+9&#x2F;yrubAJG9r9nLfP3c&#x2F;19Fk8uTcABA4iBncCWcPMiHAMDdOCJxAQCEXqg3m1YggkyEWQJtMUwQsrmMsxTsIeMMBUfJbRLjgyCnA6BCZbPFWQCoyfJiFnKyoB+1pZAdhVyBEHIzZF8On82F&#x2F;BnyqLy8qZDVrSFbZ3znJ+sfPjOGfbLZWcOsqEUuKsECiSiXPeP&#x2F;nI7&#x2F;LXm50qEYZrBR+eLweFnNsnnLmRopYyrk88KMmFjIWpCvC7hyexk&#x2F;4UvDk5T2HziSIDhngAEASuWygyMhG0A2FebGRCn1vpmCUBZkOPdooqCAlagYi3LFU+OV&#x2F;tHpPElIwhCzxfJYMptSaU5SgNLnRj6PNeSzqYifmKLIE20rFCTHQFaDfF+SkxCptHlexA+KGbIRS+NlOcP&#x2F;HAOZ4tB4hQ1mnicZqgvz4gtYMUqO4rDl+ehCnlzATwxX+MEKeZLxUUN5cnnBIYq6sGKeMEmZP1YuKgiMV47dJsqNU9pjzbzcMJneFHKrpDBhaGxfAVxsinpxICqIS1TkhmtnsyPiFHFxWxAFgkAwYAIpbBlgKsgGgtbehl74S9ETCthADLIAD9grNUMjUuQ9QvhMAEXgL0g8IBkeFyjv5YFCqP8yrFU87UGmvLdQPiIHPIGcByJBLvwtlY8SDkdLBo+hRvBTdA7MNRc2Wd9POqb6kI4YQgwmhhNDiTa4Pu6Le+NR8OkPmzPugXsO5fXNnvCE0E54RLhB6CDcmSIoFv+QORNEgw6YY6iyuozvq8MtoVdXPBD3gf6hb5yB6wN7fAyMFID7wdiuUPt9rtLhir&#x2F;NpdIX2ZGMkkeQ&#x2F;cnWP2Ugm53v61fq1WzVXJV5ZQzPVtCw1Y9egr6bPy58R&#x2F;5oiS3GDmLnsJPYBawZawBM7DjWiF3Gjsp4eG08lq+NoWjx8txyoB&#x2F;BT&#x2F;HYypiyWZM41jn2OH5W9oEC3vQC2ccSNFU0QyzI4hcwA+BuzWOyhByHUUxnRye4i8r2fsXW8oYh39MRxsVvuvwTAHiWQmXWNx0b7kFHngBAf&#x2F;dNZ&#x2F;YaLvsVABxt40jFhQodLnsQAAWowy9FDxjBvcsaVuQM3IA38AchIALEgkSQCibDOefDdSoG08AsMB+UgDKwAqwBVWAT2Ap2gj3gAGgAzeAkOAsugTZwA9yDa6UbvAB94B0YQBCEhNAQOqKHGCMWiB3ijHggvkgIEoXEI6lIOpKFCBEpMgtZgJQh5UgVsgWpRX5HjiAnkQtIO3IH6UR6kNfIJxRDqag2aohaoqNRDzQAjUQT0UloFpqPFqEL0WVoJVqD7kbr0ZPoJfQG2oG+QPsxgKliDMwEs8c8sCAsFkvDMjExNgcrxSqwGmwv1gT&#x2F;6WtYB9aLfcSJOB1n4vZwvYbjSTgHz8fn4EvxKnwnXo+fxq&#x2F;hnXgf&#x2F;pVAIxgQ7AheBBZhPCGLMI1QQqggbCccJpyB30434R2RSGQQrYju8NtLJWYTZxKXEjcQ9xFPENuJXcR+EomkR7Ij+ZBiSWxSAamEtI60m3ScdJXUTfqgoqpirOKsEqqSpiJUKVapUNmlckzlqspTlQGyBtmC7EWOJXPJM8jLydvITeQr5G7yAEWTYkXxoSRSsinzKZWUvZQzlPuUN6qqqqaqnqrjVAWq81QrVfernlftVP1I1aLaUoOoE6lS6jLqDuoJ6h3qGxqNZknzp6XRCmjLaLW0U7SHtA9qdDUHNZYaV22uWrVavdpVtZfqZHUL9QD1yepF6hXqB9WvqPdqkDUsNYI02BpzNKo1jmjc0ujXpGs6acZq5mku1dyleUHzmRZJy1IrRIurtVBrq9YprS46RjejB9E59AX0bfQz9G5toraVNks7W7tMe492q3afjpbOGJ1knek61TpHdToYGMOSwWLkMpYzDjBuMj6NMBwRMII3YsmIvSOujnivO1LXX5enW6q7T&#x2F;eG7ic9pl6IXo7eSr0GvQf6uL6t&#x2F;jj9afob9c&#x2F;o947UHuk9kjOydOSBkXcNUANbg3iDmQZbDS4b9BsaGYYZigzXGZ4y7DViGPkbZRutNjpm1GNMN&#x2F;Y1FhivNj5u&#x2F;Jypwwxg5jIrmaeZfSYGJuEmUpMtJq0mA6ZWpkmmxab7TB+YUcw8zDLNVpu1mPWZG5tHm88yrzO&#x2F;a0G28LDgW6y1OGfx3tLKMsVykWWD5TMrXSuWVZFVndV9a5q1n3W+dY31dRuijYdNjs0GmzZb1NbVlm9bbXvFDrVzsxPYbbBrH0UY5TlKOKpm1C17qn2AfaF9nX2nA8MhyqHYocHh5Wjz0WmjV44+N&#x2F;qro6tjruM2x3tOWk4RTsVOTU6vnW2dOc7VztddaC6hLnNdGl1ejbEbwxuzccxtV7prtOsi1xbXL27ubmK3vW497ubu6e7r3W95aHvEeSz1OO9J8Az0nOvZ7PnRy82rwOuA19&#x2F;e9t453ru8n421Gssbu21sl4+pD9tni0+HL9M33Xezb4efiR&#x2F;br8bvkb+ZP9d&#x2F;u&#x2F;&#x2F;TAJuA7IDdAS8DHQPFgYcD3wd5Bc0OOhGMBYcFlwa3hmiFJIVUhTwMNQ3NCq0L7QtzDZsZdiKcEB4ZvjL8FsuQxWHVsvoi3CNmR5yOpEYmRFZFPoqyjRJHNUWj0RHRq6Lvx1jECGMaYkEsK3ZV7IM4q7j8uD&#x2F;GEcfFjase9yTeKX5W&#x2F;LkEesKUhF0J7xIDE5cn3kuyTpImtSSrJ09Mrk1+nxKcUp7SMX70+NnjL6XqpwpSG9NIaclp29P6J4RMWDOhe6LrxJKJNydZTZo+6cJk&#x2F;cm5k49OUZ&#x2F;CnnIwnZCekr4r&#x2F;TM7ll3D7s9gZazP6OMEcdZyXnD9uau5PTwfXjnvaaZPZnnmsyyfrFVZPXw&#x2F;fgW&#x2F;VxAkqBK8yg7P3pT9Pic2Z0fOYG5K7r48lbz0vCNCLWGO8PRUo6nTp7aL7EQloo58r&#x2F;w1+X3iSPF2CSKZJGks0IaH7MtSa+kv0s5C38Lqwg&#x2F;TkqcdnK45XTj98gzbGUtmPC0KLfptJj6TM7Nllsms+bM6ZwfM3jIHmZMxp2Wu2dyFc7vnhc3bOZ8yP2f+n8WOxeXFbxekLGhaaLhw3sKuX8J+qStRKxGX3FrkvWjTYnyxYHHrEpcl65Z8LeWWXixzLKso+7yUs&#x2F;Tir06&#x2F;Vv46uCxzWetyt+UbVxBXCFfcXOm3cme5ZnlRedeq6FX1q5mrS1e&#x2F;XTNlzYWKMRWb1lLWStd2VEZVNq4zX7di3ecqftWN6sDqfesN1i9Z&#x2F;34Dd8PVjf4b924y3FS26dNmwebbW8K21NdY1lRsJW4t3PpkW&#x2F;K2c795&#x2F;Fa7XX972fYvO4Q7OnbG7zxd615bu8tg1&#x2F;I6tE5a17N74u62PcF7Gvfa792yj7GvbD&#x2F;YL93&#x2F;&#x2F;Pf0328eiDzQctDj4N5DFofWH6YfLq1H6mfU9zXwGzoaUxvbj0QcaWnybjr8h8MfO5pNmquP6hxdfoxybOGxweNFx&#x2F;tPiE70nsw62dUypeXeqfGnrp8ed7r1TOSZ82dDz546F3Du+Hmf880XvC4cuehxseGS26X6y66XD&#x2F;&#x2F;p+ufhVrfW+ivuVxrbPNua2se2H7vqd&#x2F;XkteBrZ6+zrl+6EXOj&#x2F;WbSzdu3Jt7quM29&#x2F;exO7p1XdwvvDtybd59wv&#x2F;SBxoOKhwYPa&#x2F;5l8699HW4dRzuDOy8&#x2F;Snh0r4vT9eKx5PHn7oVPaE8qnho&#x2F;rX3m&#x2F;Ky5J7Sn7fmE590vRC8Gekv+0vxr&#x2F;Uvrl4f+9v&#x2F;7ct&#x2F;4vu5X4leDr5e+0Xuz4+2Yty39cf0P3+W9G3hf+kHvw86PHh&#x2F;PfUr59HRg2mfS58ovNl+avkZ+vT+YNzgoYovZ8qMABhuamQnA6x0A0FLh2aENAMoExd1MLojiPikn8J9YcX+TixsAO&#x2F;wBSJoHQBQ8o2yEzQIyFb5lR&#x2F;BEf4C6uAw3pUgyXZwVvqjwxkL4MDj4xhAAUhMAX8SDgwMbBge&#x2F;bIPJ3gHgRL7iTigT2R10s4OM2rpfgh&#x2F;l34RUcT2MnhaNAAAB90lEQVQ4Ee1Tv0tbURQ+5yVqFVHs4pBioSAp1mAxUdq05sfoKrh072QXN6HdnMTVyboLShH8D+xLg8UkhjY&#x2F;tJlERIQilCpKfbmn3w08eOTdl83Nu5x7z&#x2F;m+737vnHeJHtZ9d4CDLhARK1esfSChWWF6TSQnRLwnSq2mp2OnQTw3bxS2D349I77bAijuAt0oJNfEtJiKj392c6ZotSfhFJfdfUE+jn1eWZwe6HL6Q0yjqHyE6zALr+eK9bl2rvfsc2wXKwskvAZQbibxYsYL1nu7UJ1H2BKiq+bfsaFslp12jD4bHHPLCdwumQi4bBuiP+Gov3vwaMqEMQqz6EER9fHjwyASMGVdU6KeB2F8jjH9cw2+sS5Hg0jodUTXRNFlEMYvzPyjBVa0YCLZpcoE2pBBTYmokgmjcz5hZl7RJEz&#x2F;vV2oLDcajR6XvHdYT0qTdzQPfd7s9D&#x2F;7&#x2F;gotYhdqn&#x2F;Chy3ovQrfMVMUwh3HpE51rLaGqw+FMNhH97aa80SisAblC9R1EN&#x2F;AYej0EpGgXpARyEbzKY4i&#x2F;NYkHCmux&#x2F;f3GgBP6l8EjiVp40nD8&#x2F;c3k2Mm3Uu2pUvIVkBEt3vVIpV&#x2F;FYhea466Owi7IFPPl40jTcfKojaBNB6mp8Wkvzjc8b7HTPvkyehYKh5NwXGbiP52wD7X76cB&#x2F;EiWtaCMHwyUAAAAASUVORK5CYII&#x3D;</span><br></pre></td></tr></table></figure>
<p>字符串比较长，我们可以直接用这个字符串替换掉上文中的链接地址。你会发现浏览器原来是可以理解这个字符串的，它自动就将这个字符串解码为了一个图片，而不需再去发送 HTTP 请求。</p>
<h4 id="Base64-的应用场景"><a href="#Base64-的应用场景" class="headerlink" title="Base64 的应用场景"></a>Base64 的应用场景</h4><p>上面这个实例，其实源自我们 <a href="https://juejin.im/books">掘金</a> 网站 Header 部分的搜索栏 Logo：</p>
<p><img src="https://i.loli.net/2021/01/11/zCaGifkhlXpYRMQ.png" alt="img"></p>
<p>大家不妨打开小册首页，然后打开开发者工具，在源码中搜索“base64”关键字，你会发现 Base64 码出现的地方真的不少。而且它对应的图片往往是<strong>非常小的 Logo</strong>。</p>
<p>既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？</p>
<p>这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。<br>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。</p>
<p>因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：</p>
<ul>
<li>图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）</li>
<li>图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）</li>
<li>图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）</li>
</ul>
<h4 id="Base64-编码工具推荐"><a href="#Base64-编码工具推荐" class="headerlink" title="Base64 编码工具推荐"></a>Base64 编码工具推荐</h4><p>这里最推荐的是利用 webpack 来进行 Base64 的编码——webpack 的 <a href="https://github.com/webpack-contrib/url-loader">url-loader</a> 非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。</p>
<p>除此之外，市面上免费的 Base64 编解码工具种类是非常多样化的，有很多网站都提供在线编解码的服务，大家选取自己认为顺手的工具就好。</p>
<h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>关键字：<strong>年轻的全能型选手</strong></p>
<p>WebP 是今天在座各类图片格式中最年轻的一位，它于 2010 年被提出， 是 Google 专为 Web 开发的一种<strong>旨在加快图片加载速度</strong>的图片格式，它支持有损压缩和无损压缩。</p>
<h4 id="WebP-的优点"><a href="#WebP-的优点" class="headerlink" title="WebP 的优点"></a>WebP 的优点</h4><p>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。<br>WebP 的官方介绍对这一点有着更权威的阐述：</p>
<blockquote>
<p>与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。</p>
</blockquote>
<p>我们开篇提到，图片优化是质量与性能的博弈，从这个角度看，WebP 无疑是真正的赢家。</p>
<h4 id="WebP-的局限性"><a href="#WebP-的局限性" class="headerlink" title="WebP 的局限性"></a>WebP 的局限性</h4><p>WebP 纵有千般好，但它毕竟<strong>太年轻</strong>。我们知道，任何新生事物，都逃不开兼容性的大坑。现在是 2018 年 9 月，WebP 的支持情况是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/cEVGFjt89xW3lNL.png" alt="img"></p>
<p>坦白地说，虽然没有特别惨（毕竟还有亲爹 Chrome 在撑腰），但也足够让人望而却步了。</p>
<p>此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。</p>
<h4 id="WebP-的应用场景"><a href="#WebP-的应用场景" class="headerlink" title="WebP 的应用场景"></a>WebP 的应用场景</h4><p>现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，也就是说我们需要准备 PlanB，准备降级方案。</p>
<p>目前真正把 WebP 格式落地到网页中的网站并不是很多，这其中淘宝首页对 WebP 兼容性问题的处理方式就非常有趣。我们可以打开 Chrome 的开发者工具搜索其源码里的 WebP 关键字：</p>
<p><img src="https://i.loli.net/2021/01/11/lAXUrk5Puy8hwJN.png" alt="img"></p>
<p>我们会发现检索结果还是挺多的（单就图示的加载结果来看，足足有 200 多条），下面大家注意一下这些 WebP 图片的链接地址（以其中一个为例）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;手机app - 聚划算&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>.webp 前面，还跟了一个 .jpg 后缀！</p>
<p>我们现在先大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。带着这个预判，我们打开并不支持 WebP 格式的 Safari 来进入同样的页面，再次搜索 WebP 关键字：</p>
<p><img src="https://i.loli.net/2021/01/11/tpVW4IZBGMYDJHO.png" alt="img"></p>
<p>Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;手机app - 聚划算&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。</p>
<p>此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。</p>
<p>由此也可以看出，我们 WebP 格式的局限性确实比较明显，如果决定使用 WebP，兼容性处理是必不可少的。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>不知道大家有没有注意到这一点：在图片这一节，我用到的许多案例图示，都是源于一线的电商网站。</p>
<p>为什么这么做？因为图片是电商平台的重要资源，甚至有人说“做电商就是做图片”。淘宝和京东，都是流量巨大、技术成熟的站点，它们在性能优化方面起步早、成效好，很多方面说是教科书般的案例也不为过。</p>
<p>这也是非常重要的一个学习方法。在小册开篇我提到，性能优化不那么好学，有很大原因是因为这块的知识不成体系、难以切入，同时技术方案又迭代得飞快。当我们不知道怎么切入的时候，或者说当我们面对一个具体的问题无从下手的时候，除了翻阅手中的书本（很可能是已经过时的）和网络上收藏的文章（也许没那么权威），现在是不是又多了“打开那些优秀的网站看一看”这条路可以走了呢？</p>
<p>好了，至此，我们终于结束了图片优化的征程。下面，我们以存储篇为过渡，进入 JS 和 CSS 的世界！</p>
<h1 id="存储篇-1：浏览器缓存机制介绍与缓存策略剖析"><a href="#存储篇-1：浏览器缓存机制介绍与缓存策略剖析" class="headerlink" title="存储篇 1：浏览器缓存机制介绍与缓存策略剖析"></a>存储篇 1：浏览器缓存机制介绍与缓存策略剖析</h1><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些：</p>
<blockquote>
<p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p>
</blockquote>
<p>很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p>
<ol>
<li>Memory Cache</li>
<li>Service Worker Cache</li>
<li>HTTP Cache</li>
<li>Push Cache</li>
</ol>
<p>大家对 HTTP Cache（即 Cache-Control、expires 等字段控制的缓存）应该比较熟悉，如果对其它几种缓存可能还没什么概念，我们可以先来看一张线上网站的 Network 面板截图：</p>
<p><img src="https://i.loli.net/2021/01/11/fcj1eY8Uy5uBCJK.png" alt="img"></p>
<p>我们给 size 这一栏一个特写：</p>
<p><img src="https://i.loli.net/2021/01/11/iYRVzuH1S8nWTtx.png" alt="img"></p>
<p>大家注意一下非数字——即形如“（from xxx）”这样的描述——对应的资源，这些资源就是我们通过缓存获取到的。其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。</p>
<p>本节将会针对这四个方面各个击破。考虑到 HTTP 缓存是最主要、最具有代表性的缓存策略，也是每一位前端工程师都应该深刻理解掌握的性能优化知识点，我们下面优先针对 HTTP 缓存机制进行剖析。</p>
<h2 id="HTTP-缓存机制探秘"><a href="#HTTP-缓存机制探秘" class="headerlink" title="HTTP 缓存机制探秘"></a>HTTP 缓存机制探秘</h2><p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为<strong>强缓存</strong>和<strong>协商缓存</strong>。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p>
<h3 id="强缓存的特征"><a href="#强缓存的特征" class="headerlink" title="强缓存的特征"></a>强缓存的特征</h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信。</strong></p>
<p>命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）。</p>
<p><img src="https://i.loli.net/2021/01/11/wib9DdVATQZz1qk.png" alt="img"></p>
<h3 id="强缓存的实现：从-expires-到-cache-control"><a href="#强缓存的实现：从-expires-到-cache-control" class="headerlink" title="强缓存的实现：从 expires 到 cache-control"></a>强缓存的实现：从 expires 到 cache-control</h3><p>实现强缓存，过去我们一直用 <code>expires</code>。<br>当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p>
<p><img src="https://i.loli.net/2021/01/11/sloPOrSucXNe3mv.png" alt="img"></p>
<p>我们给 expires 一个特写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">expires: Wed, 11 Sep 2019 16:12:18 GMT</span><br></pre></td></tr></table></figure>
<p>可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</p>
<p>从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。</p>
<p>考虑到 expires 的局限性，HTTP1.1 新增了 <code>Cache-Control</code> 字段来完成 expires 的任务。<br>expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的<strong>完全替代方案</strong>。在当下的前端实践里，我们继续使用 expires 的唯一目的就是<strong>向下兼容</strong>。</p>
<p>现在我们给 Cache-Control 字段一个特写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cache-control: max-age=31536000</span><br></pre></td></tr></table></figure>
<p>如大家所见，在 Cache-Control 中，我们通过 <code>max-age</code> 来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。</p>
<p><strong>Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。</strong></p>
<h3 id="Cache-Control-应用分析"><a href="#Cache-Control-应用分析" class="headerlink" title="Cache-Control 应用分析"></a>Cache-Control 应用分析</h3><p>Cache-Control 的神通，可不止于这一个小小的 max-age。如下的用法也非常常见：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cache-control: max-age=3600, s-maxage=31536000</span><br></pre></td></tr></table></figure>
<p><strong>s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。</strong></p>
<p>这个 s-maxage 不像 max-age 一样为大家所熟知。的确，在项目不是特别大的场景下，max-age 足够用了。但在依赖各种<strong>代理</strong>的大型架构中，我们不得不考虑<strong>代理服务器</strong>的缓存问题。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。</p>
<p>(此处应注意这样一个细节：s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。)</p>
<p>那么什么是 public 缓存呢？说到这里，Cache-Control 中有一些适合放在一起理解的知识点，我们集中梳理一下：</p>
<h4 id="public-与-private"><a href="#public-与-private" class="headerlink" title="public 与 private"></a>public 与 private</h4><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。</p>
<p>如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为<strong>默认值</strong>。但多数情况下，public 并不需要我们手动设置，比如有很多线上网站的 cache-control 是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/VIrpuT9J4gCl5iW.png" alt="img"></p>
<p>设置了 s-maxage，没设置 public，那么 CDN 还可以缓存这个资源吗？答案是肯定的。因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。</p>
<h4 id="no-store与no-cache"><a href="#no-store与no-cache" class="headerlink" title="no-store与no-cache"></a>no-store与no-cache</h4><p>no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。</p>
<p>no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</p>
<h3 id="协商缓存：浏览器与服务器合作之下的缓存策略"><a href="#协商缓存：浏览器与服务器合作之下的缓存策略" class="headerlink" title="协商缓存：浏览器与服务器合作之下的缓存策略"></a>协商缓存：浏览器与服务器合作之下的缓存策略</h3><p>协商缓存依赖于服务端与浏览器之间的通信。</p>
<p>协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</p>
<p>如果服务端提示缓存资源未改动（Not Modified），资源会被<strong>重定向</strong>到浏览器缓存，<strong>这种情况下网络请求对应的状态码是 304</strong>（如下图）。</p>
<p><img src="https://i.loli.net/2021/01/11/aSLMU8BgYtkmlA4.png" alt="img"></p>
<h3 id="协商缓存的实现：从-Last-Modified-到-Etag"><a href="#协商缓存的实现：从-Last-Modified-到-Etag" class="headerlink" title="协商缓存的实现：从 Last-Modified 到 Etag"></a>协商缓存的实现：从 Last-Modified 到 Etag</h3><p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT</span><br></pre></td></tr></table></figure>
<p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT</span><br></pre></td></tr></table></figure>
<p>服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。</p>
<p>使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：</p>
<ul>
<li>我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</li>
<li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</li>
</ul>
<p>这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。</p>
<p>Etag 是由服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</p>
<p>Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ETag: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>
<p>那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-None-Match: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>
<p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 <strong>Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</strong></p>
<h2 id="HTTP-缓存决策指南"><a href="#HTTP-缓存决策指南" class="headerlink" title="HTTP 缓存决策指南"></a>HTTP 缓存决策指南</h2><p>行文至此，当代 HTTP 缓存技术用到的知识点，我们已经从头到尾挖掘了一遍了。那么在面对一个具体的缓存需求时，我们到底该怎么决策呢？</p>
<p>走到决策建议这一步，我本来想给大家重新画一个流程图。但是画来画去终究不如 Chrome 官方给出的这张清晰、权威：</p>
<p><img src="https://i.loli.net/2021/01/11/5OAQfJMG31q9dYo.png" alt="img"></p>
<p>我们现在一起解读一下这张流程图：</p>
<p>当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p>
<p>我个人非常推崇这张流程图给出的决策建议，也强烈推荐大家在理解以上知识点的基础上，将这张图保存下来、在日常开发中用用看，它的可行度非常高。</p>
<p>OK，走到这里，本节最大的一座山已经被大家翻过去了。接下来的内容会相对比较轻松，大家放松心情，我们继续前行！</p>
<h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</p>
<p>内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。</p>
<p>那么哪些文件会被放入内存呢？</p>
<p>事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。</p>
<p>虽然划分规则没有定论，但根据日常开发中观察的结果，包括我们开篇给大家展示的 Network 截图，我们至少可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。</p>
<h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。</p>
<p>Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。</p>
<p>下面我们就通过实战的方式，一起见识一下 Service Worker 如何为我们实现离线缓存（注意看注释）： 我们首先在入口文件中插入这样一段 JS 代码，用以判断和引入 Service Worker：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.navigator.serviceWorker.register(<span class="string">&#x27;/test.js&#x27;</span>).then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;注册成功&#x27;</span>)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&quot;注册失败&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在 test.js 中，我们进行缓存的处理。假设我们需要缓存的文件分别是 test.html,test.css 和 test.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑  </span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">// 考虑到缓存也需要更新，open内传入的参数为缓存的版本号</span></span><br><span class="line">    caches.open(<span class="string">&#x27;test-v1&#x27;</span>).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="comment">// 此处传入指定的需缓存的文件名</span></span><br><span class="line">        <span class="string">&#x27;/test.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/test.css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/test.js&#x27;</span></span><br><span class="line">      ])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="comment">// 尝试匹配该请求对应的缓存值</span></span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果匹配到了，调用Server Worker缓存</span></span><br><span class="line">      <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果没匹配到，向服务端发起这个资源请求</span></span><br><span class="line">      <span class="keyword">return</span> fetch(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">        caches.open(<span class="string">&#x27;test-v1&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.clone();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。</p>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><blockquote>
<p>预告：本小节定位为基础科普向，对 Push Cache 有深入挖掘兴趣的同学，强烈推荐拓展阅读 Chrome 工程师 Jake Archibald 的这篇 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a>。</p>
</blockquote>
<p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，我找了好几个网站也没找到一个合适的案例来给大家做具体的介绍。但应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：</p>
<ul>
<li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li>
<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li>
<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li>
</ul>
<p>更多的特性和应用，期待大家可以在日后的开发过程中去挖掘和实践。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>小建议！很多同学在学习缓存这块知识的时候可能多少会有这样的感觉：对浏览器缓存，只能描述个大致，却说不上深层原理；好不容易记住了每个字段怎么用，过几天又给忘了。这是因为缓存部分的知识，具有“细碎、迭代快”的特点。对于这样的知识，我们应该尝试先划分出层次和重点，归纳出完整的体系，然后针对每个知识点去各个击破。</p>
<p>终于结束了对缓存世界的探索，不知道大家有没有一种意犹未尽的感觉。开篇我们谈过，缓存非常重要，它几乎是我们性能优化的首选方案。</p>
<p>但页面的数据存储方案除了缓存，还有本地存储。在下一节中，我们就将围绕本地存储展开探索。</p>
<h1 id="存储篇-2：本地存储——从-Cookie-到-Web-Storage、IndexDB"><a href="#存储篇-2：本地存储——从-Cookie-到-Web-Storage、IndexDB" class="headerlink" title="存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB"></a>存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB</h1><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。</p>
<p>我认为，WebApp 就是我们前端性能优化的产物，是我们前端工程师对体验不懈追求的结果，是 Web 网页在性能上向 Native 应用的一次“宣战”。</p>
<p>WebApp 优异的性能表现，要归功于浏览器存储技术的广泛应用——这其中除了我们上节提到的缓存，本地存储技术也功不可没。</p>
<h2 id="故事的开始：从-Cookie-说起"><a href="#故事的开始：从-Cookie-说起" class="headerlink" title="故事的开始：从 Cookie 说起"></a>故事的开始：从 Cookie 说起</h2><p>Cookie 的本职工作并非本地存储，而是“维持状态”。</p>
<p>在 Web 开发的早期，人们亟需解决的一个问题就是状态管理的问题：HTTP 协议是一个无状态协议，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。那么下次请求的时候，如何让服务器知道“我是我”呢？</p>
<p>在这样的背景下，Cookie 应运而生。</p>
<p>Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>关于 Cookie 的详细内容，我们可以在 Chrome 的 Application 面板中查看到：</p>
<p><img src="https://i.loli.net/2021/01/11/wpiyhrHStZNGMlQ.png" alt="img"></p>
<p>如大家所见，<strong>Cookie 以键值对的形式存在</strong>。</p>
<h3 id="Cookie的性能劣势"><a href="#Cookie的性能劣势" class="headerlink" title="Cookie的性能劣势"></a>Cookie的性能劣势</h3><h4 id="Cookie-不够大"><a href="#Cookie-不够大" class="headerlink" title="Cookie 不够大"></a>Cookie 不够大</h4><p>大家知道，Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。</p>
<h4 id="过量的-Cookie-会带来巨大的性能浪费"><a href="#过量的-Cookie-会带来巨大的性能浪费" class="headerlink" title="过量的 Cookie 会带来巨大的性能浪费"></a>过量的 Cookie 会带来巨大的性能浪费</h4><p><strong>Cookie 是紧跟域名的</strong>。我们通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: name=xiuyan; domain=xiuyan.me</span><br></pre></td></tr></table></figure>
<p><strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p>
<p>随着前端应用复杂度的提高，Cookie 也渐渐演化为了一个“存储多面手”——它不仅仅被用于维持状态，还被塞入了一些乱七八糟的其它信息，被迫承担起了本地存储的“重任”。在没有更好的本地存储解决方案的年代里，Cookie 小小的身体里承载了 4KB 内存所不能承受的压力。</p>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p>
<h2 id="向前一步：Web-Storage"><a href="#向前一步：Web-Storage" class="headerlink" title="向前一步：Web Storage"></a>向前一步：Web Storage</h2><p>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。这两组概念非常相近，我们不妨先理解它们之间的区别，再对它们的共性进行研究。</p>
<h3 id="Local-Storage-与-Session-Storage-的区别"><a href="#Local-Storage-与-Session-Storage-的区别" class="headerlink" title="Local Storage 与 Session Storage 的区别"></a>Local Storage 与 Session Storage 的区别</h3><p>两者的区别在于<strong>生命周期</strong>与<strong>作用域</strong>的不同。</p>
<ul>
<li>生命周期：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</li>
<li>作用域：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们<strong>不在同一个浏览器窗口中</strong>打开，那么它们的 Session Storage 内容便无法共享。</li>
</ul>
<h3 id="Web-Storage-的特性"><a href="#Web-Storage-的特性" class="headerlink" title="Web Storage 的特性"></a>Web Storage 的特性</h3><ul>
<li>存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。</li>
<li>仅位于浏览器端，不与服务端发生通信。</li>
</ul>
<h3 id="Web-Storage-核心-API-使用示例"><a href="#Web-Storage-核心-API-使用示例" class="headerlink" title="Web Storage 核心 API 使用示例"></a>Web Storage 核心 API 使用示例</h3><p>Web Storage 保存的数据内容和 Cookie 一样，是文本内容，以键值对的形式存在。Local Storage 与 Session Storage 在 API 方面无异，这里我们以 localStorage 为例：</p>
<ul>
<li>存储数据：setItem()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;user_name&#x27;</span>, <span class="string">&#x27;xiuyan&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>读取数据： getItem()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;user_name&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>删除某一键名对应的数据： removeItem()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;user_name&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>清空数据记录：clear()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.clear()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h4><p>Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。</p>
<p>这里给大家举个例子，考虑到 Local Storage 的特点之一是<strong>持久</strong>，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p>
<p><img src="https://i.loli.net/2021/01/11/VidYjZ8HMeXgLAw.png" alt="img"></p>
<p>有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。</p>
<h4 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h4><p>Session Storage 更适合用来存储生命周期和它同步的<strong>会话级别</strong>的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹：</p>
<p><img src="https://i.loli.net/2021/01/11/gfrImaMWiUYh6eL.jpg" alt="img"></p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 Session Storage 来处理再合适不过。</p>
<p>这样看来，Web Storage 确实也够强大了。那么 Web Storage 是否能 hold 住所有的存储场景呢？</p>
<p>答案是否定的。大家也看到了，Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p>
<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexDB！</p>
<h2 id="终极形态：IndexDB"><a href="#终极形态：IndexDB" class="headerlink" title="终极形态：IndexDB"></a>终极形态：IndexDB</h2><p>IndexDB 是一个<strong>运行在浏览器上的非关系型数据库</strong>。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<p>IndexDB 从推出之日起，其优质教程就层出不绝，我们今天不再着重讲解它的详细操作。接下来，我们遵循 MDN 推荐的操作模式，通过一个基本的 IndexDB 使用流程，旨在对 IndexDB 形成一个感性的认知：</p>
<ol>
<li>打开/创建一个 IndexDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 xiaoceDB 新数据库）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后面的回调中，我们可以通过event.target.result拿到数据库实例</span></span><br><span class="line"><span class="keyword">let</span> db</span><br><span class="line"><span class="comment">// 参数1位数据库名，参数2为版本号</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">&quot;xiaoceDB&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 使用IndexDB失败时的监听函数</span></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;无法使用IndexDB&#x27;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line">request.onsuccess  = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 此处就可以获取到db实例</span></span><br><span class="line">  db = event.target.result</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你打开了IndexDB&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 object store（object store 对标到数据库中的“表”单位）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectStore</span><br><span class="line">  <span class="comment">// 如果同名表未被创建过，则新建test表</span></span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">&#x27;test&#x27;</span>)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(<span class="string">&#x27;test&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ol>
<li>构建一个事务来执行一些数据库操作，像增加或提取数据等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建事务，指定表格名称和读写权限</span></span><br><span class="line"><span class="keyword">const</span> transaction = db.transaction([<span class="string">&quot;test&quot;</span>],<span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line"><span class="comment">// 拿到Object Store对象</span></span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment">// 向表格写入数据</span></span><br><span class="line">objectStore.add(&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;xiuyan&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>通过监听正确类型的事件以等待操作完成。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作成功时的监听函数</span></span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;操作成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作失败时的监听函数</span></span><br><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这里有一个Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="IndexDB-的应用场景"><a href="#IndexDB-的应用场景" class="headerlink" title="IndexDB 的应用场景"></a>IndexDB 的应用场景</h3><p>通过上面的示例大家可以看出，在 IndexDB 中，我们可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。IndexDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，我们毫无疑问可以请出 IndexDB 来帮忙。</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>浏览器缓存/存储技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于缓存/存储技术的第三方库层出不绝，此外还衍生出了 <a href="https://lavas.baidu.com/pwa">PWA</a> 这样优秀的 Web 应用模型。可以说，现代前端应用，尤其是移动端应用，之所以可以发展到在体验上叫板 Native 的地步，主要就是仰仗缓存/存储立下的汗马功劳。</p>
<h1 id="彩蛋篇：CDN-的缓存与回源机制解析"><a href="#彩蛋篇：CDN-的缓存与回源机制解析" class="headerlink" title="彩蛋篇：CDN 的缓存与回源机制解析"></a>彩蛋篇：CDN 的缓存与回源机制解析</h1><h2 id="写在小册的半山腰"><a href="#写在小册的半山腰" class="headerlink" title="写在小册的半山腰"></a>写在小册的半山腰</h2><p>不知不觉，小册内容已经过了小半了。</p>
<p>回顾一下走过的路：在对知识体系进行一番梳理后，我们操起 webpack 开始优化文件（顺便还学了点 Gzip），随后又马不停蹄进入图片的小天地，最后把缓存和本地存储的味道逐一品尝，终于得以窥见网络层面核心优化技术的全貌。</p>
<p>古人云：学而不思则罔。</p>
<p>站在性能优化的半山腰，我希望大家可以缓一缓，停下来思考一个问题：我得到了什么？</p>
<p>作为作者，我在自己写的每一行字背后都费了思量。在过去的每个章节里我都预先为知识点做了权重划分，力求“详略得当”，而非盲目地求大求全。孰详孰略，只能根据知识点本身的重要性来划分，但读者的知识结构是多样的。“如何使阅读效益最大化”的金钥匙不在我手中，而是在各位自己手中。</p>
<p>本小册中我有所提及的每一个知识点，<strong>都有大公司在实践</strong>。即便是略写的内容，大家也值得进一步去推敲。可以尝试深挖这本小册的可能性，把它用起来，用到自己的工作中去，去看看它能否给你的业务带来提升，看看是否还有更精进的方案。</p>
<p>我是一个“啰嗦”的人。尤其是意识到这本书可能会成为一些同学的性能优化启蒙读物时，我更加认为有必要在行文小半时再啰嗦这么一遍：如果读到这里，脑海中无法复现出网络层面的知识体系，无法在回忆每个技术点时记起它的场景和特性，我建议不要急于往下走，而是回过头去再看看学过的这部分的内容——走马观花不是学习，主动理解+动手实践才是。</p>
<h2 id="彩蛋：CDN的缓存与回源机制解析"><a href="#彩蛋：CDN的缓存与回源机制解析" class="headerlink" title="彩蛋：CDN的缓存与回源机制解析"></a>彩蛋：CDN的缓存与回源机制解析</h2><blockquote>
<p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p>
</blockquote>
<h3 id="为什么要用-CDN"><a href="#为什么要用-CDN" class="headerlink" title="为什么要用 CDN"></a>为什么要用 CDN</h3><p>浏览器存储的相关知识此刻离我们还不太远，大家趁热回忆一下：缓存、本地存储带来的性能提升，是不是只能在“获取到资源并把它们存起来”这件事情发生之后？也就是说，首次请求资源的时候，这些招数都是救不了我们的。要提升首次请求的响应能力，除了我们 2、3、4 节提到的方案之外，我们还需要借助 CDN 的能力。</p>
<h3 id="CDN-如何工作"><a href="#CDN-如何工作" class="headerlink" title="CDN 如何工作"></a>CDN 如何工作</h3><p>借中国地图一角来给大家举一个简单的🌰：</p>
<p><img src="https://i.loli.net/2021/01/11/ZX234PxuFqvJCeY.png" alt="img"></p>
<p>假设我的根服务器在杭州，同时在图示的五个城市里都有自己可用的机房。</p>
<p>此时有一位北京的用户向我请求资源。在网络带宽小、用户访问量大的情况下，杭州的这一台服务器或许不那么给力，不能给用户非常快的响应速度。于是我灵机一动，把这批资源 copy 了一批放在北京的机房里。当用户请求资源时，就近请求北京的服务器，北京这台服务器低头一看，这个资源我存了，离得这么近，响应速度肯定噌噌的！那如果北京这台服务器没有 copy 这批资源呢？它会再向杭州的根服务器去要这个资源。在这个过程中，北京这台服务器就扮演着 CDN 的角色。</p>
<h3 id="CDN的核心功能特写"><a href="#CDN的核心功能特写" class="headerlink" title="CDN的核心功能特写"></a>CDN的核心功能特写</h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。</p>
<p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p>
<h3 id="CDN-与前端性能优化"><a href="#CDN-与前端性能优化" class="headerlink" title="CDN 与前端性能优化"></a>CDN 与前端性能优化</h3><p>一个彩蛋的自我修养——CDN 往往是被前端认为前端不需要了解的东西。</p>
<p>具体来说，我身边许多同学对其的了解止步于：部署界面上有一个“部署到CDN”按钮，我去点一下，资源就在 CDN 上啦！</p>
<p>“眼下业务开发用不到的可以暂缓了解”，这是没毛病的。但正如我小册开篇所说的，前端工程师首先是软件工程师。对整个技术架构的理解，将会反哺我们对某一具体环节的理解；知识点的适当拓展，也会对大家技术高度和技术广度的提升大有裨益。</p>
<p>那么，我们了解一下 CDN 是怎么帮助前端的。</p>
<p><strong>CDN 往往被用来存放静态资源</strong>。上文中我们举例所提到的“根服务器”本质上是业务服务器，它的核心任务在于<strong>生成动态页面或返回非纯静态页面</strong>，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。</p>
<p>所谓“静态资源”，就是像 JS、CSS、图片等<strong>不需要业务服务器进行计算即得的资源</strong>。而“动态资源”，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。</p>
<p>什么是“非纯静态资源”呢？它是指<strong>需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。</p>
<h3 id="CDN-的实际应用"><a href="#CDN-的实际应用" class="headerlink" title="CDN 的实际应用"></a>CDN 的实际应用</h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段，在许多一线的互联网公司，“静态资源走 CDN”并不是一个建议，而是一个规定。</p>
<p>比如以淘宝为代表的阿里系产品，就遵循着这个“规定”。<br>打开淘宝首页，我们可以在 Network 面板中看到，“非纯静态”的 HTML 页面，是向业务服务器请求来的：</p>
<p><img src="https://i.loli.net/2021/01/11/aEZqyk8V4BvsfJt.png" alt="img"></p>
<p>我们点击 preview，可以看到业务服务器确实是返回给了我们一个尚未被静态资源加持过的简单 HTML 页面，所有的图片内容都是先以一个 div 占位：</p>
<p><img src="https://i.loli.net/2021/01/11/54MxRWpnTK3czNq.png" alt="img"></p>
<p>相应地，我们随便点开一个静态资源，可以看到它都是从 CDN 服务器上请求来的。</p>
<p>比如说图片：</p>
<p><img src="https://i.loli.net/2021/01/11/BnVZJvrFj1SOfac.png" alt="img"></p>
<p>再比如 JS、CSS 文件：</p>
<img src="https://i.loli.net/2021/01/11/zgLnsP2NorIGkOf.png" alt="img" style="zoom:80%;" />

<p><img src="https://i.loli.net/2021/01/11/psIly1mRXABTb5D.png" alt="img"></p>
<h3 id="CDN-优化细节"><a href="#CDN-优化细节" class="headerlink" title="CDN 优化细节"></a>CDN 优化细节</h3><p>如何让 CDN 的效用最大化？这又是需要前后端程序员一起思考的庞大命题。它涉及到 CDN 服务器本身的性能优化、CDN 节点的地址选取等。但我们今天不写高深的论文，只谈离前端最近的这部分细节：CDN 的域名选取。</p>
<p>大家先回头看一下我刚刚选取的淘宝首页的例子，我们注意到业务服务器的域名是这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.taobao.com</span><br></pre></td></tr></table></figure>
<p>而 CDN 服务器的域名是这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g.alicdn.com</span><br></pre></td></tr></table></figure>
<p>没错，我们不一样！</p>
<p>再看另一方面，我们讲到 Cookie 的时候，为了凸显 Local Storage 的优越性，曾经提到过：</p>
<blockquote>
<p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的……</p>
</blockquote>
<p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p>
<p>看起来是一个不起眼的小细节，但带来的效用却是惊人的。以电商网站静态资源的流量之庞大，如果没把这个多余的 Cookie 拿下来，不仅用户体验会大打折扣，每年因性能浪费带来的经济开销也将是一个非常恐怖的数字。</p>
<p>如此看来，性能优化还真是要步步为营！</p>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>结束了对 CDN 的剖析，我们网络层面的优化之旅也终于告一段落了。接下来等待大家的就是另一个庞大的知识板块——渲染层面的挑战。</p>
<p>与其说是“渲染层面的优化”，不如说是“浏览器端的优化”。这个板块旨在要大家对浏览器及其相关运行机制“知根知底”，进而通过具体的代码片段学习代码层面的应用手段。这部分是实打实的“硬骨头”，需要大家花些精力。</p>
<p>过去的几个小节里，我们考虑了服务端，考虑了网络，考虑了协议。那么接下来，我们就以“服务端渲染”为引子，承上启下，切入浏览器渲染的世界。</p>
<h1 id="渲染篇-1：服务端渲染的探索与实践"><a href="#渲染篇-1：服务端渲染的探索与实践" class="headerlink" title="渲染篇 1：服务端渲染的探索与实践"></a>渲染篇 1：服务端渲染的探索与实践</h1><p>服务端渲染（SSR）近两年炒得很火热，相信各位同学对这个名词多少有所耳闻。本节我们将围绕“是什么”（服务端渲染的运行机制）、“为什么”（服务端渲染解决了什么性能问题 ）、“怎么做”（服务端渲染的应用实例与使用场景）这三个点，对服务端渲染进行探索。</p>
<p>服务端渲染是一个相对的概念，它的对立面是“客户端渲染”。在运行机制解析这部分，我们会借力客户端渲染的概念，来帮大家理解服务端渲染的工作方式。基于对工作方式的了解，再去深挖它的原理与优势。</p>
<p>任何知识点都不是“一座孤岛”，服务端渲染的实践往往与当下流行的前端技术（譬如 Vue，React，Redux 等）紧密结合。本节下半场将以 React 和 Vue 下的服务端渲染实现为例，为大家呈现一个完整的 SSR 实现过程。</p>
<h2 id="服务端渲染的运行机制"><a href="#服务端渲染的运行机制" class="headerlink" title="服务端渲染的运行机制"></a>服务端渲染的运行机制</h2><p>相对于服务端渲染，同学们普遍对客户端渲染接受度更高一些，所以我们先从大家喜闻乐见的客户端渲染说起。</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，往往是这个德行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我是客户端渲染的页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;root&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;index.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根节点下到底是什么内容呢？你不知道，我不知道，只有浏览器把 index.js 跑过一遍后才知道，这就是典型的客户端渲染。</p>
<p><strong>页面上呈现的内容，你在 html 源文件里里找不到</strong>——这正是它的特点。</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。</p>
<p>使用服务端渲染的网站，可以说是“所见即所得”，<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。</p>
<p>比如知乎就是典型的服务端渲染案例：</p>
<p><img src="https://i.loli.net/2021/01/11/Pk5eAOSGRBiIsxt.png" alt="img"></p>
<p><a href="http://zhihu.com/">zhihu.com</a> 返回的 HTML 文件已经是可以直接进行渲染的内容了。</p>
<h2 id="服务端渲染解决了什么性能问题"><a href="#服务端渲染解决了什么性能问题" class="headerlink" title="服务端渲染解决了什么性能问题"></a>服务端渲染解决了什么性能问题</h2><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。</p>
<p>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。</p>
<p>但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？</p>
<h2 id="服务端渲染的应用实例"><a href="#服务端渲染的应用实例" class="headerlink" title="服务端渲染的应用实例"></a>服务端渲染的应用实例</h2><p>下面我们先来看一下在一个 React 项目里，服务端渲染是怎么实现的。本例中，我们使用 Express 搭建后端服务。</p>
<p>项目中有一个叫做 VDom 的 React 组件，它的内容如下。</p>
<p>VDom.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VDom = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个被渲染为真实DOM的虚拟DOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VDom</span><br></pre></td></tr></table></figure>
<p>在服务端的入口文件中，我引入这个组件，对它进行渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VDom <span class="keyword">from</span> <span class="string">&#x27;./VDom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个express应用</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">// renderToString 是把虚拟DOM转化为真实DOM的关键方法</span></span><br><span class="line"><span class="keyword">const</span> RDom = renderToString(<span class="xml"><span class="tag">&lt;<span class="name">VDom</span> /&gt;</span></span>)</span><br><span class="line"><span class="comment">// 编写HTML模板，插入转化后的真实DOM内容</span></span><br><span class="line"><span class="keyword">const</span> Page = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;html&gt;</span></span><br><span class="line"><span class="string">              &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;test&lt;/title&gt;</span></span><br><span class="line"><span class="string">              &lt;/head&gt;</span></span><br><span class="line"><span class="string">              &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;span&gt;服务端渲染出了真实DOM:  &lt;/span&gt;</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;RDom&#125;</span></span></span><br><span class="line"><span class="string">              &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 配置HTML内容对应的路由</span></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(Page)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置端口号</span></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
<p>根据我们的路由配置，当我访问 <a href="http://localhost:8000/index">http://localhost:8000/index</a> 时，就可以呈现出服务端渲染的结果了：</p>
<p><img src="https://i.loli.net/2021/01/11/QWUgv9nqE4CHY7L.png" alt="img"></p>
<p>我们可以看到，VDom 组件已经被 renderToString 转化为了一个内容为<code>&lt;div data-reactroot=&quot;&quot;&gt;我是一个被渲染为真实DOM的虚拟DOM&lt;/div&gt;</code>的字符串，这个字符串被插入 HTML 代码，成为了真实 DOM 树的一部分。</p>
<p>那么 Vue 是如何实现服务端渲染的呢？</p>
<p>其实是一个套路，我这里基于 <a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F">Vue SSR 指南</a> 中官方给出的例子为大家讲解 Vue 中的实现思路（思路见注释）。</p>
<p>该示例直接将 Vue 实例整合进了服务端的入口文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个express应用</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()</span><br><span class="line"><span class="comment">// 提取出renderer实例</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>).createRenderer()</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 编写Vue实例（虚拟DOM节点）</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      url: req.url</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 编写模板HTML的内容</span></span><br><span class="line">    template: <span class="string">`&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// renderToString 是把Vue实例转化为真实DOM的关键方法</span></span><br><span class="line">  renderer.renderToString(app, <span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).end(<span class="string">&#x27;Internal Server Error&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把渲染出来的真实DOM字符串插入HTML模板中</span></span><br><span class="line">    res.end(<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">      &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;<span class="subst">$&#123;html&#125;</span>&lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<p>大家对比一下 React 项目中的注释内容，是不是发现这两段代码从本质上来说区别不大呢？</p>
<p>以上两个小🌰，为大家演示了基本的服务端渲染实现流程。</p>
<p>实际项目比这些复杂很多，但万变不离其宗。强调的只有两点：一是这个 renderToString() 方法；二是把转化结果“塞”进模板里的这一步。这两个操作是服务端渲染的灵魂操作。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。</p>
<h2 id="服务端渲染的应用场景"><a href="#服务端渲染的应用场景" class="headerlink" title="服务端渲染的应用场景"></a>服务端渲染的应用场景</h2><p>打眼一看，这个服务端渲染给浏览器省了这么多事儿，性能肯定是质的飞跃啊！喜闻乐见！但是大家打开自己经常访问的那些网页看一看，会发现仍然有许多网站压根儿不用服务端渲染——看来这个东西也不是万能的。</p>
<p>根据我们前面的描述，不难看出，服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理：浏览器性能毕竟有限，服务器多牛逼！能者多劳，就该让服务器多干点活！</p>
<p>但仔细想想，在这个网民遍地的时代，几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。</p>
<p>这样分析下来，服务端渲染也并非万全之策。在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了~</p>
<h1 id="渲染篇-2：知己知彼——解锁浏览器背后的运行机制"><a href="#渲染篇-2：知己知彼——解锁浏览器背后的运行机制" class="headerlink" title="渲染篇 2：知己知彼——解锁浏览器背后的运行机制"></a>渲染篇 2：知己知彼——解锁浏览器背后的运行机制</h1><p>从本章开始，我们的性能优化探险也正式进入到了“深水区”——浏览器端的性能优化。</p>
<p>平时我们几乎每天都在和浏览器打交道，在一些兼容任务比较繁重的团队里，苦逼的前端攻城师们甚至为了兼容各个浏览器而不断地去测试和调试，还要在脑子中记下各种遇到的 BUG 及解决方案。即便如此，我们好像并没有去主动地关注和了解下浏览器的工作原理。我想如果我们对此做一点了解，在项目过程中就可以有效地避免一些问题，并对页面性能做出相应的改进。</p>
<p>“知己知彼，百战不殆”，今天，我们就一起来揭开浏览器渲染过程的神秘面纱！</p>
<h2 id="浏览器的“心”"><a href="#浏览器的“心”" class="headerlink" title="浏览器的“心”"></a>浏览器的“心”</h2><p>浏览器的“心”，说的就是浏览器的内核。在研究浏览器微观的运行机制之前，我们首先要对浏览器内核有一个宏观的把握。</p>
<p>开篇我提到许多工程师因为业务需要，免不了需要去处理不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。<br>浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（<strong>下文我们将沿用这种叫法</strong>）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。</p>
<p><img src="https://i.loli.net/2021/01/11/ZHozgmsiXAr5DtF.png" alt="img"></p>
<p>目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p>
<p>这里面大家最耳熟能详的可能就是 Webkit 内核了。很多同学可能会听说过 Chrome 的内核就是 Webkit，殊不知 Chrome 内核早已迭代为了 Blink。但是换汤不换药，Blink 其实也是基于 Webkit 衍生而来的一个分支，因此，Webkit 内核仍然是当下浏览器世界真正的霸主。</p>
<p>下面我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。</p>
<h2 id="开启浏览器渲染“黑盒”"><a href="#开启浏览器渲染“黑盒”" class="headerlink" title="开启浏览器渲染“黑盒”"></a>开启浏览器渲染“黑盒”</h2><p>什么是渲染过程？简单来说，渲染引擎根据 HTML 文件描述构建相应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果，这个过程就是渲染过程（如下图）。</p>
<p><img src="https://i.loli.net/2021/01/11/KlLrxOjn6PyzcqG.png" alt="img"></p>
<p>从这个流程来看，浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是<strong>HTML 解释器</strong>、<strong>CSS 解释器</strong>、<strong>图层布局计算模块</strong>、<strong>视图绘制模块</strong>与<strong>JavaScript 引擎</strong>这几大模块：</p>
<ul>
<li>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</li>
<li>CSS 解释器：解析 CSS 文档, 生成样式规则。</li>
<li>图层布局计算模块：布局计算每个对象的精确位置和大小。</li>
<li>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</li>
<li>JavaScript 引擎：编译执行 Javascript 代码。</li>
</ul>
<h2 id="浏览器渲染过程解析"><a href="#浏览器渲染过程解析" class="headerlink" title="浏览器渲染过程解析"></a>浏览器渲染过程解析</h2><p>有了对零部件的了解打底，我们就可以一起来走一遍浏览器的渲染流程了。在浏览器里，每一个页面的首次渲染都经历了如下阶段（图中箭头不代表串行，有一些操作是并行进行的，下文会说明）：</p>
<p><img src="https://i.loli.net/2021/01/11/gIlmvwoJ6WnXsuG.png" alt="img"></p>
<ul>
<li><strong>解析 HTML</strong></li>
</ul>
<p>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</p>
<ul>
<li><strong>计算样式</strong></li>
</ul>
<p>浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。</p>
<ul>
<li><strong>计算图层布局</strong></li>
</ul>
<p>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</p>
<ul>
<li><strong>绘制图层</strong></li>
</ul>
<p>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</p>
<ul>
<li><strong>整合图层，得到页面</strong></li>
</ul>
<p>最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</p>
<h2 id="几棵重要的“树”"><a href="#几棵重要的“树”" class="headerlink" title="几棵重要的“树”"></a>几棵重要的“树”</h2><p>上面的内容没有理解透彻？别着急，我们一起来捋一捋这个过程中的重点——树！</p>
<p>为了使渲染过程更明晰一些，我们需要给这些”树“们一个特写:</p>
<p><img src="https://i.loli.net/2021/01/11/YRt7gGVfn38LU62.png" alt="img"></p>
<ul>
<li>DOM 树：解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</li>
<li>CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是<strong>并行的</strong>。</li>
<li>渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</li>
<li>布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。</li>
<li>绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。</li>
</ul>
<p>基于这些“树”，我们再梳理一番：</p>
<p>渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</p>
<p>之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。</p>
<p>有心的同学可能已经在思考了，查表是个花时间的活，我怎么让浏览器的查询工作又快又好地实现呢？OK，讲了这么多原理，我们终于引出了我们的第一个可转化为代码的优化点——CSS 样式表规则的优化！</p>
<h2 id="不做无用功：基于渲染流程的-CSS-优化建议"><a href="#不做无用功：基于渲染流程的-CSS-优化建议" class="headerlink" title="不做无用功：基于渲染流程的 CSS 优化建议"></a>不做无用功：基于渲染流程的 CSS 优化建议</h2><p>在给出 CSS 选择器方面的优化建议之前，先告诉大家一个小知识：CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 看如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#myList</span>  <span class="selector-tag">li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样的写法其实很常见。大家平时习惯了从左到右阅读的文字阅读方式，会本能地以为浏览器也是从左到右匹配 CSS 选择器的，因此会推测这个选择器并不会费多少力气：#myList 是一个 id 选择器，它对应的元素只有一个，查找起来应该很快。定位到了 myList 元素，等于是缩小了范围后再去查找它后代中的 li 元素，没毛病。</p>
<p>事实上，<strong>CSS 选择符是从右到左进行匹配的</strong>。我们这个看似“没毛病”的选择器，实际开销相当高：浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList，你说坑不坑！</p>
<p>说到坑，不知道大家还记不记得这个经典的通配符：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>入门 CSS 的时候，不少同学拿通配符清除默认样式（我曾经也是通配符用户的一员）。但这个家伙很恐怖，它会匹配所有元素，所以浏览器必须去遍历每一个元素！大家低头看看自己页面里的元素个数，是不是心凉了——这得计算多少次呀！</p>
<p>这样一看，一个小小的 CSS 选择器，也有不少的门道！好的 CSS 选择器书写习惯，可以为我们带来非常可观的性能提升。根据上面的分析，我们至少可以总结出如下性能提升的方案：</p>
<ul>
<li><p>避免使用通配符，只对需要用到的元素进行选择。</p>
</li>
<li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p>
</li>
<li><p>少用标签选择器。如果可以，用类选择器替代，举个🌰：</p>
<p>错误示范：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#myList</span> <span class="selector-tag">li</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>课代表：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myList_li</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。举个🌰：</p>
<p>错误示范</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myList</span><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>
<p>课代表</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure></li>
<li><p>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</p>
</li>
</ul>
<p>搞定了 CSS 选择器，万里长征才刚刚开始的第一步。但现在你已经理解了浏览器的工作过程，接下来的征程对你来说并不再是什么难题~</p>
<h2 id="告别阻塞：CSS-与-JS-的加载顺序优化"><a href="#告别阻塞：CSS-与-JS-的加载顺序优化" class="headerlink" title="告别阻塞：CSS 与 JS 的加载顺序优化"></a>告别阻塞：CSS 与 JS 的加载顺序优化</h2><p>说完了过程，我们来说一说特性。</p>
<p>HTML、CSS 和 JS，都具有<strong>阻塞渲染</strong>的特性。</p>
<p>HTML 阻塞，天经地义——没有 HTML，何来 DOM？没有 DOM，渲染和优化，都是空谈。</p>
<p>那么 CSS 和 JS 的阻塞又是怎么回事呢？</p>
<h3 id="CSS-的阻塞"><a href="#CSS-的阻塞" class="headerlink" title="CSS 的阻塞"></a>CSS 的阻塞</h3><p>在刚刚的过程中，我们提到 DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，<strong>不会渲染任何已处理的内容</strong>。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。</p>
<p>我们知道，只有当我们开始解析 HTML 后、解析到 link 标签或者 style 标签时，CSS 才登场，CSSOM 的构建才开始。很多时候，DOM 不得不等待 CSSOM。因此我们可以这样总结：</p>
<blockquote>
<p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p>
</blockquote>
<p>事实上，现在很多团队都已经做到了尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）。这个“把 CSS 往前放”的动作，对很多同学来说已经内化为一种编码习惯。那么现在我们还应该知道，这个“习惯”不是空穴来风，它是由 CSS 的特性决定的。</p>
<h3 id="JS-的阻塞"><a href="#JS-的阻塞" class="headerlink" title="JS 的阻塞"></a>JS 的阻塞</h3><p>不知道大家注意到没有，前面我们说过程的时候，花了很多笔墨去说 HTML、说 CSS。相比之下，JS 的出镜率也太低了点。<br>这当然不是因为 JS 不重要。而是因为，在首次渲染过程中，JS 并不是一个非登场不可的角色——没有 JS，CSSOM 和 DOM 照样可以组成渲染树，页面依然会呈现——即使它死气沉沉、毫无交互。</p>
<p>JS 的作用在于<strong>修改</strong>，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。因此 JS 的执行会阻止 CSSOM，在我们不作显式声明的情况下，它也会阻塞 DOM。</p>
<p>我们通过一个🌰来理解一下这个机制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS阻塞测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">      background-color: yellow;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 尝试获取container元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;container&#x27;</span>, container)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 尝试获取container元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;container&#x27;</span>, container)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 输出container元素此刻的背景色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;container bgColor&#x27;</span>, getComputedStyle(container).backgroundColor)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>三个 console 的结果分别为：</p>
<p><img src="https://i.loli.net/2021/01/11/4iH615JFoY9ISZr.png" alt="img"></p>
<p>注：本例仅使用了内联 JS 做测试。感兴趣的同学可以把这部分 JS 当做外部文件引入看看效果——它们的表现一致。</p>
<p>第一次尝试获取 id 为 container 的 DOM 失败，这说明 JS 执行时阻塞了 DOM，后续的 DOM 无法构建；第二次才成功，这说明脚本块只能找到在它前面构建好的元素。这两者结合起来，“阻塞 DOM”得到了验证。再看第三个 console，尝试获取 CSS 样式，获取到的是在 JS 代码执行前的背景色（yellow），而非后续设定的新样式（blue），说明 CSSOM 也被阻塞了。那么在阻塞的背后，到底发生了什么呢？</p>
<p>我们前面说过，<strong>JS 引擎是独立于渲染引擎存在的</strong>。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 因此与其说是 JS 把 CSS 和 HTML 阻塞了，不如说是 JS 引擎抢走了渲染引擎的控制权。</p>
<p>现在理解了阻塞的表现与原理，我们开始思考一个问题。浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。但是我们是写 JS 的人，我们知道 JS 会做什么改变。假如我们可以确认一个 JS 文件的执行时机并不一定非要是此时此刻，我们就可以通过对它使用 defer 和 async 来避免不必要的阻塞，这里我们就引出了外部 JS 的三种加载方式。</p>
<h3 id="JS的三种加载方式"><a href="#JS的三种加载方式" class="headerlink" title="JS的三种加载方式"></a>JS的三种加载方式</h3><ul>
<li><p>正常模式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p>
</li>
<li><p>async 模式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会<strong>立即执行</strong>。</p>
</li>
<li><p>defer 模式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>defer 模式下，JS 的加载是异步的，执行是<strong>被推迟的</strong>。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</p>
</li>
</ul>
<p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p>
<p>通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>我们知道，当 JS 登场时，往往意味着对 DOM 的操作。DOM 操作所导致的性能开销的“昂贵”，大家可能早就有所耳闻，雅虎军规里很重要的一条就是“尽量减少 DOM 访问”。</p>
<p>那么 DOM 到底为什么慢，我们如何去规避这种慢呢？这里我们就引出了下一个章节需要重点解释的两个概念：CSS 中的回流（Reflow）与重绘（Repaint）。</p>
<h1 id="渲染篇-3：对症下药——DOM-优化原理与基本实践"><a href="#渲染篇-3：对症下药——DOM-优化原理与基本实践" class="headerlink" title="渲染篇 3：对症下药——DOM 优化原理与基本实践"></a>渲染篇 3：对症下药——DOM 优化原理与基本实践</h1><p>从本节开始，我们要关心的两大核心问题就是：“DOM 为什么这么慢”以及“如何使 DOM 变快”。</p>
<p>后者是一个比“生存还是毁灭”更加经典的问题。不仅我们为它“肝肠寸断”，许多优秀前端框架的作者大大们也曾为其绞尽脑汁。这一点可喜可贺——研究的人越多，产出优秀实践的概率就越大。因此在本章的方法论环节，我们不仅会根据 DOM 特性及渲染原理为大家讲解基本的优化思路，还会涉及到一部分生产实践。</p>
<p>循着这个思路，我们把 DOM 优化这块划分为三个小专题：“DOM 优化思路”、“异步更新策略”及“回流与重绘”。本节对应第一个小专题。三个小专题休戚与共、你侬我侬，在思路上相互依赖、一脉相承，因此此处<strong>严格禁止任何姿势的跳读行为</strong>。</p>
<p>考虑到本节内容与上一节有着密不可分的关系，因此<strong>强烈不建议没有读完上一节的同学直接跳读本节</strong>。</p>
<h2 id="望闻问切：DOM-为什么这么慢"><a href="#望闻问切：DOM-为什么这么慢" class="headerlink" title="望闻问切：DOM 为什么这么慢"></a>望闻问切：DOM 为什么这么慢</h2><h3 id="因为收了“过路费”"><a href="#因为收了“过路费”" class="headerlink" title="因为收了“过路费”"></a>因为收了“过路费”</h3><blockquote>
<p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p>
</blockquote>
<p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。</p>
<p>上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。</p>
<p><img src="https://i.loli.net/2021/01/11/WYcf4aMveD2x5Tr.png" alt="img"></p>
<p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p>
<h3 id="对-DOM-的修改引发样式的更迭"><a href="#对-DOM-的修改引发样式的更迭" class="headerlink" title="对 DOM 的修改引发样式的更迭"></a>对 DOM 的修改引发样式的更迭</h3><p>过桥很慢，到了桥对岸，我们的更改操作带来的结果也很慢。</p>
<p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发<strong>回流</strong>或<strong>重绘</strong>。</p>
<p>这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的：</p>
<p><img src="https://i.loli.net/2021/01/11/LyvZTENDgtblOwe.png" alt="img"></p>
<ul>
<li>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</li>
<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</li>
</ul>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>
<h2 id="药到病除：给你的-DOM-“提提速”"><a href="#药到病除：给你的-DOM-“提提速”" class="headerlink" title="药到病除：给你的 DOM “提提速”"></a>药到病除：给你的 DOM “提提速”</h2><p>知道了 DOM 慢的原因，我们就可以对症下药了。</p>
<h3 id="减少-DOM-操作：少交“过路费”、避免过度渲染"><a href="#减少-DOM-操作：少交“过路费”、避免过度渲染" class="headerlink" title="减少 DOM 操作：少交“过路费”、避免过度渲染"></a>减少 DOM 操作：少交“过路费”、避免过度渲染</h3><p>我们来看这样一个🌰，HTML 内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM操作测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时我有一个假需求——我想往 container 元素里写 10000 句一样的话。如果我这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>).innerHTML+=<span class="string">&#x27;&lt;span&gt;我是一个小测试&lt;/span&gt;&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这段代码有两个明显的可优化点。</p>
<p>第一点，<strong>过路费交太多了</strong>。我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，相当于每次循环都交了一次过路费。前后交了 10000 次过路费，但其中 9999 次过路费都可以用<strong>缓存变量</strong>的方式节省下来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只获取一次container</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  container.innerHTML += <span class="string">&#x27;&lt;span&gt;我是一个小测试&lt;/span&gt;&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>第二点，<strong>不必要的 DOM 更改太多了</strong>。我们的 10000 次循环里，修改了 10000 次 DOM 树。我们前面说过，对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程，而这个过程的开销是很“贵”的。这么贵的操作，我们竟然重复执行了 N 多次！其实我们可以通过<strong>就事论事</strong>的方式节省下来不必要的渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> content = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="comment">// 先对内容进行操作</span></span><br><span class="line">  content += <span class="string">&#x27;&lt;span&gt;我是一个小测试&lt;/span&gt;&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发DOM的更改</span></span><br><span class="line">container.innerHTML = content</span><br></pre></td></tr></table></figure>
<p>所谓“就事论事”，就像大家所看到的：JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告。</p>
<p>事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是<strong>让 JS 去给 DOM 分压</strong>。</p>
<p>这个思路，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">DOM Fragment</a> 中体现得淋漓尽致。</p>
<blockquote>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。</p>
</blockquote>
<p>在我们上面的例子里，字符串变量 content 就扮演着一个 DOM Fragment 的角色。其实无论字符串变量也好，DOM Fragment 也罢，它们本质上都作为脱离了真实 DOM 树的<strong>容器</strong>出现，用于缓存批量化的 DOM 操作。</p>
<p>前面我们直接用 innerHTML 去拼接目标内容，这样做固然有用，但却不够优雅。相比之下，DOM Fragment 可以帮助我们用更加结构化的方式去达成同样的目的，从而在维持性能的同时，保住我们代码的可拓展和可维护性。我们现在用 DOM Fragment 来改写上面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个DOM Fragment对象作为容器</span></span><br><span class="line"><span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123;</span><br><span class="line">  <span class="comment">// span此时可以通过DOM API去创建</span></span><br><span class="line">  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>)</span><br><span class="line">  oSpan.innerHTML = <span class="string">&#x27;我是一个小测试&#x27;</span></span><br><span class="line">  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span></span><br><span class="line">  content.appendChild(oSpan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span></span><br><span class="line">container.appendChild(content)</span><br></pre></td></tr></table></figure>
<p>我们运行这段代码，可以得到与前面两种写法相同的运行结果。<br>可以看出，DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后<strong>全身而退</strong>，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。</p>
<p>相比 DOM 命题的博大精深，一个简单的循环 Demo 显然不能说明所有问题。不过不用着急，在本节，我只希望大家能牢记原理与宏观思路。“药到病除”到这里才刚刚开了个头，下个小节，我们将深挖事件循环机制，从而深入 JS 层面的生产实践。</p>
<h1 id="渲染篇-4：千方百计——Event-Loop-与异步更新策略"><a href="#渲染篇-4：千方百计——Event-Loop-与异步更新策略" class="headerlink" title="渲染篇 4：千方百计——Event Loop 与异步更新策略"></a>渲染篇 4：千方百计——Event Loop 与异步更新策略</h1><p>Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。通过研究框架的运行机制，其设计思路将深化我们对 DOM 优化的理解，其实现手法将拓宽我们对 DOM 实践的认知。</p>
<p>本节我们将基于 Event Loop 机制，对 Vue 的异步更新策略作探讨。</p>
<h2 id="前置知识：Event-Loop-中的“渲染时机”"><a href="#前置知识：Event-Loop-中的“渲染时机”" class="headerlink" title="前置知识：Event Loop 中的“渲染时机”"></a>前置知识：Event Loop 中的“渲染时机”</h2><p>搞懂 Event Loop，是理解 Vue 对 DOM 操作优化的第一步。</p>
<h3 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h3><p>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<p>常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。</p>
<h3 id="Event-Loop-过程解析"><a href="#Event-Loop-过程解析" class="headerlink" title="Event Loop 过程解析"></a>Event Loop 过程解析</h3><p>基于对 micro 和 macro 的认知，我们来走一遍完整的事件循环过程。</p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<ul>
<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>
<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，<strong>这个过程本质上是队列的 macro-task 的执行和出队的过程</strong>。</li>
<li>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/11/23GcoTiZtbnYPaB.png" alt="img"></p>
<ul>
<li><strong>执行渲染操作，更新界面</strong>（敲黑板划重点）。</li>
<li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</li>
</ul>
<p>（上述过程循环往复，直到两个队列都清空）</p>
<p>我们总结一下，每一次循环都是一个这样的过程：</p>
<p><img src="https://i.loli.net/2021/01/11/IJD8mdKQMHTZRLC.png" alt="img"></p>
<h3 id="渲染的时机"><a href="#渲染的时机" class="headerlink" title="渲染的时机"></a>渲染的时机</h3><p>大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成 micro 还是 macro 呢？</p>
<p>我们先假设它是一个 macro 任务，比如我在 script 脚本中用 setTimeout 来处理它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task是一个用于修改DOM的回调</span></span><br><span class="line"><span class="built_in">setTimeout</span>(task, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render，对不对？</p>
<p>但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。</p>
<p>macro 不 ok，我们转向 micro 试试看。我用 Promise 来把 task 包装成是一个 micro 任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(task)</span><br></pre></td></tr></table></figure>
<p>那么我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。</p>
<p>因此，我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。<strong>当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择</strong>。</p>
<h2 id="生产实践：异步更新策略——以-Vue-为例"><a href="#生产实践：异步更新策略——以-Vue-为例" class="headerlink" title="生产实践：异步更新策略——以 Vue 为例"></a>生产实践：异步更新策略——以 Vue 为例</h2><p>什么是异步更新？</p>
<p>当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被<strong>批量触发</strong>。这就是异步更新。</p>
<p>异步更新可以帮助我们避免过度渲染，是我们上节提到的“让 JS 为 DOM 分压”的典范之一。</p>
<h3 id="异步更新的优越性"><a href="#异步更新的优越性" class="headerlink" title="异步更新的优越性"></a>异步更新的优越性</h3><p>异步更新的特性在于它<strong>只看结果</strong>，因此渲染引擎<strong>不需要为过程买单</strong>。</p>
<p>最典型的例子，比如有时我们会遇到这样的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务一</span></span><br><span class="line"><span class="built_in">this</span>.content = <span class="string">&#x27;第一次测试&#x27;</span></span><br><span class="line"><span class="comment">// 任务二</span></span><br><span class="line"><span class="built_in">this</span>.content = <span class="string">&#x27;第二次测试&#x27;</span></span><br><span class="line"><span class="comment">// 任务三</span></span><br><span class="line"><span class="built_in">this</span>.content = <span class="string">&#x27;第三次测试&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们在三个更新任务中对同一个状态修改了三次，如果我们采取传统的同步更新策略，那么就要操作三次 DOM。但本质上需要呈现给用户的目标内容其实只是第三次的结果，也就是说只有第三次的操作是有意义的——我们白白浪费了两次计算。</p>
<p>但如果我们把这三个任务塞进异步更新队列里，它们会先在 JS 的层面上被<strong>批量执行完毕</strong>。当流程走到渲染这一步时，它仅仅需要针对有意义的计算结果操作一次 DOM——这就是异步更新的妙处。</p>
<h3 id="Vue状态更新手法：nextTick"><a href="#Vue状态更新手法：nextTick" class="headerlink" title="Vue状态更新手法：nextTick"></a>Vue状态更新手法：nextTick</h3><p>Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。这件事情，在源码中是由一个叫做 nextTick 的函数来完成的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 检查上一个异步任务队列（即名为callbacks的任务数组）是否派发和执行完毕了。pending此处相当于一个锁</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    <span class="comment">// 若上一个异步任务队列已经执行完毕，则将pending设定为true（把锁锁上）</span></span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 是否要求一定要派发为macro任务</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不说明一定要macro 你们就全都是micro</span></span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，Vue 的异步任务默认情况下都是用 Promise 来包装的，也就是是说它们都是 micro-task。这一点和我们“前置知识”中的渲染时机的分析不谋而合。</p>
<p>为了带大家熟悉一下常见的 macro 和 micro 派发方式、加深对 Event Loop 的理解，我们继续细化解析一下 macroTimeFunc() 和 microTimeFunc() 两个方法。</p>
<p>macroTimeFunc() 是这么实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// macro首选setImmediate 这个兼容性最差</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">    isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">&#x27;[object MessageChannelConstructor]&#x27;</span></span><br><span class="line">  )) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 兼容性最好的派发方式是setTimeout</span></span><br><span class="line">  macroTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>microTimeFunc() 是这么实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单粗暴 不是ios全都给我去Promise 如果不兼容promise 那么你只能将就一下变成macro了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  microTimerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果无法派发micro，就退而求其次派发为macro</span></span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，无论是派发 macro 任务还是派发 micro 任务，派发的任务对象都是一个叫做 flushCallbacks 的东西，这个东西做了什么呢？</p>
<p>flushCallbacks 源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// callbacks在nextick中出现过 它是任务数组（队列）</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 将callbacks中的任务逐个取出执行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们理清楚了：Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。</p>
<p>本小节我们从性能优化的角度出发，通过解析Vue源码，对异步更新这一高效的 DOM 优化手段有了感性的认知。同时帮助大家进一步熟悉了 micro 与 macro 在生产中的应用，加深了对 Event Loop 的理解。事实上，Vue 源码中还有许多值得称道的生产实践，其设计模式与编码细节都值得我们去细细品味。对这个话题感兴趣的同学，课后不妨移步 <a href="https://juejin.im/book/5a36661851882538e2259c0f">Vue运行机制解析</a> 进行探索。</p>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的 DOM 优化之路才走完了一半。</p>
<p>以上我们都在讨论“如何减少 DOM 操作”的话题。这个话题比较宏观——DOM 操作也分很多种，它们带来的变化各不相同。有的操作只触发重绘，这时我们的性能损耗就小一些；有的操作会触发回流，这时我们更“肉疼”一些。那么如何理解回流与重绘，如何借助这些理解去提升页面渲染效率呢？</p>
<p>结束了 JS 的征程，我们下面就走进 CSS 的世界一窥究竟。</p>
<h1 id="渲染篇-5：最后一击——回流（Reflow）与重绘（Repaint）"><a href="#渲染篇-5：最后一击——回流（Reflow）与重绘（Repaint）" class="headerlink" title="渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）"></a>渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）</h1><p>开篇我们先对上上节介绍的回流与重绘的基础知识做个复习（跳读的同学请自觉回到上上节补齐 →_→）。</p>
<p><strong>回流</strong>：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p>
<p><strong>重绘</strong>：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>
<h2 id="哪些实际操作会导致回流与重绘"><a href="#哪些实际操作会导致回流与重绘" class="headerlink" title="哪些实际操作会导致回流与重绘"></a>哪些实际操作会导致回流与重绘</h2><p>要避免回流与重绘的发生，最直接的做法是避免掉可能会引发回流与重绘的 DOM 操作，就好像拆弹专家在解决一颗炸弹时，最重要的是掐灭它的导火索。</p>
<p>触发重绘的“导火索”比较好识别——只要是不触发回流，但又触发了样式改变的 DOM 操作，都会引起重绘，比如背景色、文字色、可见性(可见性这里特指形如visibility: hidden这样不改变元素位置和存在性的、单纯针对可见性的操作，注意与display:none进行区分)等。为此，我们要着重理解一下那些可能触发回流的操作。</p>
<h3 id="回流的“导火索”"><a href="#回流的“导火索”" class="headerlink" title="回流的“导火索”"></a>回流的“导火索”</h3><ul>
<li>最“贵”的操作：改变 DOM 元素的几何属性</li>
</ul>
<p>这个改变几乎可以说是“牵一发动全身”——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p>
<p>常见的几何属性有 width、height、padding、margin、left、top、border 等等。此处不再给大家一一列举。有的文章喜欢罗列属性表格，但我相信我今天列出来大家也不会看、看了也记不住（因为太多了）。我自己也不会去记这些——其实确实没必要记，️一个属性是不是几何属性、会不会导致空间布局发生变化，大家写样式的时候完全可以通过代码效果看出来。多说无益，还希望大家可以多写多试，形成自己的“肌肉记忆”。</p>
<ul>
<li>“价格适中”的操作：改变 DOM 树的结构</li>
</ul>
<p>这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。</p>
<ul>
<li>最容易被忽略的操作：获取一些特定属性的值</li>
</ul>
<p>当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！</p>
<p>“像这样”的属性，到底是像什么样？——这些值有一个共性，就是需要通过<strong>即时计算</strong>得到。因此浏览器为了获取这些值，也会进行回流。</p>
<p>除此之外，当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。</p>
<h2 id="如何规避回流与重绘"><a href="#如何规避回流与重绘" class="headerlink" title="如何规避回流与重绘"></a>如何规避回流与重绘</h2><p>了解了回流与重绘的“导火索”，我们就要尽量规避它们。但很多时候，我们不得不使用它们。当避无可避时，我们就要学会更聪明地使用它们。</p>
<h3 id="将“导火索”缓存起来，避免频繁改动"><a href="#将“导火索”缓存起来，避免频繁改动" class="headerlink" title="将“导火索”缓存起来，避免频繁改动"></a>将“导火索”缓存起来，避免频繁改动</h3><p>有时我们想要通过多次计算得到一个元素的布局位置，我们可能会这样做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#el</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;el&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取el元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;el&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这里循环判定比较简单，实际中或许会拓展出比较复杂的判定需求</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span></span><br><span class="line"><span class="javascript">      el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">      el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样做，每次循环都需要获取多次“敏感属性”，是比较糟糕的。我们可以将其以 JS 变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;el&#x27;</span>) </span><br><span class="line"><span class="keyword">let</span> offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.style.left = offLeft + <span class="string">&quot;px&quot;</span></span><br><span class="line">el.style.top = offTop  + <span class="string">&quot;px&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="避免逐条改变样式，使用类名去合并样式"><a href="#避免逐条改变样式，使用类名去合并样式" class="headerlink" title="避免逐条改变样式，使用类名去合并样式"></a>避免逐条改变样式，使用类名去合并样式</h3><p>比如我们可以把这段单纯的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.style.width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.style.height = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.style.border = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.style.color = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>
<p>优化成一个有 class 加持的样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.basic_style</span> &#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      border: 10px solid red;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  container.classList.add(<span class="string">&#x27;basic_style&#x27;</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。</p>
<p>合并之后，等于我们将所有的更改一次性发出，用一个 style 请求解决掉了。</p>
<h3 id="将-DOM-“离线”"><a href="#将-DOM-“离线”" class="headerlink" title="将 DOM “离线”"></a>将 DOM “离线”</h3><p>我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。</p>
<p>仍以我们上文的代码片段为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.style.width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.style.height = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.style.border = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br></pre></td></tr></table></figure>
<p>离线化后就是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">container.style.width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.style.height = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.style.border = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.style.display = <span class="string">&#x27;block&#x27;</span></span><br></pre></td></tr></table></figure>
<p>有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。</p>
<h2 id="Flush-队列：浏览器并没有那么简单"><a href="#Flush-队列：浏览器并没有那么简单" class="headerlink" title="Flush 队列：浏览器并没有那么简单"></a>Flush 队列：浏览器并没有那么简单</h2><p>以我们现在的知识基础，理解上面的优化操作并不难。那么现在我问大家一个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.style.width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.style.height = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.style.border = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.style.color = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这段代码里，浏览器进行了多少次的回流或重绘呢？</p>
<p>“width、height、border是几何属性，各触发一次回流；color只造成外观的变化，会触发一次重绘。”——如果你立刻这么想了，说明你是个能力不错的同学，认真阅读了前面的内容。那么我们现在立刻跑一跑这段代码，看看浏览器怎么说：</p>
<p><img src="https://i.loli.net/2021/01/11/TAMSGxPpXJRQnYN.png" alt="img"></p>
<p>这里为大家截取有“Layout”和“Paint”出镜的片段（这个图是通过 Chrome 的 Performance 面板得到的，后面会教大家用这个东西）。我们看到浏览器只进行了一次回流和一次重绘——和我们想的不一样啊，为啥呢？</p>
<p>因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。因此我们看到，上面就算我们进行了 4 次 DOM 更改，也只触发了一次 Layout 和一次 Paint。</p>
<p>大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。</p>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>整个一节读下来，可能会有同学感到疑惑：既然浏览器已经为我们做了批处理优化，为什么我们还要自己操心这么多事情呢？今天避免这个明天避免那个，多麻烦！</p>
<p>问题在于，<strong>并不是所有的浏览器都是聪明的</strong>。我们刚刚的性能图表，是 Chrome 的开发者工具呈现给我们的。Chrome 里行得通的东西，到了别处（比如 IE）就不一定行得通了。而我们并不知道用户会使用什么样的浏览器。如果不手动做优化，那么一个页面在不同的环境下就会呈现不同的性能效果，这对我们、对用户都是不利的。因此，养成良好的编码习惯、从根源上解决问题，仍然是最周全的方法。</p>
<h1 id="应用篇-1：优化首屏体验——Lazy-Load-初探"><a href="#应用篇-1：优化首屏体验——Lazy-Load-初探" class="headerlink" title="应用篇 1：优化首屏体验——Lazy-Load 初探"></a>应用篇 1：优化首屏体验——Lazy-Load 初探</h1><p>首先要告诉大家的是，截止到上个章节，我们需要大家绞尽脑汁去理解的“硬核”操作基本告一段落了。从本节开始，我们会一起去实现一些必知必会、同时难度不大的常用优化手段。</p>
<p>这部分内容不难，但<strong>很关键</strong>。尤其是近期有校招或跳槽需求的同学，还请务必对这部分内容多加留心，说不定下一次的面试题里就有它们的身影。</p>
<h2 id="Lazy-Load-初相见"><a href="#Lazy-Load-初相见" class="headerlink" title="Lazy-Load 初相见"></a>Lazy-Load 初相见</h2><p>Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片真的太多了，一口气处理这么多任务，浏览器做不到啊！</p>
<p>但我们再想，用户真的需要这么多图片吗？不对，用户点开页面的瞬间，呈现给他的只有屏幕的一部分（我们称之为首屏）。只要我们可以在页面打开的时候把首屏的图片资源加载出来，用户就会认为页面是没问题的。至于下面的图片，我们完全可以等用户下拉的瞬间再即时去请求、即时呈现给他。这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是 Lazy-Load。</p>
<p>现在我们打开掘金首页：</p>
<p><img src="https://i.loli.net/2021/01/11/Nyargkn7zY8VKv5.png" alt="img"></p>
<p>大家留意一栏文章右侧可能会出现的图片，这里咱们给个特写：</p>
<p><img src="https://i.loli.net/2021/01/11/KqCas7rQGEbFlH6.png" alt="img"></p>
<p>大家现在以尽可能快的速度，疯狂向下拉动页面。发现什么？是不是发现我们图示的这个图片的位置，会出现闪动——有时候我们明明已经拉到目标位置了，文字也呈现完毕了，图片却慢半拍才显示出来。这是因为，掘金首页也采用了懒加载策略。当我们的页面并未滚动至包含图片的 div 元素所在的位置时，它的样式是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/eUCLNvXikhKx17s.png" alt="img"></p>
<p>我们把代码提出来看一下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-v-b2db8566</span>=<span class="string">&quot;&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-v-009ea7bb</span>=<span class="string">&quot;&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-v-6b46a625</span>=<span class="string">&quot;&quot;</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">data-src</span>=<span class="string">&quot;https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1&quot;</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;lazy thumb thumb&quot;</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;background-image: none; background-size: cover;&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们注意到 style 内联样式中，背景图片设置为了 none。也就是说这个 div 是没有内容的，它只起到一个<strong>占位</strong>的作用。</p>
<p>这个“占位”的概念，在这个例子里或许体现得不够直观。最直观的应该是淘宝首页的 HTML Preview 效果：</p>
<p><img src="https://i.loli.net/2021/01/11/9UMP2XEVxs1YcG3.png" alt="img"></p>
<p>我们看到，这个还没来得及被图片填充完全的网页，是用大大小小的空 div 元素来占位的。掘金首页也是如此。</p>
<p>一旦我们通过滚动使得这个 div 出现在了可见范围内，那么 div 元素的内容就会发生变化，呈现如下的内容：</p>
<p><img src="https://i.loli.net/2021/01/11/h1WsbQwLGazTBU3.png" alt="img"></p>
<p>我们给 style 一个特写：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">style=&quot;background-image: url(&amp;quot;https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1&amp;quot;); background-size: cover;&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出，style 内联样式中的背景图片属性从 none 变成了一个在线图片的 URL。也就是说，出现在可视区域的瞬间，div 元素的内容被即时地修改掉了——它被写入了有效的图片 URL，于是图片才得以呈现。这就是懒加载的实现思路。</p>
<h2 id="一起写一个-Lazy-Load-吧！"><a href="#一起写一个-Lazy-Load-吧！" class="headerlink" title="一起写一个 Lazy-Load 吧！"></a>一起写一个 Lazy-Load 吧！</h2><p>基于上面的实现思路，我们完全可以手动实现一个属于自己的 Lazy-Load。</p>
<p>（<strong>此处敲黑板划重点，Lazy-Load 的思路及实现方式为大厂面试常考题，还望诸位同学引起重视</strong>）</p>
<p>首先新建一个空项目，目录结构如下：</p>
<p><img src="https://i.loli.net/2021/01/11/cpLIQ9ZqNdxGEVF.png" alt="img"></p>
<p>大家可以往 images 文件夹里塞入各种各样自己喜欢的图片。</p>
<p>我们在 index.html 中，为这些图片预置 img 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazy-Load<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.img</span> &#123;</span></span><br><span class="line">      width: 200px;</span><br><span class="line"><span class="css">      <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">      background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.pic</span> &#123;</span></span><br><span class="line">      // 必要的img样式</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      // 注意我们并没有为它引入真实的src</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/1.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/2.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/3.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/4.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/5.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/6.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/7.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/8.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/9.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./images/10.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在懒加载的实现中，有两个关键的数值：一个是<strong>当前可视区域的高度</strong>，另一个是<strong>元素距离可视区域顶部的高度</strong>。</p>
<p><strong>当前可视区域的高度</strong>， 在和现代浏览器及 IE9 以上的浏览器中，可以用 window.innerHeight 属性获取。在低版本 IE 的标准模式中，可以用 document.documentElement.clientHeight 获取，这里我们兼容两种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight </span><br></pre></td></tr></table></figure>
<p>而<strong>元素距离可视区域顶部的高度</strong>，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。对此 MDN 给出了非常清晰的解释：</p>
<blockquote>
<p>该方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的 CSS 边框集合 。</p>
</blockquote>
<blockquote>
<p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p>
</blockquote>
<p>其中需要引起我们注意的就是 left、top、right 和 bottom，它们对应到元素上是这样的：</p>
<p><img src="https://i.loli.net/2021/01/11/br5ZedigUfYQL8t.png" alt="img"></p>
<p>可以看出，top 属性代表了元素距离可视区域顶部的高度，正好可以为我们所用！</p>
<p>Lazy-Load 方法开工啦！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 获取所有的图片标签</span></span><br><span class="line">    <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    <span class="comment">// 获取可视区域的高度</span></span><br><span class="line">    <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="comment">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=num; i&lt;imgs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 用可视区域高度减去元素顶部距离可视区域顶部的高度</span></span><br><span class="line">            <span class="keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top</span><br><span class="line">            <span class="comment">// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span></span><br><span class="line">            <span class="keyword">if</span>(distance &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">// 给元素写入真实的src，展示图片</span></span><br><span class="line">                imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">                <span class="comment">// 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span></span><br><span class="line">                num = i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听Scroll事件</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, lazyload, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>本节我们实现出了一个最基本的懒加载功能。但是大家要注意一点：这个 scroll 事件，是一个<strong>危险</strong>的事件——它太容易被触发了。试想，用户在访问网页的时候，是不是可以无限次地去触发滚动？尤其是一个页面死活加载不出来的时候，疯狂调戏鼠标滚轮（或者浏览器滚动条）的用户可不在少数啊！</p>
<p>再回头看看我们上面写的代码。按照我们的逻辑，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。这里就引出了我们下一节的两位主角——throttle 与 debounce。</p>
<h1 id="应用篇-2：事件的节流（throttle）与防抖（debounce）"><a href="#应用篇-2：事件的节流（throttle）与防抖（debounce）" class="headerlink" title="应用篇 2：事件的节流（throttle）与防抖（debounce）"></a>应用篇 2：事件的节流（throttle）与防抖（debounce）</h1><p>上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。</p>
<p>频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。</p>
<h2 id="“节流”与“防抖”的本质"><a href="#“节流”与“防抖”的本质" class="headerlink" title="“节流”与“防抖”的本质"></a>“节流”与“防抖”的本质</h2><p>这两个东西都以<strong>闭包</strong>的形式存在。</p>
<p>它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p>
<h2 id="Throttle：-第一个人说了算"><a href="#Throttle：-第一个人说了算" class="headerlink" title="Throttle： 第一个人说了算"></a>Throttle： 第一个人说了算</h2><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p>
<p>先给大家讲个小故事：现在有一个旅客刚下了飞机，需要用车，于是打电话叫了该机场唯一的一辆机场大巴来接。司机开到机场，心想来都来了，多接几个人一起走吧，这样这趟才跑得值——我等个十分钟看看。于是司机一边打开了计时器，一边招呼后面的客人陆陆续续上车。在这十分钟内，后面下飞机的乘客都只能乘这一辆大巴，十分钟过去后，不管后面还有多少没挤上车的乘客，这班车都必须发走。</p>
<p>在这个故事里，“司机” 就是我们的节流阀，他控制发车的时机；“乘客”就是因为我们频繁操作事件而不断涌入的回调任务，它需要接受“司机”的安排；而“计时器”，就是我们上文提到的以自由变量形式存在的时间信息，它是“司机”决定发车的依据；最后“发车”这个动作，就对应到回调函数的执行。</p>
<p>总结下来，所谓的“节流”，是通过在一段时间内<strong>无视后来产生的回调请求</strong>来实现的。只要一位客人叫了车，司机就会为他开启计时器，一定的时间内，后面需要乘车的客人都得排队上这一辆车，谁也无法叫到更多的车。</p>
<p>对应到实际的交互上是一样一样的：每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“一辆车的乘客”——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。</p>
<p>理解了大致的思路，我们现在一起实现一个 throttle：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用throttle来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure>
<h2 id="Debounce：-最后一个人说了算"><a href="#Debounce：-最后一个人说了算" class="headerlink" title="Debounce： 最后一个人说了算"></a>Debounce： 最后一个人说了算</h2><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p>
<p>继续讲司机开车的故事。这次的司机比较有耐心。第一个乘客上车后，司机开始计时（比如说十分钟）。十分钟之内，如果又上来了一个乘客，司机会把计时器清零，重新开始等另一个十分钟（延迟了等待）。直到有这么一位乘客，从他上车开始，后续十分钟都没有新乘客上车，司机会认为确实没有人需要搭这趟车了，才会把车开走。</p>
<p>我们对比 throttle 来理解 debounce：在throttle的逻辑里，“第一个人说了算”，它只为第一个乘客计时，时间到了就执行回调。而 debounce 认为，“最后一个人说了算”，debounce 会为每一个新乘客设定新的定时器。</p>
<p>我们基于上面的理解，一起来写一个 debounce：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将debounce处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure>
<h2 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h2><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。</p>
<p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要delay的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间, timer是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">    <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">       timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的throttle包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure>
<h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p>throttle 和 debounce 不仅是我们日常开发中的常用优质代码片段，更是前端面试中不可不知的高频考点。“看懂了代码”、“理解了过程”在本节都是不够的，重要的是把它写到自己的项目里去，亲自体验一把节流和防抖带来的性能提升。</p>
<h1 id="性能监测篇：Performance、LightHouse-与性能-API"><a href="#性能监测篇：Performance、LightHouse-与性能-API" class="headerlink" title="性能监测篇：Performance、LightHouse 与性能 API"></a>性能监测篇：Performance、LightHouse 与性能 API</h1><p>性能监测是前端性能优化的重要一环。监测的目的是为了确定性能瓶颈，从而有的放矢地开展具体的优化工作。</p>
<p>平时我们比较推崇的性能监测方案主要有两种：<strong>可视化方案、可编程方案</strong>。这两种方案下都有非常优秀、且触手可及的相关工具供大家选择，本节我们就一起来研究一下这些工具的用法。</p>
<h2 id="可视化监测：从-Performance-面板说起"><a href="#可视化监测：从-Performance-面板说起" class="headerlink" title="可视化监测：从 Performance 面板说起"></a>可视化监测：从 Performance 面板说起</h2><p>Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。</p>
<h3 id="开始记录"><a href="#开始记录" class="headerlink" title="开始记录"></a>开始记录</h3><p>右键打开开发者工具，选中我们的 Performance 面板：</p>
<p><img src="https://i.loli.net/2021/01/11/B3LwT1yAnUrtcfi.png" alt="img"></p>
<p>当我们选中图中所标示的实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；当我们选中圆箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。<br>tips：使用 Performance 工具时，为了规避其它 Chrome 插件对页面的性能影响，我们最好在无痕模式下打开页面：</p>
<p><img src="https://i.loli.net/2021/01/11/ijXI7AMqCtYgakw.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/01/11/4qXVwsBfSx6vJ7R.png" alt="img"></p>
<h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><p>这里我打开掘金首页，选中 Performance 面板中的圆箭头，来看一下页面加载过程中的性能表现：</p>
<p><img src="https://i.loli.net/2021/01/11/qA7iYX2FNoe4fDs.png" alt="img"></p>
<p>从上到下，依次为概述面板、详情面板。下我们先来观察一下概述面板，了解页面的基本表现：</p>
<p><img src="https://i.loli.net/2021/01/11/MLIOiHQl8c5kt9E.png" alt="img"></p>
<p>我们看右上角的三个栏目：FPS、CPU 和 NET。</p>
<p><strong>FPS</strong>：这是一个和动画性能密切相关的指标，它表示每一秒的帧数。图中绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。图中以绿色为主，偶尔出现红块，说明网页性能并不糟糕，但仍有可优化的空间。</p>
<p><strong>CPU</strong>：表示CPU的使用情况，不同的颜色片段代表着消耗CPU资源的不同事件类型。这部分的图像和下文详情面板中的Summary内容有对应关系，我们可以结合这两者挖掘性能瓶颈。</p>
<p><strong>NET</strong>：粗略的展示了各请求的耗时与前后顺序。这个指标一般来说帮助不大。</p>
<h3 id="挖掘性能瓶颈"><a href="#挖掘性能瓶颈" class="headerlink" title="挖掘性能瓶颈"></a>挖掘性能瓶颈</h3><p>详情面板中的内容有很多。但一般来说，我们会主要去看 Main 栏目下的火焰图和 Summary 提供给我们的饼图——这两者和概述面板中的 CPU 一栏结合，可以帮我们迅速定位性能瓶颈（如下图）。</p>
<p><img src="https://i.loli.net/2021/01/11/px5rBCs7eJzfYwK.png" alt="img"></p>
<p>先看 CPU 图表和 Summary 饼图。CPU 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。这样我们在优化的时候，就可以抓到“主要矛盾”，进而有的放矢地开展后续的工作了。</p>
<p>再看 Main 提供给我们的火焰图。这个火焰图非常关键，它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等）。x 轴表示随时间的记录。每个长条就代表一个活动。更宽的条形意味着事件需要更长时间。y 轴表示调用堆栈，我们可以看到事件是相互堆叠的，上层的事件触发了下层的事件。</p>
<p>CPU 图标和 Summary 图都是按照“类型”给我们提供性能信息，而 Main 火焰图则将粒度细化到了每一个函数的调用。到底是从哪个过程开始出问题、是哪个函数拖了后腿、又是哪个事件触发了这个函数，这些具体的、细致的问题都将在 Main 火焰图中得到解答。</p>
<h2 id="可视化监测：-更加聪明的-LightHouse"><a href="#可视化监测：-更加聪明的-LightHouse" class="headerlink" title="可视化监测： 更加聪明的 LightHouse"></a>可视化监测： 更加聪明的 LightHouse</h2><p>Performance 无疑可以为我们提供很多有价值的信息，但它的展示作用大于分析作用。它要求使用者对工具本身及其所展示的信息有充分的理解，能够将晦涩的数据“翻译”成具体的性能问题。</p>
<p>程序员们许了个愿：如果工具能帮助我们把页面的问题也分析出来就好了！上帝听到了这个愿望，于是给了我们 LightHouse：</p>
<p><img src="https://i.loli.net/2021/01/11/9QjtRvFqEH27GJh.png" alt="img"></p>
<blockquote>
<p>Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。</p>
</blockquote>
<p>敲黑板划重点：它生成的是一个报告！Report！不是干巴巴地数据，而是一个通过测试与分析呈现出来的结果（它甚至会给你的页面跑一个分数出来）。这个东西看起来也真是太赞了，我们这就来体验一下！</p>
<p>首先在 Chrome 的应用商店里下载一个 LightHouse。这一步 OK 之后，我们浏览器右上角会出现一个小小的灯塔 ICON。打开我们需要测试的那个页面，点击这个 ICON，唤起如下的面板：</p>
<p><img src="https://i.loli.net/2021/01/11/4xRgIcwKPQtAyLJ.png" alt="img"></p>
<p>然后点击“Generate report”按钮，只需静候数秒，LightHouse 就会为我们输出一个完美的性能报告。</p>
<p>这里我拿掘金小册首页“开刀”：</p>
<p><img src="https://i.loli.net/2021/01/11/C1fGP3uxIKVpiRN.png" alt="img"></p>
<p>稍事片刻，Report 便输出成功了，LightHouse 默认会帮我们打开一个新的标签页来展示报告内容。报告内容非常丰富，首先我们看到的是整体的跑分情况：</p>
<p><img src="https://i.loli.net/2021/01/11/lTMCIGoJmVjNxcD.png" alt="img"></p>
<p>上述分别是页面性能、PWA（渐进式 Web 应用）、可访问性（无障碍）、最佳实践、SEO 五项指标的跑分。孰强孰弱，我们一看便知。</p>
<p>向下拉动 Report 页，我们还可以看到每一个指标的细化评估：</p>
<p><img src="https://i.loli.net/2021/01/11/dHofXO1NK4EjPxb.png" alt="img"></p>
<p>在“Opportunities”中，LightHouse 甚至针对我们的性能问题给出了可行的建议、以及每一项优化操作预期会帮我们节省的时间。这份报告的可操作性是很强的——我们只需要对着 LightHouse 给出的建议，一条一条地去尝试，就可以看到自己的页面，在一秒一秒地变快。</p>
<p>除了直接下载，我们还可以通过命令行使用 LightHouse：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g lighthouse</span><br><span class="line">lighthouse https:&#x2F;&#x2F;juejin.im&#x2F;books</span><br></pre></td></tr></table></figure>
<p>同样可以得到掘金小册的性能报告。</p>
<p>此外，从 Chrome 60 开始，DevTools 中直接加入了基于 LightHouse 的 Audits 面板：</p>
<p><img src="https://i.loli.net/2021/01/11/LBjW4od3ZnbkyvE.png" alt="img"></p>
<p>LightHouse 因此变得更加触手可及了，这一操作也足以证明 Chrome 团队对 LightHouse 的推崇。</p>
<h2 id="可编程的性能上报方案：-W3C-性能-API"><a href="#可编程的性能上报方案：-W3C-性能-API" class="headerlink" title="可编程的性能上报方案： W3C 性能 API"></a>可编程的性能上报方案： W3C 性能 API</h2><p>W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。</p>
<p>当下的前端世界里，数据可视化的概念已经被炒得非常热了，Performance 面板就是数据可视化的典范。那么为什么要把已经可视化的数据再掏出来处理一遍呢？这是因为，需要这些数据的人不止我们前端——很多情况下，后端也需要我们提供性能信息的上报。此外，Performance 提供的可视化结果并不一定能够满足我们实际的业务需求，只有拿到了真实的数据，我们才可以对它进行二次处理，去做一个更加深层次的可视化。</p>
<p>在这种需求背景下，我们就不得不祭出 Performance API了。</p>
<h3 id="访问-performance-对象"><a href="#访问-performance-对象" class="headerlink" title="访问 performance 对象"></a>访问 performance 对象</h3><p>performance 是一个全局对象。我们在控制台里输入 window.performance，就可一窥其全貌：</p>
<p><img src="https://i.loli.net/2021/01/11/6xjo4TvBqFEJcr2.png" alt="img"></p>
<h3 id="关键时间节点"><a href="#关键时间节点" class="headerlink" title="关键时间节点"></a>关键时间节点</h3><p>在 performance 的 timing 属性中，我们可以查看到如下的时间戳：</p>
<p><img src="https://i.loli.net/2021/01/11/VargBWHkEmPOU8h.png" alt="img"></p>
<p>这些时间戳与页面整个加载流程中的关键时间节点有着一一对应的关系：</p>
<p><img src="https://i.loli.net/2021/01/11/YWsSTvRjLEqOZin.png" alt="img"></p>
<p>通过求两个时间点之间的差值，我们可以得出某个过程花费的时间，举个🌰：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timing = <span class="built_in">window</span>.performance.timing</span><br><span class="line"><span class="comment">// DNS查询耗时</span></span><br><span class="line">timing.domainLookupEnd - timing.domainLookupStart</span><br><span class="line">  </span><br><span class="line"><span class="comment">// TCP连接耗时</span></span><br><span class="line">timing.connectEnd - timing.connectStart</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 内容加载耗时</span></span><br><span class="line">timing.responseEnd - timing.requestStart</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>除了这些常见的耗时情况，我们更应该去关注一些<strong>关键性能指标</strong>：firstbyte、fpt、tti、ready 和 load 时间。这些指标数据与真实的用户体验息息相关，是我们日常业务性能监测中不可或缺的一部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// firstbyte：首包时间	</span></span><br><span class="line">timing.responseStart – timing.domainLookupStart	</span><br><span class="line"></span><br><span class="line"><span class="comment">// fpt：First Paint Time, 首次渲染时间 / 白屏时间</span></span><br><span class="line">timing.responseEnd – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// tti：Time to Interact，首次可交互时间	</span></span><br><span class="line">timing.domInteractive – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// ready：HTML 加载完成时间，即 DOM 就位的时间</span></span><br><span class="line">timing.domContentLoaded – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// load：页面完全加载时间</span></span><br><span class="line">timing.loadEventStart – timing.fetchStart</span><br></pre></td></tr></table></figure>
<p>以上这些通过 Performance API 获取到的时间信息都具有较高的准确度。我们可以对此进行一番格式处理之后上报给服务端，也可以基于此去制作相应的统计图表，从而实现更加精准、更加个性化的性能耗时统计。</p>
<p>此外，通过访问 performance 的 memory 属性，我们还可以获取到内存占用相关的数据；通过对 performance 的其它属性方法的灵活运用，我们还可以把它耦合进业务里，实现更加多样化的性能监测需求——灵活，是可编程化方案最大的优点。</p>
<h2 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h2><p>本节我们介绍了 Performance 开发者工具、LightHouse 与 Performance API 三种性能监测的方案。只要有 Chrome 浏览器，我们就可以实现上述的所有操作。</p>
<p>由此可以看出，性能监测本身并不难。它的复杂度是在与业务发生耦合的过程中提升的。我们今天打下了坚实的地基，后续需要大家在业务中去成长、去发掘这些工具的更多的潜力，这样才能建立起属于我们自己的技术金字塔。</p>
<p>推荐阅读：</p>
<ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference">Performance 官方文档</a></li>
<li><a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-cn">使用 Lighthouse 审查网络应用</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance">MDN Performance API 介绍</a></li>
</ul>
<h1 id="前方的路：希望成为你的起点"><a href="#前方的路：希望成为你的起点" class="headerlink" title="前方的路：希望成为你的起点"></a>前方的路：希望成为你的起点</h1><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>首先要谢谢每一位读到最后一章的同学。这是我的第一本小册，也是我第一次撰写对外开放的知识内容，谢谢大家选择了这本小册，选择了我这个作者。</p>
<h2 id="未完成的故事"><a href="#未完成的故事" class="headerlink" title="未完成的故事"></a>未完成的故事</h2><p>对笔者来说，撰写小册的两个月，是挑战重重的两个月。在这个过程中，笔者时时刻刻都在与“程序员”和“技术作者”这两个角色较劲。前者要求我锱铢必较、求深求全，后者则需要我在小册内容的深度、广度与可读性之间作出权衡。正是因为有了这一番又一番的权衡，它才终于被打磨成了一本篇幅短小、卖相可爱的“小册”，而非一本庞大的、令人望而生畏的“手册”。</p>
<p>但也是因为如此，小册里多出了一些“未完成的故事”。比如网络优化这部分，我想可能会有同学兴致勃勃地想听一听 DNS 的预解析或者 TCP 协议的负载均衡；再比如资源加载这一块，为什么说了 async 和 defer，却没有提 preload 和 prefetch 呢？又或者比较追逐“潮流”的同学，心心念念的是 Service Worker 和 Web Worker 的应用方案；甚至所在团队性能这块还没做起来的同学，希望我可以提供能够耦合进业务的性能监测方案，等等（这些都是非常实际的阅读需求）。</p>
<p>但正如我开篇所说的，我的初心并非是为大家提供一本面面俱到的“手册”。前端性能优化的知识点零碎、不成体系，这是它学习的痛点，也是小册想要解决的问题。有许多同样精彩的性能知识，我们可以针对它做技术方案测试、可以为它开研讨会，但它并不适合出现在小册的写作大纲里、以短文的形式呈现。我希望呈现给大家的内容，是前后相连，自成体系的“一串”知识。是大家在学习、工作之余，在等公交、搭地铁的间隙，在碎片化的时间里，仍然能够轻松阅读并理解的友好内容。</p>
<h2 id="前方的路"><a href="#前方的路" class="headerlink" title="前方的路"></a>前方的路</h2><p>小册之愿，是希望成为大家性能优化这条路上的起点。</p>
<p>相对于模式成熟、方案完善的服务端性能优化来说，前端性能优化整体的起步是比较晚的。但在当今的大环境下，它又是极其重要的一个工作。我们是离用户最近的工程师，需要直接对用户的体验负责。因此，我们需要做的努力还有太多太多。</p>
<p>既然已经读到了最后一章，我想大家应该都收获了一张属于自己的前端性能优化的核心知识“索引表”——我希望它能成为大家的起点，成为各位今后拓展相关技能的素材。当下前端世界里，提起技术，许多初学者第一反应仍然是学框架、学工具。框架和工具固然重要，但一个合格的前端工程师，还应该具有抽象思维的能力和技术攻关的实力——这两点，都可以在性能优化的学习和实践过程中得到磨炼和凸显。</p>
<p>在庞大的前端性能知识体系面前，一本单薄的小册是远远不够的。接下来大家要做的，就是实践、实践、再实践！反复地阅读文字、一味地深究理论是无法使我们的技能变“厚”的，最好的办法就是去做，去用，在用的过程中发现问题、解决问题、拓展问题——那些“未完成的故事”，一定会在这个过程中被你书写圆满。</p>
<p>把这张“索引表”装进行囊，继续征战你的前端性能优化之旅吧！</p>
<p><a href="https://www.kancloud.cn/sllyli/performance/1242194">原文链接</a></p>
]]></content>
      <tags>
        <tag>前端 性能 优化</tag>
      </tags>
  </entry>
</search>
