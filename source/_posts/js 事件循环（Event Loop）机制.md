---

title: js 事件循环（Event Loop）机制
date: 2018/12/22 9:56:26 
tags: javascript　js　事件循环 eventloop

---

> 先放个测试题，压压惊

```

const interval = setInterval(()=>{
  console.log('setInterval');
},0);
 
setTimeout(()=>{
  console.log('setTimeout 1');
  Promise.resolve()
    .then(()=>{
      console.log('promise1');  
    })
    .then(()=>{
      setTimeout(()=>{
        console.log('setTimeout 2');
        clearInterval(interval);
      },0);
    })
},0);
 
Promise.resolve()
  .then(()=>{
     console.log('promise2');
})
```
**末尾揭晓答案**

<!-- more -->

## 单线程

我们都知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。

单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。

而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

当然，现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。

然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。

可以预见，未来的javascript也会一直是一门单线程的语言。

# 单线程的优劣势

## 优势
1. 降低处理复杂性，简化开发，例如不用考虑竞争机制等。

2. 作为用于预处理与用户互动的脚本语言，可以更加容易地处理状态同步的问题。

3. JS核心维护人员自身的理解与设计。

4. 越简单越容易推广，快速上手。

## 明显的劣势

1. 并发处理能力，任务处于 I/O 等待状态，导致CPU处理资源的浪费。

2. 于是JavaScript语言将任务的执行模分成两种：同步任务和异步任务。通过事件循环处理任务。

3. 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

4. 异步任务：不进入主线程、而进入任务队列（Task queue），只有任务通知主线程，某个任务可以执行了，该任务才会进入主线程执行。

# 执行栈与事件队列

当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。

我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。

当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并吧这个执行环境销毁。接着继续执行队列里的下一段代码。

# 事件循环（Event Loop）

先看一段伪代码

```
// eventLoop是一个用作队列的数组，（先进，先出）
var eventLoop = [ ];
var event;
// “永远”执行
while (true){
  if (eventLoop.length > 0){
    // 拿到队列中的下一个事件
    event = eventLoop.shift();
    // 现在，执行下一个事件
    try {
      event();
    }catch (err){
      reportError(err);
    }
  }
```

这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。

再贴张流程图

![img](https://i.loli.net/2021/01/11/XhrE7PtlaZGpVd3.jpg)

事件循环的具体步骤

1. 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。

2. 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。

3. 执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。

请看下面一段代码

```
console.log('A'+ new Date());
setTimeout(function(){
 console.log('B'+new Date());
},1000);
var end = Date.now()+3000;
while(Date.now()<end){}
console.log('C'+new Date());
```

A,B,C输出的顺序，以及输出的时间 ?

A会被立即输出，执行到setTimeout(...)时，将会等待1秒后在任务队列添加一个打印B的任务，然后继续往下执行。JS主线程会在while循环通过后继续往下执行，在等待3秒后C被打印，此时任务队列中还有个定时任务回调函数。JS执行栈执行完一个任务之后会再去任务队列取任务，所以C输出后。直接输出B。

PS：一定要清楚， setTimeout(..) 并 没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。

# macro task(宏任务)与micro task(微任务)

以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）。

以下事件属于宏任务：

- script
- setInterval()
- setTimeout()
- setImmediate
- 用户交互操作
- UI渲染

以下事件属于微任务

- new Promise()
- process.nextTick
- new MutaionObserver()
- Object.observe

事件循环做的事情如下：

1. 检查Macrotask 队列是否为空（同步代码），若不为空，则进行下一步，若为空，则跳到3；

2. 从Macrotask队列中取首个任务推入执行栈执行，执行完后进入下一步；

3. 检查Microtask队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）；

4. 从Microtask队列取首个任务执行，执行完后，跳到3；

5. 然后开始下一轮 Event loop，执行宏任务中的异步代码；

**简单来讲，整体的js代码这个macrotask先执行，同步代码执行完后有microtask执行microtask，没有microtask执行下一个macrotask，如此往复循环；**

---

文首测试题的答案为：

promise2

setInterval

setTimeout 1

promise1

setInterval

setTimeout2