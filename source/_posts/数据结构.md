---

title: 数据结构
date: 2019/1/20 22:47:32
tags: JavaScript 数据结构

---

> 在过去的几年中，得益于Node.js的兴起，JavaScript越来越广泛地用于服务器端编程。鉴于JavaScript语言已经走出了浏览器，程序员发现他们需要更多传统语言（比如C++和Java）提供的工具。这些工具包括传统的数据结构（如链表，栈，队列，图等），也包括传统的排序和查找算法。本文主要是总结什么情况下使用何种数据结构较好，并没有细讲里面的原理和实现方式，仅仅提供给阅读过《数据结构和算法》的同学作为总结和参考笔记，如果未细究过数据结构和算法的同学，本文也可以作为一个方向，希望能引导你去深究数据结构和算法。

<!-- more -->

# 为什么需要学习数据结构？

## 语言是相通的?

人们常说，编程语言是相通的，掌握了一门，其他语言很容易就能掌握，个人认为这是一个似是而非的观点。

每门编程语言都离不开变量，数组，循环，条件判断这些概念，这似乎能够支持上面的观点，但是，每门编程语言都有自己的适用范围。都有自己擅长的事情，即便是有了node.js这种能够一统前后端的语言，也总有它不能胜任的工作，比如机器学习。像python这样的近乎万能的语言，也总有无能为力的时候，比如面对高性能计算，许多python库的底层实现可都是C语言哦。

多年的工作经验告诉我，真正相通的不是语言，而是数据结构和算法。

数据结构和算法是脱离编程语言而存在的，不同的语言有不同的实现版本，但内在的逻辑却不会有变化，所体现的编程思想不会有变化。

## 一段亲身经历

我曾经在工作有过这样一次经历，我在后端通过websockt向前端发送数据，数据是一个具体的坐标，前端的同学得到坐标后，要在前端的中国地图上根据坐标显示一个光圈。这是一个非常简单的事情，但却遇到了麻烦，后端向前端推送数据是一个不定时的行为，有时1秒钟推了3条数据，有时3秒钟才推1条数据，当我推送数据频繁的时候，如果这些坐标都在地图上显示，地图会非常乱。长时间不推送数据时，前端页面不应该一直显示之前推送过的坐标，因为每一个坐标代表一个用户刚刚在我们的网站上做了一项操作。

于是，我们对前端显示做了限制，前端同一个时刻最多显示10个坐标，如果已经有10个，新来的坐标要把之前最早到来的坐标挤掉，每个坐标最多显示5秒钟。就是这样一个简单的要求，前端同学却迟迟不能实现该功能，因为他无法兼顾最多显示10个坐标和每个坐标最多显示5秒钟的要求。

后来，我让他用队列来实现。前端在收到坐标后，将坐标和收到时间构造成一个新的对象，一同放入到队列中，如果列队元素已经有10个，则把队列头部的元素删除，于此同时，每隔1秒钟就对队列里的元素检查一次，队列头部的元素都是最早到来的，如果当前时间距离到来时间超过5秒，则删除队列头部元素。

就这样，前端同学使用队列，非常快的实现了这个功能，而且对数据结构产生了浓厚的兴趣。

每当你怀疑学习数据结构的必要性和作用时，请提醒自己，如果你手里只有锤子，那么目光所及之处都是钉子。

## 学习数据结构的目标

- 提高程序设计能力

- 提高算法能力

- 找工作面试的时候hold住面试官

数据结构的精髓在于总结提炼了许多存储管理和使用数据的模式，这些模式的背后是最精华的编程思想，这些思想的领悟需要时间，不要想当然的认为学会了几种数据结构就可以在工作中大显身手，但学会了数据结构，对自身能力的提升是不言而喻的。

当然，在没有参悟这些数据管理方式和编程思想之前，我们先学习具体的工具和方法。

## 学习数据结构需要准备哪些知识

你需要熟练地使用数组这种数据类型，我想这没什么困难，再有就是知道如何在javascript中定义类，这里推荐一篇文章[Javascript定义类（class）的三种方法](http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html)本系列课程主要使用构造函数法定义类。

# 数据结构之----栈

## 栈的定义

栈是一种特殊的线性表，仅能够在栈顶进行操作，有着先进后出(后进先出)的特性，下面这张图展示了栈的工作特点：

![](https://i.imgur.com/k0yBPn0.png)

对于栈的理解，你必须牢牢抓住一点，那便是你只能在栈顶进行操作，生活中有一个非常贴切的例子，玩羽毛球的同学都会买一桶羽毛球，羽毛球桶就是典型的栈结构。

![](https://i.imgur.com/lNPG23S.jpg)

每次取羽毛球时，都只能从顶部取，最底下的羽毛球，你是取不到的，用完了羽毛球后，也只能从顶部放回去。

## 栈的实现

上一小节，我们对栈这种数据结构有了视觉上的接触和理解，接下来，我们要对栈进行定义，毕竟，我们写一个栈，为的是使用它，那么就必须先定义数据存储在哪里，提供什么样的方法。

### 数据存储

从数据存储的角度看，实现栈有两种方式，一种是以数组做基础，一种是以链表做基础，数组是最简单的实现方式，链表在后面会作为单独的一种数据结构来讲解。本次课程将使用数组来实现栈和队列，数组是大家平时用的最频繁的，也是最了解熟悉的数据类型。

我们先定义一个简单的Stack类

```
function Stack() {
    var items = [];  // 使用数组存储数据
};
```

数据将存储在items数组之中，现在，这个类没有任何方法。

### 栈的方法

栈有以下几个方法：

- push 添加一个元素到栈顶（向桶里放入一个羽毛球）

```
// push方法向栈里压入一个元素
this.push = function(item){
    items.push(item);
};
```

- pop 弹出栈顶元素（从桶里拿出一个羽毛球）

```
// pop方法把栈顶的元素弹出
this.pop = function(){
    return items.pop();
};
```

数组的pop方法会删除最靠后的那个元素，同时return该元素

- top 返回栈顶元素，注意，不是弹出（看一眼桶里最顶端的羽毛球，但是不拿）

```
// top 方法返回栈顶元素
this.top = function(){
    return items[items.length - 1];
};
```

top方法只是想查看一下最顶端的元素

- isEmpty 判断栈是否为空（看看羽毛球是不是都用完了）

```
// isEmpty返回栈是否为空
this.isEmpty = function(){
    return items.length == 0;
};
```
- size 返回栈里元素的个数（数一下桶里还有多少羽毛球）

```
// size方法返回栈的大小
this.size = function(){
    return items.length;
};
```
- clear 清空栈（把桶里的羽毛球都倒出来扔掉）

```
// clear 清空栈
this.clear = function(){
    items = []
}
```

最终完成版的代码如下

```
function Stack() {
    var items = [];  // 使用数组存储数据

    // push方法向栈里压入一个元素
    this.push = function(item){
        items.push(item);
    };
	// 获取数组
    this.get = function() {
        return items;
    }

    // pop方法把栈顶的元素弹出
    this.pop = function(){
        return items.pop();
    };

    // top 方法返回栈顶元素
    this.top = function(){
        return items[items.length - 1];
    };

    // isEmpty返回栈是否为空
    this.isEmpty = function(){
        return items.length == 0;
    };

    // size方法返回栈的大小
    this.size = function(){
        return items.length;
    };

    // clear 清空栈
    this.clear = function(){
        items = []
    }
}
```

### 被欺骗的错觉

看完上面的实现，难道你没有一种被欺骗的感觉么？传的那么神乎其神的数据结构，这里实现的栈，竟然就只是对数组做了一层封装而已啊！！！

只是做了一层封装么？请思考下面几个问题：

- 给你一个数组，你可以通过索引操作任意一个元素，但是给你一个栈，你能操作任意元素么？栈提供的方法只允许你操作栈顶的元素，也就是数组的最后一个元素，这种限制其实提供给我们一种思考问题的方式，这个方式也就是栈的特性，后进先出。

- 既然栈的底层实现其实就是数组，栈能做的事情，数组一样可以做啊，为什么弄出一个栈来，是不是多此一举？封装是为了隐藏实现细节，站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便，后面的练习题你将有所体会。

- 既然栈的底层就是对数组的操作，而你平时对数组的使用已经到了非常熟练的程度了，那么请问问自己，为什么就从来都没有自己实现过一个栈呢？是你此前不知道栈的这个概念，还是知道栈的概念但是不知道它有哪些具体方法？不论是哪一种情况，都表明栈对你来说是一个全新的知识，尽管底层的实现是那么的简单，可是越简单就越能说明问题，为啥，你自己就没想出栈这个东西？

## 栈的应用练习

通过两个练习题，你或许能够明白我前面所说的站在栈的肩膀上思考问题显然要比站在数组的肩膀上思考问题更方便。

### 合法括号
- 题目要求

下面的字符串中包含小括号，请编写一个函数判断字符串中的括号是否合法，所谓合法，就是括号成对出现

```
sdf(ds(ew(we)rw)rwqq)qwewe   合法
(sd(qwqw)sd(sd))             合法
()()sd()(sd()fw))(           不合法
```
- 思路分析

括号存在嵌套关系，也存在并列关系，如果是用数组存储这些括号，然后再想办法一对一对的抵消掉，似乎是一个可行的办法，可是如何判断一个左括号对应的是哪个右括号呢？站在数组的肩膀上思考这个问题，就陷入到一种无从下手的绝望之中。

现在，我们站在栈的肩膀上思考这个问题，解题的步骤就非常简单，我们可以使用for循环遍历字符串的每一个字符，对每个字符做如下的操作：

- 遇到左括号，就把左括号压如栈中

- 遇到右括号，判断栈是否为空，为空说明没有左括号与之对应，缺少左括号，字符串括号不合法，如果栈不为空，则把栈顶元素移除，这对括号抵消掉了

当for循环结束之后，如果栈是空的，就说明所有的左右括号都抵消掉了，如果栈里还有元素，则说明缺少右括号，字符串括号不合法。

- 示例代码

```
function is_leagl_brackets(string){
    var stack = new Stack();
    for(var i=0; i<string.length; i++ ){
        var item = string[i];
        if(item == "("){
            // 将左括号压入栈
            stack.push(item);
        }else if (item==")"){
            // 如果为空,就说明没有左括号与之抵消
            if(stack.isEmpty()){
                return false;
            }else{
                // 将栈顶的元素弹出
                stack.pop();
            }
        }

    }
    return stack.size() == 0;
};

console.log(is_leagl_brackets("()()))"));
console.log(is_leagl_brackets("sdf(ds(ew(we)rw)rwqq)qwewe"));
console.log(is_leagl_brackets("()()sd()(sd()fw))("));
```

- 小结

栈的底层是不是使用了数组这不重要，重要的是栈的这种后进先出的特性，重要的是你只能操作栈顶元素的的限制，一定要忽略掉栈的底层如何实现，而只去关心栈的特性。

我们在编辑文档时，包括写代码，经常进行回退的操作，control+z就可以了，那么你有没有想过，这其实就可以用栈来实现，每一步操作都放入到栈中，当你想回退的时候，就使用pop方法把栈顶元素弹出，于是得到了你之前的一步操作。

---

### 计算逆波兰表达式

- 题目要求

逆波兰表达式，也叫后序表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式，例如 (a+b)*(c+d)转换为ab+cd+*。

```
["4", "13", "5", "/", "+"] 等价于(4 + (13 / 5)) = 6
["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"] 等价于((10 * (6 / ((9 + 3) * -11))) + 17) + 5
```

请编写函数calc_exp(exp) 实现逆波兰表达式计算，exp的类型是数组。

- 思路分析

["4", "13", "5", "/", "+"] 就是一个数组，在数组层面上思考这个问题，遇到 / 时，把13 和 5 拿出来计算，然后把13 和 5 删除并把结果放入到4的后面，天哪，太复杂了，太笨拙了，我已经无法继续思考了。

如果是使用栈来解决这个问题，一切就那么的自然而简单，使用for循环遍历数组，对每一个元素做如下操作：

1. 如果元素不是 + - * / 中的某一个，就压入栈中

2. 如果元素是 + - * / 中的某一个，则从栈里连续弹出两个元素，并对这两个元素进行计算，将计算结果压入栈中

for循环结束之后，栈里只有一个元素，这个元素就是整个表达式的计算结果

- 示例代码

```
function calc_exp(arr) {
    var stack = new Stack();
    for(var i = 0, len = arr.length; i < len; i ++) {
        var item = arr[i];
        if (~['+', '-', '*', '/'].indexOf(item)) {
            // 注意这里需要用到后序表达式或中序表达式转换一下
            var v1 = stack.pop();
            var v2 = stack.pop();
            var exp_res = parseInt(eval(v2 + item + v1));
            stack.push(exp_res);
        } else {
            stack.push(item);
        }
    }
    return stack.pop();
}
console.log("-----------------------------------------");
console.log(calc_exp(["4", "13", "5", "/", "+"])); // 6
```

### 课后练习题

- 实现一个有min方法的栈

实现一个栈，除了常见的push，pop方法以外，提供一个min方法，返回栈里最小的元素，且时间复杂度为o(1)

- 思路分析

使用两个栈来存储数据，其中一个命名为data_stack,专门用来存储数据，另一个命名为min_stack，专门用来存储栈里最小的数据。

注意了，我接下来的分析过程非常重要，我希望你能多阅读几遍。

1. 我们要实现的是一个栈，除了常规的方法，还要有一个min方法，data_stack就是专门为常规方法而存在的，min_stack就是为了这个min方法而存在的。

2. 编程思想里有一个分而治之的思想，简单来说，就是分开想，分开处理。那么我们现在考虑data_stack，这个时候别管min方法，你就只关心data_stack，它就是一个普通的栈啊，没什么特别的，一个简单的栈你还不会么，就是push，pop那些方法，正常实现就可以了。

3. data_stack处理完了以后，再考虑min_stack，这个时候，你就别想data_stack了，只关心min_stack，它要存储栈里的最小值，我们先考虑边界情况，如果min_stack为空，这个时候，如果push进来一个数据，那这个数据一定是最小的，所以此时，直接放入min_stack即可。如果min_stack不为空，这个时候它的栈顶不正是栈的最小元素么，如果push进来的元素比栈顶元素还小，放入min_stack就好了，这样，min_stack的栈顶始终都是栈里的最小值。

- 示例代码:

```
function MinStack() {
    var data_stack = new Stack();
    var min_stack = new Stack();

    this.push = function(item) {
        data_stack.push(item);

        if (min_stack.isEmpty() || min_stack.top > item) {
            min_stack.push(item);
        } else {
            min_stack.push(min_stack.top());
        }
    }
    this.pop = function() {
        min_stack.pop();
        return data_stack.pop();
    }
    this.get = function() {
        return data_stack.get();
    }
    this.min = function() {
        return min_stack.top();
    }
}
var minstack = new MinStack();
minstack.push(3);
minstack.push(6);
minstack.push(8);
console.log(minstack.get()); // [3, 6, 8]
console.log(minstack.min()); // 3
minstack.push(2);
console.log(minstack.min()); // 3
```

### 使用栈，完成中序表达式转后序表达式

```
输入:["12","+", "3"]
输出:["12","3","+"]

输入:["(","1","+","(","4","+","5","+","3",")",
"-","3",")","+","(","9","+","8",")"]
输出:[ '1', '4', '5', '+', '3', '+', '+', '3', '-', '9', '8', '+', '+' ]

输入:['(', '1', '+', '(', '4', '+', '5', '+', '3',
')', '/', '4', '-', '3', ')', '+', '(', '6', '+', '8', ')', '*', '3']
输出:['1', '4', '5', '+', '3', '+', '4',
'/', '+', '3', '-', '6', '8', '+', '3', '*', '+']
```

- 思路分析

定义数组postfix_lst，用于存储后序表达式，遍历中序表达式，对每一个遍历到的元素做如处理:

1. 如果是数字,直接放入到postfix_lst中

2. 遇到左括号入栈

3. 遇到右括号,把栈顶元素弹出并放入到postfix_lst中,直到遇到左括号，最后弹出左括号

4. 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符， 把弹出的运算符加入到postfix_lst，当前的运算符入栈

5. for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中

```
// 定义运算符的优先级
var priority_map = {
    "+": 1,
    "-": 1,
    "*": 2,
    "/": 2};

function infix_exp_2_postfix_exp(exp){
    var stack = new Stack();

    var postfix_lst = [];
    for(var i = 0;i<exp.length;i++){
        var item = exp[i];
        // 如果是数字,直接放入到postfix_lst中
        if(!isNaN(item)){
            postfix_lst.push(item);
        }else if (item == "("){
            // 遇到左括号入栈
            stack.push(item);
        }else if (item == ")"){
            // 遇到右括号,把栈顶元素弹出,直到遇到左括号
            while(stack.top() != "("){
                postfix_lst.push(stack.pop());
            }
            stack.pop();   // 左括号出栈
        }else{
            // 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符
            while(!stack.isEmpty() && ["+", "-", "*", "/"].indexOf(stack.top()) >= 0 && priority_map[stack.top()] >= priority_map[item]){
                // 把弹出的运算符加入到postfix_lst
                postfix_lst.push(stack.pop());
            }
            // 当前的运算符入栈
            stack.push(item);
        }

    }

    // for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中
    while(!stack.isEmpty()) {
        postfix_lst.push(stack.pop())
    }

    return postfix_lst
};


// 12+3
console.log(infix_exp_2_postfix_exp(["12","+", "3"]))
// 2-3+2
console.log(infix_exp_2_postfix_exp(["2","-", "3", "+", "2"]))
// (1+(4+5+3)-3)+(9+8)
var exp = ["(","1","+","(","4","+","5","+","3",")","-","3",")","+","(","9","+","8",")"];
console.log(infix_exp_2_postfix_exp(exp))

// (1+(4+5+3)/4-3)+(6+8)*3
var exp = ['(', '1', '+', '(', '4', '+', '5', '+', '3', ')', '/', '4', '-', '3', ')', '+', '(', '6', '+', '8', ')', '*', '3']
console.log(infix_exp_2_postfix_exp(exp))

console.log(infix_exp_2_postfix_exp(["12","+", "3","*", "5"]))
console.log(infix_exp_2_postfix_exp(["12","*", "3","+", "5"]))
```

- 算法思路推理过程

推理的过程要从简入繁，先考虑最简单的情况

- 只有一个运算符

```
中序: 1 + 2
后序: 1 2 +
```

后序表达式，数值在前，操作符在后，因此，遇到数值时直接放入到后序表达式中。将操作符放入栈中，等到中序表达式遍历结束后，将栈里的操作符弹出放入到后序表达式中

- 多个运算符，栈顶操作符优先级和当前运算符相同

多个运算符，似乎也可以像第一步推理中那样操作，但实际不行

```
中序: 1 + 2 - 3
后序: 1 2 + 3 -
```

每次遇到操作符时，如果栈里有操作符，说明前面有需要计算的数值，且计算的操作符就在栈顶，应该弹出放入到后缀表达式中，如果都等到中缀表达式结束再弹出，就会变成 1 2 3 + -

就本示例而言，遇到减号时，后缀表达式里是 1 2 ，栈里是+，1和2需要计算，进行计算的操作符就在栈顶，因此需要弹出，放入到后缀表达式，之后减号入栈，中缀表达式遍历结束后，后缀表达式是 1 2 + 3， 栈里是-，将栈里的操作符去全部弹出，放入到后缀表达式，最终结果为 1 2 + 3 -。

```
中序: 1 * 2 + 3
后序: 1 2 * 3 +
```

栈顶运算符优先级高，和第2步的分析一致，前面有需要计算的数值，应该弹出放入到后缀表达式中

- 多个运算符，栈顶操作符优先级大于当前运算符相同

```
中序: 1 + 2 * 3
后序: 1 2 3 * +
```

栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算

- 多个运算符，栈顶操作符优先级小于当前运算符相同

```
中序: 1 + 2 * 3
后序: 1 2 3 * +
```

栈顶运算符优先级低，说明还不能进行计算，要继续压栈，压栈后，高优先级操作符在栈顶，出栈的时候先出，保证2*3先被计算

- 有括号的情况

括号里的的表达式可以视为一个独立的中缀表达式，因此，前面4步的分析都适用，但是括号里的中缀表达式在一个更大的表达式中，因此需要与其他部分分隔，分隔的方法就是遇到小括号后压栈，此后的操作遵循前面的推理逻辑，当遇到右括号时，说明括号内的表达式结束了，根据第一步的分析，应该把所有属于这个括号内表达式的操作符都弹出来放入到后缀表达式，最后一步弹出左括号。

**还在学习ing...，学习后再补充**

# 数据结构之----队列
## 队列的定义
## 队列的实现
### 数据存储
### 队列的方法
- enqueue方法
- dequeue方法
- head方法
- size方法
- clear方法
- isEmpty方法
- tail方法
## 队列的应用练习
### 约瑟夫环（普通模式）
- 题目要求
- 思路分析
- 示例代码
### 斐波那契数列（普通模式）
- 题目要求
- 思路分析
- 示例代码
- 小结
### 用队列实现栈（困难模式）
- 题目要求
- 思路分析
- 代码示例
### 打印杨辉三角（困难模式）
- 题目要求
- 思路分析
- 示例代码
## 课后作业
### 用两个栈实现一个队列（普通模式）
- 思路分析
- 思路分析
### 迷宫问题（地狱模式）
- 题目要求
- 思路分析
- 示例代码
# 数据结构之----链表
## 链表的定义
### 节点
### 首尾节点
### 有头链表和无头链表
### 猴子捞月
## 链表的实现
### 定义链表类
### 链表的方法
- append方法
- print方法
- insert方法
- remove方法
- get方法
- indexOf方法
## 基于链表实现的Stack 和 Queue
## 链表常见面试题
### 翻转链表（困难模式）
- 题目要求
- 迭代翻转思路分析
- 递归翻转链表思路分析
### 从尾到头打印链表（普通模式）
- 题目要求
- 思路分析
- 示例代码
### 合并两个两个有序链表(困难模式)
- 题目要求
- 思路分析
- 示例代码
## 课后作业
### 查找单链表中的倒数第K个节点（k > 0）（普通模式）
### 查找单链表的中间结点（普通模式）
### 实现双向链表（地狱模式）
# 数据结构之----BitMap
## 一个简单的问题
### 毫无难度的实现
### 更快的方法
### 更节省空间的算法
## 街边的路灯
## 位运算
### 按位与 &
### 按位或 |
### 左移 <<
### 小试牛刀
## bitmap
###  新的实现方式
### 概念
### 大数据排序
## 布隆过滤器
### 概念
### hash函数
### BoolmFilter 类
- 操作二进制位
- add方法
- isExist方法
## 课后练习题
### 两个集合取交集（普通模式）
- 示例代码
### 支持负数（困难模式）
- 思路分析
- 示例代码
### 查找不重复的数（地狱模式）
- 思路分析
- 示例代码
# 数据结构之----树
## 概念介绍
###结构
###节点
###节点的度
###叶节点
###分支节点
###子女节点
### 父节点
### 兄弟节点
### 祖先节点
### 子孙节点
### 节点所在层次
### 树的深度
### 树的高度
### 树的度
### 有序树
### 无序树
### 森林
## 二叉树
### 二叉树的性质
### 特殊二叉树
- 满二叉树
- 完全二叉树
### 二叉树的类定义
- 定义节点
- 定义二叉树类
- init_tree
- in_order 中序遍历算法
- pre_order 前序遍历算法
- post_order 后序遍历算法
- size 返回节点数量
- height 返回树的高度
- 查找节点
### 练习题
- 求一棵树的镜像(普通模式)
	- 思路分析
	- 示例代码
- 使用非递归方式实现前序遍历
	- 思路分析
	- 示例代码
### 课后练习题
- 使用非递归方式实现中，后两种遍历方法（普通模式+）
- 寻找两个节点的最近公共祖先（困难模式）
- 分层打印二叉树（困难模式+）
- 输出指定层的节点个数（困难模式+）