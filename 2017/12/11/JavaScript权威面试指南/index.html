<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">










  <meta name="google-site-verification" content="true">







  <meta name="baidu-site-verification" content="true">











<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="这篇文章的目的是汇集 JavaScript 相关概念。有了这篇文章，你就可以在一个地方温故一下你需要了解的关于 JavaScript 的所有知识点。">
<meta name="keywords" content="Javascript 概念 理论">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript概念整理">
<meta property="og:url" content="http://www.icrazyman.cn/2017/12/11/JavaScript权威面试指南/index.html">
<meta property="og:site_name" content="科瑞兹曼的博客">
<meta property="og:description" content="这篇文章的目的是汇集 JavaScript 相关概念。有了这篇文章，你就可以在一个地方温故一下你需要了解的关于 JavaScript 的所有知识点。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-12-11T14:47:46.836Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript概念整理">
<meta name="twitter:description" content="这篇文章的目的是汇集 JavaScript 相关概念。有了这篇文章，你就可以在一个地方温故一下你需要了解的关于 JavaScript 的所有知识点。">



  <link rel="alternate" href="/atom.xml" title="科瑞兹曼的博客" type="application/atom+xml">




  <link rel="canonical" href="http://www.icrazyman.cn/2017/12/11/JavaScript权威面试指南/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript概念整理 | 科瑞兹曼的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">科瑞兹曼的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注于前端开发技术</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
    
  
  

  

  <article class="post post-type-normal true" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.icrazyman.cn/2017/12/11/JavaScript权威面试指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="科瑞兹曼">
      <meta itemprop="description" content="交流、学习、提升">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科瑞兹曼的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript概念整理

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-11 22:44:18 / 修改时间：22:47:46" itemprop="dateCreated datePublished" datetime="2017-12-11T22:44:18+08:00">2017-12-11</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/12/11/JavaScript权威面试指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/12/11/JavaScript权威面试指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2017/12/11/JavaScript权威面试指南/" class="leancloud_visitors" data-flag-title="JavaScript概念整理">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>这篇文章的目的是汇集 JavaScript 相关概念。有了这篇文章，你就可以在一个地方温故一下你需要了解的关于 JavaScript 的所有知识点。</p>
</blockquote>
<a id="more"></a>
<h1 id="类型及其转换"><a href="#类型及其转换" class="headerlink" title="类型及其转换"></a>类型及其转换</h1><p>JavaScript 内置了7种类型：<code>null</code>, <code>undefined</code> , <code>boolean</code>, <code>number</code>, <code>string</code>, <code>object</code>以及 <code>symbol (ES6)</code>.</p>
<p>除了 object 以外，这几种类型都可以归类为<strong>原始类型（基本类型）</strong>。</p>
<pre><code>typeof 0              // number
typeof true           // boolean
typeof &#39;Hello&#39;        // string
typeof Math           // object
typeof null           // object  !!
typeof Symbol(&#39;Hi&#39;)   // symbol (New ES6) 

</code></pre><ul>
<li>Null 与 Undefined</li>
</ul>
<p><code>Undefined</code> 表示尚未定义。它被用作表示未初始化变量，未提供的函数参数，对象缺少的属性的默认值。当函数没有返回值时也会默认返回 undefined .</p>
<p><code>Null</code> 则表示空值。它可以被赋值给一个变量来表示的“没有值”。</p>
<ul>
<li>隐式类型转换</li>
</ul>
<p>让我们来看下面这个栗子：</p>
<pre><code>var name = &#39;Joey&#39;;
if (name) {
  console.log(name + &quot; doesn&#39;t share food!&quot;)  // Joey doesn’t share food!
} 
</code></pre><p>在这种情况下，字符串变量 <code>name</code> 会被转换为 <code>true</code> ，所以我们能够在命令行里输出这段话。那我们到底要如何确定这些真假值的转换呢？</p>
<p>Falsy 类型的值是指在强制类型转换时会被转换为布尔 <code>false</code> 的值。</p>
<p>Falsy 类型值包括：<code>&quot;&quot;</code>, <code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>false</code>.</p>
<p>除了 Falsy 类型值以外的都被称为 truthy 类型值，它们会被转换为 <code>true</code>.</p>
<pre><code>Boolean(null)         // false
Boolean(&#39;hello&#39;)      // true 
Boolean(&#39;0&#39;)          // true 
Boolean(&#39; &#39;)          // true 
Boolean([])           // true 
Boolean(function(){}) // true 
</code></pre><p>没错。你可能注意到了。空的数组，对象和函数布尔值也会被转换为 <code>true</code> ！</p>
<ul>
<li>String &amp; Number 运算</li>
</ul>
<p>你需要注意的第一件事是 + 操作符。这是一个棘手的操作符，因为它同时适用于数值运算和字符串连接。</p>
<p>但是，<code>*</code>，<code>/</code>和<code>-</code>操作符都是数字运算专用的。当这些运算符与字符串一起使用时，会强制转换字符串为数字类型的值。</p>
<pre><code>1 + &quot;2&quot; = &quot;12&quot;
&quot;&quot; + 1 + 0 = &quot;10&quot;
&quot;&quot; - 1 + 0 = -1
&quot;-9\n&quot; + 5 = &quot;-9\n5&quot;
&quot;-9\n&quot; - 5 = -14
&quot;2&quot; * &quot;3&quot; = 6
4 + 5 + &quot;px&quot; = &quot;9px&quot;
&quot;$&quot; + 4 + 5 = &quot;$45&quot;
&quot;4&quot; - 2 = 2
&quot;4px&quot; - 2 = NaN
null + 1 = 1
undefined + 1 = NaN 
</code></pre><ul>
<li>== 与 ===</li>
</ul>
<p>对此大多数人的理解肯定是 <code>==</code> 只比较值相等，而 <code>===</code> 在比较的同时还会检查类型。不过这种解释其实是错误的。</p>
<p>事实上，<code>==</code> 是比较强制类型转换之后的结果，而 <code>===</code> 则是直接比较。</p>
<pre><code>2 == &#39;2&#39;            // True
2 === &#39;2&#39;           // False
undefined == null   // True
undefined === null  // False 
</code></pre><p>强制类型转换有时候会造成一些混乱，我们来看下面这个栗子：</p>
<pre><code>let a = &#39;0&#39;;
console.log(Boolean(a)); // True
let b = false;
console.log(Boolean(b)); // False 
</code></pre><p>好，根据以上结果，请告诉我下面这此比较的输出：</p>
<pre><code>console.log(a == b); //(1) 
</code></pre><p>上述代码事实上返回了 True，那么这是为什么呢？</p>
<p>在 JavaScript 的机制中，当你拿一个其它类型的值和 <code>boolean</code> 类型进行比较时，JavaScript 会将这个布尔值转换为 <code>number</code> 类型再进行比较。（2）</p>
<p>此时这个问题就变成了 <code>number</code> 和 <code>string</code> 类型值之间的比较。根据我们之前所说的，JavaScript 会把 <code>string</code> 类型转换为 <code>number</code> 类型再比较两个数字。（3）</p>
<p>所以最后的表达式被转换为了 <code>0 == 0</code>，结果理所当然是 True.</p>
<pre><code>&#39;0&#39; == false   //(1)
&#39;0&#39; == 0       //(2)
 0  == 0       //(3) 
</code></pre><p>如果你想全面理解这种比较是如何进行的，可以查阅ES5文档。</p>
<p>这里也有一个 JavaScript 当中各种类型值对比结果的参照表。</p>
<p>下面是一些特殊比较的示例：</p>
<pre><code>false == &quot;&quot;  // true
false == []  // true
false == {}  // false
&quot;&quot; == 0      // true
&quot;&quot; == []     // true
&quot;&quot; == {}     // false
0 == []      // true
0 == {}      // false
0 == null    // false 
</code></pre><h1 id="赋值与引用"><a href="#赋值与引用" class="headerlink" title="赋值与引用"></a>赋值与引用</h1><p>简单值（或者称为原始值 primitives）均是 <code>null</code>, <code>undefined</code> , <code>boolean</code>, <code>number</code>, <code>string</code>, 以及 <code>symbol (ES6)</code>类型的赋值。</p>
<p>复合值则是对 <code>object</code>，包含 <code>array</code> 以及 <code>function</code> 在内的引用。</p>
<pre><code>var a = 2;        // &#39;a&#39; hold a copy of the value 2.
var b = a;        // &#39;b&#39; is always a copy of the value in &#39;a&#39;
b++;
console.log(a);   // 2
console.log(b);   // 3
var c = [1,2,3];
var d = c;        // &#39;d&#39; is a reference to the shared value
d.push( 4 );      // Mutates the referenced value (object)
console.log(c);   // [1,2,3,4]
console.log(d);   // [1,2,3,4]
/* Compound values are equal by reference */
var e = [1,2,3,4];
console.log(c === d);  // true
console.log(c === e);  // false 
</code></pre><p>当你想要复制一份复合值的时候，你需要通过一些方法对其进行<strong>拷贝</strong>（这里区分浅拷贝及深拷贝）。这样引用才不会指向同一个值：</p>
<pre><code>const copy = c.slice()    // &#39;copy&#39; references to a new value
console.log(c);           // [1,2,3,4]
console.log(copy);        // [1,2,3,4]
console.log(c === copy);  // false 
</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是指代码执行时的上下文，它定义了变量以及函数生效的范围。</p>
<p><strong>全局作用域</strong>指的是最外层的作用域。所有在函数外部声明的变量都会在全局作用域当中，可以在任何地方访问到。在浏览器当中，window 对象就属于全局作用域。</p>
<p><strong>局部作用域</strong>是指例如在某个函数内部的范围。在局部作用域中声明的变量只能够在其内部被访问到。</p>
<pre><code>function outer() {
  let a = 1;
  function inner() {
    let b = 2;
    function innermost() {
      let c = 3;
      console.log(a, b, c);   // 1 2 3
    }
    innermost();
    console.log(a, b);        // 1 2 — &#39;c&#39; is not defined
  }
  inner();
  console.log(a);             // 1 — &#39;b&#39; and &#39;c&#39; are not defined
}
outer(); 
</code></pre><p>为了便于理解，你可以把作用域想象为一扇扇从大到小排列的门。最矮的人（上述代码1，2，3表示高矮）可以进入最小的门（innermost 的作用域），同时也能通过最大的门（outer 的作用域）。</p>
<p>而个子高的人在通过门时则会被卡住（也就是在外部访问不到内部定义的变量）。</p>
<h1 id="变量提升-Hoisting"><a href="#变量提升-Hoisting" class="headerlink" title="变量提升 Hoisting"></a>变量提升 Hoisting</h1><p>在编译过程中，JavaScript 会自动把 <code>var</code> 和 <code>function</code> 声明移动到顶部的行为被称为 <strong>hoisting</strong>.</p>
<p>函数声明会被完整地提升。这就意味着你在编写代码时可以在声明一个函数之前就调用它：</p>
<pre><code>console.log(toSquare(3));  // 9

function toSquare(n){
  return n*n;
} 
</code></pre><p>变量只会被部分提升。例如只有 <code>var</code> 的声明会被提升，而赋值则不会。</p>
<p><code>let</code> 以及 <code>const</code> 也不会被提升。</p>
<pre><code>{  /* Original code */
  console.log(i);  // undefined
  var i = 10
  console.log(i);  // 10
}

{  /* Compilation phase */
  var i;
  console.log(i);  // undefined
  i = 10
  console.log(i);  // 10
}
// ES6 let &amp; const
{
  console.log(i);  // ReferenceError: i is not defined
  const i = 10
  console.log(i);  // 10
}
{
  console.log(i);  // ReferenceError: i is not defined
  let i = 10
  console.log(i);  // 10
} 
</code></pre><h1 id="函数表达式-与-函数声明"><a href="#函数表达式-与-函数声明" class="headerlink" title="函数表达式 与 函数声明"></a>函数表达式 与 函数声明</h1><ul>
<li>函数表达式</li>
</ul>
<p>函数表达式只有被执行之后才可用，它不会被提升（相当于赋值函数表达式给变量）。</p>
<pre><code>var sum = function(a, b) {
  return a + b;
} 
</code></pre><ul>
<li>函数声明</li>
</ul>
<p>函数声明则可以在定义前后被任意调用，因为它最终会被提升。</p>
<pre><code>function sum(a, b) {
  return a + b;
}
</code></pre><h1 id="变量声明方式：var-let-cost"><a href="#变量声明方式：var-let-cost" class="headerlink" title="变量声明方式：var let cost"></a>变量声明方式：var let cost</h1><p>在 ES6 之前，只有 <code>var</code> 一种声明变量的方法。在某一函数内部声明的变量和方法只能在其函数作用域内部访问到。</p>
<p>一些在例如 <code>if</code> 或者 <code>for</code> 语句的块作用域内声明的变量，能够在其包含的大括号外被访问到。</p>
<p>注意：未使用 <code>var</code>，<code>let</code> 或 <code>const</code> 关键字声明的变量会自动变成全局变量。</p>
<pre><code>function greeting() {
  console.log(s) // undefined
  if(true) {
    var s = &#39;Hi&#39;;
    undeclaredVar = &#39;I am automatically created in global scope&#39;;
  }
  console.log(s) // &#39;Hi&#39;
}
console.log(s);  // Error — ReferenceError: s is not defined
greeting();
console.log(undeclaredVar) // &#39;I am automatically created in global scope&#39; 
</code></pre><p>ES6 中我们有了 <code>let</code> 和 <code>const</code> 这两个新的关键字。它们不会被提升，且可以在块级作用域内生效：</p>
<pre><code>let g1 = &#39;global 1&#39;
let g2 = &#39;global 2&#39;
{   /* Creating a new block scope */
  g1 = &#39;new global 1&#39;
  let g2 = &#39;local global 2&#39;
  console.log(g1)   // &#39;new global 1&#39;
  console.log(g2)   // &#39;local global 2&#39;
  console.log(g3)   // ReferenceError: g3 is not defined
  let g3 = &#39;I am not hoisted&#39;;
}
console.log(g1)    // &#39;new global 1&#39;
console.log(g2)    // &#39;global 2&#39; 
</code></pre><p>另外有一个普遍的误解是 <code>const</code> 是不可变的。事实上它只是不能被重新赋值，但其指向的值是可以被操作的：</p>
<pre><code>const tryMe = &#39;initial assignment&#39;;
tryMe = &#39;this has been reassigned&#39;;  // TypeError: Assignment to constant variable.
// You cannot reassign but you can change it…
const array = [&#39;Ted&#39;, &#39;is&#39;, &#39;awesome!&#39;];
array[0] = &#39;Barney&#39;;
array[3] = &#39;Suit up!&#39;;
console.log(array);     // [“Barney”, “is”, “awesome!”, “Suit up!”]
const airplane = {};
airplane.wings = 2;
airplane.passengers = 200;
console.log(airplane);   // {passengers: 200, wings: 2} 
</code></pre><h1 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包 Closure"></a>闭包 Closure</h1><p>闭包是一个函数及其词法环境的组合。闭包可以让我们在一个函数的作用范围外访问其内部的变量。</p>
<pre><code>function sayHi(name){
  var message = `Hi ${name}!`;
  function greeting() {
    console.log(message)
  }
  return greeting
}
var sayHiToJon = sayHi(&#39;Jon&#39;);
console.log(sayHiToJon)     // ƒ() { console.log(message) }
console.log(sayHiToJon())   // &#39;Hi Jon!&#39; 
</code></pre><ol>
<li>获取变量到外部作用域。</li>
</ol>
<p>返回的 <code>greeting</code> 方法访问了其内部作用域的 <code>message</code> 变量。</p>
<ol start="2">
<li>即使在外部函数返回之后也能访问到作用域外的变量。</li>
</ol>
<p><code>sayHiToJon</code> 是在调用 <code>sayHi</code> 方法时对 <code>greeting</code> 的引用。这样我们就能够通过 <code>greeting</code> 访问到作用域外的 <code>message</code> 变量。</p>
<p>闭包比较有用的地方在于我们可以用它来实现<strong>数据封装</strong>。有一些理念认为，有些数据不应该直接暴露在外，我们举个栗子来说明：</p>
<p>例如在下面这段代码当中，我们只能过通过 <code>elementary</code> 的实例来访问和操作 <code>SpringfieldSchool</code> 内部的 <code>staff</code> 变量，而不用担心其在其他地方被改动。</p>
<pre><code>function SpringfieldSchool() {
  let staff = [&#39;Seymour Skinner&#39;, &#39;Edna Krabappel&#39;];
  return {
    getStaff: function() { console.log(staff) },
    addStaff: function(name) { staff.push(name) }
  }
}

let elementary = SpringfieldSchool()
console.log(elementary)        // { getStaff: ƒ, addStaff: ƒ }
console.log(staff)             // ReferenceError: staff is not defined
/* Closure allows access to the staff variable */
elementary.getStaff()          // [&quot;Seymour Skinner&quot;, &quot;Edna Krabappel&quot;]
elementary.addStaff(&#39;Otto Mann&#39;)
elementary.getStaff()          // [&quot;Seymour Skinner&quot;, &quot;Edna Krabappel&quot;, &quot;Otto Mann&quot;] 
</code></pre><p>我们接着再来用闭包解决一个面试中最常见的问题吧：</p>
<p>下面这段代码存在什么问题？如何输出我们想要的结果？</p>
<pre><code>const arr = [10, 12, 15, 21];
for (var i = 0; i &lt; arr.length; i++) {
  setTimeout(function() {
    console.log(`The value ${arr[i]} is at index: ${i}`);
  }, (i+1) * 1000);
} 
</code></pre><p>这段代码执行的输出结果中，每次 <code>i</code> 都等于4.这是因为 <code>setTimeout</code> 方法执行的时候，循环早已运行结束。</p>
<p>我们可以通过立即执行函数 IIFE 来解决这个问题，它可以创建出独立的作用域来存储每次传入 <code>i</code> 的值。</p>
<pre><code>const arr = [10, 12, 15, 21];
for (var i = 0; i &lt; arr.length; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(`The value ${arr[j]} is at index: ${j}`);
    }, j * 1000);
  })(i)
} 
</code></pre><p>另外一个更简洁的答案是使用 <code>let</code> 关键字来声明变量 <code>i</code>，也能够得到相同的结果：</p>
<pre><code>const arr = [10, 12, 15, 21];
for (let i = 0; i &lt; arr.length; i++) {
  setTimeout(function() {
    console.log(`The value ${arr[i]} is at index: ${i}`);
  }, (i) * 1000);
}
</code></pre><h1 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式 IIFE"></a>立即执行函数表达式 IIFE</h1><p>正如其名，立即执行函数在定义时就会被执行。我们通常在创建一个新的变量作用域时使用到它。</p>
<p>表达式外的括号用来和函数声明作以区分。</p>
<p>结尾的括号表示对函数的调用。</p>
<pre><code>var result = [];
for (var i=0; i &lt; 5; i++) {
  result.push( function() { return i } );
}
console.log( result[1]() ); // 5
console.log( result[3]() ); // 5
result = [];
for (var i=0; i &lt; 5; i++) {
  (function () {
    var j = i; // copy current value of i
    result.push( function() { return j } );
  })();
}
console.log( result[1]() ); // 1
console.log( result[3]() ); // 3 
</code></pre><p>通过使用IIFE你可以：</p>
<ul>
<li><p>使你能过添加私有数据到一个方法中</p>
</li>
<li><p>创建新的作用环境</p>
</li>
<li><p>防止污染全局命名空间</p>
</li>
</ul>
<h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>上下文的概念经常会同作用域之间混淆。为了保持条理清晰，我们需要注意以下两条：</p>
<ul>
<li>上下文是在函数被调用时确定的。它通常指的是你的代码当中某一部分的值。</li>
<li></li>
<li>作用域值的则是变量能过被访问到的范围。</li>
</ul>
<pre><code>// 作用域
var param = 1;      // global scope
function myScope(){
    var param = 2;     // local scope
}
// 上下文
this.prop = 1;      // global context
function myContext(){
    this.prop = 2;   // local context
}
var myInstance = new myContext(); 
</code></pre><p>例如上述实例当中调用 <code>this</code> 的位置不同，<code>this</code> 的指向也是不同的，也就表示着不同的上下文；而作用域则是我们在编写代码时使用 <code>var</code> 关键字来确定的。</p>
<h1 id="函数调用方式：call-apply-bind"><a href="#函数调用方式：call-apply-bind" class="headerlink" title="函数调用方式：call apply bind"></a>函数调用方式：call apply bind</h1><p>这三种方法可以改变函数调用时 <code>this</code> 的指向，区别则在于函数调用的时候。</p>
<ul>
<li><p><code>.call()</code> 会立即调用函数，并要求你按次序一个个传入参数。</p>
</li>
<li><p><code>.apply()</code> 也会立即调用函数，不过你需要以数组的形式传参。</p>
</li>
<li><p><code>.call()</code> 和 <code>.apply()</code> 效用几乎是相同的，它们都可以用来调用对象中的某个方法，具体怎么使用取决于你的使用场景里如何传参更方便。</p>
</li>
</ul>
<p>应用示例：</p>
<pre><code>const Snow = {surename: &#39;Snow&#39;}
const char = {
  surename: &#39;Stark&#39;,
  knows: function(arg, name) {
    console.log(`You know ${arg}, ${name} ${this.surename}`);
  }
}
char.knows(&#39;something&#39;, &#39;Bran&#39;);              // You know something, Bran Stark
char.knows.call(Snow, &#39;nothing&#39;, &#39;Jon&#39;);      // You know nothing, Jon Snow
char.knows.apply(Snow, [&#39;nothing&#39;, &#39;Jon&#39;]);   // You know nothing, Jon Snow 
</code></pre><p>注意： 如果你在使用 <code>.call()</code> 时传入了数组形式的参数，它会把整个数组当作一个参数使用。</p>
<p>不过在 ES6 里你倒是可以试试展开操作符的方法进行传参：</p>
<pre><code>char.knows.call(Snow, ...[&quot;nothing&quot;, &quot;Jon&quot;]);  // You know nothing, Jon Snow 
</code></pre><p><code>.bind()</code> 不会直接触发某个方法，而是根据你传入的参数和上下文返回一个新的方法。当你想要在程序之后的某些上下文环境中调用一个方法时可以使用 <code>.bind()</code> 这种方式。</p>
<p>这在我们使用一些异步操作或者事件处理函数时非常有用。<code>.bind()</code> 的传参形式则类似于 <code>.call()</code> 你需要讲参数以逗号分隔传入：</p>
<pre><code>const Snow = {surename: &#39;Snow&#39;}
const char = {
  surename: &#39;Stark&#39;,
  knows: function(arg, name) {
    console.log(`You know ${arg}, ${name} ${this.surename}`);}
  }
const whoKnowsNothing = char.knows.bind(Snow, &#39;nothing&#39;);
whoKnowsNothing(&#39;Jon&#39;);  // You know nothing, Jon Snow 
</code></pre><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>JavaScript 当中的 <code>this</code> 理解起来算比较复杂的。</p>
<p><code>this</code> 具体指向什么是由函数的执行上下文决定的（其实上一节已经有很多栗子了）。</p>
<p>关键字 <code>this</code> 类似于一个占位符。它会指向具体调用某个方法的对象。</p>
<p>下面这个检查表用来确定 <code>this</code> 的顺位规则：</p>
<ul>
<li><strong>new binding</strong> 当使用 <code>new</code> 关键字调用某个函数时，<code>this</code> 会被绑定到新构造的对象上。</li>
</ul>
<pre><code>function Person(name, age) {
  this.name = name;
  this.age =age;
  console.log(this);
}
const Rachel = new Person(&#39;Rachel&#39;, 30);   // { age: 30, name: &#39;Rachel&#39; } 
</code></pre><ul>
<li><strong>显式绑定</strong> 当使用 <code>call</code> 或者 <code>apply</code> 方法调用函数时，<code>this</code> 会指向我们传入的对象。<code>bind</code> 我们在前面已经介绍过了，返回的是一个新的函数而不是直接调用。</li>
</ul>
<pre><code>function fn() {
  console.log(this);
}
var agent = {id: &#39;007&#39;};
fn.call(agent);    // { id: &#39;007&#39; }
fn.apply(agent);   // { id: &#39;007&#39; }
var boundFn = fn.bind(agent);
boundFn();         // { id: &#39;007&#39; } 
</code></pre><ul>
<li><strong>隐式绑定</strong> 当我们在某一具体上下文中调用一个函数时，<code>this</code> 会指向这个函数所属的对象。</li>
</ul>
<pre><code>var building = {
  floors: 5,
  printThis: function() {
    console.log(this);
  }
}
building.printThis();  // { floors: 5, printThis: function() {…} } 
</code></pre><ul>
<li><strong>默认绑定</strong> 如果函数在调用时不遵从上述所有规则，那么 <code>this</code> 会被绑定在全局对象上（在浏览器里，这个全局对象就是 <code>window</code>）。</li>
</ul>
<p>这种情况会在我们定义独立函数时出现，如果一个函数在定义时不属于任何对象，它就会默认成为全局对象的一个属性。</p>
<pre><code>function printWindow() {
  console.log(this)
}
printWindow();  // window object 
</code></pre><p>注意： 即使是在不同的作用域下，调用这种独立函数也不会改变其 <code>this</code> 的指向：</p>
<pre><code>function Dinosaur(name) {
  this.name = name;
  var self = this;
  inner();
  function inner() {
    alert(this);        // window object — the function has overwritten the &#39;this&#39; context
    console.log(self);  // {name: &#39;Dino&#39;} — referencing the stored value from the outer context
  }
}
var myDinosaur = new Dinosaur(&#39;Dino&#39;); 
</code></pre><ul>
<li><strong>语法绑定</strong> 当你以 <code>=&gt;</code> 箭头函数的形式调用某一方法时，相当于为其传入了当前执行上下文的 <code>this</code> 值。</li>
</ul>
<pre><code>function Cat(name) {
  this.name = name;
  console.log(this);   // { name: &#39;Garfield&#39; }
  ( () =&gt; console.log(this) )();   // { name: &#39;Garfield&#39; }
}
var myCat = new Cat(&#39;Garfield&#39;); 
</code></pre><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>我们可以通过使用<code>&quot;use strict&quot;</code>指令来启用 JavaScript 的严格模式。它会为你的代码添加更多的限制及错误处理。</p>
<p>使用严格模式的好处有：</p>
<ul>
<li><p>更方便调试 你能够看到更多的报错，例如在你试图为只读的全局对象或属性赋值时。</p>
</li>
<li><p>防止意外产生全局变量 对未声明的变量进行赋值时会报错。</p>
</li>
<li><p>禁止无效的删除操作 尝试删除变量、函数、不可删除的属性时会报错。</p>
</li>
<li><p>禁止重复的属性名及参数 如果有命名重复的属性名或者参数值就会报错。</p>
</li>
<li><p>让 eval() 的调用更加安全 在 eval() 方法内部定义的变量及函数不会污染其他作用域。</p>
</li>
<li><p>禁止 this 指向全局对象 当 this 的值为 null 或者 undefined 时不会再默认指向到全局对象。这也就意味着在函数内部的 this 不会再默认指向 window 对象了。</p>
</li>
</ul>
<h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><p>关键字 <code>new</code> 是一种非常特殊的调用函数的方法，被通过 <code>new</code> 关键字调用的函数被称为<strong>构造函数</strong>。</p>
<p>所以 <code>new</code> 到底进行了哪些操作呢？</p>
<ul>
<li><p>创建了一个新的对象。</p>
</li>
<li><p>新对象的原型继承自构造函数的原型。</p>
</li>
<li><p>以新对象的 <code>this</code> 执行构造函数。</p>
</li>
<li><p>返回新的对象。如果构造函数返回了一个对象，那么这个对象会取代整个 <code>new</code> 出来的结果。</p>
</li>
</ul>
<pre><code>// In order to better understand what happens under the hood, lets build the new keyword 
function myNew(constructor) {
  var obj = {}
  Object.setPrototypeOf(obj, constructor.prototype);
  return constructor.apply(obj, [...arguments].slice(1)) || obj
} 
</code></pre><p>那么在调用函数时使用 <code>new</code> 关键字与否到底有什么区别呢？</p>
<pre><code>function Bird() {
  this.wings = 2;
}
/* invoking as a normal function */
let fakeBird = Bird();
console.log(fakeBird);    // undefined
/* invoking as a constructor function */
let realBird= new Bird();
console.log(realBird)     // { wings: 2 } 
</code></pre><h1 id="原型与继承"><a href="#原型与继承" class="headerlink" title="原型与继承"></a>原型与继承</h1><p>原型是 JavaScript 当中最容易造成困惑的一个概念。原因之一是因为<strong>原型</strong>这个词会在两个语境下使用：</p>
<ul>
<li>原型关系</li>
</ul>
<p>每个对象都有自己的原型对象，并会继承它原型的所有属性。</p>
<p>你可以通过 <code>.__proto__</code> 这种非标准的机制来获取一个对象的原型（在ES6中，在 ES5 标准里还可以通过 <code>Object.getPrototypeOf()</code>方法来获取）。</p>
<p>一般的对象还会继承一个叫做 <code>.constructor</code> 的属性指向其构造函数。当你使用构造函数生成一个对象时，其 <code>.__proto__</code> 属性会指向构造函数的 <code>.prototype</code> 属性。</p>
<ul>
<li>原型属性</li>
</ul>
<p>每个被定义的函数都有一个名为 <code>.prototype</code> 的属性。</p>
<p>它是一个继承了原型链上所有属性的对象。这个对象也默认包括一个 <code>.constructor</code> 属性，指向原始的构造函数。</p>
<p>所有用构造函数生成的对象也会继承一个指向这个函数的 <code>.constructor</code> 属性（用控制台把对象打出来会比较好理解，也可以看下面的示例）。</p>
<pre><code>function Dog(breed, name){
  this.breed = breed,
  this.name = name
}
Dog.prototype.describe = function() {
  console.log(`${this.name} is a ${this.breed}`)
}
const rusty = new Dog(&#39;Beagle&#39;, &#39;Rusty&#39;);

/* .prototype property points to an object which has constructor and attached 
properties to be inherited by objects created by this constructor. */
console.log(Dog.prototype)  // { describe: ƒ , constructor: ƒ }

/* Object created from Dog constructor function */
console.log(rusty)   //  { breed: &quot;Beagle&quot;, name: &quot;Rusty&quot; }
/* Object inherited properties from constructor function&#39;s prototype */
console.log(rusty.describe())   // &quot;Rusty is a Beagle&quot;
/* .__proto__ property points to the .prototype property of the constructor function */ 
console.log(rusty.__proto__)    // { describe: ƒ , constructor: ƒ }
/* .constructor property points to the constructor of the object */
console.log(rusty.constructor)  // ƒ Dog(breed, name) { ... }
</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链描述了对象之间相互引用的关系。</p>
<p>当获取一个对象的属性时，JavaScript 引擎会先从这个对象本身开始查找。如果没有找到，就会转向其原型上的属性，直到第一次找到这个属性为止。原型链上的最后一个对象是内置的 <code>Object.prototype</code> 而它的原型则是 <code>null</code>（也就是所谓原型链的终点）。JavaScript 引擎在查找属性到这一层还是没有找到时就会返回 <code>undefined</code>.</p>
<h2 id="自有属性与继承属性"><a href="#自有属性与继承属性" class="headerlink" title="自有属性与继承属性"></a>自有属性与继承属性</h2><p>对象的属性分为自有和继承两种。</p>
<p>自有属性也就是在对象内部定义的属性。</p>
<p>继承属性则是通过原型链获得的属性。继承属性是不可枚举的（也就是在 <code>for/in</code> 循环里看不到的）。</p>
<pre><code>function Car() { }
Car.prototype.wheels = 4;
Car.prototype.airbags = 1;

var myCar = new Car();
myCar.color = &#39;black&#39;;

/*  Check for Property including Prototype Chain:  */
console.log(&#39;airbags&#39; in myCar)  // true
console.log(myCar.wheels)        // 4
console.log(myCar.year)          // undefined

/*  Check for Own Property:  */
console.log(myCar.hasOwnProperty(&#39;airbags&#39;))  // false — Inherited
console.log(myCar.hasOwnProperty(&#39;color&#39;))    // true
</code></pre><p><strong>Object.create(obj)</strong> 方法可以指定原型来创建对象：</p>
<pre><code>var dog = { legs: 4 };
var myDog = Object.create(dog);

console.log(myDog.hasOwnProperty(&#39;legs&#39;))  // false
console.log(myDog.legs)                    // 4
console.log(myDog.__proto__ === dog)       // true 
</code></pre><h2 id="通过引用继承"><a href="#通过引用继承" class="headerlink" title="通过引用继承"></a>通过引用继承</h2><p>继承属性是原型对象上属性的一份引用拷贝。</p>
<p>如果对象在原型上的属性被改变了，继承这一属性的对象也会受到相同的影响。但假如属性被整个替换掉了，则不会影响到继承的对象：</p>
<pre><code>var objProt = { text: &#39;original&#39; };
var objAttachedToProt = Object.create(objProt);
console.log(objAttachedToProt.text)   // original

objProt.text = &#39;prototype property changed&#39;;
console.log(objAttachedToProt.text)   // prototype property changed

objProt = { text: &#39;replacing property&#39; };
console.log(objAttachedToProt.text)   // prototype property changed 
</code></pre><h2 id="类继承与原型继承"><a href="#类继承与原型继承" class="headerlink" title="类继承与原型继承"></a>类继承与原型继承</h2><p>在类继承模式当中，对象继承自各式各样的类。就好像为对象设置好了一些模版和描述，并创建出了子类关系。我们可以通过 <code>new</code> 关键字从构造函数中创建这样的对象。</p>
<p>但类继承模式有以下这些缺点：</p>
<ul>
<li><p>死板的层级关系</p>
</li>
<li><p>高度耦合</p>
</li>
<li><p>基类薄弱</p>
</li>
<li><p>代码重复</p>
</li>
<li><p>以及传说中的大猩猩/香蕉问题——“What you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle.”</p>
</li>
</ul>
<p>在原型继承模式中，一个对象可以直接继承另一个对象。我们可以通过 <code>Object.create()</code> 或者其他对象方法及工厂函数来创建对象。</p>
<p>下面是三种不同的原型继承的形式：</p>
<ul>
<li><p>原型代理 我们通常称那些用来给其他对象提供模型的对象为代理原型。当你继承一个代理原型时，新的对象可以获取对代理原型属性的引用。这种操作通常使用 Object.create() 来完成。</p>
</li>
<li><p>拼接继承 通过拷贝一个对象的属性来进行继承，不会产生引用关系，这种操作通常使用 Object.assign() 来进行。</p>
</li>
<li><p>函数继承 这种方法是通过工厂函数（工厂函数是指不通过 new 关键字创建并返回对象的函数）来创建对象，然后直接将新的属性添加到对象上。这种形式的好处是我们可以使用闭包进行数据封装。</p>
</li>
</ul>
<pre><code>const person = function(name) {
  const message = `Hello! My name is ${name}`;
  return { greeting: () =&gt; console.log(message) }
}
const will = person(&quot;Will&quot;);
will.greeting();     // Hello! My name is Will 
</code></pre><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><p>开发者都公认在大多数情况下应该避免使用类继承。因为在这种模式下，你需要很清楚地定义设计你的代码它们是什么。</p>
<p>而另一方面，组合的模式则允许你从你的代码要做什么的角度来定义，从而提高你代码的灵活度和可复用性（React组件就是一个非常好的栗子）。</p>
<h1 id="JavaScript-异步"><a href="#JavaScript-异步" class="headerlink" title="JavaScript 异步"></a>JavaScript 异步</h1><p>JavaScript 是一种单线程编程语言。这意味着 JavaScript 引擎一次只能处理一段代码。其主要影响之一是，当 JavaScript 遇到一段需要很长时间处理的代码时，它会阻塞后续的代码运行。</p>
<p>JavaScript 使用了一种存储运行函数信息的数据结构叫做<strong>调用栈</strong>。你可以吧调用栈想象为一摞书。每本放上去的书都会在之前的一摞书上面。最后放上去的书会最早被拿走，最先放上去的书则到最后才会被拿走（LIFO）。</p>
<p>用来解决大段代码非阻塞执行的方法叫做异步回调函数。这类函数可以推迟执行。</p>
<p>异步过程从一个放入堆或内存中的异步回调函数开始。你可以将堆视为一个<strong>事件管理器（事件队列）</strong>。调用栈可以访问事件管理器只在某个事件发生时才执行特定的函数。当某个事件发生后，事件管理器就会将该函数移至回调用队列。<em>注意：当事件管理器处理一个函数时，之后的代码不会被阻塞并且能继续执行</em>。</p>
<p>调用栈会不断检查其是否空闲。当它空闲时，如果有一个等待被调用的函数，则会检查调用队列。当有函数在等待执行时，队列中的第一个函数被压入调用栈并执行。这一过程被称为事件循环当中的一次执行循环.</p>
<p>我们还是用一个栗子来解释吧：</p>
<pre><code>const first = function () {
  console.log(&#39;First message&#39;)
}
const second = function () {
  console.log(&#39;Second message&#39;)
}
const third = function() {
  console.log(&#39;Third message&#39;)
}

first();
setTimeout(second, 0);
third();

// Output:
  // First message
  // Third message
  // Second message 
</code></pre><ol>
<li><p>初始化浏览器的控制台，清空调用栈及事件管理器。</p>
</li>
<li><p>first() 加入调用栈。</p>
</li>
<li><p>console.log(“First message”) 加入调用栈。</p>
</li>
<li><p>console.log(“First message”) 被执行并在浏览器控制台打印出”First message”.</p>
</li>
<li><p>console.log(“First message”) 被移出调用栈。</p>
</li>
<li><p>first() 被移出调用栈。</p>
</li>
<li><p>setTimeout(second, 0) 加入调用栈。</p>
</li>
<li><p>setTimeout(second, 0) 被执行并由事件管理器管理。0ms 之后事件管理器将 second() 移入调用队列。</p>
</li>
<li><p>setTimeout(second, 0) 完成执行并被移出调用栈。</p>
</li>
<li><p>third() 加入调用栈。</p>
</li>
<li><p>console.log(“Third message”) 加入调用栈。</p>
</li>
<li><p>console.log(“Third message”) 被执行并在浏览器控制台打印出”Third message”.</p>
</li>
<li><p>console.log(“Third message”) 被移出调用栈。</p>
</li>
<li><p>third() 被移出调用栈。</p>
</li>
<li><p>调用栈空闲，second() 在调用队列中等待执行。</p>
</li>
<li><p>事件管理器将 second() 从调用队列中移入调用栈。</p>
</li>
<li><p>console.log(“Second message”) 加入调用栈。</p>
</li>
<li><p>console.log(“Second message”) 被执行并在浏览器控制台打印出”Second message”.</p>
</li>
<li><p>console.log(“Second message”) 被移出调用栈。</p>
</li>
<li><p>second() 被移出调用栈。</p>
</li>
</ol>
<p><em>注意：你为 setTimeout 方法传入的时间参数并不是 second() 延迟执行的时间，而是<strong>事件管理器（事件队列）</strong>将函数移入调用栈的等待时间。</em></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Javascript-概念-理论/" rel="tag"># Javascript 概念 理论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/06/理顺react，flux，redux这些概念的关系/" rel="next" title="理顺react，flux，redux这些概念的关系">
                <i class="fa fa-chevron-left"></i> 理顺react，flux，redux这些概念的关系
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/17/入门Webpack，看这篇就够了/" rel="prev" title="入门Webpack，看这篇就够了">
                入门Webpack，看这篇就够了 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">科瑞兹曼</p>
              <p class="site-description motion-element" itemprop="description">交流、学习、提升</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/about/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.zhangxinxu.com/wordpress/" title="http://www.zhangxinxu.com/wordpress/" rel="noopener" target="_blank">张鑫旭</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="http://www.ruanyifeng.com/blog/" rel="noopener" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jstherightway.org/zh-cn/" title="http://jstherightway.org/zh-cn/" rel="noopener" target="_blank">JavaScript之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://standardjs.com/readme-zhcn.html" title="https://standardjs.com/readme-zhcn.html" rel="noopener" target="_blank">前端代码规范</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#类型及其转换"><span class="nav-number">1.</span> <span class="nav-text">类型及其转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#赋值与引用"><span class="nav-number">2.</span> <span class="nav-text">赋值与引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作用域"><span class="nav-number">3.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量提升-Hoisting"><span class="nav-number">4.</span> <span class="nav-text">变量提升 Hoisting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数表达式-与-函数声明"><span class="nav-number">5.</span> <span class="nav-text">函数表达式 与 函数声明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量声明方式：var-let-cost"><span class="nav-number">6.</span> <span class="nav-text">变量声明方式：var let cost</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包-Closure"><span class="nav-number">7.</span> <span class="nav-text">闭包 Closure</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#立即执行函数表达式-IIFE"><span class="nav-number">8.</span> <span class="nav-text">立即执行函数表达式 IIFE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#上下文"><span class="nav-number">9.</span> <span class="nav-text">上下文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数调用方式：call-apply-bind"><span class="nav-number">10.</span> <span class="nav-text">函数调用方式：call apply bind</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this-关键字"><span class="nav-number">11.</span> <span class="nav-text">this 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#严格模式"><span class="nav-number">12.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-关键字"><span class="nav-number">13.</span> <span class="nav-text">new 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原型与继承"><span class="nav-number">14.</span> <span class="nav-text">原型与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">14.1.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自有属性与继承属性"><span class="nav-number">14.2.</span> <span class="nav-text">自有属性与继承属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过引用继承"><span class="nav-number">14.3.</span> <span class="nav-text">通过引用继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类继承与原型继承"><span class="nav-number">14.4.</span> <span class="nav-text">类继承与原型继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合与继承"><span class="nav-number">14.5.</span> <span class="nav-text">组合与继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-异步"><span class="nav-number">15.</span> <span class="nav-text">JavaScript 异步</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">科瑞兹曼</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: 'hXTDTSGSHRts2UhvBgMMCgbT-gzGzoHsz',
    appKey: 'VtFW2O1nWA3hNCVyr56QqvyG',
    placeholder: '我来说两句',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true
  });
</script>




  


  




  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; 
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
